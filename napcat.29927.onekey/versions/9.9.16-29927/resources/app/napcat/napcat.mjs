import require$$0$1 from 'util';
import * as os from 'os';
import os__default from 'os';
import require$$0$2 from 'events';
import require$$0$3 from 'buffer';
import * as fs from 'fs';
import fs__default, { promises } from 'fs';
import path, { dirname } from 'path';
import require$$3$1 from 'zlib';
import require$$1 from 'string_decoder';
import require$$0$4 from 'http';
import require$$1$1 from 'https';
import path$1, { basename, join, resolve as resolve$1 } from 'node:path';
import os$1, { constants } from 'node:os';
import fs$2, { open, stat, constants as constants$1, unlink } from 'node:fs/promises';
import fsPromise, { stat as stat$1 } from 'fs/promises';
import https from 'node:https';
import http from 'node:http';
import * as crypto$1 from 'crypto';
import crypto__default, { randomUUID, createHash as createHash$1, createHmac } from 'crypto';
import ffmpeg from 'fluent-ffmpeg';
import Piscina from 'piscina';
import require$$1$2, { spawn } from 'node:child_process';
import { isSilk, isWav, getDuration, getWavFileInfo, decode } from 'silk-wasm';
import { promisify } from 'node:util';
import fs$1, { readFileSync, existsSync } from 'node:fs';
import * as crypto from 'node:crypto';
import crypto__default$1, { createHash } from 'node:crypto';
import * as net from 'node:net';
import net__default, { isIP } from 'node:net';
import * as stream$1 from 'node:stream';
import stream__default, { Readable, PassThrough, pipeline } from 'node:stream';
import assert$1 from 'node:assert';
import * as zlib from 'node:zlib';
import zlib__default from 'node:zlib';
import urlParse, { fileURLToPath } from 'url';
import { WebSocket, WebSocketServer } from 'ws';
import EventEmitter from 'node:events';
import { ReadableStream } from 'node:stream/web';
import require$$4 from 'node:process';
import qrcode from 'qrcode-terminal';
import express, { Router } from 'express';
import { pathToFileURL } from 'node:url';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var winston$1 = {};

var browser$3 = {};

var format$4;
var hasRequiredFormat$3;

function requireFormat$3 () {
	if (hasRequiredFormat$3) return format$4;
	hasRequiredFormat$3 = 1;

	/*
	 * Displays a helpful message and the source of
	 * the format when it is invalid.
	 */
	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _createClass(e, r, t) { return Object.defineProperty(e, "prototype", { writable: !1 }), e; }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
	function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
	function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
	function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
	function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
	function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
	function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
	function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
	function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
	var InvalidFormatError = /*#__PURE__*/function (_Error) {
	  function InvalidFormatError(formatFn) {
	    var _this;
	    _classCallCheck(this, InvalidFormatError);
	    _this = _callSuper(this, InvalidFormatError, ["Format functions must be synchronous taking a two arguments: (info, opts)\nFound: ".concat(formatFn.toString().split('\n')[0], "\n")]);
	    Error.captureStackTrace(_this, InvalidFormatError);
	    return _this;
	  }
	  _inherits(InvalidFormatError, _Error);
	  return _createClass(InvalidFormatError);
	}(/*#__PURE__*/_wrapNativeSuper(Error));
	/*
	 * function format (formatFn)
	 * Returns a create function for the `formatFn`.
	 */
	format$4 = function (formatFn) {
	  if (formatFn.length > 2) {
	    throw new InvalidFormatError(formatFn);
	  }

	  /*
	   * function Format (options)
	   * Base prototype which calls a `_format`
	   * function and pushes the result.
	   */
	  function Format() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    this.options = options;
	  }
	  Format.prototype.transform = formatFn;

	  //
	  // Create a function which returns new instances of
	  // FormatWrap for simple syntax like:
	  //
	  // require('winston').formats.json();
	  //
	  function createFormatWrap(opts) {
	    return new Format(opts);
	  }

	  //
	  // Expose the FormatWrap through the create function
	  // for testability.
	  //
	  createFormatWrap.Format = Format;
	  return createFormatWrap;
	};
	return format$4;
}

var colorize = {exports: {}};

var safe = {exports: {}};

var colors = {exports: {}};

var styles = {exports: {}};

/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var hasRequiredStyles;

function requireStyles () {
	if (hasRequiredStyles) return styles.exports;
	hasRequiredStyles = 1;
	(function (module) {
		var styles = {};
		module['exports'] = styles;

		var codes = {
		  reset: [0, 0],

		  bold: [1, 22],
		  dim: [2, 22],
		  italic: [3, 23],
		  underline: [4, 24],
		  inverse: [7, 27],
		  hidden: [8, 28],
		  strikethrough: [9, 29],

		  black: [30, 39],
		  red: [31, 39],
		  green: [32, 39],
		  yellow: [33, 39],
		  blue: [34, 39],
		  magenta: [35, 39],
		  cyan: [36, 39],
		  white: [37, 39],
		  gray: [90, 39],
		  grey: [90, 39],

		  brightRed: [91, 39],
		  brightGreen: [92, 39],
		  brightYellow: [93, 39],
		  brightBlue: [94, 39],
		  brightMagenta: [95, 39],
		  brightCyan: [96, 39],
		  brightWhite: [97, 39],

		  bgBlack: [40, 49],
		  bgRed: [41, 49],
		  bgGreen: [42, 49],
		  bgYellow: [43, 49],
		  bgBlue: [44, 49],
		  bgMagenta: [45, 49],
		  bgCyan: [46, 49],
		  bgWhite: [47, 49],
		  bgGray: [100, 49],
		  bgGrey: [100, 49],

		  bgBrightRed: [101, 49],
		  bgBrightGreen: [102, 49],
		  bgBrightYellow: [103, 49],
		  bgBrightBlue: [104, 49],
		  bgBrightMagenta: [105, 49],
		  bgBrightCyan: [106, 49],
		  bgBrightWhite: [107, 49],

		  // legacy styles for colors pre v1.0.0
		  blackBG: [40, 49],
		  redBG: [41, 49],
		  greenBG: [42, 49],
		  yellowBG: [43, 49],
		  blueBG: [44, 49],
		  magentaBG: [45, 49],
		  cyanBG: [46, 49],
		  whiteBG: [47, 49],

		};

		Object.keys(codes).forEach(function(key) {
		  var val = codes[key];
		  var style = styles[key] = [];
		  style.open = '\u001b[' + val[0] + 'm';
		  style.close = '\u001b[' + val[1] + 'm';
		}); 
	} (styles));
	return styles.exports;
}

/*
MIT License

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

var hasFlag;
var hasRequiredHasFlag;

function requireHasFlag () {
	if (hasRequiredHasFlag) return hasFlag;
	hasRequiredHasFlag = 1;

	hasFlag = function(flag, argv) {
	  argv = argv || process.argv || [];

	  var terminatorPos = argv.indexOf('--');
	  var prefix = /^-{1,2}/.test(flag) ? '' : '--';
	  var pos = argv.indexOf(prefix + flag);

	  return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
	};
	return hasFlag;
}

/*
The MIT License (MIT)

Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var supportsColors;
var hasRequiredSupportsColors;

function requireSupportsColors () {
	if (hasRequiredSupportsColors) return supportsColors;
	hasRequiredSupportsColors = 1;

	var os = os__default;
	var hasFlag = requireHasFlag();

	var env = process.env;

	var forceColor = void 0;
	if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
	  forceColor = false;
	} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true')
	           || hasFlag('color=always')) {
	  forceColor = true;
	}
	if ('FORCE_COLOR' in env) {
	  forceColor = env.FORCE_COLOR.length === 0
	    || parseInt(env.FORCE_COLOR, 10) !== 0;
	}

	function translateLevel(level) {
	  if (level === 0) {
	    return false;
	  }

	  return {
	    level: level,
	    hasBasic: true,
	    has256: level >= 2,
	    has16m: level >= 3,
	  };
	}

	function supportsColor(stream) {
	  if (forceColor === false) {
	    return 0;
	  }

	  if (hasFlag('color=16m') || hasFlag('color=full')
	      || hasFlag('color=truecolor')) {
	    return 3;
	  }

	  if (hasFlag('color=256')) {
	    return 2;
	  }

	  if (stream && !stream.isTTY && forceColor !== true) {
	    return 0;
	  }

	  var min = forceColor ? 1 : 0;

	  if (process.platform === 'win32') {
	    // Node.js 7.5.0 is the first version of Node.js to include a patch to
	    // libuv that enables 256 color output on Windows. Anything earlier and it
	    // won't work. However, here we target Node.js 8 at minimum as it is an LTS
	    // release, and Node.js 7 is not. Windows 10 build 10586 is the first
	    // Windows release that supports 256 colors. Windows 10 build 14931 is the
	    // first release that supports 16m/TrueColor.
	    var osRelease = os.release().split('.');
	    if (Number(process.versions.node.split('.')[0]) >= 8
	        && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
	      return Number(osRelease[2]) >= 14931 ? 3 : 2;
	    }

	    return 1;
	  }

	  if ('CI' in env) {
	    if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(function(sign) {
	      return sign in env;
	    }) || env.CI_NAME === 'codeship') {
	      return 1;
	    }

	    return min;
	  }

	  if ('TEAMCITY_VERSION' in env) {
	    return (/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0
	    );
	  }

	  if ('TERM_PROGRAM' in env) {
	    var version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

	    switch (env.TERM_PROGRAM) {
	      case 'iTerm.app':
	        return version >= 3 ? 3 : 2;
	      case 'Hyper':
	        return 3;
	      case 'Apple_Terminal':
	        return 2;
	      // No default
	    }
	  }

	  if (/-256(color)?$/i.test(env.TERM)) {
	    return 2;
	  }

	  if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
	    return 1;
	  }

	  if ('COLORTERM' in env) {
	    return 1;
	  }

	  if (env.TERM === 'dumb') {
	    return min;
	  }

	  return min;
	}

	function getSupportLevel(stream) {
	  var level = supportsColor(stream);
	  return translateLevel(level);
	}

	supportsColors = {
	  supportsColor: getSupportLevel,
	  stdout: getSupportLevel(process.stdout),
	  stderr: getSupportLevel(process.stderr),
	};
	return supportsColors;
}

var trap = {exports: {}};

var hasRequiredTrap;

function requireTrap () {
	if (hasRequiredTrap) return trap.exports;
	hasRequiredTrap = 1;
	(function (module) {
		module['exports'] = function runTheTrap(text, options) {
		  var result = '';
		  text = text || 'Run the trap, drop the bass';
		  text = text.split('');
		  var trap = {
		    a: ['\u0040', '\u0104', '\u023a', '\u0245', '\u0394', '\u039b', '\u0414'],
		    b: ['\u00df', '\u0181', '\u0243', '\u026e', '\u03b2', '\u0e3f'],
		    c: ['\u00a9', '\u023b', '\u03fe'],
		    d: ['\u00d0', '\u018a', '\u0500', '\u0501', '\u0502', '\u0503'],
		    e: ['\u00cb', '\u0115', '\u018e', '\u0258', '\u03a3', '\u03be', '\u04bc',
		      '\u0a6c'],
		    f: ['\u04fa'],
		    g: ['\u0262'],
		    h: ['\u0126', '\u0195', '\u04a2', '\u04ba', '\u04c7', '\u050a'],
		    i: ['\u0f0f'],
		    j: ['\u0134'],
		    k: ['\u0138', '\u04a0', '\u04c3', '\u051e'],
		    l: ['\u0139'],
		    m: ['\u028d', '\u04cd', '\u04ce', '\u0520', '\u0521', '\u0d69'],
		    n: ['\u00d1', '\u014b', '\u019d', '\u0376', '\u03a0', '\u048a'],
		    o: ['\u00d8', '\u00f5', '\u00f8', '\u01fe', '\u0298', '\u047a', '\u05dd',
		      '\u06dd', '\u0e4f'],
		    p: ['\u01f7', '\u048e'],
		    q: ['\u09cd'],
		    r: ['\u00ae', '\u01a6', '\u0210', '\u024c', '\u0280', '\u042f'],
		    s: ['\u00a7', '\u03de', '\u03df', '\u03e8'],
		    t: ['\u0141', '\u0166', '\u0373'],
		    u: ['\u01b1', '\u054d'],
		    v: ['\u05d8'],
		    w: ['\u0428', '\u0460', '\u047c', '\u0d70'],
		    x: ['\u04b2', '\u04fe', '\u04fc', '\u04fd'],
		    y: ['\u00a5', '\u04b0', '\u04cb'],
		    z: ['\u01b5', '\u0240'],
		  };
		  text.forEach(function(c) {
		    c = c.toLowerCase();
		    var chars = trap[c] || [' '];
		    var rand = Math.floor(Math.random() * chars.length);
		    if (typeof trap[c] !== 'undefined') {
		      result += trap[c][rand];
		    } else {
		      result += c;
		    }
		  });
		  return result;
		}; 
	} (trap));
	return trap.exports;
}

var zalgo = {exports: {}};

var hasRequiredZalgo;

function requireZalgo () {
	if (hasRequiredZalgo) return zalgo.exports;
	hasRequiredZalgo = 1;
	(function (module) {
		// please no
		module['exports'] = function zalgo(text, options) {
		  text = text || '   he is here   ';
		  var soul = {
		    'up': [
		      '̍', '̎', '̄', '̅',
		      '̿', '̑', '̆', '̐',
		      '͒', '͗', '͑', '̇',
		      '̈', '̊', '͂', '̓',
		      '̈', '͊', '͋', '͌',
		      '̃', '̂', '̌', '͐',
		      '̀', '́', '̋', '̏',
		      '̒', '̓', '̔', '̽',
		      '̉', 'ͣ', 'ͤ', 'ͥ',
		      'ͦ', 'ͧ', 'ͨ', 'ͩ',
		      'ͪ', 'ͫ', 'ͬ', 'ͭ',
		      'ͮ', 'ͯ', '̾', '͛',
		      '͆', '̚',
		    ],
		    'down': [
		      '̖', '̗', '̘', '̙',
		      '̜', '̝', '̞', '̟',
		      '̠', '̤', '̥', '̦',
		      '̩', '̪', '̫', '̬',
		      '̭', '̮', '̯', '̰',
		      '̱', '̲', '̳', '̹',
		      '̺', '̻', '̼', 'ͅ',
		      '͇', '͈', '͉', '͍',
		      '͎', '͓', '͔', '͕',
		      '͖', '͙', '͚', '̣',
		    ],
		    'mid': [
		      '̕', '̛', '̀', '́',
		      '͘', '̡', '̢', '̧',
		      '̨', '̴', '̵', '̶',
		      '͜', '͝', '͞',
		      '͟', '͠', '͢', '̸',
		      '̷', '͡', ' ҉',
		    ],
		  };
		  var all = [].concat(soul.up, soul.down, soul.mid);

		  function randomNumber(range) {
		    var r = Math.floor(Math.random() * range);
		    return r;
		  }

		  function isChar(character) {
		    var bool = false;
		    all.filter(function(i) {
		      bool = (i === character);
		    });
		    return bool;
		  }


		  function heComes(text, options) {
		    var result = '';
		    var counts;
		    var l;
		    options = options || {};
		    options['up'] =
		      typeof options['up'] !== 'undefined' ? options['up'] : true;
		    options['mid'] =
		      typeof options['mid'] !== 'undefined' ? options['mid'] : true;
		    options['down'] =
		      typeof options['down'] !== 'undefined' ? options['down'] : true;
		    options['size'] =
		      typeof options['size'] !== 'undefined' ? options['size'] : 'maxi';
		    text = text.split('');
		    for (l in text) {
		      if (isChar(l)) {
		        continue;
		      }
		      result = result + text[l];
		      counts = {'up': 0, 'down': 0, 'mid': 0};
		      switch (options.size) {
		        case 'mini':
		          counts.up = randomNumber(8);
		          counts.mid = randomNumber(2);
		          counts.down = randomNumber(8);
		          break;
		        case 'maxi':
		          counts.up = randomNumber(16) + 3;
		          counts.mid = randomNumber(4) + 1;
		          counts.down = randomNumber(64) + 3;
		          break;
		        default:
		          counts.up = randomNumber(8) + 1;
		          counts.mid = randomNumber(6) / 2;
		          counts.down = randomNumber(8) + 1;
		          break;
		      }

		      var arr = ['up', 'mid', 'down'];
		      for (var d in arr) {
		        var index = arr[d];
		        for (var i = 0; i <= counts[index]; i++) {
		          if (options[index]) {
		            result = result + soul[index][randomNumber(soul[index].length)];
		          }
		        }
		      }
		    }
		    return result;
		  }
		  // don't summon him
		  return heComes(text, options);
		}; 
	} (zalgo));
	return zalgo.exports;
}

var america = {exports: {}};

var hasRequiredAmerica;

function requireAmerica () {
	if (hasRequiredAmerica) return america.exports;
	hasRequiredAmerica = 1;
	(function (module) {
		module['exports'] = function(colors) {
		  return function(letter, i, exploded) {
		    if (letter === ' ') return letter;
		    switch (i%3) {
		      case 0: return colors.red(letter);
		      case 1: return colors.white(letter);
		      case 2: return colors.blue(letter);
		    }
		  };
		}; 
	} (america));
	return america.exports;
}

var zebra = {exports: {}};

var hasRequiredZebra;

function requireZebra () {
	if (hasRequiredZebra) return zebra.exports;
	hasRequiredZebra = 1;
	(function (module) {
		module['exports'] = function(colors) {
		  return function(letter, i, exploded) {
		    return i % 2 === 0 ? letter : colors.inverse(letter);
		  };
		}; 
	} (zebra));
	return zebra.exports;
}

var rainbow = {exports: {}};

var hasRequiredRainbow;

function requireRainbow () {
	if (hasRequiredRainbow) return rainbow.exports;
	hasRequiredRainbow = 1;
	(function (module) {
		module['exports'] = function(colors) {
		  // RoY G BiV
		  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta'];
		  return function(letter, i, exploded) {
		    if (letter === ' ') {
		      return letter;
		    } else {
		      return colors[rainbowColors[i++ % rainbowColors.length]](letter);
		    }
		  };
		}; 
	} (rainbow));
	return rainbow.exports;
}

var random = {exports: {}};

var hasRequiredRandom;

function requireRandom () {
	if (hasRequiredRandom) return random.exports;
	hasRequiredRandom = 1;
	(function (module) {
		module['exports'] = function(colors) {
		  var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green',
		    'blue', 'white', 'cyan', 'magenta', 'brightYellow', 'brightRed',
		    'brightGreen', 'brightBlue', 'brightWhite', 'brightCyan', 'brightMagenta'];
		  return function(letter, i, exploded) {
		    return letter === ' ' ? letter :
		      colors[
		          available[Math.round(Math.random() * (available.length - 2))]
		      ](letter);
		  };
		}; 
	} (random));
	return random.exports;
}

/*

The MIT License (MIT)

Original Library
  - Copyright (c) Marak Squires

Additional functionality
 - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var hasRequiredColors;

function requireColors () {
	if (hasRequiredColors) return colors.exports;
	hasRequiredColors = 1;
	(function (module) {
		var colors = {};
		module['exports'] = colors;

		colors.themes = {};

		var util = require$$0$1;
		var ansiStyles = colors.styles = requireStyles();
		var defineProps = Object.defineProperties;
		var newLineRegex = new RegExp(/[\r\n]+/g);

		colors.supportsColor = requireSupportsColors().supportsColor;

		if (typeof colors.enabled === 'undefined') {
		  colors.enabled = colors.supportsColor() !== false;
		}

		colors.enable = function() {
		  colors.enabled = true;
		};

		colors.disable = function() {
		  colors.enabled = false;
		};

		colors.stripColors = colors.strip = function(str) {
		  return ('' + str).replace(/\x1B\[\d+m/g, '');
		};

		// eslint-disable-next-line no-unused-vars
		colors.stylize = function stylize(str, style) {
		  if (!colors.enabled) {
		    return str+'';
		  }

		  var styleMap = ansiStyles[style];

		  // Stylize should work for non-ANSI styles, too
		  if (!styleMap && style in colors) {
		    // Style maps like trap operate as functions on strings;
		    // they don't have properties like open or close.
		    return colors[style](str);
		  }

		  return styleMap.open + str + styleMap.close;
		};

		var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
		var escapeStringRegexp = function(str) {
		  if (typeof str !== 'string') {
		    throw new TypeError('Expected a string');
		  }
		  return str.replace(matchOperatorsRe, '\\$&');
		};

		function build(_styles) {
		  var builder = function builder() {
		    return applyStyle.apply(builder, arguments);
		  };
		  builder._styles = _styles;
		  // __proto__ is used because we must return a function, but there is
		  // no way to create a function with a different prototype.
		  builder.__proto__ = proto;
		  return builder;
		}

		var styles = (function() {
		  var ret = {};
		  ansiStyles.grey = ansiStyles.gray;
		  Object.keys(ansiStyles).forEach(function(key) {
		    ansiStyles[key].closeRe =
		      new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
		    ret[key] = {
		      get: function() {
		        return build(this._styles.concat(key));
		      },
		    };
		  });
		  return ret;
		})();

		var proto = defineProps(function colors() {}, styles);

		function applyStyle() {
		  var args = Array.prototype.slice.call(arguments);

		  var str = args.map(function(arg) {
		    // Use weak equality check so we can colorize null/undefined in safe mode
		    if (arg != null && arg.constructor === String) {
		      return arg;
		    } else {
		      return util.inspect(arg);
		    }
		  }).join(' ');

		  if (!colors.enabled || !str) {
		    return str;
		  }

		  var newLinesPresent = str.indexOf('\n') != -1;

		  var nestedStyles = this._styles;

		  var i = nestedStyles.length;
		  while (i--) {
		    var code = ansiStyles[nestedStyles[i]];
		    str = code.open + str.replace(code.closeRe, code.open) + code.close;
		    if (newLinesPresent) {
		      str = str.replace(newLineRegex, function(match) {
		        return code.close + match + code.open;
		      });
		    }
		  }

		  return str;
		}

		colors.setTheme = function(theme) {
		  if (typeof theme === 'string') {
		    console.log('colors.setTheme now only accepts an object, not a string.  ' +
		      'If you are trying to set a theme from a file, it is now your (the ' +
		      'caller\'s) responsibility to require the file.  The old syntax ' +
		      'looked like colors.setTheme(__dirname + ' +
		      '\'/../themes/generic-logging.js\'); The new syntax looks like '+
		      'colors.setTheme(require(__dirname + ' +
		      '\'/../themes/generic-logging.js\'));');
		    return;
		  }
		  for (var style in theme) {
		    (function(style) {
		      colors[style] = function(str) {
		        if (typeof theme[style] === 'object') {
		          var out = str;
		          for (var i in theme[style]) {
		            out = colors[theme[style][i]](out);
		          }
		          return out;
		        }
		        return colors[theme[style]](str);
		      };
		    })(style);
		  }
		};

		function init() {
		  var ret = {};
		  Object.keys(styles).forEach(function(name) {
		    ret[name] = {
		      get: function() {
		        return build([name]);
		      },
		    };
		  });
		  return ret;
		}

		var sequencer = function sequencer(map, str) {
		  var exploded = str.split('');
		  exploded = exploded.map(map);
		  return exploded.join('');
		};

		// custom formatter methods
		colors.trap = requireTrap();
		colors.zalgo = requireZalgo();

		// maps
		colors.maps = {};
		colors.maps.america = requireAmerica()(colors);
		colors.maps.zebra = requireZebra()(colors);
		colors.maps.rainbow = requireRainbow()(colors);
		colors.maps.random = requireRandom()(colors);

		for (var map in colors.maps) {
		  (function(map) {
		    colors[map] = function(str) {
		      return sequencer(colors.maps[map], str);
		    };
		  })(map);
		}

		defineProps(colors, init()); 
	} (colors));
	return colors.exports;
}

var hasRequiredSafe;

function requireSafe () {
	if (hasRequiredSafe) return safe.exports;
	hasRequiredSafe = 1;
	(function (module) {
		//
		// Remark: Requiring this file will use the "safe" colors API,
		// which will not touch String.prototype.
		//
		//   var colors = require('colors/safe');
		//   colors.red("foo")
		//
		//
		var colors = requireColors();
		module['exports'] = colors; 
	} (safe));
	return safe.exports;
}

var tripleBeam = {};

var config$1 = {};

var cli$1 = {};

/**
 * cli.js: Config that conform to commonly used CLI logging levels.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var hasRequiredCli$1;

function requireCli$1 () {
	if (hasRequiredCli$1) return cli$1;
	hasRequiredCli$1 = 1;

	/**
	 * Default levels for the CLI configuration.
	 * @type {Object}
	 */
	cli$1.levels = {
	  error: 0,
	  warn: 1,
	  help: 2,
	  data: 3,
	  info: 4,
	  debug: 5,
	  prompt: 6,
	  verbose: 7,
	  input: 8,
	  silly: 9
	};

	/**
	 * Default colors for the CLI configuration.
	 * @type {Object}
	 */
	cli$1.colors = {
	  error: 'red',
	  warn: 'yellow',
	  help: 'cyan',
	  data: 'grey',
	  info: 'green',
	  debug: 'blue',
	  prompt: 'grey',
	  verbose: 'cyan',
	  input: 'grey',
	  silly: 'magenta'
	};
	return cli$1;
}

var npm = {};

/**
 * npm.js: Config that conform to npm logging levels.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var hasRequiredNpm;

function requireNpm () {
	if (hasRequiredNpm) return npm;
	hasRequiredNpm = 1;

	/**
	 * Default levels for the npm configuration.
	 * @type {Object}
	 */
	npm.levels = {
	  error: 0,
	  warn: 1,
	  info: 2,
	  http: 3,
	  verbose: 4,
	  debug: 5,
	  silly: 6
	};

	/**
	 * Default levels for the npm configuration.
	 * @type {Object}
	 */
	npm.colors = {
	  error: 'red',
	  warn: 'yellow',
	  info: 'green',
	  http: 'green',
	  verbose: 'cyan',
	  debug: 'blue',
	  silly: 'magenta'
	};
	return npm;
}

var syslog = {};

/**
 * syslog.js: Config that conform to syslog logging levels.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var hasRequiredSyslog;

function requireSyslog () {
	if (hasRequiredSyslog) return syslog;
	hasRequiredSyslog = 1;

	/**
	 * Default levels for the syslog configuration.
	 * @type {Object}
	 */
	syslog.levels = {
	  emerg: 0,
	  alert: 1,
	  crit: 2,
	  error: 3,
	  warning: 4,
	  notice: 5,
	  info: 6,
	  debug: 7
	};

	/**
	 * Default levels for the syslog configuration.
	 * @type {Object}
	 */
	syslog.colors = {
	  emerg: 'red',
	  alert: 'yellow',
	  crit: 'red',
	  error: 'red',
	  warning: 'red',
	  notice: 'yellow',
	  info: 'green',
	  debug: 'blue'
	};
	return syslog;
}

/**
 * index.js: Default settings for all levels that winston knows about.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var hasRequiredConfig$1;

function requireConfig$1 () {
	if (hasRequiredConfig$1) return config$1;
	hasRequiredConfig$1 = 1;
	(function (exports) {

		/**
		 * Export config set for the CLI.
		 * @type {Object}
		 */
		Object.defineProperty(exports, 'cli', {
		  value: requireCli$1()
		});

		/**
		 * Export config set for npm.
		 * @type {Object}
		 */
		Object.defineProperty(exports, 'npm', {
		  value: requireNpm()
		});

		/**
		 * Export config set for the syslog.
		 * @type {Object}
		 */
		Object.defineProperty(exports, 'syslog', {
		  value: requireSyslog()
		}); 
	} (config$1));
	return config$1;
}

var hasRequiredTripleBeam;

function requireTripleBeam () {
	if (hasRequiredTripleBeam) return tripleBeam;
	hasRequiredTripleBeam = 1;
	(function (exports) {

		/**
		 * A shareable symbol constant that can be used
		 * as a non-enumerable / semi-hidden level identifier
		 * to allow the readable level property to be mutable for
		 * operations like colorization
		 *
		 * @type {Symbol}
		 */
		Object.defineProperty(exports, 'LEVEL', {
		  value: Symbol.for('level')
		});

		/**
		 * A shareable symbol constant that can be used
		 * as a non-enumerable / semi-hidden message identifier
		 * to allow the final message property to not have
		 * side effects on another.
		 *
		 * @type {Symbol}
		 */
		Object.defineProperty(exports, 'MESSAGE', {
		  value: Symbol.for('message')
		});

		/**
		 * A shareable symbol constant that can be used
		 * as a non-enumerable / semi-hidden message identifier
		 * to allow the extracted splat property be hidden
		 *
		 * @type {Symbol}
		 */
		Object.defineProperty(exports, 'SPLAT', {
		  value: Symbol.for('splat')
		});

		/**
		 * A shareable object constant  that can be used
		 * as a standard configuration for winston@3.
		 *
		 * @type {Object}
		 */
		Object.defineProperty(exports, 'configs', {
		  value: requireConfig$1()
		}); 
	} (tripleBeam));
	return tripleBeam;
}

var hasRequiredColorize;

function requireColorize () {
	if (hasRequiredColorize) return colorize.exports;
	hasRequiredColorize = 1;

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
	function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }
	var colors = requireSafe();
	var _require = requireTripleBeam(),
	  LEVEL = _require.LEVEL,
	  MESSAGE = _require.MESSAGE;

	//
	// Fix colors not appearing in non-tty environments
	//
	colors.enabled = true;

	/**
	 * @property {RegExp} hasSpace
	 * Simple regex to check for presence of spaces.
	 */
	var hasSpace = /\s+/;

	/*
	 * Colorizer format. Wraps the `level` and/or `message` properties
	 * of the `info` objects with ANSI color codes based on a few options.
	 */
	var Colorizer = /*#__PURE__*/function () {
	  function Colorizer() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    _classCallCheck(this, Colorizer);
	    if (opts.colors) {
	      this.addColors(opts.colors);
	    }
	    this.options = opts;
	  }

	  /*
	   * Adds the colors Object to the set of allColors
	   * known by the Colorizer
	   *
	   * @param {Object} colors Set of color mappings to add.
	   */
	  return _createClass(Colorizer, [{
	    key: "addColors",
	    value:
	    /*
	     * Adds the colors Object to the set of allColors
	     * known by the Colorizer
	     *
	     * @param {Object} colors Set of color mappings to add.
	     */
	    function addColors(clrs) {
	      return Colorizer.addColors(clrs);
	    }

	    /*
	     * function colorize (lookup, level, message)
	     * Performs multi-step colorization using @colors/colors/safe
	     */
	  }, {
	    key: "colorize",
	    value: function colorize(lookup, level, message) {
	      if (typeof message === 'undefined') {
	        message = level;
	      }

	      //
	      // If the color for the level is just a string
	      // then attempt to colorize the message with it.
	      //
	      if (!Array.isArray(Colorizer.allColors[lookup])) {
	        return colors[Colorizer.allColors[lookup]](message);
	      }

	      //
	      // If it is an Array then iterate over that Array, applying
	      // the colors function for each item.
	      //
	      for (var i = 0, len = Colorizer.allColors[lookup].length; i < len; i++) {
	        message = colors[Colorizer.allColors[lookup][i]](message);
	      }
	      return message;
	    }

	    /*
	     * function transform (info, opts)
	     * Attempts to colorize the { level, message } of the given
	     * `logform` info object.
	     */
	  }, {
	    key: "transform",
	    value: function transform(info, opts) {
	      if (opts.all && typeof info[MESSAGE] === 'string') {
	        info[MESSAGE] = this.colorize(info[LEVEL], info.level, info[MESSAGE]);
	      }
	      if (opts.level || opts.all || !opts.message) {
	        info.level = this.colorize(info[LEVEL], info.level);
	      }
	      if (opts.all || opts.message) {
	        info.message = this.colorize(info[LEVEL], info.level, info.message);
	      }
	      return info;
	    }
	  }], [{
	    key: "addColors",
	    value: function addColors(clrs) {
	      var nextColors = Object.keys(clrs).reduce(function (acc, level) {
	        acc[level] = hasSpace.test(clrs[level]) ? clrs[level].split(hasSpace) : clrs[level];
	        return acc;
	      }, {});
	      Colorizer.allColors = Object.assign({}, Colorizer.allColors || {}, nextColors);
	      return Colorizer.allColors;
	    }
	  }]);
	}();
	/*
	 * function colorize (info)
	 * Returns a new instance of the colorize Format that applies
	 * level colors to `info` objects. This was previously exposed
	 * as { colorize: true } to transports in `winston < 3.0.0`.
	 */
	colorize.exports = function (opts) {
	  return new Colorizer(opts);
	};

	//
	// Attach the Colorizer for registration purposes
	//
	colorize.exports.Colorizer = colorize.exports.Format = Colorizer;
	return colorize.exports;
}

var levels;
var hasRequiredLevels;

function requireLevels () {
	if (hasRequiredLevels) return levels;
	hasRequiredLevels = 1;

	var _require = requireColorize(),
	  Colorizer = _require.Colorizer;

	/*
	 * Simple method to register colors with a simpler require
	 * path within the module.
	 */
	levels = function (config) {
	  Colorizer.addColors(config.colors || config);
	  return config;
	};
	return levels;
}

var align;
var hasRequiredAlign;

function requireAlign () {
	if (hasRequiredAlign) return align;
	hasRequiredAlign = 1;

	var format = requireFormat$3();

	/*
	 * function align (info)
	 * Returns a new instance of the align Format which adds a `\t`
	 * delimiter before the message to properly align it in the same place.
	 * It was previously { align: true } in winston < 3.0.0
	 */
	align = format(function (info) {
	  info.message = "\t".concat(info.message);
	  return info;
	});
	return align;
}

var cli = {exports: {}};

var padLevels = {exports: {}};

/* eslint no-unused-vars: 0 */

var hasRequiredPadLevels;

function requirePadLevels () {
	if (hasRequiredPadLevels) return padLevels.exports;
	hasRequiredPadLevels = 1;

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
	function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
	function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
	function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
	function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }
	var _require = requireTripleBeam(),
	  configs = _require.configs,
	  LEVEL = _require.LEVEL,
	  MESSAGE = _require.MESSAGE;
	var Padder = /*#__PURE__*/function () {
	  function Padder() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
	      levels: configs.npm.levels
	    };
	    _classCallCheck(this, Padder);
	    this.paddings = Padder.paddingForLevels(opts.levels, opts.filler);
	    this.options = opts;
	  }

	  /**
	   * Returns the maximum length of keys in the specified `levels` Object.
	   * @param  {Object} levels Set of all levels to calculate longest level against.
	   * @returns {Number} Maximum length of the longest level string.
	   */
	  return _createClass(Padder, [{
	    key: "transform",
	    value:
	    /**
	     * Prepends the padding onto the `message` based on the `LEVEL` of
	     * the `info`. This is based on the behavior of `winston@2` which also
	     * prepended the level onto the message.
	     *
	     * See: https://github.com/winstonjs/winston/blob/2.x/lib/winston/logger.js#L198-L201
	     *
	     * @param  {Info} info Logform info object
	     * @param  {Object} opts Options passed along to this instance.
	     * @returns {Info} Modified logform info object.
	     */
	    function transform(info, opts) {
	      info.message = "".concat(this.paddings[info[LEVEL]]).concat(info.message);
	      if (info[MESSAGE]) {
	        info[MESSAGE] = "".concat(this.paddings[info[LEVEL]]).concat(info[MESSAGE]);
	      }
	      return info;
	    }
	  }], [{
	    key: "getLongestLevel",
	    value: function getLongestLevel(levels) {
	      var lvls = Object.keys(levels).map(function (level) {
	        return level.length;
	      });
	      return Math.max.apply(Math, _toConsumableArray(lvls));
	    }

	    /**
	     * Returns the padding for the specified `level` assuming that the
	     * maximum length of all levels it's associated with is `maxLength`.
	     * @param  {String} level Level to calculate padding for.
	     * @param  {String} filler Repeatable text to use for padding.
	     * @param  {Number} maxLength Length of the longest level
	     * @returns {String} Padding string for the `level`
	     */
	  }, {
	    key: "paddingForLevel",
	    value: function paddingForLevel(level, filler, maxLength) {
	      var targetLen = maxLength + 1 - level.length;
	      var rep = Math.floor(targetLen / filler.length);
	      var padding = "".concat(filler).concat(filler.repeat(rep));
	      return padding.slice(0, targetLen);
	    }

	    /**
	     * Returns an object with the string paddings for the given `levels`
	     * using the specified `filler`.
	     * @param  {Object} levels Set of all levels to calculate padding for.
	     * @param  {String} filler Repeatable text to use for padding.
	     * @returns {Object} Mapping of level to desired padding.
	     */
	  }, {
	    key: "paddingForLevels",
	    value: function paddingForLevels(levels) {
	      var filler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';
	      var maxLength = Padder.getLongestLevel(levels);
	      return Object.keys(levels).reduce(function (acc, level) {
	        acc[level] = Padder.paddingForLevel(level, filler, maxLength);
	        return acc;
	      }, {});
	    }
	  }]);
	}();
	/*
	 * function padLevels (info)
	 * Returns a new instance of the padLevels Format which pads
	 * levels to be the same length. This was previously exposed as
	 * { padLevels: true } to transports in `winston < 3.0.0`.
	 */
	padLevels.exports = function (opts) {
	  return new Padder(opts);
	};
	padLevels.exports.Padder = padLevels.exports.Format = Padder;
	return padLevels.exports;
}

var hasRequiredCli;

function requireCli () {
	if (hasRequiredCli) return cli.exports;
	hasRequiredCli = 1;

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
	function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }
	var _require = requireColorize(),
	  Colorizer = _require.Colorizer;
	var _require2 = requirePadLevels(),
	  Padder = _require2.Padder;
	var _require3 = requireTripleBeam(),
	  configs = _require3.configs,
	  MESSAGE = _require3.MESSAGE;

	/**
	 * Cli format class that handles initial state for a a separate
	 * Colorizer and Padder instance.
	 */
	var CliFormat = /*#__PURE__*/function () {
	  function CliFormat() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    _classCallCheck(this, CliFormat);
	    if (!opts.levels) {
	      opts.levels = configs.cli.levels;
	    }
	    this.colorizer = new Colorizer(opts);
	    this.padder = new Padder(opts);
	    this.options = opts;
	  }

	  /*
	   * function transform (info, opts)
	   * Attempts to both:
	   * 1. Pad the { level }
	   * 2. Colorize the { level, message }
	   * of the given `logform` info object depending on the `opts`.
	   */
	  return _createClass(CliFormat, [{
	    key: "transform",
	    value: function transform(info, opts) {
	      this.colorizer.transform(this.padder.transform(info, opts), opts);
	      info[MESSAGE] = "".concat(info.level, ":").concat(info.message);
	      return info;
	    }
	  }]);
	}();
	/*
	 * function cli (opts)
	 * Returns a new instance of the CLI format that turns a log
	 * `info` object into the same format previously available
	 * in `winston.cli()` in `winston < 3.0.0`.
	 */
	cli.exports = function (opts) {
	  return new CliFormat(opts);
	};

	//
	// Attach the CliFormat for registration purposes
	//
	cli.exports.Format = CliFormat;
	return cli.exports;
}

var combine = {exports: {}};

var hasRequiredCombine;

function requireCombine () {
	if (hasRequiredCombine) return combine.exports;
	hasRequiredCombine = 1;

	var format = requireFormat$3();

	/*
	 * function cascade(formats)
	 * Returns a function that invokes the `._format` function in-order
	 * for the specified set of `formats`. In this manner we say that Formats
	 * are "pipe-like", but not a pure pumpify implementation. Since there is no back
	 * pressure we can remove all of the "readable" plumbing in Node streams.
	 */
	function cascade(formats) {
	  if (!formats.every(isValidFormat)) {
	    return;
	  }
	  return function (info) {
	    var obj = info;
	    for (var i = 0; i < formats.length; i++) {
	      obj = formats[i].transform(obj, formats[i].options);
	      if (!obj) {
	        return false;
	      }
	    }
	    return obj;
	  };
	}

	/*
	 * function isValidFormat(format)
	 * If the format does not define a `transform` function throw an error
	 * with more detailed usage.
	 */
	function isValidFormat(fmt) {
	  if (typeof fmt.transform !== 'function') {
	    throw new Error(['No transform function found on format. Did you create a format instance?', 'const myFormat = format(formatFn);', 'const instance = myFormat();'].join('\n'));
	  }
	  return true;
	}

	/*
	 * function combine (info)
	 * Returns a new instance of the combine Format which combines the specified
	 * formats into a new format. This is similar to a pipe-chain in transform streams.
	 * We choose to combine the prototypes this way because there is no back pressure in
	 * an in-memory transform chain.
	 */
	combine.exports = function () {
	  for (var _len = arguments.length, formats = new Array(_len), _key = 0; _key < _len; _key++) {
	    formats[_key] = arguments[_key];
	  }
	  var combinedFormat = format(cascade(formats));
	  var instance = combinedFormat();
	  instance.Format = combinedFormat.Format;
	  return instance;
	};

	//
	// Export the cascade method for use in cli and other
	// combined formats that should not be assumed to be
	// singletons.
	//
	combine.exports.cascade = cascade;
	return combine.exports;
}

/* eslint no-undefined: 0 */

var errors$1;
var hasRequiredErrors$1;

function requireErrors$1 () {
	if (hasRequiredErrors$1) return errors$1;
	hasRequiredErrors$1 = 1;

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
	var format = requireFormat$3();
	var _require = requireTripleBeam(),
	  LEVEL = _require.LEVEL,
	  MESSAGE = _require.MESSAGE;

	/*
	 * function errors (info)
	 * If the `message` property of the `info` object is an instance of `Error`,
	 * replace the `Error` object its own `message` property.
	 *
	 * Optionally, the Error's `stack` and/or `cause` properties can also be appended to the `info` object.
	 */
	errors$1 = format(function (einfo, _ref) {
	  var stack = _ref.stack,
	    cause = _ref.cause;
	  if (einfo instanceof Error) {
	    var info = Object.assign({}, einfo, _defineProperty(_defineProperty(_defineProperty({
	      level: einfo.level
	    }, LEVEL, einfo[LEVEL] || einfo.level), "message", einfo.message), MESSAGE, einfo[MESSAGE] || einfo.message));
	    if (stack) info.stack = einfo.stack;
	    if (cause) info.cause = einfo.cause;
	    return info;
	  }
	  if (!(einfo.message instanceof Error)) return einfo;

	  // Assign all enumerable properties and the
	  // message property from the error provided.
	  var err = einfo.message;
	  Object.assign(einfo, err);
	  einfo.message = err.message;
	  einfo[MESSAGE] = err.message;

	  // Assign the stack and/or cause if requested.
	  if (stack) einfo.stack = err.stack;
	  if (cause) einfo.cause = err.cause;
	  return einfo;
	});
	return errors$1;
}

var safeStableStringify = {exports: {}};

var hasRequiredSafeStableStringify;

function requireSafeStableStringify () {
	if (hasRequiredSafeStableStringify) return safeStableStringify.exports;
	hasRequiredSafeStableStringify = 1;
	(function (module, exports) {

		const { hasOwnProperty } = Object.prototype;

		const stringify = configure();

		// @ts-expect-error
		stringify.configure = configure;
		// @ts-expect-error
		stringify.stringify = stringify;

		// @ts-expect-error
		stringify.default = stringify;

		// @ts-expect-error used for named export
		exports.stringify = stringify;
		// @ts-expect-error used for named export
		exports.configure = configure;

		module.exports = stringify;

		// eslint-disable-next-line no-control-regex
		const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;

		// Escape C0 control characters, double quotes, the backslash and every code
		// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.
		function strEscape (str) {
		  // Some magic numbers that worked out fine while benchmarking with v8 8.0
		  if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
		    return `"${str}"`
		  }
		  return JSON.stringify(str)
		}

		function sort (array, comparator) {
		  // Insertion sort is very efficient for small input sizes, but it has a bad
		  // worst case complexity. Thus, use native array sort for bigger values.
		  if (array.length > 2e2 || comparator) {
		    return array.sort(comparator)
		  }
		  for (let i = 1; i < array.length; i++) {
		    const currentValue = array[i];
		    let position = i;
		    while (position !== 0 && array[position - 1] > currentValue) {
		      array[position] = array[position - 1];
		      position--;
		    }
		    array[position] = currentValue;
		  }
		  return array
		}

		const typedArrayPrototypeGetSymbolToStringTag =
		  Object.getOwnPropertyDescriptor(
		    Object.getPrototypeOf(
		      Object.getPrototypeOf(
		        new Int8Array()
		      )
		    ),
		    Symbol.toStringTag
		  ).get;

		function isTypedArrayWithEntries (value) {
		  return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0
		}

		function stringifyTypedArray (array, separator, maximumBreadth) {
		  if (array.length < maximumBreadth) {
		    maximumBreadth = array.length;
		  }
		  const whitespace = separator === ',' ? '' : ' ';
		  let res = `"0":${whitespace}${array[0]}`;
		  for (let i = 1; i < maximumBreadth; i++) {
		    res += `${separator}"${i}":${whitespace}${array[i]}`;
		  }
		  return res
		}

		function getCircularValueOption (options) {
		  if (hasOwnProperty.call(options, 'circularValue')) {
		    const circularValue = options.circularValue;
		    if (typeof circularValue === 'string') {
		      return `"${circularValue}"`
		    }
		    if (circularValue == null) {
		      return circularValue
		    }
		    if (circularValue === Error || circularValue === TypeError) {
		      return {
		        toString () {
		          throw new TypeError('Converting circular structure to JSON')
		        }
		      }
		    }
		    throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined')
		  }
		  return '"[Circular]"'
		}

		function getDeterministicOption (options) {
		  let value;
		  if (hasOwnProperty.call(options, 'deterministic')) {
		    value = options.deterministic;
		    if (typeof value !== 'boolean' && typeof value !== 'function') {
		      throw new TypeError('The "deterministic" argument must be of type boolean or comparator function')
		    }
		  }
		  return value === undefined ? true : value
		}

		function getBooleanOption (options, key) {
		  let value;
		  if (hasOwnProperty.call(options, key)) {
		    value = options[key];
		    if (typeof value !== 'boolean') {
		      throw new TypeError(`The "${key}" argument must be of type boolean`)
		    }
		  }
		  return value === undefined ? true : value
		}

		function getPositiveIntegerOption (options, key) {
		  let value;
		  if (hasOwnProperty.call(options, key)) {
		    value = options[key];
		    if (typeof value !== 'number') {
		      throw new TypeError(`The "${key}" argument must be of type number`)
		    }
		    if (!Number.isInteger(value)) {
		      throw new TypeError(`The "${key}" argument must be an integer`)
		    }
		    if (value < 1) {
		      throw new RangeError(`The "${key}" argument must be >= 1`)
		    }
		  }
		  return value === undefined ? Infinity : value
		}

		function getItemCount (number) {
		  if (number === 1) {
		    return '1 item'
		  }
		  return `${number} items`
		}

		function getUniqueReplacerSet (replacerArray) {
		  const replacerSet = new Set();
		  for (const value of replacerArray) {
		    if (typeof value === 'string' || typeof value === 'number') {
		      replacerSet.add(String(value));
		    }
		  }
		  return replacerSet
		}

		function getStrictOption (options) {
		  if (hasOwnProperty.call(options, 'strict')) {
		    const value = options.strict;
		    if (typeof value !== 'boolean') {
		      throw new TypeError('The "strict" argument must be of type boolean')
		    }
		    if (value) {
		      return (value) => {
		        let message = `Object can not safely be stringified. Received type ${typeof value}`;
		        if (typeof value !== 'function') message += ` (${value.toString()})`;
		        throw new Error(message)
		      }
		    }
		  }
		}

		function configure (options) {
		  options = { ...options };
		  const fail = getStrictOption(options);
		  if (fail) {
		    if (options.bigint === undefined) {
		      options.bigint = false;
		    }
		    if (!('circularValue' in options)) {
		      options.circularValue = Error;
		    }
		  }
		  const circularValue = getCircularValueOption(options);
		  const bigint = getBooleanOption(options, 'bigint');
		  const deterministic = getDeterministicOption(options);
		  const comparator = typeof deterministic === 'function' ? deterministic : undefined;
		  const maximumDepth = getPositiveIntegerOption(options, 'maximumDepth');
		  const maximumBreadth = getPositiveIntegerOption(options, 'maximumBreadth');

		  function stringifyFnReplacer (key, parent, stack, replacer, spacer, indentation) {
		    let value = parent[key];

		    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
		      value = value.toJSON(key);
		    }
		    value = replacer.call(parent, key, value);

		    switch (typeof value) {
		      case 'string':
		        return strEscape(value)
		      case 'object': {
		        if (value === null) {
		          return 'null'
		        }
		        if (stack.indexOf(value) !== -1) {
		          return circularValue
		        }

		        let res = '';
		        let join = ',';
		        const originalIndentation = indentation;

		        if (Array.isArray(value)) {
		          if (value.length === 0) {
		            return '[]'
		          }
		          if (maximumDepth < stack.length + 1) {
		            return '"[Array]"'
		          }
		          stack.push(value);
		          if (spacer !== '') {
		            indentation += spacer;
		            res += `\n${indentation}`;
		            join = `,\n${indentation}`;
		          }
		          const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
		          let i = 0;
		          for (; i < maximumValuesToStringify - 1; i++) {
		            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
		            res += tmp !== undefined ? tmp : 'null';
		            res += join;
		          }
		          const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
		          res += tmp !== undefined ? tmp : 'null';
		          if (value.length - 1 > maximumBreadth) {
		            const removedKeys = value.length - maximumBreadth - 1;
		            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
		          }
		          if (spacer !== '') {
		            res += `\n${originalIndentation}`;
		          }
		          stack.pop();
		          return `[${res}]`
		        }

		        let keys = Object.keys(value);
		        const keyLength = keys.length;
		        if (keyLength === 0) {
		          return '{}'
		        }
		        if (maximumDepth < stack.length + 1) {
		          return '"[Object]"'
		        }
		        let whitespace = '';
		        let separator = '';
		        if (spacer !== '') {
		          indentation += spacer;
		          join = `,\n${indentation}`;
		          whitespace = ' ';
		        }
		        const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
		        if (deterministic && !isTypedArrayWithEntries(value)) {
		          keys = sort(keys, comparator);
		        }
		        stack.push(value);
		        for (let i = 0; i < maximumPropertiesToStringify; i++) {
		          const key = keys[i];
		          const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation);
		          if (tmp !== undefined) {
		            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`;
		            separator = join;
		          }
		        }
		        if (keyLength > maximumBreadth) {
		          const removedKeys = keyLength - maximumBreadth;
		          res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
		          separator = join;
		        }
		        if (spacer !== '' && separator.length > 1) {
		          res = `\n${indentation}${res}\n${originalIndentation}`;
		        }
		        stack.pop();
		        return `{${res}}`
		      }
		      case 'number':
		        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
		      case 'boolean':
		        return value === true ? 'true' : 'false'
		      case 'undefined':
		        return undefined
		      case 'bigint':
		        if (bigint) {
		          return String(value)
		        }
		        // fallthrough
		      default:
		        return fail ? fail(value) : undefined
		    }
		  }

		  function stringifyArrayReplacer (key, value, stack, replacer, spacer, indentation) {
		    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
		      value = value.toJSON(key);
		    }

		    switch (typeof value) {
		      case 'string':
		        return strEscape(value)
		      case 'object': {
		        if (value === null) {
		          return 'null'
		        }
		        if (stack.indexOf(value) !== -1) {
		          return circularValue
		        }

		        const originalIndentation = indentation;
		        let res = '';
		        let join = ',';

		        if (Array.isArray(value)) {
		          if (value.length === 0) {
		            return '[]'
		          }
		          if (maximumDepth < stack.length + 1) {
		            return '"[Array]"'
		          }
		          stack.push(value);
		          if (spacer !== '') {
		            indentation += spacer;
		            res += `\n${indentation}`;
		            join = `,\n${indentation}`;
		          }
		          const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
		          let i = 0;
		          for (; i < maximumValuesToStringify - 1; i++) {
		            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
		            res += tmp !== undefined ? tmp : 'null';
		            res += join;
		          }
		          const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
		          res += tmp !== undefined ? tmp : 'null';
		          if (value.length - 1 > maximumBreadth) {
		            const removedKeys = value.length - maximumBreadth - 1;
		            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
		          }
		          if (spacer !== '') {
		            res += `\n${originalIndentation}`;
		          }
		          stack.pop();
		          return `[${res}]`
		        }
		        stack.push(value);
		        let whitespace = '';
		        if (spacer !== '') {
		          indentation += spacer;
		          join = `,\n${indentation}`;
		          whitespace = ' ';
		        }
		        let separator = '';
		        for (const key of replacer) {
		          const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation);
		          if (tmp !== undefined) {
		            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`;
		            separator = join;
		          }
		        }
		        if (spacer !== '' && separator.length > 1) {
		          res = `\n${indentation}${res}\n${originalIndentation}`;
		        }
		        stack.pop();
		        return `{${res}}`
		      }
		      case 'number':
		        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
		      case 'boolean':
		        return value === true ? 'true' : 'false'
		      case 'undefined':
		        return undefined
		      case 'bigint':
		        if (bigint) {
		          return String(value)
		        }
		        // fallthrough
		      default:
		        return fail ? fail(value) : undefined
		    }
		  }

		  function stringifyIndent (key, value, stack, spacer, indentation) {
		    switch (typeof value) {
		      case 'string':
		        return strEscape(value)
		      case 'object': {
		        if (value === null) {
		          return 'null'
		        }
		        if (typeof value.toJSON === 'function') {
		          value = value.toJSON(key);
		          // Prevent calling `toJSON` again.
		          if (typeof value !== 'object') {
		            return stringifyIndent(key, value, stack, spacer, indentation)
		          }
		          if (value === null) {
		            return 'null'
		          }
		        }
		        if (stack.indexOf(value) !== -1) {
		          return circularValue
		        }
		        const originalIndentation = indentation;

		        if (Array.isArray(value)) {
		          if (value.length === 0) {
		            return '[]'
		          }
		          if (maximumDepth < stack.length + 1) {
		            return '"[Array]"'
		          }
		          stack.push(value);
		          indentation += spacer;
		          let res = `\n${indentation}`;
		          const join = `,\n${indentation}`;
		          const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
		          let i = 0;
		          for (; i < maximumValuesToStringify - 1; i++) {
		            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
		            res += tmp !== undefined ? tmp : 'null';
		            res += join;
		          }
		          const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
		          res += tmp !== undefined ? tmp : 'null';
		          if (value.length - 1 > maximumBreadth) {
		            const removedKeys = value.length - maximumBreadth - 1;
		            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
		          }
		          res += `\n${originalIndentation}`;
		          stack.pop();
		          return `[${res}]`
		        }

		        let keys = Object.keys(value);
		        const keyLength = keys.length;
		        if (keyLength === 0) {
		          return '{}'
		        }
		        if (maximumDepth < stack.length + 1) {
		          return '"[Object]"'
		        }
		        indentation += spacer;
		        const join = `,\n${indentation}`;
		        let res = '';
		        let separator = '';
		        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
		        if (isTypedArrayWithEntries(value)) {
		          res += stringifyTypedArray(value, join, maximumBreadth);
		          keys = keys.slice(value.length);
		          maximumPropertiesToStringify -= value.length;
		          separator = join;
		        }
		        if (deterministic) {
		          keys = sort(keys, comparator);
		        }
		        stack.push(value);
		        for (let i = 0; i < maximumPropertiesToStringify; i++) {
		          const key = keys[i];
		          const tmp = stringifyIndent(key, value[key], stack, spacer, indentation);
		          if (tmp !== undefined) {
		            res += `${separator}${strEscape(key)}: ${tmp}`;
		            separator = join;
		          }
		        }
		        if (keyLength > maximumBreadth) {
		          const removedKeys = keyLength - maximumBreadth;
		          res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
		          separator = join;
		        }
		        if (separator !== '') {
		          res = `\n${indentation}${res}\n${originalIndentation}`;
		        }
		        stack.pop();
		        return `{${res}}`
		      }
		      case 'number':
		        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
		      case 'boolean':
		        return value === true ? 'true' : 'false'
		      case 'undefined':
		        return undefined
		      case 'bigint':
		        if (bigint) {
		          return String(value)
		        }
		        // fallthrough
		      default:
		        return fail ? fail(value) : undefined
		    }
		  }

		  function stringifySimple (key, value, stack) {
		    switch (typeof value) {
		      case 'string':
		        return strEscape(value)
		      case 'object': {
		        if (value === null) {
		          return 'null'
		        }
		        if (typeof value.toJSON === 'function') {
		          value = value.toJSON(key);
		          // Prevent calling `toJSON` again
		          if (typeof value !== 'object') {
		            return stringifySimple(key, value, stack)
		          }
		          if (value === null) {
		            return 'null'
		          }
		        }
		        if (stack.indexOf(value) !== -1) {
		          return circularValue
		        }

		        let res = '';

		        const hasLength = value.length !== undefined;
		        if (hasLength && Array.isArray(value)) {
		          if (value.length === 0) {
		            return '[]'
		          }
		          if (maximumDepth < stack.length + 1) {
		            return '"[Array]"'
		          }
		          stack.push(value);
		          const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
		          let i = 0;
		          for (; i < maximumValuesToStringify - 1; i++) {
		            const tmp = stringifySimple(String(i), value[i], stack);
		            res += tmp !== undefined ? tmp : 'null';
		            res += ',';
		          }
		          const tmp = stringifySimple(String(i), value[i], stack);
		          res += tmp !== undefined ? tmp : 'null';
		          if (value.length - 1 > maximumBreadth) {
		            const removedKeys = value.length - maximumBreadth - 1;
		            res += `,"... ${getItemCount(removedKeys)} not stringified"`;
		          }
		          stack.pop();
		          return `[${res}]`
		        }

		        let keys = Object.keys(value);
		        const keyLength = keys.length;
		        if (keyLength === 0) {
		          return '{}'
		        }
		        if (maximumDepth < stack.length + 1) {
		          return '"[Object]"'
		        }
		        let separator = '';
		        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
		        if (hasLength && isTypedArrayWithEntries(value)) {
		          res += stringifyTypedArray(value, ',', maximumBreadth);
		          keys = keys.slice(value.length);
		          maximumPropertiesToStringify -= value.length;
		          separator = ',';
		        }
		        if (deterministic) {
		          keys = sort(keys, comparator);
		        }
		        stack.push(value);
		        for (let i = 0; i < maximumPropertiesToStringify; i++) {
		          const key = keys[i];
		          const tmp = stringifySimple(key, value[key], stack);
		          if (tmp !== undefined) {
		            res += `${separator}${strEscape(key)}:${tmp}`;
		            separator = ',';
		          }
		        }
		        if (keyLength > maximumBreadth) {
		          const removedKeys = keyLength - maximumBreadth;
		          res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
		        }
		        stack.pop();
		        return `{${res}}`
		      }
		      case 'number':
		        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
		      case 'boolean':
		        return value === true ? 'true' : 'false'
		      case 'undefined':
		        return undefined
		      case 'bigint':
		        if (bigint) {
		          return String(value)
		        }
		        // fallthrough
		      default:
		        return fail ? fail(value) : undefined
		    }
		  }

		  function stringify (value, replacer, space) {
		    if (arguments.length > 1) {
		      let spacer = '';
		      if (typeof space === 'number') {
		        spacer = ' '.repeat(Math.min(space, 10));
		      } else if (typeof space === 'string') {
		        spacer = space.slice(0, 10);
		      }
		      if (replacer != null) {
		        if (typeof replacer === 'function') {
		          return stringifyFnReplacer('', { '': value }, [], replacer, spacer, '')
		        }
		        if (Array.isArray(replacer)) {
		          return stringifyArrayReplacer('', value, [], getUniqueReplacerSet(replacer), spacer, '')
		        }
		      }
		      if (spacer.length !== 0) {
		        return stringifyIndent('', value, [], spacer, '')
		      }
		    }
		    return stringifySimple('', value, [])
		  }

		  return stringify
		} 
	} (safeStableStringify, safeStableStringify.exports));
	return safeStableStringify.exports;
}

var json$1;
var hasRequiredJson$1;

function requireJson$1 () {
	if (hasRequiredJson$1) return json$1;
	hasRequiredJson$1 = 1;

	var format = requireFormat$3();
	var _require = requireTripleBeam(),
	  MESSAGE = _require.MESSAGE;
	var stringify = requireSafeStableStringify();

	/*
	 * function replacer (key, value)
	 * Handles proper stringification of Buffer and bigint output.
	 */
	function replacer(key, value) {
	  // safe-stable-stringify does support BigInt, however, it doesn't wrap the value in quotes.
	  // Leading to a loss in fidelity if the resulting string is parsed.
	  // It would also be a breaking change for logform.
	  if (typeof value === 'bigint') return value.toString();
	  return value;
	}

	/*
	 * function json (info)
	 * Returns a new instance of the JSON format that turns a log `info`
	 * object into pure JSON. This was previously exposed as { json: true }
	 * to transports in `winston < 3.0.0`.
	 */
	json$1 = format(function (info, opts) {
	  var jsonStringify = stringify.configure(opts);
	  info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
	  return info;
	});
	return json$1;
}

var label;
var hasRequiredLabel;

function requireLabel () {
	if (hasRequiredLabel) return label;
	hasRequiredLabel = 1;

	var format = requireFormat$3();

	/*
	 * function label (info)
	 * Returns a new instance of the label Format which adds the specified
	 * `opts.label` before the message. This was previously exposed as
	 * { label: 'my label' } to transports in `winston < 3.0.0`.
	 */
	label = format(function (info, opts) {
	  if (opts.message) {
	    info.message = "[".concat(opts.label, "] ").concat(info.message);
	    return info;
	  }
	  info.label = opts.label;
	  return info;
	});
	return label;
}

var logstash;
var hasRequiredLogstash;

function requireLogstash () {
	if (hasRequiredLogstash) return logstash;
	hasRequiredLogstash = 1;

	var format = requireFormat$3();
	var _require = requireTripleBeam(),
	  MESSAGE = _require.MESSAGE;
	var jsonStringify = requireSafeStableStringify();

	/*
	 * function logstash (info)
	 * Returns a new instance of the LogStash Format that turns a
	 * log `info` object into pure JSON with the appropriate logstash
	 * options. This was previously exposed as { logstash: true }
	 * to transports in `winston < 3.0.0`.
	 */
	logstash = format(function (info) {
	  var logstash = {};
	  if (info.message) {
	    logstash['@message'] = info.message;
	    delete info.message;
	  }
	  if (info.timestamp) {
	    logstash['@timestamp'] = info.timestamp;
	    delete info.timestamp;
	  }
	  logstash['@fields'] = info;
	  info[MESSAGE] = jsonStringify(logstash);
	  return info;
	});
	return logstash;
}

var metadata$1;
var hasRequiredMetadata$1;

function requireMetadata$1 () {
	if (hasRequiredMetadata$1) return metadata$1;
	hasRequiredMetadata$1 = 1;

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
	var format = requireFormat$3();
	function fillExcept(info, fillExceptKeys, metadataKey) {
	  var savedKeys = fillExceptKeys.reduce(function (acc, key) {
	    acc[key] = info[key];
	    delete info[key];
	    return acc;
	  }, {});
	  var metadata = Object.keys(info).reduce(function (acc, key) {
	    acc[key] = info[key];
	    delete info[key];
	    return acc;
	  }, {});
	  Object.assign(info, savedKeys, _defineProperty({}, metadataKey, metadata));
	  return info;
	}
	function fillWith(info, fillWithKeys, metadataKey) {
	  info[metadataKey] = fillWithKeys.reduce(function (acc, key) {
	    acc[key] = info[key];
	    delete info[key];
	    return acc;
	  }, {});
	  return info;
	}

	/**
	 * Adds in a "metadata" object to collect extraneous data, similar to the metadata
	 * object in winston 2.x.
	 */
	metadata$1 = format(function (info) {
	  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var metadataKey = 'metadata';
	  if (opts.key) {
	    metadataKey = opts.key;
	  }
	  var fillExceptKeys = [];
	  if (!opts.fillExcept && !opts.fillWith) {
	    fillExceptKeys.push('level');
	    fillExceptKeys.push('message');
	  }
	  if (opts.fillExcept) {
	    fillExceptKeys = opts.fillExcept;
	  }
	  if (fillExceptKeys.length > 0) {
	    return fillExcept(info, fillExceptKeys, metadataKey);
	  }
	  if (opts.fillWith) {
	    return fillWith(info, opts.fillWith, metadataKey);
	  }
	  return info;
	});
	return metadata$1;
}

/**
 * Helpers.
 */

var ms;
var hasRequiredMs$1;

function requireMs$1 () {
	if (hasRequiredMs$1) return ms;
	hasRequiredMs$1 = 1;
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	ms = function (val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isFinite(val)) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'weeks':
	    case 'week':
	    case 'w':
	      return n * w;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (msAbs >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (msAbs >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (msAbs >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return plural(ms, msAbs, d, 'day');
	  }
	  if (msAbs >= h) {
	    return plural(ms, msAbs, h, 'hour');
	  }
	  if (msAbs >= m) {
	    return plural(ms, msAbs, m, 'minute');
	  }
	  if (msAbs >= s) {
	    return plural(ms, msAbs, s, 'second');
	  }
	  return ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, msAbs, n, name) {
	  var isPlural = msAbs >= n * 1.5;
	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	}
	return ms;
}

var ms_1;
var hasRequiredMs;

function requireMs () {
	if (hasRequiredMs) return ms_1;
	hasRequiredMs = 1;

	var _this = void 0;
	var format = requireFormat$3();
	var ms = requireMs$1();

	/*
	 * function ms (info)
	 * Returns an `info` with a `ms` property. The `ms` property holds the Value
	 * of the time difference between two calls in milliseconds.
	 */
	ms_1 = format(function (info) {
	  var curr = +new Date();
	  _this.diff = curr - (_this.prevTime || curr);
	  _this.prevTime = curr;
	  info.ms = "+".concat(ms(_this.diff));
	  return info;
	});
	return ms_1;
}

var prettyPrint;
var hasRequiredPrettyPrint;

function requirePrettyPrint () {
	if (hasRequiredPrettyPrint) return prettyPrint;
	hasRequiredPrettyPrint = 1;

	var inspect = require$$0$1.inspect;
	var format = requireFormat$3();
	var _require = requireTripleBeam(),
	  LEVEL = _require.LEVEL,
	  MESSAGE = _require.MESSAGE,
	  SPLAT = _require.SPLAT;

	/*
	 * function prettyPrint (info)
	 * Returns a new instance of the prettyPrint Format that "prettyPrint"
	 * serializes `info` objects. This was previously exposed as
	 * { prettyPrint: true } to transports in `winston < 3.0.0`.
	 */
	prettyPrint = format(function (info) {
	  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  //
	  // info[{LEVEL, MESSAGE, SPLAT}] are enumerable here. Since they
	  // are internal, we remove them before util.inspect so they
	  // are not printed.
	  //
	  var stripped = Object.assign({}, info);

	  // Remark (indexzero): update this technique in April 2019
	  // when node@6 is EOL
	  delete stripped[LEVEL];
	  delete stripped[MESSAGE];
	  delete stripped[SPLAT];
	  info[MESSAGE] = inspect(stripped, false, opts.depth || null, opts.colorize);
	  return info;
	});
	return prettyPrint;
}

var printf = {exports: {}};

var hasRequiredPrintf;

function requirePrintf () {
	if (hasRequiredPrintf) return printf.exports;
	hasRequiredPrintf = 1;

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
	function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }
	var _require = requireTripleBeam(),
	  MESSAGE = _require.MESSAGE;
	var Printf = /*#__PURE__*/function () {
	  function Printf(templateFn) {
	    _classCallCheck(this, Printf);
	    this.template = templateFn;
	  }
	  return _createClass(Printf, [{
	    key: "transform",
	    value: function transform(info) {
	      info[MESSAGE] = this.template(info);
	      return info;
	    }
	  }]);
	}();
	/*
	 * function printf (templateFn)
	 * Returns a new instance of the printf Format that creates an
	 * intermediate prototype to store the template string-based formatter
	 * function.
	 */
	printf.exports = function (opts) {
	  return new Printf(opts);
	};
	printf.exports.Printf = printf.exports.Format = Printf;
	return printf.exports;
}

/* eslint no-undefined: 0 */

var simple;
var hasRequiredSimple;

function requireSimple () {
	if (hasRequiredSimple) return simple;
	hasRequiredSimple = 1;

	var format = requireFormat$3();
	var _require = requireTripleBeam(),
	  MESSAGE = _require.MESSAGE;
	var jsonStringify = requireSafeStableStringify();

	/*
	 * function simple (info)
	 * Returns a new instance of the simple format TransformStream
	 * which writes a simple representation of logs.
	 *
	 *    const { level, message, splat, ...rest } = info;
	 *
	 *    ${level}: ${message}                            if rest is empty
	 *    ${level}: ${message} ${JSON.stringify(rest)}    otherwise
	 */
	simple = format(function (info) {
	  var stringifiedRest = jsonStringify(Object.assign({}, info, {
	    level: undefined,
	    message: undefined,
	    splat: undefined
	  }));
	  var padding = info.padding && info.padding[info.level] || '';
	  if (stringifiedRest !== '{}') {
	    info[MESSAGE] = "".concat(info.level, ":").concat(padding, " ").concat(info.message, " ").concat(stringifiedRest);
	  } else {
	    info[MESSAGE] = "".concat(info.level, ":").concat(padding, " ").concat(info.message);
	  }
	  return info;
	});
	return simple;
}

var splat;
var hasRequiredSplat;

function requireSplat () {
	if (hasRequiredSplat) return splat;
	hasRequiredSplat = 1;

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
	function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
	function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
	function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
	function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }
	var util = require$$0$1;
	var _require = requireTripleBeam(),
	  SPLAT = _require.SPLAT;

	/**
	 * Captures the number of format (i.e. %s strings) in a given string.
	 * Based on `util.format`, see Node.js source:
	 * https://github.com/nodejs/node/blob/b1c8f15c5f169e021f7c46eb7b219de95fe97603/lib/util.js#L201-L230
	 * @type {RegExp}
	 */
	var formatRegExp = /%[scdjifoO%]/g;

	/**
	 * Captures the number of escaped % signs in a format string (i.e. %s strings).
	 * @type {RegExp}
	 */
	var escapedPercent = /%%/g;
	var Splatter = /*#__PURE__*/function () {
	  function Splatter(opts) {
	    _classCallCheck(this, Splatter);
	    this.options = opts;
	  }

	  /**
	     * Check to see if tokens <= splat.length, assign { splat, meta } into the
	     * `info` accordingly, and write to this instance.
	     *
	     * @param  {Info} info Logform info message.
	     * @param  {String[]} tokens Set of string interpolation tokens.
	     * @returns {Info} Modified info message
	     * @private
	     */
	  return _createClass(Splatter, [{
	    key: "_splat",
	    value: function _splat(info, tokens) {
	      var msg = info.message;
	      var splat = info[SPLAT] || info.splat || [];
	      var percents = msg.match(escapedPercent);
	      var escapes = percents && percents.length || 0;

	      // The expected splat is the number of tokens minus the number of escapes
	      // e.g.
	      // - { expectedSplat: 3 } '%d %s %j'
	      // - { expectedSplat: 5 } '[%s] %d%% %d%% %s %j'
	      //
	      // Any "meta" will be arugments in addition to the expected splat size
	      // regardless of type. e.g.
	      //
	      // logger.log('info', '%d%% %s %j', 100, 'wow', { such: 'js' }, { thisIsMeta: true });
	      // would result in splat of four (4), but only three (3) are expected. Therefore:
	      //
	      // extraSplat = 3 - 4 = -1
	      // metas = [100, 'wow', { such: 'js' }, { thisIsMeta: true }].splice(-1, -1 * -1);
	      // splat = [100, 'wow', { such: 'js' }]
	      var expectedSplat = tokens.length - escapes;
	      var extraSplat = expectedSplat - splat.length;
	      var metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : [];

	      // Now that { splat } has been separated from any potential { meta }. we
	      // can assign this to the `info` object and write it to our format stream.
	      // If the additional metas are **NOT** objects or **LACK** enumerable properties
	      // you are going to have a bad time.
	      var metalen = metas.length;
	      if (metalen) {
	        for (var i = 0; i < metalen; i++) {
	          Object.assign(info, metas[i]);
	        }
	      }
	      info.message = util.format.apply(util, [msg].concat(_toConsumableArray(splat)));
	      return info;
	    }

	    /**
	      * Transforms the `info` message by using `util.format` to complete
	      * any `info.message` provided it has string interpolation tokens.
	      * If no tokens exist then `info` is immutable.
	      *
	      * @param  {Info} info Logform info message.
	      * @param  {Object} opts Options for this instance.
	      * @returns {Info} Modified info message
	      */
	  }, {
	    key: "transform",
	    value: function transform(info) {
	      var msg = info.message;
	      var splat = info[SPLAT] || info.splat;

	      // No need to process anything if splat is undefined
	      if (!splat || !splat.length) {
	        return info;
	      }

	      // Extract tokens, if none available default to empty array to
	      // ensure consistancy in expected results
	      var tokens = msg && msg.match && msg.match(formatRegExp);

	      // This condition will take care of inputs with info[SPLAT]
	      // but no tokens present
	      if (!tokens && (splat || splat.length)) {
	        var metas = splat.length > 1 ? splat.splice(0) : splat;

	        // Now that { splat } has been separated from any potential { meta }. we
	        // can assign this to the `info` object and write it to our format stream.
	        // If the additional metas are **NOT** objects or **LACK** enumerable properties
	        // you are going to have a bad time.
	        var metalen = metas.length;
	        if (metalen) {
	          for (var i = 0; i < metalen; i++) {
	            Object.assign(info, metas[i]);
	          }
	        }
	        return info;
	      }
	      if (tokens) {
	        return this._splat(info, tokens);
	      }
	      return info;
	    }
	  }]);
	}();
	/*
	 * function splat (info)
	 * Returns a new instance of the splat format TransformStream
	 * which performs string interpolation from `info` objects. This was
	 * previously exposed implicitly in `winston < 3.0.0`.
	 */
	splat = function (opts) {
	  return new Splatter(opts);
	};
	return splat;
}

var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigitsOptional = "\\d\\d?";
var twoDigits = "\\d\\d";
var threeDigits = "\\d{3}";
var fourDigits = "\\d{4}";
var word = "[^\\s]+";
var literal = /\[([^]*?)\]/gm;
function shorten(arr, sLen) {
    var newArr = [];
    for (var i = 0, len = arr.length; i < len; i++) {
        newArr.push(arr[i].substr(0, sLen));
    }
    return newArr;
}
var monthUpdate = function (arrName) { return function (v, i18n) {
    var lowerCaseArr = i18n[arrName].map(function (v) { return v.toLowerCase(); });
    var index = lowerCaseArr.indexOf(v.toLowerCase());
    if (index > -1) {
        return index;
    }
    return null;
}; };
function assign(origObj) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
        var obj = args_1[_a];
        for (var key in obj) {
            // @ts-ignore ex
            origObj[key] = obj[key];
        }
    }
    return origObj;
}
var dayNames = [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
];
var monthNames = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
];
var monthNamesShort = shorten(monthNames, 3);
var dayNamesShort = shorten(dayNames, 3);
var defaultI18n = {
    dayNamesShort: dayNamesShort,
    dayNames: dayNames,
    monthNamesShort: monthNamesShort,
    monthNames: monthNames,
    amPm: ["am", "pm"],
    DoFn: function (dayOfMonth) {
        return (dayOfMonth +
            ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3
                ? 0
                : ((dayOfMonth - (dayOfMonth % 10) !== 10 ? 1 : 0) * dayOfMonth) % 10]);
    }
};
var globalI18n = assign({}, defaultI18n);
var setGlobalDateI18n = function (i18n) {
    return (globalI18n = assign(globalI18n, i18n));
};
var regexEscape = function (str) {
    return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
};
var pad = function (val, len) {
    if (len === void 0) { len = 2; }
    val = String(val);
    while (val.length < len) {
        val = "0" + val;
    }
    return val;
};
var formatFlags = {
    D: function (dateObj) { return String(dateObj.getDate()); },
    DD: function (dateObj) { return pad(dateObj.getDate()); },
    Do: function (dateObj, i18n) {
        return i18n.DoFn(dateObj.getDate());
    },
    d: function (dateObj) { return String(dateObj.getDay()); },
    dd: function (dateObj) { return pad(dateObj.getDay()); },
    ddd: function (dateObj, i18n) {
        return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function (dateObj, i18n) {
        return i18n.dayNames[dateObj.getDay()];
    },
    M: function (dateObj) { return String(dateObj.getMonth() + 1); },
    MM: function (dateObj) { return pad(dateObj.getMonth() + 1); },
    MMM: function (dateObj, i18n) {
        return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function (dateObj, i18n) {
        return i18n.monthNames[dateObj.getMonth()];
    },
    YY: function (dateObj) {
        return pad(String(dateObj.getFullYear()), 4).substr(2);
    },
    YYYY: function (dateObj) { return pad(dateObj.getFullYear(), 4); },
    h: function (dateObj) { return String(dateObj.getHours() % 12 || 12); },
    hh: function (dateObj) { return pad(dateObj.getHours() % 12 || 12); },
    H: function (dateObj) { return String(dateObj.getHours()); },
    HH: function (dateObj) { return pad(dateObj.getHours()); },
    m: function (dateObj) { return String(dateObj.getMinutes()); },
    mm: function (dateObj) { return pad(dateObj.getMinutes()); },
    s: function (dateObj) { return String(dateObj.getSeconds()); },
    ss: function (dateObj) { return pad(dateObj.getSeconds()); },
    S: function (dateObj) {
        return String(Math.round(dateObj.getMilliseconds() / 100));
    },
    SS: function (dateObj) {
        return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function (dateObj) { return pad(dateObj.getMilliseconds(), 3); },
    a: function (dateObj, i18n) {
        return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function (dateObj, i18n) {
        return dateObj.getHours() < 12
            ? i18n.amPm[0].toUpperCase()
            : i18n.amPm[1].toUpperCase();
    },
    ZZ: function (dateObj) {
        var offset = dateObj.getTimezoneOffset();
        return ((offset > 0 ? "-" : "+") +
            pad(Math.floor(Math.abs(offset) / 60) * 100 + (Math.abs(offset) % 60), 4));
    },
    Z: function (dateObj) {
        var offset = dateObj.getTimezoneOffset();
        return ((offset > 0 ? "-" : "+") +
            pad(Math.floor(Math.abs(offset) / 60), 2) +
            ":" +
            pad(Math.abs(offset) % 60, 2));
    }
};
var monthParse = function (v) { return +v - 1; };
var emptyDigits = [null, twoDigitsOptional];
var emptyWord = [null, word];
var amPm = [
    "isPm",
    word,
    function (v, i18n) {
        var val = v.toLowerCase();
        if (val === i18n.amPm[0]) {
            return 0;
        }
        else if (val === i18n.amPm[1]) {
            return 1;
        }
        return null;
    }
];
var timezoneOffset = [
    "timezoneOffset",
    "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
    function (v) {
        var parts = (v + "").match(/([+-]|\d\d)/gi);
        if (parts) {
            var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
            return parts[0] === "+" ? minutes : -minutes;
        }
        return 0;
    }
];
var parseFlags = {
    D: ["day", twoDigitsOptional],
    DD: ["day", twoDigits],
    Do: ["day", twoDigitsOptional + word, function (v) { return parseInt(v, 10); }],
    M: ["month", twoDigitsOptional, monthParse],
    MM: ["month", twoDigits, monthParse],
    YY: [
        "year",
        twoDigits,
        function (v) {
            var now = new Date();
            var cent = +("" + now.getFullYear()).substr(0, 2);
            return +("" + (+v > 68 ? cent - 1 : cent) + v);
        }
    ],
    h: ["hour", twoDigitsOptional, undefined, "isPm"],
    hh: ["hour", twoDigits, undefined, "isPm"],
    H: ["hour", twoDigitsOptional],
    HH: ["hour", twoDigits],
    m: ["minute", twoDigitsOptional],
    mm: ["minute", twoDigits],
    s: ["second", twoDigitsOptional],
    ss: ["second", twoDigits],
    YYYY: ["year", fourDigits],
    S: ["millisecond", "\\d", function (v) { return +v * 100; }],
    SS: ["millisecond", twoDigits, function (v) { return +v * 10; }],
    SSS: ["millisecond", threeDigits],
    d: emptyDigits,
    dd: emptyDigits,
    ddd: emptyWord,
    dddd: emptyWord,
    MMM: ["month", word, monthUpdate("monthNamesShort")],
    MMMM: ["month", word, monthUpdate("monthNames")],
    a: amPm,
    A: amPm,
    ZZ: timezoneOffset,
    Z: timezoneOffset
};
// Some common format strings
var globalMasks = {
    default: "ddd MMM DD YYYY HH:mm:ss",
    shortDate: "M/D/YY",
    mediumDate: "MMM D, YYYY",
    longDate: "MMMM D, YYYY",
    fullDate: "dddd, MMMM D, YYYY",
    isoDate: "YYYY-MM-DD",
    isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
    shortTime: "HH:mm",
    mediumTime: "HH:mm:ss",
    longTime: "HH:mm:ss.SSS"
};
var setGlobalDateMasks = function (masks) { return assign(globalMasks, masks); };
/***
 * Format a date
 * @method format
 * @param {Date|number} dateObj
 * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
 * @returns {string} Formatted date string
 */
var format$3 = function (dateObj, mask, i18n) {
    if (mask === void 0) { mask = globalMasks["default"]; }
    if (i18n === void 0) { i18n = {}; }
    if (typeof dateObj === "number") {
        dateObj = new Date(dateObj);
    }
    if (Object.prototype.toString.call(dateObj) !== "[object Date]" ||
        isNaN(dateObj.getTime())) {
        throw new Error("Invalid Date pass to format");
    }
    mask = globalMasks[mask] || mask;
    var literals = [];
    // Make literals inactive by replacing them with @@@
    mask = mask.replace(literal, function ($0, $1) {
        literals.push($1);
        return "@@@";
    });
    var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
    // Apply formatting rules
    mask = mask.replace(token, function ($0) {
        return formatFlags[$0](dateObj, combinedI18nSettings);
    });
    // Inline literal values back into the formatted value
    return mask.replace(/@@@/g, function () { return literals.shift(); });
};
/**
 * Parse a date string into a Javascript Date object /
 * @method parse
 * @param {string} dateStr Date string
 * @param {string} format Date parse format
 * @param {i18n} I18nSettingsOptional Full or subset of I18N settings
 * @returns {Date|null} Returns Date object. Returns null what date string is invalid or doesn't match format
 */
function parse(dateStr, format, i18n) {
    if (i18n === void 0) { i18n = {}; }
    if (typeof format !== "string") {
        throw new Error("Invalid format in fecha parse");
    }
    // Check to see if the format is actually a mask
    format = globalMasks[format] || format;
    // Avoid regular expression denial of service, fail early for really long strings
    // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS
    if (dateStr.length > 1000) {
        return null;
    }
    // Default to the beginning of the year.
    var today = new Date();
    var dateInfo = {
        year: today.getFullYear(),
        month: 0,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0,
        isPm: null,
        timezoneOffset: null
    };
    var parseInfo = [];
    var literals = [];
    // Replace all the literals with @@@. Hopefully a string that won't exist in the format
    var newFormat = format.replace(literal, function ($0, $1) {
        literals.push(regexEscape($1));
        return "@@@";
    });
    var specifiedFields = {};
    var requiredFields = {};
    // Change every token that we find into the correct regex
    newFormat = regexEscape(newFormat).replace(token, function ($0) {
        var info = parseFlags[$0];
        var field = info[0], regex = info[1], requiredField = info[3];
        // Check if the person has specified the same field twice. This will lead to confusing results.
        if (specifiedFields[field]) {
            throw new Error("Invalid format. " + field + " specified twice in format");
        }
        specifiedFields[field] = true;
        // Check if there are any required fields. For instance, 12 hour time requires AM/PM specified
        if (requiredField) {
            requiredFields[requiredField] = true;
        }
        parseInfo.push(info);
        return "(" + regex + ")";
    });
    // Check all the required fields are present
    Object.keys(requiredFields).forEach(function (field) {
        if (!specifiedFields[field]) {
            throw new Error("Invalid format. " + field + " is required in specified format");
        }
    });
    // Add back all the literals after
    newFormat = newFormat.replace(/@@@/g, function () { return literals.shift(); });
    // Check if the date string matches the format. If it doesn't return null
    var matches = dateStr.match(new RegExp(newFormat, "i"));
    if (!matches) {
        return null;
    }
    var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
    // For each match, call the parser function for that date part
    for (var i = 1; i < matches.length; i++) {
        var _a = parseInfo[i - 1], field = _a[0], parser = _a[2];
        var value = parser
            ? parser(matches[i], combinedI18nSettings)
            : +matches[i];
        // If the parser can't make sense of the value, return null
        if (value == null) {
            return null;
        }
        dateInfo[field] = value;
    }
    if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
        dateInfo.hour = +dateInfo.hour + 12;
    }
    else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
        dateInfo.hour = 0;
    }
    var dateTZ;
    if (dateInfo.timezoneOffset == null) {
        dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
        var validateFields = [
            ["month", "getMonth"],
            ["day", "getDate"],
            ["hour", "getHours"],
            ["minute", "getMinutes"],
            ["second", "getSeconds"]
        ];
        for (var i = 0, len = validateFields.length; i < len; i++) {
            // Check to make sure the date field is within the allowed range. Javascript dates allows values
            // outside the allowed range. If the values don't match the value was invalid
            if (specifiedFields[validateFields[i][0]] &&
                dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
                return null;
            }
        }
    }
    else {
        dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
        // We can't validate dates in another timezone unfortunately. Do a basic check instead
        if (dateInfo.month > 11 ||
            dateInfo.month < 0 ||
            dateInfo.day > 31 ||
            dateInfo.day < 1 ||
            dateInfo.hour > 23 ||
            dateInfo.hour < 0 ||
            dateInfo.minute > 59 ||
            dateInfo.minute < 0 ||
            dateInfo.second > 59 ||
            dateInfo.second < 0) {
            return null;
        }
    }
    // Don't allow invalid dates
    return dateTZ;
}
var fecha = {
    format: format$3,
    parse: parse,
    defaultI18n: defaultI18n,
    setGlobalDateI18n: setGlobalDateI18n,
    setGlobalDateMasks: setGlobalDateMasks
};

const fecha$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	assign,
	default: fecha,
	defaultI18n,
	format: format$3,
	parse,
	setGlobalDateI18n,
	setGlobalDateMasks
}, Symbol.toStringTag, { value: 'Module' }));

const require$$0 = /*@__PURE__*/getAugmentedNamespace(fecha$1);

var timestamp;
var hasRequiredTimestamp;

function requireTimestamp () {
	if (hasRequiredTimestamp) return timestamp;
	hasRequiredTimestamp = 1;

	var fecha = require$$0;
	var format = requireFormat$3();

	/*
	 * function timestamp (info)
	 * Returns a new instance of the timestamp Format which adds a timestamp
	 * to the info. It was previously available in winston < 3.0.0 as:
	 *
	 * - { timestamp: true }             // `new Date.toISOString()`
	 * - { timestamp: function:String }  // Value returned by `timestamp()`
	 */
	timestamp = format(function (info) {
	  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  if (opts.format) {
	    info.timestamp = typeof opts.format === 'function' ? opts.format() : fecha.format(new Date(), opts.format);
	  }
	  if (!info.timestamp) {
	    info.timestamp = new Date().toISOString();
	  }
	  if (opts.alias) {
	    info[opts.alias] = info.timestamp;
	  }
	  return info;
	});
	return timestamp;
}

var uncolorize;
var hasRequiredUncolorize;

function requireUncolorize () {
	if (hasRequiredUncolorize) return uncolorize;
	hasRequiredUncolorize = 1;

	var colors = requireSafe();
	var format = requireFormat$3();
	var _require = requireTripleBeam(),
	  MESSAGE = _require.MESSAGE;

	/*
	 * function uncolorize (info)
	 * Returns a new instance of the uncolorize Format that strips colors
	 * from `info` objects. This was previously exposed as { stripColors: true }
	 * to transports in `winston < 3.0.0`.
	 */
	uncolorize = format(function (info, opts) {
	  if (opts.level !== false) {
	    info.level = colors.strip(info.level);
	  }
	  if (opts.message !== false) {
	    info.message = colors.strip(String(info.message));
	  }
	  if (opts.raw !== false && info[MESSAGE]) {
	    info[MESSAGE] = colors.strip(String(info[MESSAGE]));
	  }
	  return info;
	});
	return uncolorize;
}

var hasRequiredBrowser$2;

function requireBrowser$2 () {
	if (hasRequiredBrowser$2) return browser$3;
	hasRequiredBrowser$2 = 1;

	/*
	 * @api public
	 * @property {function} format
	 * Both the construction method and set of exposed
	 * formats.
	 */
	var format = browser$3.format = requireFormat$3();

	/*
	 * @api public
	 * @method {function} levels
	 * Registers the specified levels with logform.
	 */
	browser$3.levels = requireLevels();

	//
	// Setup all transports as eager-loaded exports
	// so that they are static for the bundlers.
	//
	Object.defineProperty(format, 'align', {
	  value: requireAlign()
	});
	Object.defineProperty(format, 'cli', {
	  value: requireCli()
	});
	Object.defineProperty(format, 'colorize', {
	  value: requireColorize()
	});
	Object.defineProperty(format, 'combine', {
	  value: requireCombine()
	});
	Object.defineProperty(format, 'errors', {
	  value: requireErrors$1()
	});
	Object.defineProperty(format, 'json', {
	  value: requireJson$1()
	});
	Object.defineProperty(format, 'label', {
	  value: requireLabel()
	});
	Object.defineProperty(format, 'logstash', {
	  value: requireLogstash()
	});
	Object.defineProperty(format, 'metadata', {
	  value: requireMetadata$1()
	});
	Object.defineProperty(format, 'ms', {
	  value: requireMs()
	});
	Object.defineProperty(format, 'padLevels', {
	  value: requirePadLevels()
	});
	Object.defineProperty(format, 'prettyPrint', {
	  value: requirePrettyPrint()
	});
	Object.defineProperty(format, 'printf', {
	  value: requirePrintf()
	});
	Object.defineProperty(format, 'simple', {
	  value: requireSimple()
	});
	Object.defineProperty(format, 'splat', {
	  value: requireSplat()
	});
	Object.defineProperty(format, 'timestamp', {
	  value: requireTimestamp()
	});
	Object.defineProperty(format, 'uncolorize', {
	  value: requireUncolorize()
	});
	return browser$3;
}

var common = {};

/**
 * common.js: Internal helper and utility functions for winston.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	(function (exports) {

		var _require = require$$0$1,
		  format = _require.format;

		/**
		 * Set of simple deprecation notices and a way to expose them for a set of
		 * properties.
		 * @type {Object}
		 * @private
		 */
		exports.warn = {
		  deprecated: function deprecated(prop) {
		    return function () {
		      throw new Error(format('{ %s } was removed in winston@3.0.0.', prop));
		    };
		  },
		  useFormat: function useFormat(prop) {
		    return function () {
		      throw new Error([format('{ %s } was removed in winston@3.0.0.', prop), 'Use a custom winston.format = winston.format(function) instead.'].join('\n'));
		    };
		  },
		  forFunctions: function forFunctions(obj, type, props) {
		    props.forEach(function (prop) {
		      obj[prop] = exports.warn[type](prop);
		    });
		  },
		  forProperties: function forProperties(obj, type, props) {
		    props.forEach(function (prop) {
		      var notice = exports.warn[type](prop);
		      Object.defineProperty(obj, prop, {
		        get: notice,
		        set: notice
		      });
		    });
		  }
		}; 
	} (common));
	return common;
}

const name = "winston";
const description$1 = "A logger for just about everything.";
const version = "3.17.0";
const author = "Charlie Robbins <charlie.robbins@gmail.com>";
const maintainers = ["David Hyde <dabh@alumni.stanford.edu>"];
const repository = {"type":"git","url":"https://github.com/winstonjs/winston.git"};
const keywords = ["winston","logger","logging","logs","sysadmin","bunyan","pino","loglevel","tools","json","stream"];
const dependencies$1 = {"@dabh/diagnostics":"^2.0.2","@colors/colors":"^1.6.0","async":"^3.2.3","is-stream":"^2.0.0","logform":"^2.7.0","one-time":"^1.0.0","readable-stream":"^3.4.0","safe-stable-stringify":"^2.3.1","stack-trace":"0.0.x","triple-beam":"^1.3.0","winston-transport":"^4.9.0"};
const devDependencies = {"@babel/cli":"^7.23.9","@babel/core":"^7.24.0","@babel/preset-env":"^7.24.0","@dabh/eslint-config-populist":"^4.4.0","@types/node":"^20.11.24","abstract-winston-transport":"^0.5.1","assume":"^2.2.0","cross-spawn-async":"^2.2.5","eslint":"^8.57.0","hock":"^1.4.1","mocha":"^10.3.0","nyc":"^17.1.0","rimraf":"5.0.1","split2":"^4.1.0","std-mocks":"^2.0.0","through2":"^4.0.2","winston-compat":"^0.1.5"};
const main = "./lib/winston.js";
const browser$2 = "./dist/winston";
const types$2 = "./index.d.ts";
const scripts = {"lint":"eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist","test":"rimraf test/fixtures/logs/* && mocha","test:coverage":"nyc npm run test:unit","test:unit":"mocha test/unit","test:integration":"mocha test/integration","build":"rimraf dist && babel lib -d dist","prepublishOnly":"npm run build"};
const engines = {"node":">= 12.0.0"};
const license = "MIT";
const require$$2 = {
  name,
  description: description$1,
  version,
  author,
  maintainers,
  repository,
  keywords,
  dependencies: dependencies$1,
  devDependencies,
  main,
  browser: browser$2,
  types: types$2,
  scripts,
  engines,
  license,
};

var transports = {};

var dist$1 = {exports: {}};

var modern$1 = {exports: {}};

var browser$1;
var hasRequiredBrowser$1;

function requireBrowser$1 () {
	if (hasRequiredBrowser$1) return browser$1;
	hasRequiredBrowser$1 = 1;
	/**
	 * Module exports.
	 */

	browser$1 = deprecate;

	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */

	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */

	function config (name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!commonjsGlobal.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = commonjsGlobal.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}
	return browser$1;
}

var streamBrowser;
var hasRequiredStreamBrowser;

function requireStreamBrowser () {
	if (hasRequiredStreamBrowser) return streamBrowser;
	hasRequiredStreamBrowser = 1;
	streamBrowser = require$$0$2.EventEmitter;
	return streamBrowser;
}

var destroy_1;
var hasRequiredDestroy;

function requireDestroy () {
	if (hasRequiredDestroy) return destroy_1;
	hasRequiredDestroy = 1;

	// undocumented cb() API, needed for core, not for public API
	function destroy(err, cb) {
	  var _this = this;
	  var readableDestroyed = this._readableState && this._readableState.destroyed;
	  var writableDestroyed = this._writableState && this._writableState.destroyed;
	  if (readableDestroyed || writableDestroyed) {
	    if (cb) {
	      cb(err);
	    } else if (err) {
	      if (!this._writableState) {
	        process.nextTick(emitErrorNT, this, err);
	      } else if (!this._writableState.errorEmitted) {
	        this._writableState.errorEmitted = true;
	        process.nextTick(emitErrorNT, this, err);
	      }
	    }
	    return this;
	  }

	  // we set destroyed to true before firing error callbacks in order
	  // to make it re-entrance safe in case destroy() is called within callbacks

	  if (this._readableState) {
	    this._readableState.destroyed = true;
	  }

	  // if this is a duplex stream mark the writable part as destroyed as well
	  if (this._writableState) {
	    this._writableState.destroyed = true;
	  }
	  this._destroy(err || null, function (err) {
	    if (!cb && err) {
	      if (!_this._writableState) {
	        process.nextTick(emitErrorAndCloseNT, _this, err);
	      } else if (!_this._writableState.errorEmitted) {
	        _this._writableState.errorEmitted = true;
	        process.nextTick(emitErrorAndCloseNT, _this, err);
	      } else {
	        process.nextTick(emitCloseNT, _this);
	      }
	    } else if (cb) {
	      process.nextTick(emitCloseNT, _this);
	      cb(err);
	    } else {
	      process.nextTick(emitCloseNT, _this);
	    }
	  });
	  return this;
	}
	function emitErrorAndCloseNT(self, err) {
	  emitErrorNT(self, err);
	  emitCloseNT(self);
	}
	function emitCloseNT(self) {
	  if (self._writableState && !self._writableState.emitClose) return;
	  if (self._readableState && !self._readableState.emitClose) return;
	  self.emit('close');
	}
	function undestroy() {
	  if (this._readableState) {
	    this._readableState.destroyed = false;
	    this._readableState.reading = false;
	    this._readableState.ended = false;
	    this._readableState.endEmitted = false;
	  }
	  if (this._writableState) {
	    this._writableState.destroyed = false;
	    this._writableState.ended = false;
	    this._writableState.ending = false;
	    this._writableState.finalCalled = false;
	    this._writableState.prefinished = false;
	    this._writableState.finished = false;
	    this._writableState.errorEmitted = false;
	  }
	}
	function emitErrorNT(self, err) {
	  self.emit('error', err);
	}
	function errorOrDestroy(stream, err) {
	  // We have tests that rely on errors being emitted
	  // in the same tick, so changing this is semver major.
	  // For now when you opt-in to autoDestroy we allow
	  // the error to be emitted nextTick. In a future
	  // semver major update we should change the default to this.

	  var rState = stream._readableState;
	  var wState = stream._writableState;
	  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
	}
	destroy_1 = {
	  destroy: destroy,
	  undestroy: undestroy,
	  errorOrDestroy: errorOrDestroy
	};
	return destroy_1;
}

var errorsBrowser = {};

var hasRequiredErrorsBrowser;

function requireErrorsBrowser () {
	if (hasRequiredErrorsBrowser) return errorsBrowser;
	hasRequiredErrorsBrowser = 1;

	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

	var codes = {};

	function createErrorType(code, message, Base) {
	  if (!Base) {
	    Base = Error;
	  }

	  function getMessage(arg1, arg2, arg3) {
	    if (typeof message === 'string') {
	      return message;
	    } else {
	      return message(arg1, arg2, arg3);
	    }
	  }

	  var NodeError =
	  /*#__PURE__*/
	  function (_Base) {
	    _inheritsLoose(NodeError, _Base);

	    function NodeError(arg1, arg2, arg3) {
	      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
	    }

	    return NodeError;
	  }(Base);

	  NodeError.prototype.name = Base.name;
	  NodeError.prototype.code = code;
	  codes[code] = NodeError;
	} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


	function oneOf(expected, thing) {
	  if (Array.isArray(expected)) {
	    var len = expected.length;
	    expected = expected.map(function (i) {
	      return String(i);
	    });

	    if (len > 2) {
	      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
	    } else if (len === 2) {
	      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
	    } else {
	      return "of ".concat(thing, " ").concat(expected[0]);
	    }
	  } else {
	    return "of ".concat(thing, " ").concat(String(expected));
	  }
	} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


	function startsWith(str, search, pos) {
	  return str.substr(0 , search.length) === search;
	} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


	function endsWith(str, search, this_len) {
	  if (this_len === undefined || this_len > str.length) {
	    this_len = str.length;
	  }

	  return str.substring(this_len - search.length, this_len) === search;
	} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


	function includes(str, search, start) {
	  if (typeof start !== 'number') {
	    start = 0;
	  }

	  if (start + search.length > str.length) {
	    return false;
	  } else {
	    return str.indexOf(search, start) !== -1;
	  }
	}

	createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
	  return 'The value "' + value + '" is invalid for option "' + name + '"';
	}, TypeError);
	createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
	  // determiner: 'must be' or 'must not be'
	  var determiner;

	  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
	    determiner = 'must not be';
	    expected = expected.replace(/^not /, '');
	  } else {
	    determiner = 'must be';
	  }

	  var msg;

	  if (endsWith(name, ' argument')) {
	    // For cases like 'first argument'
	    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
	  } else {
	    var type = includes(name, '.') ? 'property' : 'argument';
	    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
	  }

	  msg += ". Received type ".concat(typeof actual);
	  return msg;
	}, TypeError);
	createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
	createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
	  return 'The ' + name + ' method is not implemented';
	});
	createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
	createErrorType('ERR_STREAM_DESTROYED', function (name) {
	  return 'Cannot call ' + name + ' after a stream was destroyed';
	});
	createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
	createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
	createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
	createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
	createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
	  return 'Unknown encoding: ' + arg;
	}, TypeError);
	createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
	errorsBrowser.codes = codes;
	return errorsBrowser;
}

var state;
var hasRequiredState;

function requireState () {
	if (hasRequiredState) return state;
	hasRequiredState = 1;

	var ERR_INVALID_OPT_VALUE = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
	function highWaterMarkFrom(options, isDuplex, duplexKey) {
	  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
	}
	function getHighWaterMark(state, options, duplexKey, isDuplex) {
	  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
	  if (hwm != null) {
	    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
	      var name = isDuplex ? duplexKey : 'highWaterMark';
	      throw new ERR_INVALID_OPT_VALUE(name, hwm);
	    }
	    return Math.floor(hwm);
	  }

	  // Default value
	  return state.objectMode ? 16 : 16 * 1024;
	}
	state = {
	  getHighWaterMark: getHighWaterMark
	};
	return state;
}

var inherits_browser = {exports: {}};

var hasRequiredInherits_browser;

function requireInherits_browser () {
	if (hasRequiredInherits_browser) return inherits_browser.exports;
	hasRequiredInherits_browser = 1;
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    }
	  };
	} else {
	  // old school shim for old browsers
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      var TempCtor = function () {};
	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    }
	  };
	}
	return inherits_browser.exports;
}

var buffer_list;
var hasRequiredBuffer_list;

function requireBuffer_list () {
	if (hasRequiredBuffer_list) return buffer_list;
	hasRequiredBuffer_list = 1;

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
	function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
	var _require = require$$0$3,
	  Buffer = _require.Buffer;
	var _require2 = require$$0$1,
	  inspect = _require2.inspect;
	var custom = inspect && inspect.custom || 'inspect';
	function copyBuffer(src, target, offset) {
	  Buffer.prototype.copy.call(src, target, offset);
	}
	buffer_list = /*#__PURE__*/function () {
	  function BufferList() {
	    _classCallCheck(this, BufferList);
	    this.head = null;
	    this.tail = null;
	    this.length = 0;
	  }
	  _createClass(BufferList, [{
	    key: "push",
	    value: function push(v) {
	      var entry = {
	        data: v,
	        next: null
	      };
	      if (this.length > 0) this.tail.next = entry;else this.head = entry;
	      this.tail = entry;
	      ++this.length;
	    }
	  }, {
	    key: "unshift",
	    value: function unshift(v) {
	      var entry = {
	        data: v,
	        next: this.head
	      };
	      if (this.length === 0) this.tail = entry;
	      this.head = entry;
	      ++this.length;
	    }
	  }, {
	    key: "shift",
	    value: function shift() {
	      if (this.length === 0) return;
	      var ret = this.head.data;
	      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	      --this.length;
	      return ret;
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      this.head = this.tail = null;
	      this.length = 0;
	    }
	  }, {
	    key: "join",
	    value: function join(s) {
	      if (this.length === 0) return '';
	      var p = this.head;
	      var ret = '' + p.data;
	      while (p = p.next) ret += s + p.data;
	      return ret;
	    }
	  }, {
	    key: "concat",
	    value: function concat(n) {
	      if (this.length === 0) return Buffer.alloc(0);
	      var ret = Buffer.allocUnsafe(n >>> 0);
	      var p = this.head;
	      var i = 0;
	      while (p) {
	        copyBuffer(p.data, ret, i);
	        i += p.data.length;
	        p = p.next;
	      }
	      return ret;
	    }

	    // Consumes a specified amount of bytes or characters from the buffered data.
	  }, {
	    key: "consume",
	    value: function consume(n, hasStrings) {
	      var ret;
	      if (n < this.head.data.length) {
	        // `slice` is the same for buffers and strings.
	        ret = this.head.data.slice(0, n);
	        this.head.data = this.head.data.slice(n);
	      } else if (n === this.head.data.length) {
	        // First chunk is a perfect match.
	        ret = this.shift();
	      } else {
	        // Result spans more than one buffer.
	        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
	      }
	      return ret;
	    }
	  }, {
	    key: "first",
	    value: function first() {
	      return this.head.data;
	    }

	    // Consumes a specified amount of characters from the buffered data.
	  }, {
	    key: "_getString",
	    value: function _getString(n) {
	      var p = this.head;
	      var c = 1;
	      var ret = p.data;
	      n -= ret.length;
	      while (p = p.next) {
	        var str = p.data;
	        var nb = n > str.length ? str.length : n;
	        if (nb === str.length) ret += str;else ret += str.slice(0, n);
	        n -= nb;
	        if (n === 0) {
	          if (nb === str.length) {
	            ++c;
	            if (p.next) this.head = p.next;else this.head = this.tail = null;
	          } else {
	            this.head = p;
	            p.data = str.slice(nb);
	          }
	          break;
	        }
	        ++c;
	      }
	      this.length -= c;
	      return ret;
	    }

	    // Consumes a specified amount of bytes from the buffered data.
	  }, {
	    key: "_getBuffer",
	    value: function _getBuffer(n) {
	      var ret = Buffer.allocUnsafe(n);
	      var p = this.head;
	      var c = 1;
	      p.data.copy(ret);
	      n -= p.data.length;
	      while (p = p.next) {
	        var buf = p.data;
	        var nb = n > buf.length ? buf.length : n;
	        buf.copy(ret, ret.length - n, 0, nb);
	        n -= nb;
	        if (n === 0) {
	          if (nb === buf.length) {
	            ++c;
	            if (p.next) this.head = p.next;else this.head = this.tail = null;
	          } else {
	            this.head = p;
	            p.data = buf.slice(nb);
	          }
	          break;
	        }
	        ++c;
	      }
	      this.length -= c;
	      return ret;
	    }

	    // Make sure the linked list only shows the minimal necessary information.
	  }, {
	    key: custom,
	    value: function value(_, options) {
	      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
	        // Only inspect one level.
	        depth: 0,
	        // It should not recurse.
	        customInspect: false
	      }));
	    }
	  }]);
	  return BufferList;
	}();
	return buffer_list;
}

var string_decoder = {};

var safeBuffer = {exports: {}};

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredSafeBuffer;

function requireSafeBuffer () {
	if (hasRequiredSafeBuffer) return safeBuffer.exports;
	hasRequiredSafeBuffer = 1;
	(function (module, exports) {
		/* eslint-disable node/no-deprecated-api */
		var buffer = require$$0$3;
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports);
		  exports.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		SafeBuffer.prototype = Object.create(Buffer.prototype);

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		}; 
	} (safeBuffer, safeBuffer.exports));
	return safeBuffer.exports;
}

var hasRequiredString_decoder;

function requireString_decoder () {
	if (hasRequiredString_decoder) return string_decoder;
	hasRequiredString_decoder = 1;

	/*<replacement>*/

	var Buffer = requireSafeBuffer().Buffer;
	/*</replacement>*/

	var isEncoding = Buffer.isEncoding || function (encoding) {
	  encoding = '' + encoding;
	  switch (encoding && encoding.toLowerCase()) {
	    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
	      return true;
	    default:
	      return false;
	  }
	};

	function _normalizeEncoding(enc) {
	  if (!enc) return 'utf8';
	  var retried;
	  while (true) {
	    switch (enc) {
	      case 'utf8':
	      case 'utf-8':
	        return 'utf8';
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return 'utf16le';
	      case 'latin1':
	      case 'binary':
	        return 'latin1';
	      case 'base64':
	      case 'ascii':
	      case 'hex':
	        return enc;
	      default:
	        if (retried) return; // undefined
	        enc = ('' + enc).toLowerCase();
	        retried = true;
	    }
	  }
	}
	// Do not cache `Buffer.isEncoding` when checking encoding names as some
	// modules monkey-patch it to support additional encodings
	function normalizeEncoding(enc) {
	  var nenc = _normalizeEncoding(enc);
	  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
	  return nenc || enc;
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters.
	string_decoder.StringDecoder = StringDecoder;
	function StringDecoder(encoding) {
	  this.encoding = normalizeEncoding(encoding);
	  var nb;
	  switch (this.encoding) {
	    case 'utf16le':
	      this.text = utf16Text;
	      this.end = utf16End;
	      nb = 4;
	      break;
	    case 'utf8':
	      this.fillLast = utf8FillLast;
	      nb = 4;
	      break;
	    case 'base64':
	      this.text = base64Text;
	      this.end = base64End;
	      nb = 3;
	      break;
	    default:
	      this.write = simpleWrite;
	      this.end = simpleEnd;
	      return;
	  }
	  this.lastNeed = 0;
	  this.lastTotal = 0;
	  this.lastChar = Buffer.allocUnsafe(nb);
	}

	StringDecoder.prototype.write = function (buf) {
	  if (buf.length === 0) return '';
	  var r;
	  var i;
	  if (this.lastNeed) {
	    r = this.fillLast(buf);
	    if (r === undefined) return '';
	    i = this.lastNeed;
	    this.lastNeed = 0;
	  } else {
	    i = 0;
	  }
	  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
	  return r || '';
	};

	StringDecoder.prototype.end = utf8End;

	// Returns only complete characters in a Buffer
	StringDecoder.prototype.text = utf8Text;

	// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
	StringDecoder.prototype.fillLast = function (buf) {
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
	  this.lastNeed -= buf.length;
	};

	// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
	// continuation byte. If an invalid byte is detected, -2 is returned.
	function utf8CheckByte(byte) {
	  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
	  return byte >> 6 === 0x02 ? -1 : -2;
	}

	// Checks at most 3 bytes at the end of a Buffer in order to detect an
	// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
	// needed to complete the UTF-8 character (if applicable) are returned.
	function utf8CheckIncomplete(self, buf, i) {
	  var j = buf.length - 1;
	  if (j < i) return 0;
	  var nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 1;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 2;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) {
	      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
	    }
	    return nb;
	  }
	  return 0;
	}

	// Validates as many continuation bytes for a multi-byte UTF-8 character as
	// needed or are available. If we see a non-continuation byte where we expect
	// one, we "replace" the validated continuation bytes we've seen so far with
	// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
	// behavior. The continuation byte check is included three times in the case
	// where all of the continuation bytes for a character exist in the same buffer.
	// It is also done this way as a slight performance increase instead of using a
	// loop.
	function utf8CheckExtraBytes(self, buf, p) {
	  if ((buf[0] & 0xC0) !== 0x80) {
	    self.lastNeed = 0;
	    return '\ufffd';
	  }
	  if (self.lastNeed > 1 && buf.length > 1) {
	    if ((buf[1] & 0xC0) !== 0x80) {
	      self.lastNeed = 1;
	      return '\ufffd';
	    }
	    if (self.lastNeed > 2 && buf.length > 2) {
	      if ((buf[2] & 0xC0) !== 0x80) {
	        self.lastNeed = 2;
	        return '\ufffd';
	      }
	    }
	  }
	}

	// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
	function utf8FillLast(buf) {
	  var p = this.lastTotal - this.lastNeed;
	  var r = utf8CheckExtraBytes(this, buf);
	  if (r !== undefined) return r;
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, p, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, p, 0, buf.length);
	  this.lastNeed -= buf.length;
	}

	// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
	// partial character, the character's bytes are buffered until the required
	// number of bytes are available.
	function utf8Text(buf, i) {
	  var total = utf8CheckIncomplete(this, buf, i);
	  if (!this.lastNeed) return buf.toString('utf8', i);
	  this.lastTotal = total;
	  var end = buf.length - (total - this.lastNeed);
	  buf.copy(this.lastChar, 0, end);
	  return buf.toString('utf8', i, end);
	}

	// For UTF-8, a replacement character is added when ending on a partial
	// character.
	function utf8End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + '\ufffd';
	  return r;
	}

	// UTF-16LE typically needs two bytes per character, but even if we have an even
	// number of bytes available, we need to check if we end on a leading/high
	// surrogate. In that case, we need to wait for the next two bytes in order to
	// decode the last character properly.
	function utf16Text(buf, i) {
	  if ((buf.length - i) % 2 === 0) {
	    var r = buf.toString('utf16le', i);
	    if (r) {
	      var c = r.charCodeAt(r.length - 1);
	      if (c >= 0xD800 && c <= 0xDBFF) {
	        this.lastNeed = 2;
	        this.lastTotal = 4;
	        this.lastChar[0] = buf[buf.length - 2];
	        this.lastChar[1] = buf[buf.length - 1];
	        return r.slice(0, -1);
	      }
	    }
	    return r;
	  }
	  this.lastNeed = 1;
	  this.lastTotal = 2;
	  this.lastChar[0] = buf[buf.length - 1];
	  return buf.toString('utf16le', i, buf.length - 1);
	}

	// For UTF-16LE we do not explicitly append special replacement characters if we
	// end on a partial character, we simply let v8 handle that.
	function utf16End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) {
	    var end = this.lastTotal - this.lastNeed;
	    return r + this.lastChar.toString('utf16le', 0, end);
	  }
	  return r;
	}

	function base64Text(buf, i) {
	  var n = (buf.length - i) % 3;
	  if (n === 0) return buf.toString('base64', i);
	  this.lastNeed = 3 - n;
	  this.lastTotal = 3;
	  if (n === 1) {
	    this.lastChar[0] = buf[buf.length - 1];
	  } else {
	    this.lastChar[0] = buf[buf.length - 2];
	    this.lastChar[1] = buf[buf.length - 1];
	  }
	  return buf.toString('base64', i, buf.length - n);
	}

	function base64End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
	  return r;
	}

	// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
	function simpleWrite(buf) {
	  return buf.toString(this.encoding);
	}

	function simpleEnd(buf) {
	  return buf && buf.length ? this.write(buf) : '';
	}
	return string_decoder;
}

var endOfStream;
var hasRequiredEndOfStream;

function requireEndOfStream () {
	if (hasRequiredEndOfStream) return endOfStream;
	hasRequiredEndOfStream = 1;

	var ERR_STREAM_PREMATURE_CLOSE = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
	function once(callback) {
	  var called = false;
	  return function () {
	    if (called) return;
	    called = true;
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    callback.apply(this, args);
	  };
	}
	function noop() {}
	function isRequest(stream) {
	  return stream.setHeader && typeof stream.abort === 'function';
	}
	function eos(stream, opts, callback) {
	  if (typeof opts === 'function') return eos(stream, null, opts);
	  if (!opts) opts = {};
	  callback = once(callback || noop);
	  var readable = opts.readable || opts.readable !== false && stream.readable;
	  var writable = opts.writable || opts.writable !== false && stream.writable;
	  var onlegacyfinish = function onlegacyfinish() {
	    if (!stream.writable) onfinish();
	  };
	  var writableEnded = stream._writableState && stream._writableState.finished;
	  var onfinish = function onfinish() {
	    writable = false;
	    writableEnded = true;
	    if (!readable) callback.call(stream);
	  };
	  var readableEnded = stream._readableState && stream._readableState.endEmitted;
	  var onend = function onend() {
	    readable = false;
	    readableEnded = true;
	    if (!writable) callback.call(stream);
	  };
	  var onerror = function onerror(err) {
	    callback.call(stream, err);
	  };
	  var onclose = function onclose() {
	    var err;
	    if (readable && !readableEnded) {
	      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
	      return callback.call(stream, err);
	    }
	    if (writable && !writableEnded) {
	      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
	      return callback.call(stream, err);
	    }
	  };
	  var onrequest = function onrequest() {
	    stream.req.on('finish', onfinish);
	  };
	  if (isRequest(stream)) {
	    stream.on('complete', onfinish);
	    stream.on('abort', onclose);
	    if (stream.req) onrequest();else stream.on('request', onrequest);
	  } else if (writable && !stream._writableState) {
	    // legacy streams
	    stream.on('end', onlegacyfinish);
	    stream.on('close', onlegacyfinish);
	  }
	  stream.on('end', onend);
	  stream.on('finish', onfinish);
	  if (opts.error !== false) stream.on('error', onerror);
	  stream.on('close', onclose);
	  return function () {
	    stream.removeListener('complete', onfinish);
	    stream.removeListener('abort', onclose);
	    stream.removeListener('request', onrequest);
	    if (stream.req) stream.req.removeListener('finish', onfinish);
	    stream.removeListener('end', onlegacyfinish);
	    stream.removeListener('close', onlegacyfinish);
	    stream.removeListener('finish', onfinish);
	    stream.removeListener('end', onend);
	    stream.removeListener('error', onerror);
	    stream.removeListener('close', onclose);
	  };
	}
	endOfStream = eos;
	return endOfStream;
}

var async_iterator;
var hasRequiredAsync_iterator;

function requireAsync_iterator () {
	if (hasRequiredAsync_iterator) return async_iterator;
	hasRequiredAsync_iterator = 1;

	var _Object$setPrototypeO;
	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
	function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
	var finished = requireEndOfStream();
	var kLastResolve = Symbol('lastResolve');
	var kLastReject = Symbol('lastReject');
	var kError = Symbol('error');
	var kEnded = Symbol('ended');
	var kLastPromise = Symbol('lastPromise');
	var kHandlePromise = Symbol('handlePromise');
	var kStream = Symbol('stream');
	function createIterResult(value, done) {
	  return {
	    value: value,
	    done: done
	  };
	}
	function readAndResolve(iter) {
	  var resolve = iter[kLastResolve];
	  if (resolve !== null) {
	    var data = iter[kStream].read();
	    // we defer if data is null
	    // we can be expecting either 'end' or
	    // 'error'
	    if (data !== null) {
	      iter[kLastPromise] = null;
	      iter[kLastResolve] = null;
	      iter[kLastReject] = null;
	      resolve(createIterResult(data, false));
	    }
	  }
	}
	function onReadable(iter) {
	  // we wait for the next tick, because it might
	  // emit an error with process.nextTick
	  process.nextTick(readAndResolve, iter);
	}
	function wrapForNext(lastPromise, iter) {
	  return function (resolve, reject) {
	    lastPromise.then(function () {
	      if (iter[kEnded]) {
	        resolve(createIterResult(undefined, true));
	        return;
	      }
	      iter[kHandlePromise](resolve, reject);
	    }, reject);
	  };
	}
	var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
	var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
	  get stream() {
	    return this[kStream];
	  },
	  next: function next() {
	    var _this = this;
	    // if we have detected an error in the meanwhile
	    // reject straight away
	    var error = this[kError];
	    if (error !== null) {
	      return Promise.reject(error);
	    }
	    if (this[kEnded]) {
	      return Promise.resolve(createIterResult(undefined, true));
	    }
	    if (this[kStream].destroyed) {
	      // We need to defer via nextTick because if .destroy(err) is
	      // called, the error will be emitted via nextTick, and
	      // we cannot guarantee that there is no error lingering around
	      // waiting to be emitted.
	      return new Promise(function (resolve, reject) {
	        process.nextTick(function () {
	          if (_this[kError]) {
	            reject(_this[kError]);
	          } else {
	            resolve(createIterResult(undefined, true));
	          }
	        });
	      });
	    }

	    // if we have multiple next() calls
	    // we will wait for the previous Promise to finish
	    // this logic is optimized to support for await loops,
	    // where next() is only called once at a time
	    var lastPromise = this[kLastPromise];
	    var promise;
	    if (lastPromise) {
	      promise = new Promise(wrapForNext(lastPromise, this));
	    } else {
	      // fast path needed to support multiple this.push()
	      // without triggering the next() queue
	      var data = this[kStream].read();
	      if (data !== null) {
	        return Promise.resolve(createIterResult(data, false));
	      }
	      promise = new Promise(this[kHandlePromise]);
	    }
	    this[kLastPromise] = promise;
	    return promise;
	  }
	}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
	  return this;
	}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
	  var _this2 = this;
	  // destroy(err, cb) is a private API
	  // we can guarantee we have that here, because we control the
	  // Readable class this is attached to
	  return new Promise(function (resolve, reject) {
	    _this2[kStream].destroy(null, function (err) {
	      if (err) {
	        reject(err);
	        return;
	      }
	      resolve(createIterResult(undefined, true));
	    });
	  });
	}), _Object$setPrototypeO), AsyncIteratorPrototype);
	var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
	  var _Object$create;
	  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
	    value: stream,
	    writable: true
	  }), _defineProperty(_Object$create, kLastResolve, {
	    value: null,
	    writable: true
	  }), _defineProperty(_Object$create, kLastReject, {
	    value: null,
	    writable: true
	  }), _defineProperty(_Object$create, kError, {
	    value: null,
	    writable: true
	  }), _defineProperty(_Object$create, kEnded, {
	    value: stream._readableState.endEmitted,
	    writable: true
	  }), _defineProperty(_Object$create, kHandlePromise, {
	    value: function value(resolve, reject) {
	      var data = iterator[kStream].read();
	      if (data) {
	        iterator[kLastPromise] = null;
	        iterator[kLastResolve] = null;
	        iterator[kLastReject] = null;
	        resolve(createIterResult(data, false));
	      } else {
	        iterator[kLastResolve] = resolve;
	        iterator[kLastReject] = reject;
	      }
	    },
	    writable: true
	  }), _Object$create));
	  iterator[kLastPromise] = null;
	  finished(stream, function (err) {
	    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
	      var reject = iterator[kLastReject];
	      // reject if we are waiting for data in the Promise
	      // returned by next() and store the error
	      if (reject !== null) {
	        iterator[kLastPromise] = null;
	        iterator[kLastResolve] = null;
	        iterator[kLastReject] = null;
	        reject(err);
	      }
	      iterator[kError] = err;
	      return;
	    }
	    var resolve = iterator[kLastResolve];
	    if (resolve !== null) {
	      iterator[kLastPromise] = null;
	      iterator[kLastResolve] = null;
	      iterator[kLastReject] = null;
	      resolve(createIterResult(undefined, true));
	    }
	    iterator[kEnded] = true;
	  });
	  stream.on('readable', onReadable.bind(null, iterator));
	  return iterator;
	};
	async_iterator = createReadableStreamAsyncIterator;
	return async_iterator;
}

var fromBrowser;
var hasRequiredFromBrowser;

function requireFromBrowser () {
	if (hasRequiredFromBrowser) return fromBrowser;
	hasRequiredFromBrowser = 1;
	fromBrowser = function () {
	  throw new Error('Readable.from is not available in the browser')
	};
	return fromBrowser;
}

var _stream_readable;
var hasRequired_stream_readable;

function require_stream_readable () {
	if (hasRequired_stream_readable) return _stream_readable;
	hasRequired_stream_readable = 1;

	_stream_readable = Readable;

	/*<replacement>*/
	var Duplex;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	/*<replacement>*/
	require$$0$2.EventEmitter;
	var EElistenerCount = function EElistenerCount(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream = requireStreamBrowser();
	/*</replacement>*/

	var Buffer = require$$0$3.Buffer;
	var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}

	/*<replacement>*/
	var debugUtil = require$$0$1;
	var debug;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function debug() {};
	}
	/*</replacement>*/

	var BufferList = requireBuffer_list();
	var destroyImpl = requireDestroy();
	var _require = requireState(),
	  getHighWaterMark = _require.getHighWaterMark;
	var _require$codes = requireErrorsBrowser().codes,
	  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
	  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

	// Lazy loaded to improve the startup performance.
	var StringDecoder;
	var createReadableStreamAsyncIterator;
	var from;
	requireInherits_browser()(Readable, Stream);
	var errorOrDestroy = destroyImpl.errorOrDestroy;
	var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

	  // This is a hack to make sure that our error handler is attached before any
	  // userland ones.  NEVER DO THIS. This is here only because this code needs
	  // to continue to work with older versions of Node.js that do not include
	  // the prependListener() method. The goal is to eventually remove this hack.
	  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	}
	function ReadableState(options, stream, isDuplex) {
	  Duplex = Duplex || require_stream_duplex();
	  options = options || {};

	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream.
	  // These options can be provided separately as readableXXX and writableXXX.
	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the event 'readable'/'data' is emitted
	  // immediately, or on a later tick.  We set this to true at first, because
	  // any actions that shouldn't happen until "later" should generally also
	  // not happen before the first read call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;
	  this.paused = true;

	  // Should close be emitted on destroy. Defaults to true.
	  this.emitClose = options.emitClose !== false;

	  // Should .destroy() be called after 'end' (and potentially 'finish')
	  this.autoDestroy = !!options.autoDestroy;

	  // has it been destroyed
	  this.destroyed = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	function Readable(options) {
	  Duplex = Duplex || require_stream_duplex();
	  if (!(this instanceof Readable)) return new Readable(options);

	  // Checking for a Stream.Duplex instance is faster here instead of inside
	  // the ReadableState constructor, at least with V8 6.5
	  var isDuplex = this instanceof Duplex;
	  this._readableState = new ReadableState(options, this, isDuplex);

	  // legacy
	  this.readable = true;
	  if (options) {
	    if (typeof options.read === 'function') this._read = options.read;
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	  }
	  Stream.call(this);
	}
	Object.defineProperty(Readable.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._readableState === undefined) {
	      return false;
	    }
	    return this._readableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._readableState) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._readableState.destroyed = value;
	  }
	});
	Readable.prototype.destroy = destroyImpl.destroy;
	Readable.prototype._undestroy = destroyImpl.undestroy;
	Readable.prototype._destroy = function (err, cb) {
	  cb(err);
	};

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	  var skipChunkCheck;
	  if (!state.objectMode) {
	    if (typeof chunk === 'string') {
	      encoding = encoding || state.defaultEncoding;
	      if (encoding !== state.encoding) {
	        chunk = Buffer.from(chunk, encoding);
	        encoding = '';
	      }
	      skipChunkCheck = true;
	    }
	  } else {
	    skipChunkCheck = true;
	  }
	  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  return readableAddChunk(this, chunk, null, true, false);
	};
	function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
	  debug('readableAddChunk', chunk);
	  var state = stream._readableState;
	  if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else {
	    var er;
	    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
	    if (er) {
	      errorOrDestroy(stream, er);
	    } else if (state.objectMode || chunk && chunk.length > 0) {
	      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
	        chunk = _uint8ArrayToBuffer(chunk);
	      }
	      if (addToFront) {
	        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
	      } else if (state.ended) {
	        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
	      } else if (state.destroyed) {
	        return false;
	      } else {
	        state.reading = false;
	        if (state.decoder && !encoding) {
	          chunk = state.decoder.write(chunk);
	          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
	        } else {
	          addChunk(stream, state, chunk, false);
	        }
	      }
	    } else if (!addToFront) {
	      state.reading = false;
	      maybeReadMore(stream, state);
	    }
	  }

	  // We can push more data if we are below the highWaterMark.
	  // Also, if we have no data yet, we can stand some more bytes.
	  // This is to work around cases where hwm=0, such as the repl.
	  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
	}
	function addChunk(stream, state, chunk, addToFront) {
	  if (state.flowing && state.length === 0 && !state.sync) {
	    state.awaitDrain = 0;
	    stream.emit('data', chunk);
	  } else {
	    // update the buffer info.
	    state.length += state.objectMode ? 1 : chunk.length;
	    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	    if (state.needReadable) emitReadable(stream);
	  }
	  maybeReadMore(stream, state);
	}
	function chunkInvalid(state, chunk) {
	  var er;
	  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
	  }
	  return er;
	}
	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};

	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
	  var decoder = new StringDecoder(enc);
	  this._readableState.decoder = decoder;
	  // If setEncoding(null), decoder.encoding equals utf8
	  this._readableState.encoding = this._readableState.decoder.encoding;

	  // Iterate over current buffer to convert already stored Buffers:
	  var p = this._readableState.buffer.head;
	  var content = '';
	  while (p !== null) {
	    content += decoder.write(p.data);
	    p = p.next;
	  }
	  this._readableState.buffer.clear();
	  if (content !== '') this._readableState.buffer.push(content);
	  this._readableState.length = content.length;
	  return this;
	};

	// Don't raise the hwm > 1GB
	var MAX_HWM = 0x40000000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}

	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;
	  if (n !== 0) state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }
	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }
	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;
	  if (ret === null) {
	    state.needReadable = state.length <= state.highWaterMark;
	    n = 0;
	  } else {
	    state.length -= n;
	    state.awaitDrain = 0;
	  }
	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;

	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }
	  if (ret !== null) this.emit('data', ret);
	  return ret;
	};
	function onEofChunk(stream, state) {
	  debug('onEofChunk');
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	  if (state.sync) {
	    // if we are sync, wait until next tick to emit the data.
	    // Otherwise we risk emitting data in the flow()
	    // the readable code triggers during a read() call
	    emitReadable(stream);
	  } else {
	    // emit 'readable' now to make sure it gets picked up.
	    state.needReadable = false;
	    if (!state.emittedReadable) {
	      state.emittedReadable = true;
	      emitReadable_(stream);
	    }
	  }
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  debug('emitReadable', state.needReadable, state.emittedReadable);
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    process.nextTick(emitReadable_, stream);
	  }
	}
	function emitReadable_(stream) {
	  var state = stream._readableState;
	  debug('emitReadable_', state.destroyed, state.length, state.ended);
	  if (!state.destroyed && (state.length || state.ended)) {
	    stream.emit('readable');
	    state.emittedReadable = false;
	  }

	  // The stream needs another readable event if
	  // 1. It is not flowing, as the flow mechanism will take
	  //    care of it.
	  // 2. It is not ended.
	  // 3. It is below the highWaterMark, so we can schedule
	  //    another readable later.
	  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
	  flow(stream);
	}

	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(maybeReadMore_, stream, state);
	  }
	}
	function maybeReadMore_(stream, state) {
	  // Attempt to read more data if we should.
	  //
	  // The conditions for reading more data are (one of):
	  // - Not enough data buffered (state.length < state.highWaterMark). The loop
	  //   is responsible for filling the buffer with enough data if such data
	  //   is available. If highWaterMark is 0 and we are not in the flowing mode
	  //   we should _not_ attempt to buffer any extra data. We'll get more data
	  //   when the stream consumer calls read() instead.
	  // - No data in the buffer, and the stream is in flowing mode. In this mode
	  //   the loop below is responsible for ensuring read() is called. Failing to
	  //   call read here would abort the flow and there's no other mechanism for
	  //   continuing the flow if the stream consumer has just subscribed to the
	  //   'data' event.
	  //
	  // In addition to the above conditions to keep reading data, the following
	  // conditions prevent the data from being read:
	  // - The stream has ended (state.ended).
	  // - There is already a pending 'read' operation (state.reading). This is a
	  //   case where the the stream has called the implementation defined _read()
	  //   method, but they are processing the call asynchronously and have _not_
	  //   called push() with new data. In this case we skip performing more
	  //   read()s. The execution ends in this method again after the _read() ends
	  //   up calling push() with more data.
	  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
	    var len = state.length;
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
	};
	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	  var endFn = doEnd ? onend : unpipe;
	  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable, unpipeInfo) {
	    debug('onunpipe');
	    if (readable === src) {
	      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
	        unpipeInfo.hasUnpiped = true;
	        cleanup();
	      }
	    }
	  }
	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', unpipe);
	    src.removeListener('data', ondata);
	    cleanedUp = true;

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    debug('dest.write', ret);
	    if (ret === false) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', state.awaitDrain);
	        state.awaitDrain++;
	      }
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
	  }

	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	  return dest;
	};
	function pipeOnDrain(src) {
	  return function pipeOnDrainFunctionResult() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;
	  var unpipeInfo = {
	    hasUnpiped: false
	  };

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;
	    if (!dest) dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this, unpipeInfo);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
	      hasUnpiped: false
	    });
	    return this;
	  }

	  // try to find the right one.
	  var index = indexOf(state.pipes, dest);
	  if (index === -1) return this;
	  state.pipes.splice(index, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];
	  dest.emit('unpipe', this, unpipeInfo);
	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	  var state = this._readableState;
	  if (ev === 'data') {
	    // update readableListening so that resume() may be a no-op
	    // a few lines down. This is needed to support once('readable').
	    state.readableListening = this.listenerCount('readable') > 0;

	    // Try start flowing on next tick if stream isn't explicitly paused
	    if (state.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.flowing = false;
	      state.emittedReadable = false;
	      debug('on readable', state.length, state.reading);
	      if (state.length) {
	        emitReadable(this);
	      } else if (!state.reading) {
	        process.nextTick(nReadingNextTick, this);
	      }
	    }
	  }
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	Readable.prototype.removeListener = function (ev, fn) {
	  var res = Stream.prototype.removeListener.call(this, ev, fn);
	  if (ev === 'readable') {
	    // We need to check if there is someone still listening to
	    // readable and reset the state. However this needs to happen
	    // after readable has been emitted but before I/O (nextTick) to
	    // support once('readable', fn) cycles. This means that calling
	    // resume within the same tick will have no
	    // effect.
	    process.nextTick(updateReadableListening, this);
	  }
	  return res;
	};
	Readable.prototype.removeAllListeners = function (ev) {
	  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
	  if (ev === 'readable' || ev === undefined) {
	    // We need to check if there is someone still listening to
	    // readable and reset the state. However this needs to happen
	    // after readable has been emitted but before I/O (nextTick) to
	    // support once('readable', fn) cycles. This means that calling
	    // resume within the same tick will have no
	    // effect.
	    process.nextTick(updateReadableListening, this);
	  }
	  return res;
	};
	function updateReadableListening(self) {
	  var state = self._readableState;
	  state.readableListening = self.listenerCount('readable') > 0;
	  if (state.resumeScheduled && !state.paused) {
	    // flowing needs to be set to true now, otherwise
	    // the upcoming resume will not flow.
	    state.flowing = true;

	    // crude way to check if we should resume
	  } else if (self.listenerCount('data') > 0) {
	    self.resume();
	  }
	}
	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    // we flow only if there is no one listening
	    // for readable, but we still have to call
	    // resume()
	    state.flowing = !state.readableListening;
	    resume(this, state);
	  }
	  state.paused = false;
	  return this;
	};
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(resume_, stream, state);
	  }
	}
	function resume_(stream, state) {
	  debug('resume', state.reading);
	  if (!state.reading) {
	    stream.read(0);
	  }
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}
	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (this._readableState.flowing !== false) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  this._readableState.paused = true;
	  return this;
	};
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null);
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var _this = this;
	  var state = this._readableState;
	  var paused = false;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) _this.push(chunk);
	    }
	    _this.push(null);
	  });
	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
	    var ret = _this.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function methodWrap(method) {
	        return function methodWrapReturnFunction() {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }

	  // proxy certain important events.
	  for (var n = 0; n < kProxyEvents.length; n++) {
	    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
	  }

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  this._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	  return this;
	};
	if (typeof Symbol === 'function') {
	  Readable.prototype[Symbol.asyncIterator] = function () {
	    if (createReadableStreamAsyncIterator === undefined) {
	      createReadableStreamAsyncIterator = requireAsync_iterator();
	    }
	    return createReadableStreamAsyncIterator(this);
	  };
	}
	Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.highWaterMark;
	  }
	});
	Object.defineProperty(Readable.prototype, 'readableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState && this._readableState.buffer;
	  }
	});
	Object.defineProperty(Readable.prototype, 'readableFlowing', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.flowing;
	  },
	  set: function set(state) {
	    if (this._readableState) {
	      this._readableState.flowing = state;
	    }
	  }
	});

	// exposed for testing purposes only.
	Readable._fromList = fromList;
	Object.defineProperty(Readable.prototype, 'readableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.length;
	  }
	});

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;
	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = state.buffer.consume(n, state.decoder);
	  }
	  return ret;
	}
	function endReadable(stream) {
	  var state = stream._readableState;
	  debug('endReadable', state.endEmitted);
	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(endReadableNT, state, stream);
	  }
	}
	function endReadableNT(state, stream) {
	  debug('endReadableNT', state.endEmitted, state.length);

	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	    if (state.autoDestroy) {
	      // In case of duplex streams we need a way to detect
	      // if the writable side is ready for autoDestroy as well
	      var wState = stream._writableState;
	      if (!wState || wState.autoDestroy && wState.finished) {
	        stream.destroy();
	      }
	    }
	  }
	}
	if (typeof Symbol === 'function') {
	  Readable.from = function (iterable, opts) {
	    if (from === undefined) {
	      from = requireFromBrowser();
	    }
	    return from(Readable, iterable, opts);
	  };
	}
	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	return _stream_readable;
}

var _stream_duplex;
var hasRequired_stream_duplex;

function require_stream_duplex () {
	if (hasRequired_stream_duplex) return _stream_duplex;
	hasRequired_stream_duplex = 1;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	};
	/*</replacement>*/

	_stream_duplex = Duplex;
	var Readable = require_stream_readable();
	var Writable = require_stream_writable();
	requireInherits_browser()(Duplex, Readable);
	{
	  // Allow the keys array to be GC'ed.
	  var keys = objectKeys(Writable.prototype);
	  for (var v = 0; v < keys.length; v++) {
	    var method = keys[v];
	    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	  }
	}
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);
	  Readable.call(this, options);
	  Writable.call(this, options);
	  this.allowHalfOpen = true;
	  if (options) {
	    if (options.readable === false) this.readable = false;
	    if (options.writable === false) this.writable = false;
	    if (options.allowHalfOpen === false) {
	      this.allowHalfOpen = false;
	      this.once('end', onend);
	    }
	  }
	}
	Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.highWaterMark;
	  }
	});
	Object.defineProperty(Duplex.prototype, 'writableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState && this._writableState.getBuffer();
	  }
	});
	Object.defineProperty(Duplex.prototype, 'writableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.length;
	  }
	});

	// the no-half-open enforcer
	function onend() {
	  // If the writable side ended, then we're ok.
	  if (this._writableState.ended) return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(onEndNT, this);
	}
	function onEndNT(self) {
	  self.end();
	}
	Object.defineProperty(Duplex.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return false;
	    }
	    return this._readableState.destroyed && this._writableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._readableState.destroyed = value;
	    this._writableState.destroyed = value;
	  }
	});
	return _stream_duplex;
}

var _stream_writable;
var hasRequired_stream_writable;

function require_stream_writable () {
	if (hasRequired_stream_writable) return _stream_writable;
	hasRequired_stream_writable = 1;

	_stream_writable = Writable;

	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;
	  this.next = null;
	  this.entry = null;
	  this.finish = function () {
	    onCorkedFinish(_this, state);
	  };
	}
	/* </replacement> */

	/*<replacement>*/
	var Duplex;
	/*</replacement>*/

	Writable.WritableState = WritableState;

	/*<replacement>*/
	var internalUtil = {
	  deprecate: requireBrowser$1()
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream = requireStreamBrowser();
	/*</replacement>*/

	var Buffer = require$$0$3.Buffer;
	var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}
	var destroyImpl = requireDestroy();
	var _require = requireState(),
	  getHighWaterMark = _require.getHighWaterMark;
	var _require$codes = requireErrorsBrowser().codes,
	  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
	  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
	  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
	  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
	  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
	  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
	var errorOrDestroy = destroyImpl.errorOrDestroy;
	requireInherits_browser()(Writable, Stream);
	function nop() {}
	function WritableState(options, stream, isDuplex) {
	  Duplex = Duplex || require_stream_duplex();
	  options = options || {};

	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream,
	  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

	  // if _final has been called
	  this.finalCalled = false;

	  // drain event flag.
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // has it been destroyed
	  this.destroyed = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;

	  // Should close be emitted on destroy. Defaults to true.
	  this.emitClose = options.emitClose !== false;

	  // Should .destroy() be called after 'finish' (and potentially 'end')
	  this.autoDestroy = !!options.autoDestroy;

	  // count buffered requests
	  this.bufferedRequestCount = 0;

	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}
	WritableState.prototype.getBuffer = function getBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function writableStateBufferGetter() {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
	    });
	  } catch (_) {}
	})();

	// Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.
	var realHasInstance;
	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
	  realHasInstance = Function.prototype[Symbol.hasInstance];
	  Object.defineProperty(Writable, Symbol.hasInstance, {
	    value: function value(object) {
	      if (realHasInstance.call(this, object)) return true;
	      if (this !== Writable) return false;
	      return object && object._writableState instanceof WritableState;
	    }
	  });
	} else {
	  realHasInstance = function realHasInstance(object) {
	    return object instanceof this;
	  };
	}
	function Writable(options) {
	  Duplex = Duplex || require_stream_duplex();

	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.

	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.

	  // Checking for a Stream.Duplex instance is faster here instead of inside
	  // the WritableState constructor, at least with V8 6.5
	  var isDuplex = this instanceof Duplex;
	  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
	  this._writableState = new WritableState(options, this, isDuplex);

	  // legacy.
	  this.writable = true;
	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	    if (typeof options.writev === 'function') this._writev = options.writev;
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	    if (typeof options.final === 'function') this._final = options.final;
	  }
	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
	};
	function writeAfterEnd(stream, cb) {
	  var er = new ERR_STREAM_WRITE_AFTER_END();
	  // TODO: defer error events consistently everywhere, not just the cb
	  errorOrDestroy(stream, er);
	  process.nextTick(cb, er);
	}

	// Checks that a user-supplied chunk is valid, especially for the particular
	// mode the stream is in. Currently this means that `null` is never accepted
	// and undefined/non-string values are only allowed in object mode.
	function validChunk(stream, state, chunk, cb) {
	  var er;
	  if (chunk === null) {
	    er = new ERR_STREAM_NULL_VALUES();
	  } else if (typeof chunk !== 'string' && !state.objectMode) {
	    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
	  }
	  if (er) {
	    errorOrDestroy(stream, er);
	    process.nextTick(cb, er);
	    return false;
	  }
	  return true;
	}
	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	  var isBuf = !state.objectMode && _isUint8Array(chunk);
	  if (isBuf && !Buffer.isBuffer(chunk)) {
	    chunk = _uint8ArrayToBuffer(chunk);
	  }
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	  if (typeof cb !== 'function') cb = nop;
	  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
	  }
	  return ret;
	};
	Writable.prototype.cork = function () {
	  this._writableState.corked++;
	};
	Writable.prototype.uncork = function () {
	  var state = this._writableState;
	  if (state.corked) {
	    state.corked--;
	    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};
	Object.defineProperty(Writable.prototype, 'writableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState && this._writableState.getBuffer();
	  }
	});
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = Buffer.from(chunk, encoding);
	  }
	  return chunk;
	}
	Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.highWaterMark;
	  }
	});

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
	  if (!isBuf) {
	    var newChunk = decodeChunk(state, chunk, encoding);
	    if (chunk !== newChunk) {
	      isBuf = true;
	      encoding = 'buffer';
	      chunk = newChunk;
	    }
	  }
	  var len = state.objectMode ? 1 : chunk.length;
	  state.length += len;
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;
	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = {
	      chunk: chunk,
	      encoding: encoding,
	      isBuf: isBuf,
	      callback: cb,
	      next: null
	    };
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }
	  return ret;
	}
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) {
	    // defer the callback if we are being called synchronously
	    // to avoid piling up things on the stack
	    process.nextTick(cb, er);
	    // this can emit finish, and it will always happen
	    // after error
	    process.nextTick(finishMaybe, stream, state);
	    stream._writableState.errorEmitted = true;
	    errorOrDestroy(stream, er);
	  } else {
	    // the caller expect this to happen before if
	    // it is async
	    cb(er);
	    stream._writableState.errorEmitted = true;
	    errorOrDestroy(stream, er);
	    // this can emit finish, but finish must
	    // always follow error
	    finishMaybe(stream, state);
	  }
	}
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
	  onwriteStateUpdate(state);
	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state) || stream.destroyed;
	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }
	    if (sync) {
	      process.nextTick(afterWrite, stream, state, finished, cb);
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}

	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;
	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;
	    var count = 0;
	    var allBuffers = true;
	    while (entry) {
	      buffer[count] = entry;
	      if (!entry.isBuf) allBuffers = false;
	      entry = entry.next;
	      count += 1;
	    }
	    buffer.allBuffers = allBuffers;
	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	    state.bufferedRequestCount = 0;
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      state.bufferedRequestCount--;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }
	    if (entry === null) state.lastBufferedRequest = null;
	  }
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}
	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
	};
	Writable.prototype._writev = null;
	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending) endWritable(this, state, cb);
	  return this;
	};
	Object.defineProperty(Writable.prototype, 'writableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.length;
	  }
	});
	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	function callFinal(stream, state) {
	  stream._final(function (err) {
	    state.pendingcb--;
	    if (err) {
	      errorOrDestroy(stream, err);
	    }
	    state.prefinished = true;
	    stream.emit('prefinish');
	    finishMaybe(stream, state);
	  });
	}
	function prefinish(stream, state) {
	  if (!state.prefinished && !state.finalCalled) {
	    if (typeof stream._final === 'function' && !state.destroyed) {
	      state.pendingcb++;
	      state.finalCalled = true;
	      process.nextTick(callFinal, stream, state);
	    } else {
	      state.prefinished = true;
	      stream.emit('prefinish');
	    }
	  }
	}
	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    prefinish(stream, state);
	    if (state.pendingcb === 0) {
	      state.finished = true;
	      stream.emit('finish');
	      if (state.autoDestroy) {
	        // In case of duplex streams we need a way to detect
	        // if the readable side is ready for autoDestroy as well
	        var rState = stream._readableState;
	        if (!rState || rState.autoDestroy && rState.endEmitted) {
	          stream.destroy();
	        }
	      }
	    }
	  }
	  return need;
	}
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}
	function onCorkedFinish(corkReq, state, err) {
	  var entry = corkReq.entry;
	  corkReq.entry = null;
	  while (entry) {
	    var cb = entry.callback;
	    state.pendingcb--;
	    cb(err);
	    entry = entry.next;
	  }

	  // reuse the free corkReq.
	  state.corkedRequestsFree.next = corkReq;
	}
	Object.defineProperty(Writable.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._writableState === undefined) {
	      return false;
	    }
	    return this._writableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._writableState) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._writableState.destroyed = value;
	  }
	});
	Writable.prototype.destroy = destroyImpl.destroy;
	Writable.prototype._undestroy = destroyImpl.undestroy;
	Writable.prototype._destroy = function (err, cb) {
	  cb(err);
	};
	return _stream_writable;
}

var hasRequiredModern$1;

function requireModern$1 () {
	if (hasRequiredModern$1) return modern$1.exports;
	hasRequiredModern$1 = 1;

	var util = require$$0$1;
	var Writable = require_stream_writable();

	var _require = requireTripleBeam(),
	    LEVEL = _require.LEVEL;

	/**
	 * Constructor function for the TransportStream. This is the base prototype
	 * that all `winston >= 3` transports should inherit from.
	 * @param {Object} options - Options for this TransportStream instance
	 * @param {String} options.level - Highest level according to RFC5424.
	 * @param {Boolean} options.handleExceptions - If true, info with
	 * { exception: true } will be written.
	 * @param {Function} options.log - Custom log function for simple Transport
	 * creation
	 * @param {Function} options.close - Called on "unpipe" from parent.
	 */


	var TransportStream = modern$1.exports = function TransportStream() {
	  var _this = this;

	  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });

	  this.format = options.format;
	  this.level = options.level;
	  this.handleExceptions = options.handleExceptions;
	  this.handleRejections = options.handleRejections;
	  this.silent = options.silent;

	  if (options.log) this.log = options.log;
	  if (options.logv) this.logv = options.logv;
	  if (options.close) this.close = options.close;

	  // Get the levels from the source we are piped from.
	  this.once('pipe', function (logger) {
	    // Remark (indexzero): this bookkeeping can only support multiple
	    // Logger parents with the same `levels`. This comes into play in
	    // the `winston.Container` code in which `container.add` takes
	    // a fully realized set of options with pre-constructed TransportStreams.
	    _this.levels = logger.levels;
	    _this.parent = logger;
	  });

	  // If and/or when the transport is removed from this instance
	  this.once('unpipe', function (src) {
	    // Remark (indexzero): this bookkeeping can only support multiple
	    // Logger parents with the same `levels`. This comes into play in
	    // the `winston.Container` code in which `container.add` takes
	    // a fully realized set of options with pre-constructed TransportStreams.
	    if (src === _this.parent) {
	      _this.parent = null;
	      if (_this.close) {
	        _this.close();
	      }
	    }
	  });
	};

	/*
	 * Inherit from Writeable using Node.js built-ins
	 */
	util.inherits(TransportStream, Writable);

	/**
	 * Writes the info object to our transport instance.
	 * @param {mixed} info - TODO: add param description.
	 * @param {mixed} enc - TODO: add param description.
	 * @param {function} callback - TODO: add param description.
	 * @returns {undefined}
	 * @private
	 */
	TransportStream.prototype._write = function _write(info, enc, callback) {
	  if (this.silent || info.exception === true && !this.handleExceptions) {
	    return callback(null);
	  }

	  // Remark: This has to be handled in the base transport now because we
	  // cannot conditionally write to our pipe targets as stream. We always
	  // prefer any explicit level set on the Transport itself falling back to
	  // any level set on the parent.
	  var level = this.level || this.parent && this.parent.level;

	  if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
	    if (info && !this.format) {
	      return this.log(info, callback);
	    }

	    var errState = void 0;
	    var transformed = void 0;

	    // We trap(and re-throw) any errors generated by the user-provided format, but also
	    // guarantee that the streams callback is invoked so that we can continue flowing.
	    try {
	      transformed = this.format.transform(Object.assign({}, info), this.format.options);
	    } catch (err) {
	      errState = err;
	    }

	    if (errState || !transformed) {
	      // eslint-disable-next-line callback-return
	      callback();
	      if (errState) throw errState;
	      return;
	    }

	    return this.log(transformed, callback);
	  }
	  this._writableState.sync = false;
	  return callback(null);
	};

	/**
	 * Writes the batch of info objects (i.e. "object chunks") to our transport
	 * instance after performing any necessary filtering.
	 * @param {mixed} chunks - TODO: add params description.
	 * @param {function} callback - TODO: add params description.
	 * @returns {mixed} - TODO: add returns description.
	 * @private
	 */
	TransportStream.prototype._writev = function _writev(chunks, callback) {
	  if (this.logv) {
	    var infos = chunks.filter(this._accept, this);
	    if (!infos.length) {
	      return callback(null);
	    }

	    // Remark (indexzero): from a performance perspective if Transport
	    // implementers do choose to implement logv should we make it their
	    // responsibility to invoke their format?
	    return this.logv(infos, callback);
	  }

	  for (var i = 0; i < chunks.length; i++) {
	    if (!this._accept(chunks[i])) continue;

	    if (chunks[i].chunk && !this.format) {
	      this.log(chunks[i].chunk, chunks[i].callback);
	      continue;
	    }

	    var errState = void 0;
	    var transformed = void 0;

	    // We trap(and re-throw) any errors generated by the user-provided format, but also
	    // guarantee that the streams callback is invoked so that we can continue flowing.
	    try {
	      transformed = this.format.transform(Object.assign({}, chunks[i].chunk), this.format.options);
	    } catch (err) {
	      errState = err;
	    }

	    if (errState || !transformed) {
	      // eslint-disable-next-line callback-return
	      chunks[i].callback();
	      if (errState) {
	        // eslint-disable-next-line callback-return
	        callback(null);
	        throw errState;
	      }
	    } else {
	      this.log(transformed, chunks[i].callback);
	    }
	  }

	  return callback(null);
	};

	/**
	 * Predicate function that returns true if the specfied `info` on the
	 * WriteReq, `write`, should be passed down into the derived
	 * TransportStream's I/O via `.log(info, callback)`.
	 * @param {WriteReq} write - winston@3 Node.js WriteReq for the `info` object
	 * representing the log message.
	 * @returns {Boolean} - Value indicating if the `write` should be accepted &
	 * logged.
	 */
	TransportStream.prototype._accept = function _accept(write) {
	  var info = write.chunk;
	  if (this.silent) {
	    return false;
	  }

	  // We always prefer any explicit level set on the Transport itself
	  // falling back to any level set on the parent.
	  var level = this.level || this.parent && this.parent.level;

	  // Immediately check the average case: log level filtering.
	  if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
	    // Ensure the info object is valid based on `{ exception }`:
	    // 1. { handleExceptions: true }: all `info` objects are valid
	    // 2. { exception: false }: accepted by all transports.
	    if (this.handleExceptions || info.exception !== true) {
	      return true;
	    }
	  }

	  return false;
	};

	/**
	 * _nop is short for "No operation"
	 * @returns {Boolean} Intentionally false.
	 */
	TransportStream.prototype._nop = function _nop() {
	  // eslint-disable-next-line no-undefined
	  return void undefined;
	};
	return modern$1.exports;
}

var legacy$1 = {exports: {}};

var hasRequiredLegacy$1;

function requireLegacy$1 () {
	if (hasRequiredLegacy$1) return legacy$1.exports;
	hasRequiredLegacy$1 = 1;

	var util = require$$0$1;

	var _require = requireTripleBeam(),
	    LEVEL = _require.LEVEL;

	var TransportStream = requireModern$1();

	/**
	 * Constructor function for the LegacyTransportStream. This is an internal
	 * wrapper `winston >= 3` uses to wrap older transports implementing
	 * log(level, message, meta).
	 * @param {Object} options - Options for this TransportStream instance.
	 * @param {Transpot} options.transport - winston@2 or older Transport to wrap.
	 */

	var LegacyTransportStream = legacy$1.exports = function LegacyTransportStream() {
	  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  TransportStream.call(this, options);
	  if (!options.transport || typeof options.transport.log !== 'function') {
	    throw new Error('Invalid transport, must be an object with a log method.');
	  }

	  this.transport = options.transport;
	  this.level = this.level || options.transport.level;
	  this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;

	  // Display our deprecation notice.
	  this._deprecated();

	  // Properly bubble up errors from the transport to the
	  // LegacyTransportStream instance, but only once no matter how many times
	  // this transport is shared.
	  function transportError(err) {
	    this.emit('error', err, this.transport);
	  }

	  if (!this.transport.__winstonError) {
	    this.transport.__winstonError = transportError.bind(this);
	    this.transport.on('error', this.transport.__winstonError);
	  }
	};

	/*
	 * Inherit from TransportStream using Node.js built-ins
	 */
	util.inherits(LegacyTransportStream, TransportStream);

	/**
	 * Writes the info object to our transport instance.
	 * @param {mixed} info - TODO: add param description.
	 * @param {mixed} enc - TODO: add param description.
	 * @param {function} callback - TODO: add param description.
	 * @returns {undefined}
	 * @private
	 */
	LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
	  if (this.silent || info.exception === true && !this.handleExceptions) {
	    return callback(null);
	  }

	  // Remark: This has to be handled in the base transport now because we
	  // cannot conditionally write to our pipe targets as stream.
	  if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
	    this.transport.log(info[LEVEL], info.message, info, this._nop);
	  }

	  callback(null);
	};

	/**
	 * Writes the batch of info objects (i.e. "object chunks") to our transport
	 * instance after performing any necessary filtering.
	 * @param {mixed} chunks - TODO: add params description.
	 * @param {function} callback - TODO: add params description.
	 * @returns {mixed} - TODO: add returns description.
	 * @private
	 */
	LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
	  for (var i = 0; i < chunks.length; i++) {
	    if (this._accept(chunks[i])) {
	      this.transport.log(chunks[i].chunk[LEVEL], chunks[i].chunk.message, chunks[i].chunk, this._nop);
	      chunks[i].callback();
	    }
	  }

	  return callback(null);
	};

	/**
	 * Displays a deprecation notice. Defined as a function so it can be
	 * overriden in tests.
	 * @returns {undefined}
	 */
	LegacyTransportStream.prototype._deprecated = function _deprecated() {
	  // eslint-disable-next-line no-console
	  console.error([this.transport.name + ' is a legacy winston transport. Consider upgrading: ', '- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md'].join('\n'));
	};

	/**
	 * Clean up error handling state on the legacy transport associated
	 * with this instance.
	 * @returns {undefined}
	 */
	LegacyTransportStream.prototype.close = function close() {
	  if (this.transport.close) {
	    this.transport.close();
	  }

	  if (this.transport.__winstonError) {
	    this.transport.removeListener('error', this.transport.__winstonError);
	    this.transport.__winstonError = null;
	  }
	};
	return legacy$1.exports;
}

var hasRequiredDist$1;

function requireDist$1 () {
	if (hasRequiredDist$1) return dist$1.exports;
	hasRequiredDist$1 = 1;

	// Expose modern transport directly as the export

	dist$1.exports = requireModern$1();

	// Expose legacy stream
	dist$1.exports.LegacyTransportStream = requireLegacy$1();
	return dist$1.exports;
}

/* eslint-disable no-console */

var console_1$1;
var hasRequiredConsole$1;

function requireConsole$1 () {
	if (hasRequiredConsole$1) return console_1$1;
	hasRequiredConsole$1 = 1;

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
	function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }
	function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
	function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
	function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
	function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
	function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
	function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
	var os = os__default;
	var _require = requireTripleBeam(),
	  LEVEL = _require.LEVEL,
	  MESSAGE = _require.MESSAGE;
	var TransportStream = requireDist$1();

	/**
	 * Transport for outputting to the console.
	 * @type {Console}
	 * @extends {TransportStream}
	 */
	console_1$1 = /*#__PURE__*/function (_TransportStream) {
	  /**
	   * Constructor function for the Console transport object responsible for
	   * persisting log messages and metadata to a terminal or TTY.
	   * @param {!Object} [options={}] - Options for this instance.
	   */
	  function Console() {
	    var _this;
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    _classCallCheck(this, Console);
	    _this = _callSuper(this, Console, [options]);

	    // Expose the name of this Transport on the prototype
	    _this.name = options.name || 'console';
	    _this.stderrLevels = _this._stringArrayToSet(options.stderrLevels);
	    _this.consoleWarnLevels = _this._stringArrayToSet(options.consoleWarnLevels);
	    _this.eol = typeof options.eol === 'string' ? options.eol : os.EOL;
	    _this.forceConsole = options.forceConsole || false;

	    // Keep a reference to the log, warn, and error console methods
	    // in case they get redirected to this transport after the logger is
	    // instantiated. This prevents a circular reference issue.
	    _this._consoleLog = console.log.bind(console);
	    _this._consoleWarn = console.warn.bind(console);
	    _this._consoleError = console.error.bind(console);
	    _this.setMaxListeners(30);
	    return _this;
	  }

	  /**
	   * Core logging method exposed to Winston.
	   * @param {Object} info - TODO: add param description.
	   * @param {Function} callback - TODO: add param description.
	   * @returns {undefined}
	   */
	  _inherits(Console, _TransportStream);
	  return _createClass(Console, [{
	    key: "log",
	    value: function log(info, callback) {
	      var _this2 = this;
	      setImmediate(function () {
	        return _this2.emit('logged', info);
	      });

	      // Remark: what if there is no raw...?
	      if (this.stderrLevels[info[LEVEL]]) {
	        if (console._stderr && !this.forceConsole) {
	          // Node.js maps `process.stderr` to `console._stderr`.
	          console._stderr.write("".concat(info[MESSAGE]).concat(this.eol));
	        } else {
	          // console.error adds a newline
	          this._consoleError(info[MESSAGE]);
	        }
	        if (callback) {
	          callback(); // eslint-disable-line callback-return
	        }
	        return;
	      } else if (this.consoleWarnLevels[info[LEVEL]]) {
	        if (console._stderr && !this.forceConsole) {
	          // Node.js maps `process.stderr` to `console._stderr`.
	          // in Node.js console.warn is an alias for console.error
	          console._stderr.write("".concat(info[MESSAGE]).concat(this.eol));
	        } else {
	          // console.warn adds a newline
	          this._consoleWarn(info[MESSAGE]);
	        }
	        if (callback) {
	          callback(); // eslint-disable-line callback-return
	        }
	        return;
	      }
	      if (console._stdout && !this.forceConsole) {
	        // Node.js maps `process.stdout` to `console._stdout`.
	        console._stdout.write("".concat(info[MESSAGE]).concat(this.eol));
	      } else {
	        // console.log adds a newline.
	        this._consoleLog(info[MESSAGE]);
	      }
	      if (callback) {
	        callback(); // eslint-disable-line callback-return
	      }
	    }

	    /**
	     * Returns a Set-like object with strArray's elements as keys (each with the
	     * value true).
	     * @param {Array} strArray - Array of Set-elements as strings.
	     * @param {?string} [errMsg] - Custom error message thrown on invalid input.
	     * @returns {Object} - TODO: add return description.
	     * @private
	     */
	  }, {
	    key: "_stringArrayToSet",
	    value: function _stringArrayToSet(strArray, errMsg) {
	      if (!strArray) return {};
	      errMsg = errMsg || 'Cannot make set from type other than Array of string elements';
	      if (!Array.isArray(strArray)) {
	        throw new Error(errMsg);
	      }
	      return strArray.reduce(function (set, el) {
	        if (typeof el !== 'string') {
	          throw new Error(errMsg);
	        }
	        set[el] = true;
	        return set;
	      }, {});
	    }
	  }]);
	}(TransportStream);
	return console_1$1;
}

var series = {exports: {}};

var parallel = {exports: {}};

var isArrayLike = {exports: {}};

var hasRequiredIsArrayLike;

function requireIsArrayLike () {
	if (hasRequiredIsArrayLike) return isArrayLike.exports;
	hasRequiredIsArrayLike = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = isArrayLike;
		function isArrayLike(value) {
		    return value && typeof value.length === 'number' && value.length >= 0 && value.length % 1 === 0;
		}
		module.exports = exports.default; 
	} (isArrayLike, isArrayLike.exports));
	return isArrayLike.exports;
}

var wrapAsync = {};

var asyncify = {exports: {}};

var initialParams = {exports: {}};

var hasRequiredInitialParams;

function requireInitialParams () {
	if (hasRequiredInitialParams) return initialParams.exports;
	hasRequiredInitialParams = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		    value: true
		});

		exports.default = function (fn) {
		    return function (...args /*, callback*/) {
		        var callback = args.pop();
		        return fn.call(this, args, callback);
		    };
		};

		module.exports = exports.default; 
	} (initialParams, initialParams.exports));
	return initialParams.exports;
}

var setImmediate$1 = {};

var hasRequiredSetImmediate;

function requireSetImmediate () {
	if (hasRequiredSetImmediate) return setImmediate$1;
	hasRequiredSetImmediate = 1;

	Object.defineProperty(setImmediate$1, "__esModule", {
	    value: true
	});
	setImmediate$1.fallback = fallback;
	setImmediate$1.wrap = wrap;
	/* istanbul ignore file */

	var hasQueueMicrotask = setImmediate$1.hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;
	var hasSetImmediate = setImmediate$1.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
	var hasNextTick = setImmediate$1.hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

	function fallback(fn) {
	    setTimeout(fn, 0);
	}

	function wrap(defer) {
	    return (fn, ...args) => defer(() => fn(...args));
	}

	var _defer;

	if (hasQueueMicrotask) {
	    _defer = queueMicrotask;
	} else if (hasSetImmediate) {
	    _defer = setImmediate;
	} else if (hasNextTick) {
	    _defer = process.nextTick;
	} else {
	    _defer = fallback;
	}

	setImmediate$1.default = wrap(_defer);
	return setImmediate$1;
}

var hasRequiredAsyncify;

function requireAsyncify () {
	if (hasRequiredAsyncify) return asyncify.exports;
	hasRequiredAsyncify = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = asyncify;

		var _initialParams = requireInitialParams();

		var _initialParams2 = _interopRequireDefault(_initialParams);

		var _setImmediate = requireSetImmediate();

		var _setImmediate2 = _interopRequireDefault(_setImmediate);

		var _wrapAsync = requireWrapAsync();

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		/**
		 * Take a sync function and make it async, passing its return value to a
		 * callback. This is useful for plugging sync functions into a waterfall,
		 * series, or other async functions. Any arguments passed to the generated
		 * function will be passed to the wrapped function (except for the final
		 * callback argument). Errors thrown will be passed to the callback.
		 *
		 * If the function passed to `asyncify` returns a Promise, that promises's
		 * resolved/rejected state will be used to call the callback, rather than simply
		 * the synchronous return value.
		 *
		 * This also means you can asyncify ES2017 `async` functions.
		 *
		 * @name asyncify
		 * @static
		 * @memberOf module:Utils
		 * @method
		 * @alias wrapSync
		 * @category Util
		 * @param {Function} func - The synchronous function, or Promise-returning
		 * function to convert to an {@link AsyncFunction}.
		 * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
		 * invoked with `(args..., callback)`.
		 * @example
		 *
		 * // passing a regular synchronous function
		 * async.waterfall([
		 *     async.apply(fs.readFile, filename, "utf8"),
		 *     async.asyncify(JSON.parse),
		 *     function (data, next) {
		 *         // data is the result of parsing the text.
		 *         // If there was a parsing error, it would have been caught.
		 *     }
		 * ], callback);
		 *
		 * // passing a function returning a promise
		 * async.waterfall([
		 *     async.apply(fs.readFile, filename, "utf8"),
		 *     async.asyncify(function (contents) {
		 *         return db.model.create(contents);
		 *     }),
		 *     function (model, next) {
		 *         // `model` is the instantiated model object.
		 *         // If there was an error, this function would be skipped.
		 *     }
		 * ], callback);
		 *
		 * // es2017 example, though `asyncify` is not needed if your JS environment
		 * // supports async functions out of the box
		 * var q = async.queue(async.asyncify(async function(file) {
		 *     var intermediateStep = await processFile(file);
		 *     return await somePromise(intermediateStep)
		 * }));
		 *
		 * q.push(files);
		 */
		function asyncify(func) {
		    if ((0, _wrapAsync.isAsync)(func)) {
		        return function (...args /*, callback*/) {
		            const callback = args.pop();
		            const promise = func.apply(this, args);
		            return handlePromise(promise, callback);
		        };
		    }

		    return (0, _initialParams2.default)(function (args, callback) {
		        var result;
		        try {
		            result = func.apply(this, args);
		        } catch (e) {
		            return callback(e);
		        }
		        // if result is Promise object
		        if (result && typeof result.then === 'function') {
		            return handlePromise(result, callback);
		        } else {
		            callback(null, result);
		        }
		    });
		}

		function handlePromise(promise, callback) {
		    return promise.then(value => {
		        invokeCallback(callback, null, value);
		    }, err => {
		        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
		    });
		}

		function invokeCallback(callback, error, value) {
		    try {
		        callback(error, value);
		    } catch (err) {
		        (0, _setImmediate2.default)(e => {
		            throw e;
		        }, err);
		    }
		}
		module.exports = exports.default; 
	} (asyncify, asyncify.exports));
	return asyncify.exports;
}

var hasRequiredWrapAsync;

function requireWrapAsync () {
	if (hasRequiredWrapAsync) return wrapAsync;
	hasRequiredWrapAsync = 1;

	Object.defineProperty(wrapAsync, "__esModule", {
	    value: true
	});
	wrapAsync.isAsyncIterable = wrapAsync.isAsyncGenerator = wrapAsync.isAsync = undefined;

	var _asyncify = requireAsyncify();

	var _asyncify2 = _interopRequireDefault(_asyncify);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isAsync(fn) {
	    return fn[Symbol.toStringTag] === 'AsyncFunction';
	}

	function isAsyncGenerator(fn) {
	    return fn[Symbol.toStringTag] === 'AsyncGenerator';
	}

	function isAsyncIterable(obj) {
	    return typeof obj[Symbol.asyncIterator] === 'function';
	}

	function wrapAsync$1(asyncFn) {
	    if (typeof asyncFn !== 'function') throw new Error('expected a function');
	    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
	}

	wrapAsync.default = wrapAsync$1;
	wrapAsync.isAsync = isAsync;
	wrapAsync.isAsyncGenerator = isAsyncGenerator;
	wrapAsync.isAsyncIterable = isAsyncIterable;
	return wrapAsync;
}

var awaitify = {exports: {}};

var hasRequiredAwaitify;

function requireAwaitify () {
	if (hasRequiredAwaitify) return awaitify.exports;
	hasRequiredAwaitify = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = awaitify;
		// conditionally promisify a function.
		// only return a promise if a callback is omitted
		function awaitify(asyncFn, arity) {
		    if (!arity) arity = asyncFn.length;
		    if (!arity) throw new Error('arity is undefined');
		    function awaitable(...args) {
		        if (typeof args[arity - 1] === 'function') {
		            return asyncFn.apply(this, args);
		        }

		        return new Promise((resolve, reject) => {
		            args[arity - 1] = (err, ...cbArgs) => {
		                if (err) return reject(err);
		                resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
		            };
		            asyncFn.apply(this, args);
		        });
		    }

		    return awaitable;
		}
		module.exports = exports.default; 
	} (awaitify, awaitify.exports));
	return awaitify.exports;
}

var hasRequiredParallel;

function requireParallel () {
	if (hasRequiredParallel) return parallel.exports;
	hasRequiredParallel = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		    value: true
		});

		var _isArrayLike = requireIsArrayLike();

		var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

		var _wrapAsync = requireWrapAsync();

		var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

		var _awaitify = requireAwaitify();

		var _awaitify2 = _interopRequireDefault(_awaitify);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		exports.default = (0, _awaitify2.default)((eachfn, tasks, callback) => {
		    var results = (0, _isArrayLike2.default)(tasks) ? [] : {};

		    eachfn(tasks, (task, key, taskCb) => {
		        (0, _wrapAsync2.default)(task)((err, ...result) => {
		            if (result.length < 2) {
		                [result] = result;
		            }
		            results[key] = result;
		            taskCb(err);
		        });
		    }, err => callback(err, results));
		}, 3);
		module.exports = exports.default; 
	} (parallel, parallel.exports));
	return parallel.exports;
}

var eachOfSeries = {exports: {}};

var eachOfLimit$1 = {exports: {}};

var eachOfLimit = {exports: {}};

var once = {exports: {}};

var hasRequiredOnce;

function requireOnce () {
	if (hasRequiredOnce) return once.exports;
	hasRequiredOnce = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = once;
		function once(fn) {
		    function wrapper(...args) {
		        if (fn === null) return;
		        var callFn = fn;
		        fn = null;
		        callFn.apply(this, args);
		    }
		    Object.assign(wrapper, fn);
		    return wrapper;
		}
		module.exports = exports.default; 
	} (once, once.exports));
	return once.exports;
}

var iterator = {exports: {}};

var getIterator = {exports: {}};

var hasRequiredGetIterator;

function requireGetIterator () {
	if (hasRequiredGetIterator) return getIterator.exports;
	hasRequiredGetIterator = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		    value: true
		});

		exports.default = function (coll) {
		    return coll[Symbol.iterator] && coll[Symbol.iterator]();
		};

		module.exports = exports.default; 
	} (getIterator, getIterator.exports));
	return getIterator.exports;
}

var hasRequiredIterator;

function requireIterator () {
	if (hasRequiredIterator) return iterator.exports;
	hasRequiredIterator = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = createIterator;

		var _isArrayLike = requireIsArrayLike();

		var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

		var _getIterator = requireGetIterator();

		var _getIterator2 = _interopRequireDefault(_getIterator);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		function createArrayIterator(coll) {
		    var i = -1;
		    var len = coll.length;
		    return function next() {
		        return ++i < len ? { value: coll[i], key: i } : null;
		    };
		}

		function createES2015Iterator(iterator) {
		    var i = -1;
		    return function next() {
		        var item = iterator.next();
		        if (item.done) return null;
		        i++;
		        return { value: item.value, key: i };
		    };
		}

		function createObjectIterator(obj) {
		    var okeys = obj ? Object.keys(obj) : [];
		    var i = -1;
		    var len = okeys.length;
		    return function next() {
		        var key = okeys[++i];
		        if (key === '__proto__') {
		            return next();
		        }
		        return i < len ? { value: obj[key], key } : null;
		    };
		}

		function createIterator(coll) {
		    if ((0, _isArrayLike2.default)(coll)) {
		        return createArrayIterator(coll);
		    }

		    var iterator = (0, _getIterator2.default)(coll);
		    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
		}
		module.exports = exports.default; 
	} (iterator, iterator.exports));
	return iterator.exports;
}

var onlyOnce = {exports: {}};

var hasRequiredOnlyOnce;

function requireOnlyOnce () {
	if (hasRequiredOnlyOnce) return onlyOnce.exports;
	hasRequiredOnlyOnce = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = onlyOnce;
		function onlyOnce(fn) {
		    return function (...args) {
		        if (fn === null) throw new Error("Callback was already called.");
		        var callFn = fn;
		        fn = null;
		        callFn.apply(this, args);
		    };
		}
		module.exports = exports.default; 
	} (onlyOnce, onlyOnce.exports));
	return onlyOnce.exports;
}

var asyncEachOfLimit = {exports: {}};

var breakLoop = {exports: {}};

var hasRequiredBreakLoop;

function requireBreakLoop () {
	if (hasRequiredBreakLoop) return breakLoop.exports;
	hasRequiredBreakLoop = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		// A temporary value used to identify if the loop should be broken.
		// See #1064, #1293
		const breakLoop = {};
		exports.default = breakLoop;
		module.exports = exports.default; 
	} (breakLoop, breakLoop.exports));
	return breakLoop.exports;
}

var hasRequiredAsyncEachOfLimit;

function requireAsyncEachOfLimit () {
	if (hasRequiredAsyncEachOfLimit) return asyncEachOfLimit.exports;
	hasRequiredAsyncEachOfLimit = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = asyncEachOfLimit;

		var _breakLoop = requireBreakLoop();

		var _breakLoop2 = _interopRequireDefault(_breakLoop);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		// for async generators
		function asyncEachOfLimit(generator, limit, iteratee, callback) {
		    let done = false;
		    let canceled = false;
		    let awaiting = false;
		    let running = 0;
		    let idx = 0;

		    function replenish() {
		        //console.log('replenish')
		        if (running >= limit || awaiting || done) return;
		        //console.log('replenish awaiting')
		        awaiting = true;
		        generator.next().then(({ value, done: iterDone }) => {
		            //console.log('got value', value)
		            if (canceled || done) return;
		            awaiting = false;
		            if (iterDone) {
		                done = true;
		                if (running <= 0) {
		                    //console.log('done nextCb')
		                    callback(null);
		                }
		                return;
		            }
		            running++;
		            iteratee(value, idx, iterateeCallback);
		            idx++;
		            replenish();
		        }).catch(handleError);
		    }

		    function iterateeCallback(err, result) {
		        //console.log('iterateeCallback')
		        running -= 1;
		        if (canceled) return;
		        if (err) return handleError(err);

		        if (err === false) {
		            done = true;
		            canceled = true;
		            return;
		        }

		        if (result === _breakLoop2.default || done && running <= 0) {
		            done = true;
		            //console.log('done iterCb')
		            return callback(null);
		        }
		        replenish();
		    }

		    function handleError(err) {
		        if (canceled) return;
		        awaiting = false;
		        done = true;
		        callback(err);
		    }

		    replenish();
		}
		module.exports = exports.default; 
	} (asyncEachOfLimit, asyncEachOfLimit.exports));
	return asyncEachOfLimit.exports;
}

var hasRequiredEachOfLimit$1;

function requireEachOfLimit$1 () {
	if (hasRequiredEachOfLimit$1) return eachOfLimit.exports;
	hasRequiredEachOfLimit$1 = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		    value: true
		});

		var _once = requireOnce();

		var _once2 = _interopRequireDefault(_once);

		var _iterator = requireIterator();

		var _iterator2 = _interopRequireDefault(_iterator);

		var _onlyOnce = requireOnlyOnce();

		var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

		var _wrapAsync = requireWrapAsync();

		var _asyncEachOfLimit = requireAsyncEachOfLimit();

		var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);

		var _breakLoop = requireBreakLoop();

		var _breakLoop2 = _interopRequireDefault(_breakLoop);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		exports.default = limit => {
		    return (obj, iteratee, callback) => {
		        callback = (0, _once2.default)(callback);
		        if (limit <= 0) {
		            throw new RangeError('concurrency limit cannot be less than 1');
		        }
		        if (!obj) {
		            return callback(null);
		        }
		        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
		            return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
		        }
		        if ((0, _wrapAsync.isAsyncIterable)(obj)) {
		            return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
		        }
		        var nextElem = (0, _iterator2.default)(obj);
		        var done = false;
		        var canceled = false;
		        var running = 0;
		        var looping = false;

		        function iterateeCallback(err, value) {
		            if (canceled) return;
		            running -= 1;
		            if (err) {
		                done = true;
		                callback(err);
		            } else if (err === false) {
		                done = true;
		                canceled = true;
		            } else if (value === _breakLoop2.default || done && running <= 0) {
		                done = true;
		                return callback(null);
		            } else if (!looping) {
		                replenish();
		            }
		        }

		        function replenish() {
		            looping = true;
		            while (running < limit && !done) {
		                var elem = nextElem();
		                if (elem === null) {
		                    done = true;
		                    if (running <= 0) {
		                        callback(null);
		                    }
		                    return;
		                }
		                running += 1;
		                iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
		            }
		            looping = false;
		        }

		        replenish();
		    };
		};

		module.exports = exports.default; 
	} (eachOfLimit, eachOfLimit.exports));
	return eachOfLimit.exports;
}

var hasRequiredEachOfLimit;

function requireEachOfLimit () {
	if (hasRequiredEachOfLimit) return eachOfLimit$1.exports;
	hasRequiredEachOfLimit = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		    value: true
		});

		var _eachOfLimit2 = requireEachOfLimit$1();

		var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);

		var _wrapAsync = requireWrapAsync();

		var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

		var _awaitify = requireAwaitify();

		var _awaitify2 = _interopRequireDefault(_awaitify);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		/**
		 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
		 * time.
		 *
		 * @name eachOfLimit
		 * @static
		 * @memberOf module:Collections
		 * @method
		 * @see [async.eachOf]{@link module:Collections.eachOf}
		 * @alias forEachOfLimit
		 * @category Collection
		 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
		 * @param {number} limit - The maximum number of async operations at a time.
		 * @param {AsyncFunction} iteratee - An async function to apply to each
		 * item in `coll`. The `key` is the item's key, or index in the case of an
		 * array.
		 * Invoked with (item, key, callback).
		 * @param {Function} [callback] - A callback which is called when all
		 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
		 * @returns {Promise} a promise, if a callback is omitted
		 */
		function eachOfLimit(coll, limit, iteratee, callback) {
		    return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
		}

		exports.default = (0, _awaitify2.default)(eachOfLimit, 4);
		module.exports = exports.default; 
	} (eachOfLimit$1, eachOfLimit$1.exports));
	return eachOfLimit$1.exports;
}

var hasRequiredEachOfSeries;

function requireEachOfSeries () {
	if (hasRequiredEachOfSeries) return eachOfSeries.exports;
	hasRequiredEachOfSeries = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		    value: true
		});

		var _eachOfLimit = requireEachOfLimit();

		var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);

		var _awaitify = requireAwaitify();

		var _awaitify2 = _interopRequireDefault(_awaitify);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		/**
		 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
		 *
		 * @name eachOfSeries
		 * @static
		 * @memberOf module:Collections
		 * @method
		 * @see [async.eachOf]{@link module:Collections.eachOf}
		 * @alias forEachOfSeries
		 * @category Collection
		 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
		 * @param {AsyncFunction} iteratee - An async function to apply to each item in
		 * `coll`.
		 * Invoked with (item, key, callback).
		 * @param {Function} [callback] - A callback which is called when all `iteratee`
		 * functions have finished, or an error occurs. Invoked with (err).
		 * @returns {Promise} a promise, if a callback is omitted
		 */
		function eachOfSeries(coll, iteratee, callback) {
		    return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
		}
		exports.default = (0, _awaitify2.default)(eachOfSeries, 3);
		module.exports = exports.default; 
	} (eachOfSeries, eachOfSeries.exports));
	return eachOfSeries.exports;
}

var hasRequiredSeries;

function requireSeries () {
	if (hasRequiredSeries) return series.exports;
	hasRequiredSeries = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = series;

		var _parallel2 = requireParallel();

		var _parallel3 = _interopRequireDefault(_parallel2);

		var _eachOfSeries = requireEachOfSeries();

		var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		/**
		 * Run the functions in the `tasks` collection in series, each one running once
		 * the previous function has completed. If any functions in the series pass an
		 * error to its callback, no more functions are run, and `callback` is
		 * immediately called with the value of the error. Otherwise, `callback`
		 * receives an array of results when `tasks` have completed.
		 *
		 * It is also possible to use an object instead of an array. Each property will
		 * be run as a function, and the results will be passed to the final `callback`
		 * as an object instead of an array. This can be a more readable way of handling
		 *  results from {@link async.series}.
		 *
		 * **Note** that while many implementations preserve the order of object
		 * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
		 * explicitly states that
		 *
		 * > The mechanics and order of enumerating the properties is not specified.
		 *
		 * So if you rely on the order in which your series of functions are executed,
		 * and want this to work on all platforms, consider using an array.
		 *
		 * @name series
		 * @static
		 * @memberOf module:ControlFlow
		 * @method
		 * @category Control Flow
		 * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing
		 * [async functions]{@link AsyncFunction} to run in series.
		 * Each function can complete with any number of optional `result` values.
		 * @param {Function} [callback] - An optional callback to run once all the
		 * functions have completed. This function gets a results array (or object)
		 * containing all the result arguments passed to the `task` callbacks. Invoked
		 * with (err, result).
		 * @return {Promise} a promise, if no callback is passed
		 * @example
		 *
		 * //Using Callbacks
		 * async.series([
		 *     function(callback) {
		 *         setTimeout(function() {
		 *             // do some async task
		 *             callback(null, 'one');
		 *         }, 200);
		 *     },
		 *     function(callback) {
		 *         setTimeout(function() {
		 *             // then do another async task
		 *             callback(null, 'two');
		 *         }, 100);
		 *     }
		 * ], function(err, results) {
		 *     console.log(results);
		 *     // results is equal to ['one','two']
		 * });
		 *
		 * // an example using objects instead of arrays
		 * async.series({
		 *     one: function(callback) {
		 *         setTimeout(function() {
		 *             // do some async task
		 *             callback(null, 1);
		 *         }, 200);
		 *     },
		 *     two: function(callback) {
		 *         setTimeout(function() {
		 *             // then do another async task
		 *             callback(null, 2);
		 *         }, 100);
		 *     }
		 * }, function(err, results) {
		 *     console.log(results);
		 *     // results is equal to: { one: 1, two: 2 }
		 * });
		 *
		 * //Using Promises
		 * async.series([
		 *     function(callback) {
		 *         setTimeout(function() {
		 *             callback(null, 'one');
		 *         }, 200);
		 *     },
		 *     function(callback) {
		 *         setTimeout(function() {
		 *             callback(null, 'two');
		 *         }, 100);
		 *     }
		 * ]).then(results => {
		 *     console.log(results);
		 *     // results is equal to ['one','two']
		 * }).catch(err => {
		 *     console.log(err);
		 * });
		 *
		 * // an example using an object instead of an array
		 * async.series({
		 *     one: function(callback) {
		 *         setTimeout(function() {
		 *             // do some async task
		 *             callback(null, 1);
		 *         }, 200);
		 *     },
		 *     two: function(callback) {
		 *         setTimeout(function() {
		 *             // then do another async task
		 *             callback(null, 2);
		 *         }, 100);
		 *     }
		 * }).then(results => {
		 *     console.log(results);
		 *     // results is equal to: { one: 1, two: 2 }
		 * }).catch(err => {
		 *     console.log(err);
		 * });
		 *
		 * //Using async/await
		 * async () => {
		 *     try {
		 *         let results = await async.series([
		 *             function(callback) {
		 *                 setTimeout(function() {
		 *                     // do some async task
		 *                     callback(null, 'one');
		 *                 }, 200);
		 *             },
		 *             function(callback) {
		 *                 setTimeout(function() {
		 *                     // then do another async task
		 *                     callback(null, 'two');
		 *                 }, 100);
		 *             }
		 *         ]);
		 *         console.log(results);
		 *         // results is equal to ['one','two']
		 *     }
		 *     catch (err) {
		 *         console.log(err);
		 *     }
		 * }
		 *
		 * // an example using an object instead of an array
		 * async () => {
		 *     try {
		 *         let results = await async.parallel({
		 *             one: function(callback) {
		 *                 setTimeout(function() {
		 *                     // do some async task
		 *                     callback(null, 1);
		 *                 }, 200);
		 *             },
		 *            two: function(callback) {
		 *                 setTimeout(function() {
		 *                     // then do another async task
		 *                     callback(null, 2);
		 *                 }, 100);
		 *            }
		 *         });
		 *         console.log(results);
		 *         // results is equal to: { one: 1, two: 2 }
		 *     }
		 *     catch (err) {
		 *         console.log(err);
		 *     }
		 * }
		 *
		 */
		function series(tasks, callback) {
		    return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
		}
		module.exports = exports.default; 
	} (series, series.exports));
	return series.exports;
}

var readableBrowser = {exports: {}};

var _stream_transform;
var hasRequired_stream_transform;

function require_stream_transform () {
	if (hasRequired_stream_transform) return _stream_transform;
	hasRequired_stream_transform = 1;

	_stream_transform = Transform;
	var _require$codes = requireErrorsBrowser().codes,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
	  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
	  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
	var Duplex = require_stream_duplex();
	requireInherits_browser()(Transform, Duplex);
	function afterTransform(er, data) {
	  var ts = this._transformState;
	  ts.transforming = false;
	  var cb = ts.writecb;
	  if (cb === null) {
	    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
	  }
	  ts.writechunk = null;
	  ts.writecb = null;
	  if (data != null)
	    // single equals check for both `null` and `undefined`
	    this.push(data);
	  cb(er);
	  var rs = this._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    this._read(rs.highWaterMark);
	  }
	}
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);
	  Duplex.call(this, options);
	  this._transformState = {
	    afterTransform: afterTransform.bind(this),
	    needTransform: false,
	    transforming: false,
	    writecb: null,
	    writechunk: null,
	    writeencoding: null
	  };

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }

	  // When the writable side finishes, then flush out anything remaining.
	  this.on('prefinish', prefinish);
	}
	function prefinish() {
	  var _this = this;
	  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
	    this._flush(function (er, data) {
	      done(_this, er, data);
	    });
	  } else {
	    done(this, null, null);
	  }
	}
	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
	};
	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;
	  if (ts.writechunk !== null && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	Transform.prototype._destroy = function (err, cb) {
	  Duplex.prototype._destroy.call(this, err, function (err2) {
	    cb(err2);
	  });
	};
	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);
	  if (data != null)
	    // single equals check for both `null` and `undefined`
	    stream.push(data);

	  // TODO(BridgeAR): Write a test for these two error cases
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
	  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
	  return stream.push(null);
	}
	return _stream_transform;
}

var _stream_passthrough;
var hasRequired_stream_passthrough;

function require_stream_passthrough () {
	if (hasRequired_stream_passthrough) return _stream_passthrough;
	hasRequired_stream_passthrough = 1;

	_stream_passthrough = PassThrough;
	var Transform = require_stream_transform();
	requireInherits_browser()(PassThrough, Transform);
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);
	  Transform.call(this, options);
	}
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};
	return _stream_passthrough;
}

var pipeline_1;
var hasRequiredPipeline;

function requirePipeline () {
	if (hasRequiredPipeline) return pipeline_1;
	hasRequiredPipeline = 1;

	var eos;
	function once(callback) {
	  var called = false;
	  return function () {
	    if (called) return;
	    called = true;
	    callback.apply(void 0, arguments);
	  };
	}
	var _require$codes = requireErrorsBrowser().codes,
	  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
	  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
	function noop(err) {
	  // Rethrow the error if it exists to avoid swallowing it
	  if (err) throw err;
	}
	function isRequest(stream) {
	  return stream.setHeader && typeof stream.abort === 'function';
	}
	function destroyer(stream, reading, writing, callback) {
	  callback = once(callback);
	  var closed = false;
	  stream.on('close', function () {
	    closed = true;
	  });
	  if (eos === undefined) eos = requireEndOfStream();
	  eos(stream, {
	    readable: reading,
	    writable: writing
	  }, function (err) {
	    if (err) return callback(err);
	    closed = true;
	    callback();
	  });
	  var destroyed = false;
	  return function (err) {
	    if (closed) return;
	    if (destroyed) return;
	    destroyed = true;

	    // request.destroy just do .end - .abort is what we want
	    if (isRequest(stream)) return stream.abort();
	    if (typeof stream.destroy === 'function') return stream.destroy();
	    callback(err || new ERR_STREAM_DESTROYED('pipe'));
	  };
	}
	function call(fn) {
	  fn();
	}
	function pipe(from, to) {
	  return from.pipe(to);
	}
	function popCallback(streams) {
	  if (!streams.length) return noop;
	  if (typeof streams[streams.length - 1] !== 'function') return noop;
	  return streams.pop();
	}
	function pipeline() {
	  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
	    streams[_key] = arguments[_key];
	  }
	  var callback = popCallback(streams);
	  if (Array.isArray(streams[0])) streams = streams[0];
	  if (streams.length < 2) {
	    throw new ERR_MISSING_ARGS('streams');
	  }
	  var error;
	  var destroys = streams.map(function (stream, i) {
	    var reading = i < streams.length - 1;
	    var writing = i > 0;
	    return destroyer(stream, reading, writing, function (err) {
	      if (!error) error = err;
	      if (err) destroys.forEach(call);
	      if (reading) return;
	      destroys.forEach(call);
	      callback(error);
	    });
	  });
	  return streams.reduce(pipe);
	}
	pipeline_1 = pipeline;
	return pipeline_1;
}

var hasRequiredReadableBrowser;

function requireReadableBrowser () {
	if (hasRequiredReadableBrowser) return readableBrowser.exports;
	hasRequiredReadableBrowser = 1;
	(function (module, exports) {
		exports = module.exports = require_stream_readable();
		exports.Stream = exports;
		exports.Readable = exports;
		exports.Writable = require_stream_writable();
		exports.Duplex = require_stream_duplex();
		exports.Transform = require_stream_transform();
		exports.PassThrough = require_stream_passthrough();
		exports.finished = requireEndOfStream();
		exports.pipeline = requirePipeline(); 
	} (readableBrowser, readableBrowser.exports));
	return readableBrowser.exports;
}

var browser = {exports: {}};

/**
 * Contains all configured adapters for the given environment.
 *
 * @type {Array}
 * @public
 */

var diagnostics;
var hasRequiredDiagnostics;

function requireDiagnostics () {
	if (hasRequiredDiagnostics) return diagnostics;
	hasRequiredDiagnostics = 1;
	var adapters = [];

	/**
	 * Contains all modifier functions.
	 *
	 * @typs {Array}
	 * @public
	 */
	var modifiers = [];

	/**
	 * Our default logger.
	 *
	 * @public
	 */
	var logger = function devnull() {};

	/**
	 * Register a new adapter that will used to find environments.
	 *
	 * @param {Function} adapter A function that will return the possible env.
	 * @returns {Boolean} Indication of a successful add.
	 * @public
	 */
	function use(adapter) {
	  if (~adapters.indexOf(adapter)) return false;

	  adapters.push(adapter);
	  return true;
	}

	/**
	 * Assign a new log method.
	 *
	 * @param {Function} custom The log method.
	 * @public
	 */
	function set(custom) {
	  logger = custom;
	}

	/**
	 * Check if the namespace is allowed by any of our adapters.
	 *
	 * @param {String} namespace The namespace that needs to be enabled
	 * @returns {Boolean|Promise} Indication if the namespace is enabled by our adapters.
	 * @public
	 */
	function enabled(namespace) {
	  var async = [];

	  for (var i = 0; i < adapters.length; i++) {
	    if (adapters[i].async) {
	      async.push(adapters[i]);
	      continue;
	    }

	    if (adapters[i](namespace)) return true;
	  }

	  if (!async.length) return false;

	  //
	  // Now that we know that we Async functions, we know we run in an ES6
	  // environment and can use all the API's that they offer, in this case
	  // we want to return a Promise so that we can `await` in React-Native
	  // for an async adapter.
	  //
	  return new Promise(function pinky(resolve) {
	    Promise.all(
	      async.map(function prebind(fn) {
	        return fn(namespace);
	      })
	    ).then(function resolved(values) {
	      resolve(values.some(Boolean));
	    });
	  });
	}

	/**
	 * Add a new message modifier to the debugger.
	 *
	 * @param {Function} fn Modification function.
	 * @returns {Boolean} Indication of a successful add.
	 * @public
	 */
	function modify(fn) {
	  if (~modifiers.indexOf(fn)) return false;

	  modifiers.push(fn);
	  return true;
	}

	/**
	 * Write data to the supplied logger.
	 *
	 * @param {Object} meta Meta information about the log.
	 * @param {Array} args Arguments for console.log.
	 * @public
	 */
	function write() {
	  logger.apply(logger, arguments);
	}

	/**
	 * Process the message with the modifiers.
	 *
	 * @param {Mixed} message The message to be transformed by modifers.
	 * @returns {String} Transformed message.
	 * @public
	 */
	function process(message) {
	  for (var i = 0; i < modifiers.length; i++) {
	    message = modifiers[i].apply(modifiers[i], arguments);
	  }

	  return message;
	}

	/**
	 * Introduce options to the logger function.
	 *
	 * @param {Function} fn Calback function.
	 * @param {Object} options Properties to introduce on fn.
	 * @returns {Function} The passed function
	 * @public
	 */
	function introduce(fn, options) {
	  var has = Object.prototype.hasOwnProperty;

	  for (var key in options) {
	    if (has.call(options, key)) {
	      fn[key] = options[key];
	    }
	  }

	  return fn;
	}

	/**
	 * Nope, we're not allowed to write messages.
	 *
	 * @returns {Boolean} false
	 * @public
	 */
	function nope(options) {
	  options.enabled = false;
	  options.modify = modify;
	  options.set = set;
	  options.use = use;

	  return introduce(function diagnopes() {
	    return false;
	  }, options);
	}

	/**
	 * Yep, we're allowed to write debug messages.
	 *
	 * @param {Object} options The options for the process.
	 * @returns {Function} The function that does the logging.
	 * @public
	 */
	function yep(options) {
	  /**
	   * The function that receives the actual debug information.
	   *
	   * @returns {Boolean} indication that we're logging.
	   * @public
	   */
	  function diagnostics() {
	    var args = Array.prototype.slice.call(arguments, 0);

	    write.call(write, options, process(args, options));
	    return true;
	  }

	  options.enabled = true;
	  options.modify = modify;
	  options.set = set;
	  options.use = use;

	  return introduce(diagnostics, options);
	}

	/**
	 * Simple helper function to introduce various of helper methods to our given
	 * diagnostics function.
	 *
	 * @param {Function} diagnostics The diagnostics function.
	 * @returns {Function} diagnostics
	 * @public
	 */
	diagnostics = function create(diagnostics) {
	  diagnostics.introduce = introduce;
	  diagnostics.enabled = enabled;
	  diagnostics.process = process;
	  diagnostics.modify = modify;
	  diagnostics.write = write;
	  diagnostics.nope = nope;
	  diagnostics.yep = yep;
	  diagnostics.set = set;
	  diagnostics.use = use;

	  return diagnostics;
	};
	return diagnostics;
}

var production;
var hasRequiredProduction;

function requireProduction () {
	if (hasRequiredProduction) return production;
	hasRequiredProduction = 1;
	var create = requireDiagnostics();

	/**
	 * Create a new diagnostics logger.
	 *
	 * @param {String} namespace The namespace it should enable.
	 * @param {Object} options Additional options.
	 * @returns {Function} The logger.
	 * @public
	 */
	var diagnostics = create(function prod(namespace, options) {
	  options = options || {};
	  options.namespace = namespace;
	  options.prod = true;
	  options.dev = false;

	  if (!(options.force || prod.force)) return prod.nope(options);
	  return prod.yep(options);
	});

	//
	// Expose the diagnostics logger.
	//
	production = diagnostics;
	return production;
}

var colorString = {exports: {}};

var colorName$1;
var hasRequiredColorName$1;

function requireColorName$1 () {
	if (hasRequiredColorName$1) return colorName$1;
	hasRequiredColorName$1 = 1;

	colorName$1 = {
		"aliceblue": [240, 248, 255],
		"antiquewhite": [250, 235, 215],
		"aqua": [0, 255, 255],
		"aquamarine": [127, 255, 212],
		"azure": [240, 255, 255],
		"beige": [245, 245, 220],
		"bisque": [255, 228, 196],
		"black": [0, 0, 0],
		"blanchedalmond": [255, 235, 205],
		"blue": [0, 0, 255],
		"blueviolet": [138, 43, 226],
		"brown": [165, 42, 42],
		"burlywood": [222, 184, 135],
		"cadetblue": [95, 158, 160],
		"chartreuse": [127, 255, 0],
		"chocolate": [210, 105, 30],
		"coral": [255, 127, 80],
		"cornflowerblue": [100, 149, 237],
		"cornsilk": [255, 248, 220],
		"crimson": [220, 20, 60],
		"cyan": [0, 255, 255],
		"darkblue": [0, 0, 139],
		"darkcyan": [0, 139, 139],
		"darkgoldenrod": [184, 134, 11],
		"darkgray": [169, 169, 169],
		"darkgreen": [0, 100, 0],
		"darkgrey": [169, 169, 169],
		"darkkhaki": [189, 183, 107],
		"darkmagenta": [139, 0, 139],
		"darkolivegreen": [85, 107, 47],
		"darkorange": [255, 140, 0],
		"darkorchid": [153, 50, 204],
		"darkred": [139, 0, 0],
		"darksalmon": [233, 150, 122],
		"darkseagreen": [143, 188, 143],
		"darkslateblue": [72, 61, 139],
		"darkslategray": [47, 79, 79],
		"darkslategrey": [47, 79, 79],
		"darkturquoise": [0, 206, 209],
		"darkviolet": [148, 0, 211],
		"deeppink": [255, 20, 147],
		"deepskyblue": [0, 191, 255],
		"dimgray": [105, 105, 105],
		"dimgrey": [105, 105, 105],
		"dodgerblue": [30, 144, 255],
		"firebrick": [178, 34, 34],
		"floralwhite": [255, 250, 240],
		"forestgreen": [34, 139, 34],
		"fuchsia": [255, 0, 255],
		"gainsboro": [220, 220, 220],
		"ghostwhite": [248, 248, 255],
		"gold": [255, 215, 0],
		"goldenrod": [218, 165, 32],
		"gray": [128, 128, 128],
		"green": [0, 128, 0],
		"greenyellow": [173, 255, 47],
		"grey": [128, 128, 128],
		"honeydew": [240, 255, 240],
		"hotpink": [255, 105, 180],
		"indianred": [205, 92, 92],
		"indigo": [75, 0, 130],
		"ivory": [255, 255, 240],
		"khaki": [240, 230, 140],
		"lavender": [230, 230, 250],
		"lavenderblush": [255, 240, 245],
		"lawngreen": [124, 252, 0],
		"lemonchiffon": [255, 250, 205],
		"lightblue": [173, 216, 230],
		"lightcoral": [240, 128, 128],
		"lightcyan": [224, 255, 255],
		"lightgoldenrodyellow": [250, 250, 210],
		"lightgray": [211, 211, 211],
		"lightgreen": [144, 238, 144],
		"lightgrey": [211, 211, 211],
		"lightpink": [255, 182, 193],
		"lightsalmon": [255, 160, 122],
		"lightseagreen": [32, 178, 170],
		"lightskyblue": [135, 206, 250],
		"lightslategray": [119, 136, 153],
		"lightslategrey": [119, 136, 153],
		"lightsteelblue": [176, 196, 222],
		"lightyellow": [255, 255, 224],
		"lime": [0, 255, 0],
		"limegreen": [50, 205, 50],
		"linen": [250, 240, 230],
		"magenta": [255, 0, 255],
		"maroon": [128, 0, 0],
		"mediumaquamarine": [102, 205, 170],
		"mediumblue": [0, 0, 205],
		"mediumorchid": [186, 85, 211],
		"mediumpurple": [147, 112, 219],
		"mediumseagreen": [60, 179, 113],
		"mediumslateblue": [123, 104, 238],
		"mediumspringgreen": [0, 250, 154],
		"mediumturquoise": [72, 209, 204],
		"mediumvioletred": [199, 21, 133],
		"midnightblue": [25, 25, 112],
		"mintcream": [245, 255, 250],
		"mistyrose": [255, 228, 225],
		"moccasin": [255, 228, 181],
		"navajowhite": [255, 222, 173],
		"navy": [0, 0, 128],
		"oldlace": [253, 245, 230],
		"olive": [128, 128, 0],
		"olivedrab": [107, 142, 35],
		"orange": [255, 165, 0],
		"orangered": [255, 69, 0],
		"orchid": [218, 112, 214],
		"palegoldenrod": [238, 232, 170],
		"palegreen": [152, 251, 152],
		"paleturquoise": [175, 238, 238],
		"palevioletred": [219, 112, 147],
		"papayawhip": [255, 239, 213],
		"peachpuff": [255, 218, 185],
		"peru": [205, 133, 63],
		"pink": [255, 192, 203],
		"plum": [221, 160, 221],
		"powderblue": [176, 224, 230],
		"purple": [128, 0, 128],
		"rebeccapurple": [102, 51, 153],
		"red": [255, 0, 0],
		"rosybrown": [188, 143, 143],
		"royalblue": [65, 105, 225],
		"saddlebrown": [139, 69, 19],
		"salmon": [250, 128, 114],
		"sandybrown": [244, 164, 96],
		"seagreen": [46, 139, 87],
		"seashell": [255, 245, 238],
		"sienna": [160, 82, 45],
		"silver": [192, 192, 192],
		"skyblue": [135, 206, 235],
		"slateblue": [106, 90, 205],
		"slategray": [112, 128, 144],
		"slategrey": [112, 128, 144],
		"snow": [255, 250, 250],
		"springgreen": [0, 255, 127],
		"steelblue": [70, 130, 180],
		"tan": [210, 180, 140],
		"teal": [0, 128, 128],
		"thistle": [216, 191, 216],
		"tomato": [255, 99, 71],
		"turquoise": [64, 224, 208],
		"violet": [238, 130, 238],
		"wheat": [245, 222, 179],
		"white": [255, 255, 255],
		"whitesmoke": [245, 245, 245],
		"yellow": [255, 255, 0],
		"yellowgreen": [154, 205, 50]
	};
	return colorName$1;
}

var simpleSwizzle = {exports: {}};

var isArrayish;
var hasRequiredIsArrayish;

function requireIsArrayish () {
	if (hasRequiredIsArrayish) return isArrayish;
	hasRequiredIsArrayish = 1;
	isArrayish = function isArrayish(obj) {
		if (!obj || typeof obj === 'string') {
			return false;
		}

		return obj instanceof Array || Array.isArray(obj) ||
			(obj.length >= 0 && (obj.splice instanceof Function ||
				(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
	};
	return isArrayish;
}

var hasRequiredSimpleSwizzle;

function requireSimpleSwizzle () {
	if (hasRequiredSimpleSwizzle) return simpleSwizzle.exports;
	hasRequiredSimpleSwizzle = 1;

	var isArrayish = requireIsArrayish();

	var concat = Array.prototype.concat;
	var slice = Array.prototype.slice;

	var swizzle = simpleSwizzle.exports = function swizzle(args) {
		var results = [];

		for (var i = 0, len = args.length; i < len; i++) {
			var arg = args[i];

			if (isArrayish(arg)) {
				// http://jsperf.com/javascript-array-concat-vs-push/98
				results = concat.call(results, slice.call(arg));
			} else {
				results.push(arg);
			}
		}

		return results;
	};

	swizzle.wrap = function (fn) {
		return function () {
			return fn(swizzle(arguments));
		};
	};
	return simpleSwizzle.exports;
}

/* MIT license */

var hasRequiredColorString;

function requireColorString () {
	if (hasRequiredColorString) return colorString.exports;
	hasRequiredColorString = 1;
	var colorNames = requireColorName$1();
	var swizzle = requireSimpleSwizzle();
	var hasOwnProperty = Object.hasOwnProperty;

	var reverseNames = Object.create(null);

	// create a list of reverse color names
	for (var name in colorNames) {
		if (hasOwnProperty.call(colorNames, name)) {
			reverseNames[colorNames[name]] = name;
		}
	}

	var cs = colorString.exports = {
		to: {},
		get: {}
	};

	cs.get = function (string) {
		var prefix = string.substring(0, 3).toLowerCase();
		var val;
		var model;
		switch (prefix) {
			case 'hsl':
				val = cs.get.hsl(string);
				model = 'hsl';
				break;
			case 'hwb':
				val = cs.get.hwb(string);
				model = 'hwb';
				break;
			default:
				val = cs.get.rgb(string);
				model = 'rgb';
				break;
		}

		if (!val) {
			return null;
		}

		return {model: model, value: val};
	};

	cs.get.rgb = function (string) {
		if (!string) {
			return null;
		}

		var abbr = /^#([a-f0-9]{3,4})$/i;
		var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
		var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
		var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
		var keyword = /^(\w+)$/;

		var rgb = [0, 0, 0, 1];
		var match;
		var i;
		var hexAlpha;

		if (match = string.match(hex)) {
			hexAlpha = match[2];
			match = match[1];

			for (i = 0; i < 3; i++) {
				// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
				var i2 = i * 2;
				rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
			}

			if (hexAlpha) {
				rgb[3] = parseInt(hexAlpha, 16) / 255;
			}
		} else if (match = string.match(abbr)) {
			match = match[1];
			hexAlpha = match[3];

			for (i = 0; i < 3; i++) {
				rgb[i] = parseInt(match[i] + match[i], 16);
			}

			if (hexAlpha) {
				rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
			}
		} else if (match = string.match(rgba)) {
			for (i = 0; i < 3; i++) {
				rgb[i] = parseInt(match[i + 1], 0);
			}

			if (match[4]) {
				if (match[5]) {
					rgb[3] = parseFloat(match[4]) * 0.01;
				} else {
					rgb[3] = parseFloat(match[4]);
				}
			}
		} else if (match = string.match(per)) {
			for (i = 0; i < 3; i++) {
				rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
			}

			if (match[4]) {
				if (match[5]) {
					rgb[3] = parseFloat(match[4]) * 0.01;
				} else {
					rgb[3] = parseFloat(match[4]);
				}
			}
		} else if (match = string.match(keyword)) {
			if (match[1] === 'transparent') {
				return [0, 0, 0, 0];
			}

			if (!hasOwnProperty.call(colorNames, match[1])) {
				return null;
			}

			rgb = colorNames[match[1]];
			rgb[3] = 1;

			return rgb;
		} else {
			return null;
		}

		for (i = 0; i < 3; i++) {
			rgb[i] = clamp(rgb[i], 0, 255);
		}
		rgb[3] = clamp(rgb[3], 0, 1);

		return rgb;
	};

	cs.get.hsl = function (string) {
		if (!string) {
			return null;
		}

		var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
		var match = string.match(hsl);

		if (match) {
			var alpha = parseFloat(match[4]);
			var h = ((parseFloat(match[1]) % 360) + 360) % 360;
			var s = clamp(parseFloat(match[2]), 0, 100);
			var l = clamp(parseFloat(match[3]), 0, 100);
			var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

			return [h, s, l, a];
		}

		return null;
	};

	cs.get.hwb = function (string) {
		if (!string) {
			return null;
		}

		var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
		var match = string.match(hwb);

		if (match) {
			var alpha = parseFloat(match[4]);
			var h = ((parseFloat(match[1]) % 360) + 360) % 360;
			var w = clamp(parseFloat(match[2]), 0, 100);
			var b = clamp(parseFloat(match[3]), 0, 100);
			var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
			return [h, w, b, a];
		}

		return null;
	};

	cs.to.hex = function () {
		var rgba = swizzle(arguments);

		return (
			'#' +
			hexDouble(rgba[0]) +
			hexDouble(rgba[1]) +
			hexDouble(rgba[2]) +
			(rgba[3] < 1
				? (hexDouble(Math.round(rgba[3] * 255)))
				: '')
		);
	};

	cs.to.rgb = function () {
		var rgba = swizzle(arguments);

		return rgba.length < 4 || rgba[3] === 1
			? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
			: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
	};

	cs.to.rgb.percent = function () {
		var rgba = swizzle(arguments);

		var r = Math.round(rgba[0] / 255 * 100);
		var g = Math.round(rgba[1] / 255 * 100);
		var b = Math.round(rgba[2] / 255 * 100);

		return rgba.length < 4 || rgba[3] === 1
			? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
			: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
	};

	cs.to.hsl = function () {
		var hsla = swizzle(arguments);
		return hsla.length < 4 || hsla[3] === 1
			? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
			: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
	};

	// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
	// (hwb have alpha optional & 1 is default value)
	cs.to.hwb = function () {
		var hwba = swizzle(arguments);

		var a = '';
		if (hwba.length >= 4 && hwba[3] !== 1) {
			a = ', ' + hwba[3];
		}

		return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
	};

	cs.to.keyword = function (rgb) {
		return reverseNames[rgb.slice(0, 3)];
	};

	// helpers
	function clamp(num, min, max) {
		return Math.min(Math.max(min, num), max);
	}

	function hexDouble(num) {
		var str = Math.round(num).toString(16).toUpperCase();
		return (str.length < 2) ? '0' + str : str;
	}
	return colorString.exports;
}

var conversions = {exports: {}};

var colorName;
var hasRequiredColorName;

function requireColorName () {
	if (hasRequiredColorName) return colorName;
	hasRequiredColorName = 1;

	colorName = {
		"aliceblue": [240, 248, 255],
		"antiquewhite": [250, 235, 215],
		"aqua": [0, 255, 255],
		"aquamarine": [127, 255, 212],
		"azure": [240, 255, 255],
		"beige": [245, 245, 220],
		"bisque": [255, 228, 196],
		"black": [0, 0, 0],
		"blanchedalmond": [255, 235, 205],
		"blue": [0, 0, 255],
		"blueviolet": [138, 43, 226],
		"brown": [165, 42, 42],
		"burlywood": [222, 184, 135],
		"cadetblue": [95, 158, 160],
		"chartreuse": [127, 255, 0],
		"chocolate": [210, 105, 30],
		"coral": [255, 127, 80],
		"cornflowerblue": [100, 149, 237],
		"cornsilk": [255, 248, 220],
		"crimson": [220, 20, 60],
		"cyan": [0, 255, 255],
		"darkblue": [0, 0, 139],
		"darkcyan": [0, 139, 139],
		"darkgoldenrod": [184, 134, 11],
		"darkgray": [169, 169, 169],
		"darkgreen": [0, 100, 0],
		"darkgrey": [169, 169, 169],
		"darkkhaki": [189, 183, 107],
		"darkmagenta": [139, 0, 139],
		"darkolivegreen": [85, 107, 47],
		"darkorange": [255, 140, 0],
		"darkorchid": [153, 50, 204],
		"darkred": [139, 0, 0],
		"darksalmon": [233, 150, 122],
		"darkseagreen": [143, 188, 143],
		"darkslateblue": [72, 61, 139],
		"darkslategray": [47, 79, 79],
		"darkslategrey": [47, 79, 79],
		"darkturquoise": [0, 206, 209],
		"darkviolet": [148, 0, 211],
		"deeppink": [255, 20, 147],
		"deepskyblue": [0, 191, 255],
		"dimgray": [105, 105, 105],
		"dimgrey": [105, 105, 105],
		"dodgerblue": [30, 144, 255],
		"firebrick": [178, 34, 34],
		"floralwhite": [255, 250, 240],
		"forestgreen": [34, 139, 34],
		"fuchsia": [255, 0, 255],
		"gainsboro": [220, 220, 220],
		"ghostwhite": [248, 248, 255],
		"gold": [255, 215, 0],
		"goldenrod": [218, 165, 32],
		"gray": [128, 128, 128],
		"green": [0, 128, 0],
		"greenyellow": [173, 255, 47],
		"grey": [128, 128, 128],
		"honeydew": [240, 255, 240],
		"hotpink": [255, 105, 180],
		"indianred": [205, 92, 92],
		"indigo": [75, 0, 130],
		"ivory": [255, 255, 240],
		"khaki": [240, 230, 140],
		"lavender": [230, 230, 250],
		"lavenderblush": [255, 240, 245],
		"lawngreen": [124, 252, 0],
		"lemonchiffon": [255, 250, 205],
		"lightblue": [173, 216, 230],
		"lightcoral": [240, 128, 128],
		"lightcyan": [224, 255, 255],
		"lightgoldenrodyellow": [250, 250, 210],
		"lightgray": [211, 211, 211],
		"lightgreen": [144, 238, 144],
		"lightgrey": [211, 211, 211],
		"lightpink": [255, 182, 193],
		"lightsalmon": [255, 160, 122],
		"lightseagreen": [32, 178, 170],
		"lightskyblue": [135, 206, 250],
		"lightslategray": [119, 136, 153],
		"lightslategrey": [119, 136, 153],
		"lightsteelblue": [176, 196, 222],
		"lightyellow": [255, 255, 224],
		"lime": [0, 255, 0],
		"limegreen": [50, 205, 50],
		"linen": [250, 240, 230],
		"magenta": [255, 0, 255],
		"maroon": [128, 0, 0],
		"mediumaquamarine": [102, 205, 170],
		"mediumblue": [0, 0, 205],
		"mediumorchid": [186, 85, 211],
		"mediumpurple": [147, 112, 219],
		"mediumseagreen": [60, 179, 113],
		"mediumslateblue": [123, 104, 238],
		"mediumspringgreen": [0, 250, 154],
		"mediumturquoise": [72, 209, 204],
		"mediumvioletred": [199, 21, 133],
		"midnightblue": [25, 25, 112],
		"mintcream": [245, 255, 250],
		"mistyrose": [255, 228, 225],
		"moccasin": [255, 228, 181],
		"navajowhite": [255, 222, 173],
		"navy": [0, 0, 128],
		"oldlace": [253, 245, 230],
		"olive": [128, 128, 0],
		"olivedrab": [107, 142, 35],
		"orange": [255, 165, 0],
		"orangered": [255, 69, 0],
		"orchid": [218, 112, 214],
		"palegoldenrod": [238, 232, 170],
		"palegreen": [152, 251, 152],
		"paleturquoise": [175, 238, 238],
		"palevioletred": [219, 112, 147],
		"papayawhip": [255, 239, 213],
		"peachpuff": [255, 218, 185],
		"peru": [205, 133, 63],
		"pink": [255, 192, 203],
		"plum": [221, 160, 221],
		"powderblue": [176, 224, 230],
		"purple": [128, 0, 128],
		"rebeccapurple": [102, 51, 153],
		"red": [255, 0, 0],
		"rosybrown": [188, 143, 143],
		"royalblue": [65, 105, 225],
		"saddlebrown": [139, 69, 19],
		"salmon": [250, 128, 114],
		"sandybrown": [244, 164, 96],
		"seagreen": [46, 139, 87],
		"seashell": [255, 245, 238],
		"sienna": [160, 82, 45],
		"silver": [192, 192, 192],
		"skyblue": [135, 206, 235],
		"slateblue": [106, 90, 205],
		"slategray": [112, 128, 144],
		"slategrey": [112, 128, 144],
		"snow": [255, 250, 250],
		"springgreen": [0, 255, 127],
		"steelblue": [70, 130, 180],
		"tan": [210, 180, 140],
		"teal": [0, 128, 128],
		"thistle": [216, 191, 216],
		"tomato": [255, 99, 71],
		"turquoise": [64, 224, 208],
		"violet": [238, 130, 238],
		"wheat": [245, 222, 179],
		"white": [255, 255, 255],
		"whitesmoke": [245, 245, 245],
		"yellow": [255, 255, 0],
		"yellowgreen": [154, 205, 50]
	};
	return colorName;
}

/* MIT license */

var hasRequiredConversions;

function requireConversions () {
	if (hasRequiredConversions) return conversions.exports;
	hasRequiredConversions = 1;
	var cssKeywords = requireColorName();

	// NOTE: conversions should only return primitive values (i.e. arrays, or
	//       values that give correct `typeof` results).
	//       do not use box values types (i.e. Number(), String(), etc.)

	var reverseKeywords = {};
	for (var key in cssKeywords) {
		if (cssKeywords.hasOwnProperty(key)) {
			reverseKeywords[cssKeywords[key]] = key;
		}
	}

	var convert = conversions.exports = {
		rgb: {channels: 3, labels: 'rgb'},
		hsl: {channels: 3, labels: 'hsl'},
		hsv: {channels: 3, labels: 'hsv'},
		hwb: {channels: 3, labels: 'hwb'},
		cmyk: {channels: 4, labels: 'cmyk'},
		xyz: {channels: 3, labels: 'xyz'},
		lab: {channels: 3, labels: 'lab'},
		lch: {channels: 3, labels: 'lch'},
		hex: {channels: 1, labels: ['hex']},
		keyword: {channels: 1, labels: ['keyword']},
		ansi16: {channels: 1, labels: ['ansi16']},
		ansi256: {channels: 1, labels: ['ansi256']},
		hcg: {channels: 3, labels: ['h', 'c', 'g']},
		apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
		gray: {channels: 1, labels: ['gray']}
	};

	// hide .channels and .labels properties
	for (var model in convert) {
		if (convert.hasOwnProperty(model)) {
			if (!('channels' in convert[model])) {
				throw new Error('missing channels property: ' + model);
			}

			if (!('labels' in convert[model])) {
				throw new Error('missing channel labels property: ' + model);
			}

			if (convert[model].labels.length !== convert[model].channels) {
				throw new Error('channel and label counts mismatch: ' + model);
			}

			var channels = convert[model].channels;
			var labels = convert[model].labels;
			delete convert[model].channels;
			delete convert[model].labels;
			Object.defineProperty(convert[model], 'channels', {value: channels});
			Object.defineProperty(convert[model], 'labels', {value: labels});
		}
	}

	convert.rgb.hsl = function (rgb) {
		var r = rgb[0] / 255;
		var g = rgb[1] / 255;
		var b = rgb[2] / 255;
		var min = Math.min(r, g, b);
		var max = Math.max(r, g, b);
		var delta = max - min;
		var h;
		var s;
		var l;

		if (max === min) {
			h = 0;
		} else if (r === max) {
			h = (g - b) / delta;
		} else if (g === max) {
			h = 2 + (b - r) / delta;
		} else if (b === max) {
			h = 4 + (r - g) / delta;
		}

		h = Math.min(h * 60, 360);

		if (h < 0) {
			h += 360;
		}

		l = (min + max) / 2;

		if (max === min) {
			s = 0;
		} else if (l <= 0.5) {
			s = delta / (max + min);
		} else {
			s = delta / (2 - max - min);
		}

		return [h, s * 100, l * 100];
	};

	convert.rgb.hsv = function (rgb) {
		var rdif;
		var gdif;
		var bdif;
		var h;
		var s;

		var r = rgb[0] / 255;
		var g = rgb[1] / 255;
		var b = rgb[2] / 255;
		var v = Math.max(r, g, b);
		var diff = v - Math.min(r, g, b);
		var diffc = function (c) {
			return (v - c) / 6 / diff + 1 / 2;
		};

		if (diff === 0) {
			h = s = 0;
		} else {
			s = diff / v;
			rdif = diffc(r);
			gdif = diffc(g);
			bdif = diffc(b);

			if (r === v) {
				h = bdif - gdif;
			} else if (g === v) {
				h = (1 / 3) + rdif - bdif;
			} else if (b === v) {
				h = (2 / 3) + gdif - rdif;
			}
			if (h < 0) {
				h += 1;
			} else if (h > 1) {
				h -= 1;
			}
		}

		return [
			h * 360,
			s * 100,
			v * 100
		];
	};

	convert.rgb.hwb = function (rgb) {
		var r = rgb[0];
		var g = rgb[1];
		var b = rgb[2];
		var h = convert.rgb.hsl(rgb)[0];
		var w = 1 / 255 * Math.min(r, Math.min(g, b));

		b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

		return [h, w * 100, b * 100];
	};

	convert.rgb.cmyk = function (rgb) {
		var r = rgb[0] / 255;
		var g = rgb[1] / 255;
		var b = rgb[2] / 255;
		var c;
		var m;
		var y;
		var k;

		k = Math.min(1 - r, 1 - g, 1 - b);
		c = (1 - r - k) / (1 - k) || 0;
		m = (1 - g - k) / (1 - k) || 0;
		y = (1 - b - k) / (1 - k) || 0;

		return [c * 100, m * 100, y * 100, k * 100];
	};

	/**
	 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	 * */
	function comparativeDistance(x, y) {
		return (
			Math.pow(x[0] - y[0], 2) +
			Math.pow(x[1] - y[1], 2) +
			Math.pow(x[2] - y[2], 2)
		);
	}

	convert.rgb.keyword = function (rgb) {
		var reversed = reverseKeywords[rgb];
		if (reversed) {
			return reversed;
		}

		var currentClosestDistance = Infinity;
		var currentClosestKeyword;

		for (var keyword in cssKeywords) {
			if (cssKeywords.hasOwnProperty(keyword)) {
				var value = cssKeywords[keyword];

				// Compute comparative distance
				var distance = comparativeDistance(rgb, value);

				// Check if its less, if so set as closest
				if (distance < currentClosestDistance) {
					currentClosestDistance = distance;
					currentClosestKeyword = keyword;
				}
			}
		}

		return currentClosestKeyword;
	};

	convert.keyword.rgb = function (keyword) {
		return cssKeywords[keyword];
	};

	convert.rgb.xyz = function (rgb) {
		var r = rgb[0] / 255;
		var g = rgb[1] / 255;
		var b = rgb[2] / 255;

		// assume sRGB
		r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
		g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
		b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

		var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
		var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
		var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

		return [x * 100, y * 100, z * 100];
	};

	convert.rgb.lab = function (rgb) {
		var xyz = convert.rgb.xyz(rgb);
		var x = xyz[0];
		var y = xyz[1];
		var z = xyz[2];
		var l;
		var a;
		var b;

		x /= 95.047;
		y /= 100;
		z /= 108.883;

		x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
		y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
		z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

		l = (116 * y) - 16;
		a = 500 * (x - y);
		b = 200 * (y - z);

		return [l, a, b];
	};

	convert.hsl.rgb = function (hsl) {
		var h = hsl[0] / 360;
		var s = hsl[1] / 100;
		var l = hsl[2] / 100;
		var t1;
		var t2;
		var t3;
		var rgb;
		var val;

		if (s === 0) {
			val = l * 255;
			return [val, val, val];
		}

		if (l < 0.5) {
			t2 = l * (1 + s);
		} else {
			t2 = l + s - l * s;
		}

		t1 = 2 * l - t2;

		rgb = [0, 0, 0];
		for (var i = 0; i < 3; i++) {
			t3 = h + 1 / 3 * -(i - 1);
			if (t3 < 0) {
				t3++;
			}
			if (t3 > 1) {
				t3--;
			}

			if (6 * t3 < 1) {
				val = t1 + (t2 - t1) * 6 * t3;
			} else if (2 * t3 < 1) {
				val = t2;
			} else if (3 * t3 < 2) {
				val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
			} else {
				val = t1;
			}

			rgb[i] = val * 255;
		}

		return rgb;
	};

	convert.hsl.hsv = function (hsl) {
		var h = hsl[0];
		var s = hsl[1] / 100;
		var l = hsl[2] / 100;
		var smin = s;
		var lmin = Math.max(l, 0.01);
		var sv;
		var v;

		l *= 2;
		s *= (l <= 1) ? l : 2 - l;
		smin *= lmin <= 1 ? lmin : 2 - lmin;
		v = (l + s) / 2;
		sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

		return [h, sv * 100, v * 100];
	};

	convert.hsv.rgb = function (hsv) {
		var h = hsv[0] / 60;
		var s = hsv[1] / 100;
		var v = hsv[2] / 100;
		var hi = Math.floor(h) % 6;

		var f = h - Math.floor(h);
		var p = 255 * v * (1 - s);
		var q = 255 * v * (1 - (s * f));
		var t = 255 * v * (1 - (s * (1 - f)));
		v *= 255;

		switch (hi) {
			case 0:
				return [v, t, p];
			case 1:
				return [q, v, p];
			case 2:
				return [p, v, t];
			case 3:
				return [p, q, v];
			case 4:
				return [t, p, v];
			case 5:
				return [v, p, q];
		}
	};

	convert.hsv.hsl = function (hsv) {
		var h = hsv[0];
		var s = hsv[1] / 100;
		var v = hsv[2] / 100;
		var vmin = Math.max(v, 0.01);
		var lmin;
		var sl;
		var l;

		l = (2 - s) * v;
		lmin = (2 - s) * vmin;
		sl = s * vmin;
		sl /= (lmin <= 1) ? lmin : 2 - lmin;
		sl = sl || 0;
		l /= 2;

		return [h, sl * 100, l * 100];
	};

	// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
	convert.hwb.rgb = function (hwb) {
		var h = hwb[0] / 360;
		var wh = hwb[1] / 100;
		var bl = hwb[2] / 100;
		var ratio = wh + bl;
		var i;
		var v;
		var f;
		var n;

		// wh + bl cant be > 1
		if (ratio > 1) {
			wh /= ratio;
			bl /= ratio;
		}

		i = Math.floor(6 * h);
		v = 1 - bl;
		f = 6 * h - i;

		if ((i & 0x01) !== 0) {
			f = 1 - f;
		}

		n = wh + f * (v - wh); // linear interpolation

		var r;
		var g;
		var b;
		switch (i) {
			default:
			case 6:
			case 0: r = v; g = n; b = wh; break;
			case 1: r = n; g = v; b = wh; break;
			case 2: r = wh; g = v; b = n; break;
			case 3: r = wh; g = n; b = v; break;
			case 4: r = n; g = wh; b = v; break;
			case 5: r = v; g = wh; b = n; break;
		}

		return [r * 255, g * 255, b * 255];
	};

	convert.cmyk.rgb = function (cmyk) {
		var c = cmyk[0] / 100;
		var m = cmyk[1] / 100;
		var y = cmyk[2] / 100;
		var k = cmyk[3] / 100;
		var r;
		var g;
		var b;

		r = 1 - Math.min(1, c * (1 - k) + k);
		g = 1 - Math.min(1, m * (1 - k) + k);
		b = 1 - Math.min(1, y * (1 - k) + k);

		return [r * 255, g * 255, b * 255];
	};

	convert.xyz.rgb = function (xyz) {
		var x = xyz[0] / 100;
		var y = xyz[1] / 100;
		var z = xyz[2] / 100;
		var r;
		var g;
		var b;

		r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
		g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
		b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

		// assume sRGB
		r = r > 0.0031308
			? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
			: r * 12.92;

		g = g > 0.0031308
			? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
			: g * 12.92;

		b = b > 0.0031308
			? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
			: b * 12.92;

		r = Math.min(Math.max(0, r), 1);
		g = Math.min(Math.max(0, g), 1);
		b = Math.min(Math.max(0, b), 1);

		return [r * 255, g * 255, b * 255];
	};

	convert.xyz.lab = function (xyz) {
		var x = xyz[0];
		var y = xyz[1];
		var z = xyz[2];
		var l;
		var a;
		var b;

		x /= 95.047;
		y /= 100;
		z /= 108.883;

		x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
		y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
		z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

		l = (116 * y) - 16;
		a = 500 * (x - y);
		b = 200 * (y - z);

		return [l, a, b];
	};

	convert.lab.xyz = function (lab) {
		var l = lab[0];
		var a = lab[1];
		var b = lab[2];
		var x;
		var y;
		var z;

		y = (l + 16) / 116;
		x = a / 500 + y;
		z = y - b / 200;

		var y2 = Math.pow(y, 3);
		var x2 = Math.pow(x, 3);
		var z2 = Math.pow(z, 3);
		y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
		x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
		z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

		x *= 95.047;
		y *= 100;
		z *= 108.883;

		return [x, y, z];
	};

	convert.lab.lch = function (lab) {
		var l = lab[0];
		var a = lab[1];
		var b = lab[2];
		var hr;
		var h;
		var c;

		hr = Math.atan2(b, a);
		h = hr * 360 / 2 / Math.PI;

		if (h < 0) {
			h += 360;
		}

		c = Math.sqrt(a * a + b * b);

		return [l, c, h];
	};

	convert.lch.lab = function (lch) {
		var l = lch[0];
		var c = lch[1];
		var h = lch[2];
		var a;
		var b;
		var hr;

		hr = h / 360 * 2 * Math.PI;
		a = c * Math.cos(hr);
		b = c * Math.sin(hr);

		return [l, a, b];
	};

	convert.rgb.ansi16 = function (args) {
		var r = args[0];
		var g = args[1];
		var b = args[2];
		var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

		value = Math.round(value / 50);

		if (value === 0) {
			return 30;
		}

		var ansi = 30
			+ ((Math.round(b / 255) << 2)
			| (Math.round(g / 255) << 1)
			| Math.round(r / 255));

		if (value === 2) {
			ansi += 60;
		}

		return ansi;
	};

	convert.hsv.ansi16 = function (args) {
		// optimization here; we already know the value and don't need to get
		// it converted for us.
		return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
	};

	convert.rgb.ansi256 = function (args) {
		var r = args[0];
		var g = args[1];
		var b = args[2];

		// we use the extended greyscale palette here, with the exception of
		// black and white. normal palette only has 4 greyscale shades.
		if (r === g && g === b) {
			if (r < 8) {
				return 16;
			}

			if (r > 248) {
				return 231;
			}

			return Math.round(((r - 8) / 247) * 24) + 232;
		}

		var ansi = 16
			+ (36 * Math.round(r / 255 * 5))
			+ (6 * Math.round(g / 255 * 5))
			+ Math.round(b / 255 * 5);

		return ansi;
	};

	convert.ansi16.rgb = function (args) {
		var color = args % 10;

		// handle greyscale
		if (color === 0 || color === 7) {
			if (args > 50) {
				color += 3.5;
			}

			color = color / 10.5 * 255;

			return [color, color, color];
		}

		var mult = (~~(args > 50) + 1) * 0.5;
		var r = ((color & 1) * mult) * 255;
		var g = (((color >> 1) & 1) * mult) * 255;
		var b = (((color >> 2) & 1) * mult) * 255;

		return [r, g, b];
	};

	convert.ansi256.rgb = function (args) {
		// handle greyscale
		if (args >= 232) {
			var c = (args - 232) * 10 + 8;
			return [c, c, c];
		}

		args -= 16;

		var rem;
		var r = Math.floor(args / 36) / 5 * 255;
		var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
		var b = (rem % 6) / 5 * 255;

		return [r, g, b];
	};

	convert.rgb.hex = function (args) {
		var integer = ((Math.round(args[0]) & 0xFF) << 16)
			+ ((Math.round(args[1]) & 0xFF) << 8)
			+ (Math.round(args[2]) & 0xFF);

		var string = integer.toString(16).toUpperCase();
		return '000000'.substring(string.length) + string;
	};

	convert.hex.rgb = function (args) {
		var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
		if (!match) {
			return [0, 0, 0];
		}

		var colorString = match[0];

		if (match[0].length === 3) {
			colorString = colorString.split('').map(function (char) {
				return char + char;
			}).join('');
		}

		var integer = parseInt(colorString, 16);
		var r = (integer >> 16) & 0xFF;
		var g = (integer >> 8) & 0xFF;
		var b = integer & 0xFF;

		return [r, g, b];
	};

	convert.rgb.hcg = function (rgb) {
		var r = rgb[0] / 255;
		var g = rgb[1] / 255;
		var b = rgb[2] / 255;
		var max = Math.max(Math.max(r, g), b);
		var min = Math.min(Math.min(r, g), b);
		var chroma = (max - min);
		var grayscale;
		var hue;

		if (chroma < 1) {
			grayscale = min / (1 - chroma);
		} else {
			grayscale = 0;
		}

		if (chroma <= 0) {
			hue = 0;
		} else
		if (max === r) {
			hue = ((g - b) / chroma) % 6;
		} else
		if (max === g) {
			hue = 2 + (b - r) / chroma;
		} else {
			hue = 4 + (r - g) / chroma + 4;
		}

		hue /= 6;
		hue %= 1;

		return [hue * 360, chroma * 100, grayscale * 100];
	};

	convert.hsl.hcg = function (hsl) {
		var s = hsl[1] / 100;
		var l = hsl[2] / 100;
		var c = 1;
		var f = 0;

		if (l < 0.5) {
			c = 2.0 * s * l;
		} else {
			c = 2.0 * s * (1.0 - l);
		}

		if (c < 1.0) {
			f = (l - 0.5 * c) / (1.0 - c);
		}

		return [hsl[0], c * 100, f * 100];
	};

	convert.hsv.hcg = function (hsv) {
		var s = hsv[1] / 100;
		var v = hsv[2] / 100;

		var c = s * v;
		var f = 0;

		if (c < 1.0) {
			f = (v - c) / (1 - c);
		}

		return [hsv[0], c * 100, f * 100];
	};

	convert.hcg.rgb = function (hcg) {
		var h = hcg[0] / 360;
		var c = hcg[1] / 100;
		var g = hcg[2] / 100;

		if (c === 0.0) {
			return [g * 255, g * 255, g * 255];
		}

		var pure = [0, 0, 0];
		var hi = (h % 1) * 6;
		var v = hi % 1;
		var w = 1 - v;
		var mg = 0;

		switch (Math.floor(hi)) {
			case 0:
				pure[0] = 1; pure[1] = v; pure[2] = 0; break;
			case 1:
				pure[0] = w; pure[1] = 1; pure[2] = 0; break;
			case 2:
				pure[0] = 0; pure[1] = 1; pure[2] = v; break;
			case 3:
				pure[0] = 0; pure[1] = w; pure[2] = 1; break;
			case 4:
				pure[0] = v; pure[1] = 0; pure[2] = 1; break;
			default:
				pure[0] = 1; pure[1] = 0; pure[2] = w;
		}

		mg = (1.0 - c) * g;

		return [
			(c * pure[0] + mg) * 255,
			(c * pure[1] + mg) * 255,
			(c * pure[2] + mg) * 255
		];
	};

	convert.hcg.hsv = function (hcg) {
		var c = hcg[1] / 100;
		var g = hcg[2] / 100;

		var v = c + g * (1.0 - c);
		var f = 0;

		if (v > 0.0) {
			f = c / v;
		}

		return [hcg[0], f * 100, v * 100];
	};

	convert.hcg.hsl = function (hcg) {
		var c = hcg[1] / 100;
		var g = hcg[2] / 100;

		var l = g * (1.0 - c) + 0.5 * c;
		var s = 0;

		if (l > 0.0 && l < 0.5) {
			s = c / (2 * l);
		} else
		if (l >= 0.5 && l < 1.0) {
			s = c / (2 * (1 - l));
		}

		return [hcg[0], s * 100, l * 100];
	};

	convert.hcg.hwb = function (hcg) {
		var c = hcg[1] / 100;
		var g = hcg[2] / 100;
		var v = c + g * (1.0 - c);
		return [hcg[0], (v - c) * 100, (1 - v) * 100];
	};

	convert.hwb.hcg = function (hwb) {
		var w = hwb[1] / 100;
		var b = hwb[2] / 100;
		var v = 1 - b;
		var c = v - w;
		var g = 0;

		if (c < 1) {
			g = (v - c) / (1 - c);
		}

		return [hwb[0], c * 100, g * 100];
	};

	convert.apple.rgb = function (apple) {
		return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
	};

	convert.rgb.apple = function (rgb) {
		return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
	};

	convert.gray.rgb = function (args) {
		return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
	};

	convert.gray.hsl = convert.gray.hsv = function (args) {
		return [0, 0, args[0]];
	};

	convert.gray.hwb = function (gray) {
		return [0, 100, gray[0]];
	};

	convert.gray.cmyk = function (gray) {
		return [0, 0, 0, gray[0]];
	};

	convert.gray.lab = function (gray) {
		return [gray[0], 0, 0];
	};

	convert.gray.hex = function (gray) {
		var val = Math.round(gray[0] / 100 * 255) & 0xFF;
		var integer = (val << 16) + (val << 8) + val;

		var string = integer.toString(16).toUpperCase();
		return '000000'.substring(string.length) + string;
	};

	convert.rgb.gray = function (rgb) {
		var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
		return [val / 255 * 100];
	};
	return conversions.exports;
}

var route;
var hasRequiredRoute;

function requireRoute () {
	if (hasRequiredRoute) return route;
	hasRequiredRoute = 1;
	var conversions = requireConversions();

	/*
		this function routes a model to all other models.

		all functions that are routed have a property `.conversion` attached
		to the returned synthetic function. This property is an array
		of strings, each with the steps in between the 'from' and 'to'
		color models (inclusive).

		conversions that are not possible simply are not included.
	*/

	function buildGraph() {
		var graph = {};
		// https://jsperf.com/object-keys-vs-for-in-with-closure/3
		var models = Object.keys(conversions);

		for (var len = models.length, i = 0; i < len; i++) {
			graph[models[i]] = {
				// http://jsperf.com/1-vs-infinity
				// micro-opt, but this is simple.
				distance: -1,
				parent: null
			};
		}

		return graph;
	}

	// https://en.wikipedia.org/wiki/Breadth-first_search
	function deriveBFS(fromModel) {
		var graph = buildGraph();
		var queue = [fromModel]; // unshift -> queue -> pop

		graph[fromModel].distance = 0;

		while (queue.length) {
			var current = queue.pop();
			var adjacents = Object.keys(conversions[current]);

			for (var len = adjacents.length, i = 0; i < len; i++) {
				var adjacent = adjacents[i];
				var node = graph[adjacent];

				if (node.distance === -1) {
					node.distance = graph[current].distance + 1;
					node.parent = current;
					queue.unshift(adjacent);
				}
			}
		}

		return graph;
	}

	function link(from, to) {
		return function (args) {
			return to(from(args));
		};
	}

	function wrapConversion(toModel, graph) {
		var path = [graph[toModel].parent, toModel];
		var fn = conversions[graph[toModel].parent][toModel];

		var cur = graph[toModel].parent;
		while (graph[cur].parent) {
			path.unshift(graph[cur].parent);
			fn = link(conversions[graph[cur].parent][cur], fn);
			cur = graph[cur].parent;
		}

		fn.conversion = path;
		return fn;
	}

	route = function (fromModel) {
		var graph = deriveBFS(fromModel);
		var conversion = {};

		var models = Object.keys(graph);
		for (var len = models.length, i = 0; i < len; i++) {
			var toModel = models[i];
			var node = graph[toModel];

			if (node.parent === null) {
				// no possible conversion, or this node is the source model.
				continue;
			}

			conversion[toModel] = wrapConversion(toModel, graph);
		}

		return conversion;
	};
	return route;
}

var colorConvert;
var hasRequiredColorConvert;

function requireColorConvert () {
	if (hasRequiredColorConvert) return colorConvert;
	hasRequiredColorConvert = 1;
	var conversions = requireConversions();
	var route = requireRoute();

	var convert = {};

	var models = Object.keys(conversions);

	function wrapRaw(fn) {
		var wrappedFn = function (args) {
			if (args === undefined || args === null) {
				return args;
			}

			if (arguments.length > 1) {
				args = Array.prototype.slice.call(arguments);
			}

			return fn(args);
		};

		// preserve .conversion property if there is one
		if ('conversion' in fn) {
			wrappedFn.conversion = fn.conversion;
		}

		return wrappedFn;
	}

	function wrapRounded(fn) {
		var wrappedFn = function (args) {
			if (args === undefined || args === null) {
				return args;
			}

			if (arguments.length > 1) {
				args = Array.prototype.slice.call(arguments);
			}

			var result = fn(args);

			// we're assuming the result is an array here.
			// see notice in conversions.js; don't use box types
			// in conversion functions.
			if (typeof result === 'object') {
				for (var len = result.length, i = 0; i < len; i++) {
					result[i] = Math.round(result[i]);
				}
			}

			return result;
		};

		// preserve .conversion property if there is one
		if ('conversion' in fn) {
			wrappedFn.conversion = fn.conversion;
		}

		return wrappedFn;
	}

	models.forEach(function (fromModel) {
		convert[fromModel] = {};

		Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
		Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

		var routes = route(fromModel);
		var routeModels = Object.keys(routes);

		routeModels.forEach(function (toModel) {
			var fn = routes[toModel];

			convert[fromModel][toModel] = wrapRounded(fn);
			convert[fromModel][toModel].raw = wrapRaw(fn);
		});
	});

	colorConvert = convert;
	return colorConvert;
}

var color;
var hasRequiredColor;

function requireColor () {
	if (hasRequiredColor) return color;
	hasRequiredColor = 1;

	var colorString = requireColorString();
	var convert = requireColorConvert();

	var _slice = [].slice;

	var skippedModels = [
		// to be honest, I don't really feel like keyword belongs in color convert, but eh.
		'keyword',

		// gray conflicts with some method names, and has its own method defined.
		'gray',

		// shouldn't really be in color-convert either...
		'hex'
	];

	var hashedModelKeys = {};
	Object.keys(convert).forEach(function (model) {
		hashedModelKeys[_slice.call(convert[model].labels).sort().join('')] = model;
	});

	var limiters = {};

	function Color(obj, model) {
		if (!(this instanceof Color)) {
			return new Color(obj, model);
		}

		if (model && model in skippedModels) {
			model = null;
		}

		if (model && !(model in convert)) {
			throw new Error('Unknown model: ' + model);
		}

		var i;
		var channels;

		if (obj == null) { // eslint-disable-line no-eq-null,eqeqeq
			this.model = 'rgb';
			this.color = [0, 0, 0];
			this.valpha = 1;
		} else if (obj instanceof Color) {
			this.model = obj.model;
			this.color = obj.color.slice();
			this.valpha = obj.valpha;
		} else if (typeof obj === 'string') {
			var result = colorString.get(obj);
			if (result === null) {
				throw new Error('Unable to parse color from string: ' + obj);
			}

			this.model = result.model;
			channels = convert[this.model].channels;
			this.color = result.value.slice(0, channels);
			this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
		} else if (obj.length) {
			this.model = model || 'rgb';
			channels = convert[this.model].channels;
			var newArr = _slice.call(obj, 0, channels);
			this.color = zeroArray(newArr, channels);
			this.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;
		} else if (typeof obj === 'number') {
			// this is always RGB - can be converted later on.
			obj &= 0xFFFFFF;
			this.model = 'rgb';
			this.color = [
				(obj >> 16) & 0xFF,
				(obj >> 8) & 0xFF,
				obj & 0xFF
			];
			this.valpha = 1;
		} else {
			this.valpha = 1;

			var keys = Object.keys(obj);
			if ('alpha' in obj) {
				keys.splice(keys.indexOf('alpha'), 1);
				this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;
			}

			var hashedKeys = keys.sort().join('');
			if (!(hashedKeys in hashedModelKeys)) {
				throw new Error('Unable to parse color from object: ' + JSON.stringify(obj));
			}

			this.model = hashedModelKeys[hashedKeys];

			var labels = convert[this.model].labels;
			var color = [];
			for (i = 0; i < labels.length; i++) {
				color.push(obj[labels[i]]);
			}

			this.color = zeroArray(color);
		}

		// perform limitations (clamping, etc.)
		if (limiters[this.model]) {
			channels = convert[this.model].channels;
			for (i = 0; i < channels; i++) {
				var limit = limiters[this.model][i];
				if (limit) {
					this.color[i] = limit(this.color[i]);
				}
			}
		}

		this.valpha = Math.max(0, Math.min(1, this.valpha));

		if (Object.freeze) {
			Object.freeze(this);
		}
	}

	Color.prototype = {
		toString: function () {
			return this.string();
		},

		toJSON: function () {
			return this[this.model]();
		},

		string: function (places) {
			var self = this.model in colorString.to ? this : this.rgb();
			self = self.round(typeof places === 'number' ? places : 1);
			var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
			return colorString.to[self.model](args);
		},

		percentString: function (places) {
			var self = this.rgb().round(typeof places === 'number' ? places : 1);
			var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
			return colorString.to.rgb.percent(args);
		},

		array: function () {
			return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
		},

		object: function () {
			var result = {};
			var channels = convert[this.model].channels;
			var labels = convert[this.model].labels;

			for (var i = 0; i < channels; i++) {
				result[labels[i]] = this.color[i];
			}

			if (this.valpha !== 1) {
				result.alpha = this.valpha;
			}

			return result;
		},

		unitArray: function () {
			var rgb = this.rgb().color;
			rgb[0] /= 255;
			rgb[1] /= 255;
			rgb[2] /= 255;

			if (this.valpha !== 1) {
				rgb.push(this.valpha);
			}

			return rgb;
		},

		unitObject: function () {
			var rgb = this.rgb().object();
			rgb.r /= 255;
			rgb.g /= 255;
			rgb.b /= 255;

			if (this.valpha !== 1) {
				rgb.alpha = this.valpha;
			}

			return rgb;
		},

		round: function (places) {
			places = Math.max(places || 0, 0);
			return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
		},

		alpha: function (val) {
			if (arguments.length) {
				return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
			}

			return this.valpha;
		},

		// rgb
		red: getset('rgb', 0, maxfn(255)),
		green: getset('rgb', 1, maxfn(255)),
		blue: getset('rgb', 2, maxfn(255)),

		hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style

		saturationl: getset('hsl', 1, maxfn(100)),
		lightness: getset('hsl', 2, maxfn(100)),

		saturationv: getset('hsv', 1, maxfn(100)),
		value: getset('hsv', 2, maxfn(100)),

		chroma: getset('hcg', 1, maxfn(100)),
		gray: getset('hcg', 2, maxfn(100)),

		white: getset('hwb', 1, maxfn(100)),
		wblack: getset('hwb', 2, maxfn(100)),

		cyan: getset('cmyk', 0, maxfn(100)),
		magenta: getset('cmyk', 1, maxfn(100)),
		yellow: getset('cmyk', 2, maxfn(100)),
		black: getset('cmyk', 3, maxfn(100)),

		x: getset('xyz', 0, maxfn(100)),
		y: getset('xyz', 1, maxfn(100)),
		z: getset('xyz', 2, maxfn(100)),

		l: getset('lab', 0, maxfn(100)),
		a: getset('lab', 1),
		b: getset('lab', 2),

		keyword: function (val) {
			if (arguments.length) {
				return new Color(val);
			}

			return convert[this.model].keyword(this.color);
		},

		hex: function (val) {
			if (arguments.length) {
				return new Color(val);
			}

			return colorString.to.hex(this.rgb().round().color);
		},

		rgbNumber: function () {
			var rgb = this.rgb().color;
			return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
		},

		luminosity: function () {
			// http://www.w3.org/TR/WCAG20/#relativeluminancedef
			var rgb = this.rgb().color;

			var lum = [];
			for (var i = 0; i < rgb.length; i++) {
				var chan = rgb[i] / 255;
				lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
			}

			return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
		},

		contrast: function (color2) {
			// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
			var lum1 = this.luminosity();
			var lum2 = color2.luminosity();

			if (lum1 > lum2) {
				return (lum1 + 0.05) / (lum2 + 0.05);
			}

			return (lum2 + 0.05) / (lum1 + 0.05);
		},

		level: function (color2) {
			var contrastRatio = this.contrast(color2);
			if (contrastRatio >= 7.1) {
				return 'AAA';
			}

			return (contrastRatio >= 4.5) ? 'AA' : '';
		},

		isDark: function () {
			// YIQ equation from http://24ways.org/2010/calculating-color-contrast
			var rgb = this.rgb().color;
			var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
			return yiq < 128;
		},

		isLight: function () {
			return !this.isDark();
		},

		negate: function () {
			var rgb = this.rgb();
			for (var i = 0; i < 3; i++) {
				rgb.color[i] = 255 - rgb.color[i];
			}
			return rgb;
		},

		lighten: function (ratio) {
			var hsl = this.hsl();
			hsl.color[2] += hsl.color[2] * ratio;
			return hsl;
		},

		darken: function (ratio) {
			var hsl = this.hsl();
			hsl.color[2] -= hsl.color[2] * ratio;
			return hsl;
		},

		saturate: function (ratio) {
			var hsl = this.hsl();
			hsl.color[1] += hsl.color[1] * ratio;
			return hsl;
		},

		desaturate: function (ratio) {
			var hsl = this.hsl();
			hsl.color[1] -= hsl.color[1] * ratio;
			return hsl;
		},

		whiten: function (ratio) {
			var hwb = this.hwb();
			hwb.color[1] += hwb.color[1] * ratio;
			return hwb;
		},

		blacken: function (ratio) {
			var hwb = this.hwb();
			hwb.color[2] += hwb.color[2] * ratio;
			return hwb;
		},

		grayscale: function () {
			// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
			var rgb = this.rgb().color;
			var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
			return Color.rgb(val, val, val);
		},

		fade: function (ratio) {
			return this.alpha(this.valpha - (this.valpha * ratio));
		},

		opaquer: function (ratio) {
			return this.alpha(this.valpha + (this.valpha * ratio));
		},

		rotate: function (degrees) {
			var hsl = this.hsl();
			var hue = hsl.color[0];
			hue = (hue + degrees) % 360;
			hue = hue < 0 ? 360 + hue : hue;
			hsl.color[0] = hue;
			return hsl;
		},

		mix: function (mixinColor, weight) {
			// ported from sass implementation in C
			// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
			if (!mixinColor || !mixinColor.rgb) {
				throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
			}
			var color1 = mixinColor.rgb();
			var color2 = this.rgb();
			var p = weight === undefined ? 0.5 : weight;

			var w = 2 * p - 1;
			var a = color1.alpha() - color2.alpha();

			var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
			var w2 = 1 - w1;

			return Color.rgb(
					w1 * color1.red() + w2 * color2.red(),
					w1 * color1.green() + w2 * color2.green(),
					w1 * color1.blue() + w2 * color2.blue(),
					color1.alpha() * p + color2.alpha() * (1 - p));
		}
	};

	// model conversion methods and static constructors
	Object.keys(convert).forEach(function (model) {
		if (skippedModels.indexOf(model) !== -1) {
			return;
		}

		var channels = convert[model].channels;

		// conversion methods
		Color.prototype[model] = function () {
			if (this.model === model) {
				return new Color(this);
			}

			if (arguments.length) {
				return new Color(arguments, model);
			}

			var newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;
			return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
		};

		// 'static' construction methods
		Color[model] = function (color) {
			if (typeof color === 'number') {
				color = zeroArray(_slice.call(arguments), channels);
			}
			return new Color(color, model);
		};
	});

	function roundTo(num, places) {
		return Number(num.toFixed(places));
	}

	function roundToPlace(places) {
		return function (num) {
			return roundTo(num, places);
		};
	}

	function getset(model, channel, modifier) {
		model = Array.isArray(model) ? model : [model];

		model.forEach(function (m) {
			(limiters[m] || (limiters[m] = []))[channel] = modifier;
		});

		model = model[0];

		return function (val) {
			var result;

			if (arguments.length) {
				if (modifier) {
					val = modifier(val);
				}

				result = this[model]();
				result.color[channel] = val;
				return result;
			}

			result = this[model]().color[channel];
			if (modifier) {
				result = modifier(result);
			}

			return result;
		};
	}

	function maxfn(max) {
		return function (v) {
			return Math.max(0, Math.min(max, v));
		};
	}

	function assertArray(val) {
		return Array.isArray(val) ? val : [val];
	}

	function zeroArray(arr, length) {
		for (var i = 0; i < length; i++) {
			if (typeof arr[i] !== 'number') {
				arr[i] = 0;
			}
		}

		return arr;
	}

	color = Color;
	return color;
}

var textHex;
var hasRequiredTextHex;

function requireTextHex () {
	if (hasRequiredTextHex) return textHex;
	hasRequiredTextHex = 1;

	/***
	 * Convert string to hex color.
	 *
	 * @param {String} str Text to hash and convert to hex.
	 * @returns {String}
	 * @api public
	 */
	textHex = function hex(str) {
	  for (
	    var i = 0, hash = 0;
	    i < str.length;
	    hash = str.charCodeAt(i++) + ((hash << 5) - hash)
	  );

	  var color = Math.floor(
	    Math.abs(
	      (Math.sin(hash) * 10000) % 1 * 16777216
	    )
	  ).toString(16);

	  return '#' + Array(6 - color.length + 1).join('0') + color;
	};
	return textHex;
}

var colorspace;
var hasRequiredColorspace;

function requireColorspace () {
	if (hasRequiredColorspace) return colorspace;
	hasRequiredColorspace = 1;

	var color = requireColor()
	  , hex = requireTextHex();

	/**
	 * Generate a color for a given name. But be reasonably smart about it by
	 * understanding name spaces and coloring each namespace a bit lighter so they
	 * still have the same base color as the root.
	 *
	 * @param {string} namespace The namespace
	 * @param {string} [delimiter] The delimiter
	 * @returns {string} color
	 */
	colorspace = function colorspace(namespace, delimiter) {
	  var split = namespace.split(delimiter || ':');
	  var base = hex(split[0]);

	  if (!split.length) return base;

	  for (var i = 0, l = split.length - 1; i < l; i++) {
	    base = color(base)
	    .mix(color(hex(split[i + 1])))
	    .saturate(1)
	    .hex();
	  }

	  return base;
	};
	return colorspace;
}

var namespace;
var hasRequiredNamespace;

function requireNamespace () {
	if (hasRequiredNamespace) return namespace;
	hasRequiredNamespace = 1;
	var colorspace = requireColorspace();

	/**
	 * Prefix the messages with a colored namespace.
	 *
	 * @param {Array} messages The messages array that is getting written.
	 * @param {Object} options Options for diagnostics.
	 * @returns {Array} Altered messages array.
	 * @public
	 */
	namespace = function colorNamespace(args, options) {
	  var namespace = options.namespace;

	  if (options.colors === false) {
	    args[0] = namespace +': '+ args[0];
	    return args;
	  }

	  var color = colorspace(namespace);

	  //
	  // The console API supports a special %c formatter in browsers. This is used
	  // to style console messages with any CSS styling, in our case we want to
	  // use colorize the namespace for clarity. As these are formatters, and
	  // we need to inject our CSS string as second messages argument so it
	  // gets picked up correctly.
	  //
	  args[0] = '%c'+ namespace +':%c '+ args[0];
	  args.splice(1, 0, 'color:'+ color, 'color:inherit');

	  return args;
	};
	return namespace;
}

var enabled;
var hasRequiredEnabled;

function requireEnabled () {
	if (hasRequiredEnabled) return enabled;
	hasRequiredEnabled = 1;

	/**
	 * Checks if a given namespace is allowed by the given variable.
	 *
	 * @param {String} name namespace that should be included.
	 * @param {String} variable Value that needs to be tested.
	 * @returns {Boolean} Indication if namespace is enabled.
	 * @public
	 */
	enabled = function enabled(name, variable) {
	  if (!variable) return false;

	  var variables = variable.split(/[\s,]+/)
	    , i = 0;

	  for (; i < variables.length; i++) {
	    variable = variables[i].replace('*', '.*?');

	    if ('-' === variable.charAt(0)) {
	      if ((new RegExp('^'+ variable.substr(1) +'$')).test(name)) {
	        return false;
	      }

	      continue;
	    }

	    if ((new RegExp('^'+ variable +'$')).test(name)) {
	      return true;
	    }
	  }

	  return false;
	};
	return enabled;
}

var adapters;
var hasRequiredAdapters;

function requireAdapters () {
	if (hasRequiredAdapters) return adapters;
	hasRequiredAdapters = 1;
	var enabled = requireEnabled();

	/**
	 * Creates a new Adapter.
	 *
	 * @param {Function} fn Function that returns the value.
	 * @returns {Function} The adapter logic.
	 * @public
	 */
	adapters = function create(fn) {
	  return function adapter(namespace) {
	    try {
	      return enabled(namespace, fn());
	    } catch (e) { /* Any failure means that we found nothing */ }

	    return false;
	  };
	};
	return adapters;
}

var localstorage;
var hasRequiredLocalstorage;

function requireLocalstorage () {
	if (hasRequiredLocalstorage) return localstorage;
	hasRequiredLocalstorage = 1;
	var adapter = requireAdapters();

	/**
	 * Extracts the values from process.env.
	 *
	 * @type {Function}
	 * @public
	 */
	localstorage = adapter(function storage() {
	  return localStorage.getItem('debug') || localStorage.getItem('diagnostics');
	});
	return localstorage;
}

var hash;
var hasRequiredHash;

function requireHash () {
	if (hasRequiredHash) return hash;
	hasRequiredHash = 1;
	var adapter = requireAdapters();

	/**
	 * Extracts the values from process.env.
	 *
	 * @type {Function}
	 * @public
	 */
	hash = adapter(function hash() {
	  return /(debug|diagnostics)=([^&]+)/i.exec(window.location.hash)[2];
	});
	return hash;
}

/**
 * An idiot proof logger to be used as default. We've wrapped it in a try/catch
 * statement to ensure the environments without the `console` API do not crash
 * as well as an additional fix for ancient browsers like IE8 where the
 * `console.log` API doesn't have an `apply`, so we need to use the Function's
 * apply functionality to apply the arguments.
 *
 * @param {Object} meta Options of the logger.
 * @param {Array} messages The actuall message that needs to be logged.
 * @public
 */

var console_1;
var hasRequiredConsole;

function requireConsole () {
	if (hasRequiredConsole) return console_1;
	hasRequiredConsole = 1;
	console_1 = function (meta, messages) {
	  //
	  // So yea. IE8 doesn't have an apply so we need a work around to puke the
	  // arguments in place.
	  //
	  try { Function.prototype.apply.call(console.log, console, messages); }
	  catch (e) {}
	};
	return console_1;
}

var development;
var hasRequiredDevelopment;

function requireDevelopment () {
	if (hasRequiredDevelopment) return development;
	hasRequiredDevelopment = 1;
	var create = requireDiagnostics();

	/**
	 * Create a new diagnostics logger.
	 *
	 * @param {String} namespace The namespace it should enable.
	 * @param {Object} options Additional options.
	 * @returns {Function} The logger.
	 * @public
	 */
	var diagnostics = create(function dev(namespace, options) {
	  options = options || {};
	  options.namespace = namespace;
	  options.prod = false;
	  options.dev = true;

	  if (!dev.enabled(namespace) && !(options.force || dev.force)) {
	    return dev.nope(options);
	  }

	  return dev.yep(options);
	});

	//
	// Configure the logger for the given environment.
	//
	diagnostics.modify(requireNamespace());
	diagnostics.use(requireLocalstorage());
	diagnostics.use(requireHash());
	diagnostics.set(requireConsole());

	//
	// Expose the diagnostics logger.
	//
	development = diagnostics;
	return development;
}

var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browser.exports;
	hasRequiredBrowser = 1;
	//
	// Select the correct build version depending on the environment.
	//
	if (process.env.NODE_ENV === 'production') {
	  browser.exports = requireProduction();
	} else {
	  browser.exports = requireDevelopment();
	}
	return browser.exports;
}

/**
 * tail-file.js: TODO: add file header description.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var tailFile;
var hasRequiredTailFile;

function requireTailFile () {
	if (hasRequiredTailFile) return tailFile;
	hasRequiredTailFile = 1;

	var fs = fs__default;
	var _require = require$$1,
	  StringDecoder = _require.StringDecoder;
	var _require2 = requireReadableBrowser(),
	  Stream = _require2.Stream;

	/**
	 * Simple no-op function.
	 * @returns {undefined}
	 */
	function noop() {}

	/**
	 * TODO: add function description.
	 * @param {Object} options - Options for tail.
	 * @param {function} iter - Iterator function to execute on every line.
	* `tail -f` a file. Options must include file.
	 * @returns {mixed} - TODO: add return description.
	 */
	tailFile = function (options, iter) {
	  var buffer = Buffer.alloc(64 * 1024);
	  var decode = new StringDecoder('utf8');
	  var stream = new Stream();
	  var buff = '';
	  var pos = 0;
	  var row = 0;
	  if (options.start === -1) {
	    delete options.start;
	  }
	  stream.readable = true;
	  stream.destroy = function () {
	    stream.destroyed = true;
	    stream.emit('end');
	    stream.emit('close');
	  };
	  fs.open(options.file, 'a+', '0644', function (err, fd) {
	    if (err) {
	      if (!iter) {
	        stream.emit('error', err);
	      } else {
	        iter(err);
	      }
	      stream.destroy();
	      return;
	    }
	    (function read() {
	      if (stream.destroyed) {
	        fs.close(fd, noop);
	        return;
	      }
	      return fs.read(fd, buffer, 0, buffer.length, pos, function (error, bytes) {
	        if (error) {
	          if (!iter) {
	            stream.emit('error', error);
	          } else {
	            iter(error);
	          }
	          stream.destroy();
	          return;
	        }
	        if (!bytes) {
	          if (buff) {
	            // eslint-disable-next-line eqeqeq
	            if (options.start == null || row > options.start) {
	              if (!iter) {
	                stream.emit('line', buff);
	              } else {
	                iter(null, buff);
	              }
	            }
	            row++;
	            buff = '';
	          }
	          return setTimeout(read, 1000);
	        }
	        var data = decode.write(buffer.slice(0, bytes));
	        if (!iter) {
	          stream.emit('data', data);
	        }
	        data = (buff + data).split(/\n+/);
	        var l = data.length - 1;
	        var i = 0;
	        for (; i < l; i++) {
	          // eslint-disable-next-line eqeqeq
	          if (options.start == null || row > options.start) {
	            if (!iter) {
	              stream.emit('line', data[i]);
	            } else {
	              iter(null, data[i]);
	            }
	          }
	          row++;
	        }
	        buff = data[l];
	        pos += bytes;
	        return read();
	      });
	    })();
	  });
	  if (!iter) {
	    return stream;
	  }
	  return stream.destroy;
	};
	return tailFile;
}

/* eslint-disable complexity,max-statements */

var file;
var hasRequiredFile;

function requireFile () {
	if (hasRequiredFile) return file;
	hasRequiredFile = 1;
	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
	function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }
	function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
	function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
	function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
	function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
	function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
	function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
	var fs = fs__default;
	var path$1 = path;
	var asyncSeries = requireSeries();
	var zlib = require$$3$1;
	var _require = requireTripleBeam(),
	  MESSAGE = _require.MESSAGE;
	var _require2 = requireReadableBrowser(),
	  Stream = _require2.Stream,
	  PassThrough = _require2.PassThrough;
	var TransportStream = requireDist$1();
	var debug = requireBrowser()('winston:file');
	var os = os__default;
	var tailFile = requireTailFile();

	/**
	 * Transport for outputting to a local log file.
	 * @type {File}
	 * @extends {TransportStream}
	 */
	file = /*#__PURE__*/function (_TransportStream) {
	  /**
	   * Constructor function for the File transport object responsible for
	   * persisting log messages and metadata to one or more files.
	   * @param {Object} options - Options for this instance.
	   */
	  function File() {
	    var _this;
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    _classCallCheck(this, File);
	    _this = _callSuper(this, File, [options]);

	    // Expose the name of this Transport on the prototype.
	    _this.name = options.name || 'file';

	    // Helper function which throws an `Error` in the event that any of the
	    // rest of the arguments is present in `options`.
	    function throwIf(target) {
	      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	      args.slice(1).forEach(function (name) {
	        if (options[name]) {
	          throw new Error("Cannot set ".concat(name, " and ").concat(target, " together"));
	        }
	      });
	    }

	    // Setup the base stream that always gets piped to to handle buffering.
	    _this._stream = new PassThrough();
	    _this._stream.setMaxListeners(30);

	    // Bind this context for listener methods.
	    _this._onError = _this._onError.bind(_this);
	    if (options.filename || options.dirname) {
	      throwIf('filename or dirname', 'stream');
	      _this._basename = _this.filename = options.filename ? path$1.basename(options.filename) : 'winston.log';
	      _this.dirname = options.dirname || path$1.dirname(options.filename);
	      _this.options = options.options || {
	        flags: 'a'
	      };
	    } else if (options.stream) {
	      // eslint-disable-next-line no-console
	      console.warn('options.stream will be removed in winston@4. Use winston.transports.Stream');
	      throwIf('stream', 'filename', 'maxsize');
	      _this._dest = _this._stream.pipe(_this._setupStream(options.stream));
	      _this.dirname = path$1.dirname(_this._dest.path);
	      // We need to listen for drain events when write() returns false. This
	      // can make node mad at times.
	    } else {
	      throw new Error('Cannot log to file without filename or stream.');
	    }
	    _this.maxsize = options.maxsize || null;
	    _this.rotationFormat = options.rotationFormat || false;
	    _this.zippedArchive = options.zippedArchive || false;
	    _this.maxFiles = options.maxFiles || null;
	    _this.eol = typeof options.eol === 'string' ? options.eol : os.EOL;
	    _this.tailable = options.tailable || false;
	    _this.lazy = options.lazy || false;

	    // Internal state variables representing the number of files this instance
	    // has created and the current size (in bytes) of the current logfile.
	    _this._size = 0;
	    _this._pendingSize = 0;
	    _this._created = 0;
	    _this._drain = false;
	    _this._opening = false;
	    _this._ending = false;
	    _this._fileExist = false;
	    if (_this.dirname) _this._createLogDirIfNotExist(_this.dirname);
	    if (!_this.lazy) _this.open();
	    return _this;
	  }
	  _inherits(File, _TransportStream);
	  return _createClass(File, [{
	    key: "finishIfEnding",
	    value: function finishIfEnding() {
	      var _this2 = this;
	      if (this._ending) {
	        if (this._opening) {
	          this.once('open', function () {
	            _this2._stream.once('finish', function () {
	              return _this2.emit('finish');
	            });
	            setImmediate(function () {
	              return _this2._stream.end();
	            });
	          });
	        } else {
	          this._stream.once('finish', function () {
	            return _this2.emit('finish');
	          });
	          setImmediate(function () {
	            return _this2._stream.end();
	          });
	        }
	      }
	    }

	    /**
	     * Core logging method exposed to Winston. Metadata is optional.
	     * @param {Object} info - TODO: add param description.
	     * @param {Function} callback - TODO: add param description.
	     * @returns {undefined}
	     */
	  }, {
	    key: "log",
	    value: function log(info) {
	      var _this3 = this;
	      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
	      // Remark: (jcrugzz) What is necessary about this callback(null, true) now
	      // when thinking about 3.x? Should silent be handled in the base
	      // TransportStream _write method?
	      if (this.silent) {
	        callback();
	        return true;
	      }

	      // Output stream buffer is full and has asked us to wait for the drain event
	      if (this._drain) {
	        this._stream.once('drain', function () {
	          _this3._drain = false;
	          _this3.log(info, callback);
	        });
	        return;
	      }
	      if (this._rotate) {
	        this._stream.once('rotate', function () {
	          _this3._rotate = false;
	          _this3.log(info, callback);
	        });
	        return;
	      }
	      if (this.lazy) {
	        if (!this._fileExist) {
	          if (!this._opening) {
	            this.open();
	          }
	          this.once('open', function () {
	            _this3._fileExist = true;
	            _this3.log(info, callback);
	            return;
	          });
	          return;
	        }
	        if (this._needsNewFile(this._pendingSize)) {
	          this._dest.once('close', function () {
	            if (!_this3._opening) {
	              _this3.open();
	            }
	            _this3.once('open', function () {
	              _this3.log(info, callback);
	              return;
	            });
	            return;
	          });
	          return;
	        }
	      }

	      // Grab the raw string and append the expected EOL.
	      var output = "".concat(info[MESSAGE]).concat(this.eol);
	      var bytes = Buffer.byteLength(output);

	      // After we have written to the PassThrough check to see if we need
	      // to rotate to the next file.
	      //
	      // Remark: This gets called too early and does not depict when data
	      // has been actually flushed to disk.
	      function logged() {
	        var _this4 = this;
	        this._size += bytes;
	        this._pendingSize -= bytes;
	        debug('logged %s %s', this._size, output);
	        this.emit('logged', info);

	        // Do not attempt to rotate files while rotating
	        if (this._rotate) {
	          return;
	        }

	        // Do not attempt to rotate files while opening
	        if (this._opening) {
	          return;
	        }

	        // Check to see if we need to end the stream and create a new one.
	        if (!this._needsNewFile()) {
	          return;
	        }
	        if (this.lazy) {
	          this._endStream(function () {
	            _this4.emit('fileclosed');
	          });
	          return;
	        }

	        // End the current stream, ensure it flushes and create a new one.
	        // This could potentially be optimized to not run a stat call but its
	        // the safest way since we are supporting `maxFiles`.
	        this._rotate = true;
	        this._endStream(function () {
	          return _this4._rotateFile();
	        });
	      }

	      // Keep track of the pending bytes being written while files are opening
	      // in order to properly rotate the PassThrough this._stream when the file
	      // eventually does open.
	      this._pendingSize += bytes;
	      if (this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize)) {
	        this.rotatedWhileOpening = true;
	      }
	      var written = this._stream.write(output, logged.bind(this));
	      if (!written) {
	        this._drain = true;
	        this._stream.once('drain', function () {
	          _this3._drain = false;
	          callback();
	        });
	      } else {
	        callback(); // eslint-disable-line callback-return
	      }
	      debug('written', written, this._drain);
	      this.finishIfEnding();
	      return written;
	    }

	    /**
	     * Query the transport. Options object is optional.
	     * @param {Object} options - Loggly-like query options for this instance.
	     * @param {function} callback - Continuation to respond to when complete.
	     * TODO: Refactor me.
	     */
	  }, {
	    key: "query",
	    value: function query(options, callback) {
	      if (typeof options === 'function') {
	        callback = options;
	        options = {};
	      }
	      options = normalizeQuery(options);
	      var file = path$1.join(this.dirname, this.filename);
	      var buff = '';
	      var results = [];
	      var row = 0;
	      var stream = fs.createReadStream(file, {
	        encoding: 'utf8'
	      });
	      stream.on('error', function (err) {
	        if (stream.readable) {
	          stream.destroy();
	        }
	        if (!callback) {
	          return;
	        }
	        return err.code !== 'ENOENT' ? callback(err) : callback(null, results);
	      });
	      stream.on('data', function (data) {
	        data = (buff + data).split(/\n+/);
	        var l = data.length - 1;
	        var i = 0;
	        for (; i < l; i++) {
	          if (!options.start || row >= options.start) {
	            add(data[i]);
	          }
	          row++;
	        }
	        buff = data[l];
	      });
	      stream.on('close', function () {
	        if (buff) {
	          add(buff, true);
	        }
	        if (options.order === 'desc') {
	          results = results.reverse();
	        }

	        // eslint-disable-next-line callback-return
	        if (callback) callback(null, results);
	      });
	      function add(buff, attempt) {
	        try {
	          var log = JSON.parse(buff);
	          if (check(log)) {
	            push(log);
	          }
	        } catch (e) {
	          if (!attempt) {
	            stream.emit('error', e);
	          }
	        }
	      }
	      function push(log) {
	        if (options.rows && results.length >= options.rows && options.order !== 'desc') {
	          if (stream.readable) {
	            stream.destroy();
	          }
	          return;
	        }
	        if (options.fields) {
	          log = options.fields.reduce(function (obj, key) {
	            obj[key] = log[key];
	            return obj;
	          }, {});
	        }
	        if (options.order === 'desc') {
	          if (results.length >= options.rows) {
	            results.shift();
	          }
	        }
	        results.push(log);
	      }
	      function check(log) {
	        if (!log) {
	          return;
	        }
	        if (_typeof(log) !== 'object') {
	          return;
	        }
	        var time = new Date(log.timestamp);
	        if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {
	          return;
	        }
	        return true;
	      }
	      function normalizeQuery(options) {
	        options = options || {};

	        // limit
	        options.rows = options.rows || options.limit || 10;

	        // starting row offset
	        options.start = options.start || 0;

	        // now
	        options.until = options.until || new Date();
	        if (_typeof(options.until) !== 'object') {
	          options.until = new Date(options.until);
	        }

	        // now - 24
	        options.from = options.from || options.until - 24 * 60 * 60 * 1000;
	        if (_typeof(options.from) !== 'object') {
	          options.from = new Date(options.from);
	        }

	        // 'asc' or 'desc'
	        options.order = options.order || 'desc';
	        return options;
	      }
	    }

	    /**
	     * Returns a log stream for this transport. Options object is optional.
	     * @param {Object} options - Stream options for this instance.
	     * @returns {Stream} - TODO: add return description.
	     * TODO: Refactor me.
	     */
	  }, {
	    key: "stream",
	    value: function stream() {
	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var file = path$1.join(this.dirname, this.filename);
	      var stream = new Stream();
	      var tail = {
	        file: file,
	        start: options.start
	      };
	      stream.destroy = tailFile(tail, function (err, line) {
	        if (err) {
	          return stream.emit('error', err);
	        }
	        try {
	          stream.emit('data', line);
	          line = JSON.parse(line);
	          stream.emit('log', line);
	        } catch (e) {
	          stream.emit('error', e);
	        }
	      });
	      return stream;
	    }

	    /**
	     * Checks to see the filesize of.
	     * @returns {undefined}
	     */
	  }, {
	    key: "open",
	    value: function open() {
	      var _this5 = this;
	      // If we do not have a filename then we were passed a stream and
	      // don't need to keep track of size.
	      if (!this.filename) return;
	      if (this._opening) return;
	      this._opening = true;

	      // Stat the target file to get the size and create the stream.
	      this.stat(function (err, size) {
	        if (err) {
	          return _this5.emit('error', err);
	        }
	        debug('stat done: %s { size: %s }', _this5.filename, size);
	        _this5._size = size;
	        _this5._dest = _this5._createStream(_this5._stream);
	        _this5._opening = false;
	        _this5.once('open', function () {
	          if (!_this5._stream.emit('rotate')) {
	            _this5._rotate = false;
	          }
	        });
	      });
	    }

	    /**
	     * Stat the file and assess information in order to create the proper stream.
	     * @param {function} callback - TODO: add param description.
	     * @returns {undefined}
	     */
	  }, {
	    key: "stat",
	    value: function stat(callback) {
	      var _this6 = this;
	      var target = this._getFile();
	      var fullpath = path$1.join(this.dirname, target);
	      fs.stat(fullpath, function (err, stat) {
	        if (err && err.code === 'ENOENT') {
	          debug('ENOENT ok', fullpath);
	          // Update internally tracked filename with the new target name.
	          _this6.filename = target;
	          return callback(null, 0);
	        }
	        if (err) {
	          debug("err ".concat(err.code, " ").concat(fullpath));
	          return callback(err);
	        }
	        if (!stat || _this6._needsNewFile(stat.size)) {
	          // If `stats.size` is greater than the `maxsize` for this
	          // instance then try again.
	          return _this6._incFile(function () {
	            return _this6.stat(callback);
	          });
	        }

	        // Once we have figured out what the filename is, set it
	        // and return the size.
	        _this6.filename = target;
	        callback(null, stat.size);
	      });
	    }

	    /**
	     * Closes the stream associated with this instance.
	     * @param {function} cb - TODO: add param description.
	     * @returns {undefined}
	     */
	  }, {
	    key: "close",
	    value: function close(cb) {
	      var _this7 = this;
	      if (!this._stream) {
	        return;
	      }
	      this._stream.end(function () {
	        if (cb) {
	          cb(); // eslint-disable-line callback-return
	        }
	        _this7.emit('flush');
	        _this7.emit('closed');
	      });
	    }

	    /**
	     * TODO: add method description.
	     * @param {number} size - TODO: add param description.
	     * @returns {undefined}
	     */
	  }, {
	    key: "_needsNewFile",
	    value: function _needsNewFile(size) {
	      size = size || this._size;
	      return this.maxsize && size >= this.maxsize;
	    }

	    /**
	     * TODO: add method description.
	     * @param {Error} err - TODO: add param description.
	     * @returns {undefined}
	     */
	  }, {
	    key: "_onError",
	    value: function _onError(err) {
	      this.emit('error', err);
	    }

	    /**
	     * TODO: add method description.
	     * @param {Stream} stream - TODO: add param description.
	     * @returns {mixed} - TODO: add return description.
	     */
	  }, {
	    key: "_setupStream",
	    value: function _setupStream(stream) {
	      stream.on('error', this._onError);
	      return stream;
	    }

	    /**
	     * TODO: add method description.
	     * @param {Stream} stream - TODO: add param description.
	     * @returns {mixed} - TODO: add return description.
	     */
	  }, {
	    key: "_cleanupStream",
	    value: function _cleanupStream(stream) {
	      stream.removeListener('error', this._onError);
	      stream.destroy();
	      return stream;
	    }

	    /**
	     * TODO: add method description.
	     */
	  }, {
	    key: "_rotateFile",
	    value: function _rotateFile() {
	      var _this8 = this;
	      this._incFile(function () {
	        return _this8.open();
	      });
	    }

	    /**
	     * Unpipe from the stream that has been marked as full and end it so it
	     * flushes to disk.
	     *
	     * @param {function} callback - Callback for when the current file has closed.
	     * @private
	     */
	  }, {
	    key: "_endStream",
	    value: function _endStream() {
	      var _this9 = this;
	      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
	      if (this._dest) {
	        this._stream.unpipe(this._dest);
	        this._dest.end(function () {
	          _this9._cleanupStream(_this9._dest);
	          callback();
	        });
	      } else {
	        callback(); // eslint-disable-line callback-return
	      }
	    }

	    /**
	     * Returns the WritableStream for the active file on this instance. If we
	     * should gzip the file then a zlib stream is returned.
	     *
	     * @param {ReadableStream} source –PassThrough to pipe to the file when open.
	     * @returns {WritableStream} Stream that writes to disk for the active file.
	     */
	  }, {
	    key: "_createStream",
	    value: function _createStream(source) {
	      var _this10 = this;
	      var fullpath = path$1.join(this.dirname, this.filename);
	      debug('create stream start', fullpath, this.options);
	      var dest = fs.createWriteStream(fullpath, this.options)
	      // TODO: What should we do with errors here?
	      .on('error', function (err) {
	        return debug(err);
	      }).on('close', function () {
	        return debug('close', dest.path, dest.bytesWritten);
	      }).on('open', function () {
	        debug('file open ok', fullpath);
	        _this10.emit('open', fullpath);
	        source.pipe(dest);

	        // If rotation occured during the open operation then we immediately
	        // start writing to a new PassThrough, begin opening the next file
	        // and cleanup the previous source and dest once the source has drained.
	        if (_this10.rotatedWhileOpening) {
	          _this10._stream = new PassThrough();
	          _this10._stream.setMaxListeners(30);
	          _this10._rotateFile();
	          _this10.rotatedWhileOpening = false;
	          _this10._cleanupStream(dest);
	          source.end();
	        }
	      });
	      debug('create stream ok', fullpath);
	      return dest;
	    }

	    /**
	     * TODO: add method description.
	     * @param {function} callback - TODO: add param description.
	     * @returns {undefined}
	     */
	  }, {
	    key: "_incFile",
	    value: function _incFile(callback) {
	      debug('_incFile', this.filename);
	      var ext = path$1.extname(this._basename);
	      var basename = path$1.basename(this._basename, ext);
	      var tasks = [];
	      if (this.zippedArchive) {
	        tasks.push(function (cb) {
	          var num = this._created > 0 && !this.tailable ? this._created : '';
	          this._compressFile(path$1.join(this.dirname, "".concat(basename).concat(num).concat(ext)), path$1.join(this.dirname, "".concat(basename).concat(num).concat(ext, ".gz")), cb);
	        }.bind(this));
	      }
	      tasks.push(function (cb) {
	        if (!this.tailable) {
	          this._created += 1;
	          this._checkMaxFilesIncrementing(ext, basename, cb);
	        } else {
	          this._checkMaxFilesTailable(ext, basename, cb);
	        }
	      }.bind(this));
	      asyncSeries(tasks, callback);
	    }

	    /**
	     * Gets the next filename to use for this instance in the case that log
	     * filesizes are being capped.
	     * @returns {string} - TODO: add return description.
	     * @private
	     */
	  }, {
	    key: "_getFile",
	    value: function _getFile() {
	      var ext = path$1.extname(this._basename);
	      var basename = path$1.basename(this._basename, ext);
	      var isRotation = this.rotationFormat ? this.rotationFormat() : this._created;

	      // Caveat emptor (indexzero): rotationFormat() was broken by design When
	      // combined with max files because the set of files to unlink is never
	      // stored.
	      return !this.tailable && this._created ? "".concat(basename).concat(isRotation).concat(ext) : "".concat(basename).concat(ext);
	    }

	    /**
	     * Increment the number of files created or checked by this instance.
	     * @param {mixed} ext - TODO: add param description.
	     * @param {mixed} basename - TODO: add param description.
	     * @param {mixed} callback - TODO: add param description.
	     * @returns {undefined}
	     * @private
	     */
	  }, {
	    key: "_checkMaxFilesIncrementing",
	    value: function _checkMaxFilesIncrementing(ext, basename, callback) {
	      // Check for maxFiles option and delete file.
	      if (!this.maxFiles || this._created < this.maxFiles) {
	        return setImmediate(callback);
	      }
	      var oldest = this._created - this.maxFiles;
	      var isOldest = oldest !== 0 ? oldest : '';
	      var isZipped = this.zippedArchive ? '.gz' : '';
	      var filePath = "".concat(basename).concat(isOldest).concat(ext).concat(isZipped);
	      var target = path$1.join(this.dirname, filePath);
	      fs.unlink(target, callback);
	    }

	    /**
	     * Roll files forward based on integer, up to maxFiles. e.g. if base if
	     * file.log and it becomes oversized, roll to file1.log, and allow file.log
	     * to be re-used. If file is oversized again, roll file1.log to file2.log,
	     * roll file.log to file1.log, and so on.
	     * @param {mixed} ext - TODO: add param description.
	     * @param {mixed} basename - TODO: add param description.
	     * @param {mixed} callback - TODO: add param description.
	     * @returns {undefined}
	     * @private
	     */
	  }, {
	    key: "_checkMaxFilesTailable",
	    value: function _checkMaxFilesTailable(ext, basename, callback) {
	      var _this12 = this;
	      var tasks = [];
	      if (!this.maxFiles) {
	        return;
	      }

	      // const isZipped = this.zippedArchive ? '.gz' : '';
	      var isZipped = this.zippedArchive ? '.gz' : '';
	      for (var x = this.maxFiles - 1; x > 1; x--) {
	        tasks.push(function (i, cb) {
	          var _this11 = this;
	          var fileName = "".concat(basename).concat(i - 1).concat(ext).concat(isZipped);
	          var tmppath = path$1.join(this.dirname, fileName);
	          fs.exists(tmppath, function (exists) {
	            if (!exists) {
	              return cb(null);
	            }
	            fileName = "".concat(basename).concat(i).concat(ext).concat(isZipped);
	            fs.rename(tmppath, path$1.join(_this11.dirname, fileName), cb);
	          });
	        }.bind(this, x));
	      }
	      asyncSeries(tasks, function () {
	        fs.rename(path$1.join(_this12.dirname, "".concat(basename).concat(ext).concat(isZipped)), path$1.join(_this12.dirname, "".concat(basename, "1").concat(ext).concat(isZipped)), callback);
	      });
	    }

	    /**
	     * Compresses src to dest with gzip and unlinks src
	     * @param {string} src - path to source file.
	     * @param {string} dest - path to zipped destination file.
	     * @param {Function} callback - callback called after file has been compressed.
	     * @returns {undefined}
	     * @private
	     */
	  }, {
	    key: "_compressFile",
	    value: function _compressFile(src, dest, callback) {
	      fs.access(src, fs.F_OK, function (err) {
	        if (err) {
	          return callback();
	        }
	        var gzip = zlib.createGzip();
	        var inp = fs.createReadStream(src);
	        var out = fs.createWriteStream(dest);
	        out.on('finish', function () {
	          fs.unlink(src, callback);
	        });
	        inp.pipe(gzip).pipe(out);
	      });
	    }
	  }, {
	    key: "_createLogDirIfNotExist",
	    value: function _createLogDirIfNotExist(dirPath) {
	      /* eslint-disable no-sync */
	      if (!fs.existsSync(dirPath)) {
	        fs.mkdirSync(dirPath, {
	          recursive: true
	        });
	      }
	      /* eslint-enable no-sync */
	    }
	  }]);
	}(TransportStream);
	return file;
}

/**
 * http.js: Transport for outputting to a json-rpcserver.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var http_1;
var hasRequiredHttp;

function requireHttp () {
	if (hasRequiredHttp) return http_1;
	hasRequiredHttp = 1;

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
	function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
	function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
	function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
	function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
	function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
	function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
	function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
	var http = require$$0$4;
	var https = require$$1$1;
	var _require = requireReadableBrowser(),
	  Stream = _require.Stream;
	var TransportStream = requireDist$1();
	var _require2 = requireSafeStableStringify(),
	  configure = _require2.configure;

	/**
	 * Transport for outputting to a json-rpc server.
	 * @type {Stream}
	 * @extends {TransportStream}
	 */
	http_1 = /*#__PURE__*/function (_TransportStream) {
	  /**
	   * Constructor function for the Http transport object responsible for
	   * persisting log messages and metadata to a terminal or TTY.
	   * @param {!Object} [options={}] - Options for this instance.
	   */
	  // eslint-disable-next-line max-statements
	  function Http() {
	    var _this;
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    _classCallCheck(this, Http);
	    _this = _callSuper(this, Http, [options]);
	    _this.options = options;
	    _this.name = options.name || 'http';
	    _this.ssl = !!options.ssl;
	    _this.host = options.host || 'localhost';
	    _this.port = options.port;
	    _this.auth = options.auth;
	    _this.path = options.path || '';
	    _this.maximumDepth = options.maximumDepth;
	    _this.agent = options.agent;
	    _this.headers = options.headers || {};
	    _this.headers['content-type'] = 'application/json';
	    _this.batch = options.batch || false;
	    _this.batchInterval = options.batchInterval || 5000;
	    _this.batchCount = options.batchCount || 10;
	    _this.batchOptions = [];
	    _this.batchTimeoutID = -1;
	    _this.batchCallback = {};
	    if (!_this.port) {
	      _this.port = _this.ssl ? 443 : 80;
	    }
	    return _this;
	  }

	  /**
	   * Core logging method exposed to Winston.
	   * @param {Object} info - TODO: add param description.
	   * @param {function} callback - TODO: add param description.
	   * @returns {undefined}
	   */
	  _inherits(Http, _TransportStream);
	  return _createClass(Http, [{
	    key: "log",
	    value: function log(info, callback) {
	      var _this2 = this;
	      this._request(info, null, null, function (err, res) {
	        if (res && res.statusCode !== 200) {
	          err = new Error("Invalid HTTP Status Code: ".concat(res.statusCode));
	        }
	        if (err) {
	          _this2.emit('warn', err);
	        } else {
	          _this2.emit('logged', info);
	        }
	      });

	      // Remark: (jcrugzz) Fire and forget here so requests dont cause buffering
	      // and block more requests from happening?
	      if (callback) {
	        setImmediate(callback);
	      }
	    }

	    /**
	     * Query the transport. Options object is optional.
	     * @param {Object} options -  Loggly-like query options for this instance.
	     * @param {function} callback - Continuation to respond to when complete.
	     * @returns {undefined}
	     */
	  }, {
	    key: "query",
	    value: function query(options, callback) {
	      if (typeof options === 'function') {
	        callback = options;
	        options = {};
	      }
	      options = {
	        method: 'query',
	        params: this.normalizeQuery(options)
	      };
	      var auth = options.params.auth || null;
	      delete options.params.auth;
	      var path = options.params.path || null;
	      delete options.params.path;
	      this._request(options, auth, path, function (err, res, body) {
	        if (res && res.statusCode !== 200) {
	          err = new Error("Invalid HTTP Status Code: ".concat(res.statusCode));
	        }
	        if (err) {
	          return callback(err);
	        }
	        if (typeof body === 'string') {
	          try {
	            body = JSON.parse(body);
	          } catch (e) {
	            return callback(e);
	          }
	        }
	        callback(null, body);
	      });
	    }

	    /**
	     * Returns a log stream for this transport. Options object is optional.
	     * @param {Object} options - Stream options for this instance.
	     * @returns {Stream} - TODO: add return description
	     */
	  }, {
	    key: "stream",
	    value: function stream() {
	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var stream = new Stream();
	      options = {
	        method: 'stream',
	        params: options
	      };
	      var path = options.params.path || null;
	      delete options.params.path;
	      var auth = options.params.auth || null;
	      delete options.params.auth;
	      var buff = '';
	      var req = this._request(options, auth, path);
	      stream.destroy = function () {
	        return req.destroy();
	      };
	      req.on('data', function (data) {
	        data = (buff + data).split(/\n+/);
	        var l = data.length - 1;
	        var i = 0;
	        for (; i < l; i++) {
	          try {
	            stream.emit('log', JSON.parse(data[i]));
	          } catch (e) {
	            stream.emit('error', e);
	          }
	        }
	        buff = data[l];
	      });
	      req.on('error', function (err) {
	        return stream.emit('error', err);
	      });
	      return stream;
	    }

	    /**
	     * Make a request to a winstond server or any http server which can
	     * handle json-rpc.
	     * @param {function} options - Options to sent the request.
	     * @param {Object?} auth - authentication options
	     * @param {string} path - request path
	     * @param {function} callback - Continuation to respond to when complete.
	     */
	  }, {
	    key: "_request",
	    value: function _request(options, auth, path, callback) {
	      options = options || {};
	      auth = auth || this.auth;
	      path = path || this.path || '';
	      if (this.batch) {
	        this._doBatch(options, callback, auth, path);
	      } else {
	        this._doRequest(options, callback, auth, path);
	      }
	    }

	    /**
	     * Send or memorize the options according to batch configuration
	     * @param {function} options - Options to sent the request.
	     * @param {function} callback - Continuation to respond to when complete.
	     * @param {Object?} auth - authentication options
	     * @param {string} path - request path
	     */
	  }, {
	    key: "_doBatch",
	    value: function _doBatch(options, callback, auth, path) {
	      this.batchOptions.push(options);
	      if (this.batchOptions.length === 1) {
	        // First message stored, it's time to start the timeout!
	        var me = this;
	        this.batchCallback = callback;
	        this.batchTimeoutID = setTimeout(function () {
	          // timeout is reached, send all messages to endpoint
	          me.batchTimeoutID = -1;
	          me._doBatchRequest(me.batchCallback, auth, path);
	        }, this.batchInterval);
	      }
	      if (this.batchOptions.length === this.batchCount) {
	        // max batch count is reached, send all messages to endpoint
	        this._doBatchRequest(this.batchCallback, auth, path);
	      }
	    }

	    /**
	     * Initiate a request with the memorized batch options, stop the batch timeout
	     * @param {function} callback - Continuation to respond to when complete.
	     * @param {Object?} auth - authentication options
	     * @param {string} path - request path
	     */
	  }, {
	    key: "_doBatchRequest",
	    value: function _doBatchRequest(callback, auth, path) {
	      if (this.batchTimeoutID > 0) {
	        clearTimeout(this.batchTimeoutID);
	        this.batchTimeoutID = -1;
	      }
	      var batchOptionsCopy = this.batchOptions.slice();
	      this.batchOptions = [];
	      this._doRequest(batchOptionsCopy, callback, auth, path);
	    }

	    /**
	     * Make a request to a winstond server or any http server which can
	     * handle json-rpc.
	     * @param {function} options - Options to sent the request.
	     * @param {function} callback - Continuation to respond to when complete.
	     * @param {Object?} auth - authentication options
	     * @param {string} path - request path
	     */
	  }, {
	    key: "_doRequest",
	    value: function _doRequest(options, callback, auth, path) {
	      // Prepare options for outgoing HTTP request
	      var headers = Object.assign({}, this.headers);
	      if (auth && auth.bearer) {
	        headers.Authorization = "Bearer ".concat(auth.bearer);
	      }
	      var req = (this.ssl ? https : http).request(_objectSpread(_objectSpread({}, this.options), {}, {
	        method: 'POST',
	        host: this.host,
	        port: this.port,
	        path: "/".concat(path.replace(/^\//, '')),
	        headers: headers,
	        auth: auth && auth.username && auth.password ? "".concat(auth.username, ":").concat(auth.password) : '',
	        agent: this.agent
	      }));
	      req.on('error', callback);
	      req.on('response', function (res) {
	        return res.on('end', function () {
	          return callback(null, res);
	        }).resume();
	      });
	      var jsonStringify = configure(_objectSpread({}, this.maximumDepth && {
	        maximumDepth: this.maximumDepth
	      }));
	      req.end(Buffer.from(jsonStringify(options, this.options.replacer), 'utf8'));
	    }
	  }]);
	}(TransportStream);
	return http_1;
}

var isStream_1;
var hasRequiredIsStream;

function requireIsStream () {
	if (hasRequiredIsStream) return isStream_1;
	hasRequiredIsStream = 1;

	const isStream = stream =>
		stream !== null &&
		typeof stream === 'object' &&
		typeof stream.pipe === 'function';

	isStream.writable = stream =>
		isStream(stream) &&
		stream.writable !== false &&
		typeof stream._write === 'function' &&
		typeof stream._writableState === 'object';

	isStream.readable = stream =>
		isStream(stream) &&
		stream.readable !== false &&
		typeof stream._read === 'function' &&
		typeof stream._readableState === 'object';

	isStream.duplex = stream =>
		isStream.writable(stream) &&
		isStream.readable(stream);

	isStream.transform = stream =>
		isStream.duplex(stream) &&
		typeof stream._transform === 'function';

	isStream_1 = isStream;
	return isStream_1;
}

/**
 * stream.js: Transport for outputting to any arbitrary stream.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var stream;
var hasRequiredStream;

function requireStream () {
	if (hasRequiredStream) return stream;
	hasRequiredStream = 1;

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
	function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }
	function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
	function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
	function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
	function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
	function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
	function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
	var isStream = requireIsStream();
	var _require = requireTripleBeam(),
	  MESSAGE = _require.MESSAGE;
	var os = os__default;
	var TransportStream = requireDist$1();

	/**
	 * Transport for outputting to any arbitrary stream.
	 * @type {Stream}
	 * @extends {TransportStream}
	 */
	stream = /*#__PURE__*/function (_TransportStream) {
	  /**
	   * Constructor function for the Console transport object responsible for
	   * persisting log messages and metadata to a terminal or TTY.
	   * @param {!Object} [options={}] - Options for this instance.
	   */
	  function Stream() {
	    var _this;
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    _classCallCheck(this, Stream);
	    _this = _callSuper(this, Stream, [options]);
	    if (!options.stream || !isStream(options.stream)) {
	      throw new Error('options.stream is required.');
	    }

	    // We need to listen for drain events when write() returns false. This can
	    // make node mad at times.
	    _this._stream = options.stream;
	    _this._stream.setMaxListeners(Infinity);
	    _this.isObjectMode = options.stream._writableState.objectMode;
	    _this.eol = typeof options.eol === 'string' ? options.eol : os.EOL;
	    return _this;
	  }

	  /**
	   * Core logging method exposed to Winston.
	   * @param {Object} info - TODO: add param description.
	   * @param {Function} callback - TODO: add param description.
	   * @returns {undefined}
	   */
	  _inherits(Stream, _TransportStream);
	  return _createClass(Stream, [{
	    key: "log",
	    value: function log(info, callback) {
	      var _this2 = this;
	      setImmediate(function () {
	        return _this2.emit('logged', info);
	      });
	      if (this.isObjectMode) {
	        this._stream.write(info);
	        if (callback) {
	          callback(); // eslint-disable-line callback-return
	        }
	        return;
	      }
	      this._stream.write("".concat(info[MESSAGE]).concat(this.eol));
	      if (callback) {
	        callback(); // eslint-disable-line callback-return
	      }
	      return;
	    }
	  }]);
	}(TransportStream);
	return stream;
}

/**
 * transports.js: Set of all transports Winston knows about.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var hasRequiredTransports;

function requireTransports () {
	if (hasRequiredTransports) return transports;
	hasRequiredTransports = 1;
	(function (exports) {

		/**
		 * TODO: add property description.
		 * @type {Console}
		 */
		Object.defineProperty(exports, 'Console', {
		  configurable: true,
		  enumerable: true,
		  get: function get() {
		    return requireConsole$1();
		  }
		});

		/**
		 * TODO: add property description.
		 * @type {File}
		 */
		Object.defineProperty(exports, 'File', {
		  configurable: true,
		  enumerable: true,
		  get: function get() {
		    return requireFile();
		  }
		});

		/**
		 * TODO: add property description.
		 * @type {Http}
		 */
		Object.defineProperty(exports, 'Http', {
		  configurable: true,
		  enumerable: true,
		  get: function get() {
		    return requireHttp();
		  }
		});

		/**
		 * TODO: add property description.
		 * @type {Stream}
		 */
		Object.defineProperty(exports, 'Stream', {
		  configurable: true,
		  enumerable: true,
		  get: function get() {
		    return requireStream();
		  }
		}); 
	} (transports));
	return transports;
}

var config = {};

/**
 * index.js: Default settings for all levels that winston knows about.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var hasRequiredConfig;

function requireConfig () {
	if (hasRequiredConfig) return config;
	hasRequiredConfig = 1;

	var logform = requireBrowser$2();
	var _require = requireTripleBeam(),
	  configs = _require.configs;

	/**
	 * Export config set for the CLI.
	 * @type {Object}
	 */
	config.cli = logform.levels(configs.cli);

	/**
	 * Export config set for npm.
	 * @type {Object}
	 */
	config.npm = logform.levels(configs.npm);

	/**
	 * Export config set for the syslog.
	 * @type {Object}
	 */
	config.syslog = logform.levels(configs.syslog);

	/**
	 * Hoist addColors from logform where it was refactored into in winston@3.
	 * @type {Object}
	 */
	config.addColors = logform.levels;
	return config;
}

var forEach = {exports: {}};

var eachOf = {exports: {}};

var hasRequiredEachOf;

function requireEachOf () {
	if (hasRequiredEachOf) return eachOf.exports;
	hasRequiredEachOf = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		    value: true
		});

		var _isArrayLike = requireIsArrayLike();

		var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

		var _breakLoop = requireBreakLoop();

		var _breakLoop2 = _interopRequireDefault(_breakLoop);

		var _eachOfLimit = requireEachOfLimit();

		var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);

		var _once = requireOnce();

		var _once2 = _interopRequireDefault(_once);

		var _onlyOnce = requireOnlyOnce();

		var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

		var _wrapAsync = requireWrapAsync();

		var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

		var _awaitify = requireAwaitify();

		var _awaitify2 = _interopRequireDefault(_awaitify);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		// eachOf implementation optimized for array-likes
		function eachOfArrayLike(coll, iteratee, callback) {
		    callback = (0, _once2.default)(callback);
		    var index = 0,
		        completed = 0,
		        { length } = coll,
		        canceled = false;
		    if (length === 0) {
		        callback(null);
		    }

		    function iteratorCallback(err, value) {
		        if (err === false) {
		            canceled = true;
		        }
		        if (canceled === true) return;
		        if (err) {
		            callback(err);
		        } else if (++completed === length || value === _breakLoop2.default) {
		            callback(null);
		        }
		    }

		    for (; index < length; index++) {
		        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
		    }
		}

		// a generic version of eachOf which can handle array, object, and iterator cases.
		function eachOfGeneric(coll, iteratee, callback) {
		    return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
		}

		/**
		 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
		 * to the iteratee.
		 *
		 * @name eachOf
		 * @static
		 * @memberOf module:Collections
		 * @method
		 * @alias forEachOf
		 * @category Collection
		 * @see [async.each]{@link module:Collections.each}
		 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
		 * @param {AsyncFunction} iteratee - A function to apply to each
		 * item in `coll`.
		 * The `key` is the item's key, or index in the case of an array.
		 * Invoked with (item, key, callback).
		 * @param {Function} [callback] - A callback which is called when all
		 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
		 * @returns {Promise} a promise, if a callback is omitted
		 * @example
		 *
		 * // dev.json is a file containing a valid json object config for dev environment
		 * // dev.json is a file containing a valid json object config for test environment
		 * // prod.json is a file containing a valid json object config for prod environment
		 * // invalid.json is a file with a malformed json object
		 *
		 * let configs = {}; //global variable
		 * let validConfigFileMap = {dev: 'dev.json', test: 'test.json', prod: 'prod.json'};
		 * let invalidConfigFileMap = {dev: 'dev.json', test: 'test.json', invalid: 'invalid.json'};
		 *
		 * // asynchronous function that reads a json file and parses the contents as json object
		 * function parseFile(file, key, callback) {
		 *     fs.readFile(file, "utf8", function(err, data) {
		 *         if (err) return calback(err);
		 *         try {
		 *             configs[key] = JSON.parse(data);
		 *         } catch (e) {
		 *             return callback(e);
		 *         }
		 *         callback();
		 *     });
		 * }
		 *
		 * // Using callbacks
		 * async.forEachOf(validConfigFileMap, parseFile, function (err) {
		 *     if (err) {
		 *         console.error(err);
		 *     } else {
		 *         console.log(configs);
		 *         // configs is now a map of JSON data, e.g.
		 *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
		 *     }
		 * });
		 *
		 * //Error handing
		 * async.forEachOf(invalidConfigFileMap, parseFile, function (err) {
		 *     if (err) {
		 *         console.error(err);
		 *         // JSON parse error exception
		 *     } else {
		 *         console.log(configs);
		 *     }
		 * });
		 *
		 * // Using Promises
		 * async.forEachOf(validConfigFileMap, parseFile)
		 * .then( () => {
		 *     console.log(configs);
		 *     // configs is now a map of JSON data, e.g.
		 *     // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
		 * }).catch( err => {
		 *     console.error(err);
		 * });
		 *
		 * //Error handing
		 * async.forEachOf(invalidConfigFileMap, parseFile)
		 * .then( () => {
		 *     console.log(configs);
		 * }).catch( err => {
		 *     console.error(err);
		 *     // JSON parse error exception
		 * });
		 *
		 * // Using async/await
		 * async () => {
		 *     try {
		 *         let result = await async.forEachOf(validConfigFileMap, parseFile);
		 *         console.log(configs);
		 *         // configs is now a map of JSON data, e.g.
		 *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
		 *     }
		 *     catch (err) {
		 *         console.log(err);
		 *     }
		 * }
		 *
		 * //Error handing
		 * async () => {
		 *     try {
		 *         let result = await async.forEachOf(invalidConfigFileMap, parseFile);
		 *         console.log(configs);
		 *     }
		 *     catch (err) {
		 *         console.log(err);
		 *         // JSON parse error exception
		 *     }
		 * }
		 *
		 */
		function eachOf(coll, iteratee, callback) {
		    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
		    return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
		}

		exports.default = (0, _awaitify2.default)(eachOf, 3);
		module.exports = exports.default; 
	} (eachOf, eachOf.exports));
	return eachOf.exports;
}

var withoutIndex = {exports: {}};

var hasRequiredWithoutIndex;

function requireWithoutIndex () {
	if (hasRequiredWithoutIndex) return withoutIndex.exports;
	hasRequiredWithoutIndex = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		exports.default = _withoutIndex;
		function _withoutIndex(iteratee) {
		    return (value, index, callback) => iteratee(value, callback);
		}
		module.exports = exports.default; 
	} (withoutIndex, withoutIndex.exports));
	return withoutIndex.exports;
}

var hasRequiredForEach;

function requireForEach () {
	if (hasRequiredForEach) return forEach.exports;
	hasRequiredForEach = 1;
	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		    value: true
		});

		var _eachOf = requireEachOf();

		var _eachOf2 = _interopRequireDefault(_eachOf);

		var _withoutIndex = requireWithoutIndex();

		var _withoutIndex2 = _interopRequireDefault(_withoutIndex);

		var _wrapAsync = requireWrapAsync();

		var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

		var _awaitify = requireAwaitify();

		var _awaitify2 = _interopRequireDefault(_awaitify);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		/**
		 * Applies the function `iteratee` to each item in `coll`, in parallel.
		 * The `iteratee` is called with an item from the list, and a callback for when
		 * it has finished. If the `iteratee` passes an error to its `callback`, the
		 * main `callback` (for the `each` function) is immediately called with the
		 * error.
		 *
		 * Note, that since this function applies `iteratee` to each item in parallel,
		 * there is no guarantee that the iteratee functions will complete in order.
		 *
		 * @name each
		 * @static
		 * @memberOf module:Collections
		 * @method
		 * @alias forEach
		 * @category Collection
		 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
		 * @param {AsyncFunction} iteratee - An async function to apply to
		 * each item in `coll`. Invoked with (item, callback).
		 * The array index is not passed to the iteratee.
		 * If you need the index, use `eachOf`.
		 * @param {Function} [callback] - A callback which is called when all
		 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
		 * @returns {Promise} a promise, if a callback is omitted
		 * @example
		 *
		 * // dir1 is a directory that contains file1.txt, file2.txt
		 * // dir2 is a directory that contains file3.txt, file4.txt
		 * // dir3 is a directory that contains file5.txt
		 * // dir4 does not exist
		 *
		 * const fileList = [ 'dir1/file2.txt', 'dir2/file3.txt', 'dir/file5.txt'];
		 * const withMissingFileList = ['dir1/file1.txt', 'dir4/file2.txt'];
		 *
		 * // asynchronous function that deletes a file
		 * const deleteFile = function(file, callback) {
		 *     fs.unlink(file, callback);
		 * };
		 *
		 * // Using callbacks
		 * async.each(fileList, deleteFile, function(err) {
		 *     if( err ) {
		 *         console.log(err);
		 *     } else {
		 *         console.log('All files have been deleted successfully');
		 *     }
		 * });
		 *
		 * // Error Handling
		 * async.each(withMissingFileList, deleteFile, function(err){
		 *     console.log(err);
		 *     // [ Error: ENOENT: no such file or directory ]
		 *     // since dir4/file2.txt does not exist
		 *     // dir1/file1.txt could have been deleted
		 * });
		 *
		 * // Using Promises
		 * async.each(fileList, deleteFile)
		 * .then( () => {
		 *     console.log('All files have been deleted successfully');
		 * }).catch( err => {
		 *     console.log(err);
		 * });
		 *
		 * // Error Handling
		 * async.each(fileList, deleteFile)
		 * .then( () => {
		 *     console.log('All files have been deleted successfully');
		 * }).catch( err => {
		 *     console.log(err);
		 *     // [ Error: ENOENT: no such file or directory ]
		 *     // since dir4/file2.txt does not exist
		 *     // dir1/file1.txt could have been deleted
		 * });
		 *
		 * // Using async/await
		 * async () => {
		 *     try {
		 *         await async.each(files, deleteFile);
		 *     }
		 *     catch (err) {
		 *         console.log(err);
		 *     }
		 * }
		 *
		 * // Error Handling
		 * async () => {
		 *     try {
		 *         await async.each(withMissingFileList, deleteFile);
		 *     }
		 *     catch (err) {
		 *         console.log(err);
		 *         // [ Error: ENOENT: no such file or directory ]
		 *         // since dir4/file2.txt does not exist
		 *         // dir1/file1.txt could have been deleted
		 *     }
		 * }
		 *
		 */
		function eachLimit(coll, iteratee, callback) {
		    return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
		}

		exports.default = (0, _awaitify2.default)(eachLimit, 3);
		module.exports = exports.default; 
	} (forEach, forEach.exports));
	return forEach.exports;
}

var fn_name;
var hasRequiredFn_name;

function requireFn_name () {
	if (hasRequiredFn_name) return fn_name;
	hasRequiredFn_name = 1;

	var toString = Object.prototype.toString;

	/**
	 * Extract names from functions.
	 *
	 * @param {Function} fn The function who's name we need to extract.
	 * @returns {String} The name of the function.
	 * @public
	 */
	fn_name = function name(fn) {
	  if ('string' === typeof fn.displayName && fn.constructor.name) {
	    return fn.displayName;
	  } else if ('string' === typeof fn.name && fn.name) {
	    return fn.name;
	  }

	  //
	  // Check to see if the constructor has a name.
	  //
	  if (
	       'object' === typeof fn
	    && fn.constructor
	    && 'string' === typeof fn.constructor.name
	  ) return fn.constructor.name;

	  //
	  // toString the given function and attempt to parse it out of it, or determine
	  // the class.
	  //
	  var named = fn.toString()
	    , type = toString.call(fn).slice(8, -1);

	  if ('Function' === type) {
	    named = named.substring(named.indexOf('(') + 1, named.indexOf(')'));
	  } else {
	    named = type;
	  }

	  return named || 'anonymous';
	};
	return fn_name;
}

var oneTime;
var hasRequiredOneTime;

function requireOneTime () {
	if (hasRequiredOneTime) return oneTime;
	hasRequiredOneTime = 1;

	var name = requireFn_name();

	/**
	 * Wrap callbacks to prevent double execution.
	 *
	 * @param {Function} fn Function that should only be called once.
	 * @returns {Function} A wrapped callback which prevents multiple executions.
	 * @public
	 */
	oneTime = function one(fn) {
	  var called = 0
	    , value;

	  /**
	   * The function that prevents double execution.
	   *
	   * @private
	   */
	  function onetime() {
	    if (called) return value;

	    called = 1;
	    value = fn.apply(this, arguments);
	    fn = null;

	    return value;
	  }

	  //
	  // To make debugging more easy we want to use the name of the supplied
	  // function. So when you look at the functions that are assigned to event
	  // listeners you don't see a load of `onetime` functions but actually the
	  // names of the functions that this module will call.
	  //
	  // NOTE: We cannot override the `name` property, as that is `readOnly`
	  // property, so displayName will have to do.
	  //
	  onetime.displayName = name(fn);
	  return onetime;
	};
	return oneTime;
}

var stackTrace = {};

var hasRequiredStackTrace;

function requireStackTrace () {
	if (hasRequiredStackTrace) return stackTrace;
	hasRequiredStackTrace = 1;
	(function (exports) {
		exports.get = function(belowFn) {
		  var oldLimit = Error.stackTraceLimit;
		  Error.stackTraceLimit = Infinity;

		  var dummyObject = {};

		  var v8Handler = Error.prepareStackTrace;
		  Error.prepareStackTrace = function(dummyObject, v8StackTrace) {
		    return v8StackTrace;
		  };
		  Error.captureStackTrace(dummyObject, belowFn || exports.get);

		  var v8StackTrace = dummyObject.stack;
		  Error.prepareStackTrace = v8Handler;
		  Error.stackTraceLimit = oldLimit;

		  return v8StackTrace;
		};

		exports.parse = function(err) {
		  if (!err.stack) {
		    return [];
		  }

		  var self = this;
		  var lines = err.stack.split('\n').slice(1);

		  return lines
		    .map(function(line) {
		      if (line.match(/^\s*[-]{4,}$/)) {
		        return self._createParsedCallSite({
		          fileName: line,
		          lineNumber: null,
		          functionName: null,
		          typeName: null,
		          methodName: null,
		          columnNumber: null,
		          'native': null,
		        });
		      }

		      var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
		      if (!lineMatch) {
		        return;
		      }

		      var object = null;
		      var method = null;
		      var functionName = null;
		      var typeName = null;
		      var methodName = null;
		      var isNative = (lineMatch[5] === 'native');

		      if (lineMatch[1]) {
		        functionName = lineMatch[1];
		        var methodStart = functionName.lastIndexOf('.');
		        if (functionName[methodStart-1] == '.')
		          methodStart--;
		        if (methodStart > 0) {
		          object = functionName.substr(0, methodStart);
		          method = functionName.substr(methodStart + 1);
		          var objectEnd = object.indexOf('.Module');
		          if (objectEnd > 0) {
		            functionName = functionName.substr(objectEnd + 1);
		            object = object.substr(0, objectEnd);
		          }
		        }
		        typeName = null;
		      }

		      if (method) {
		        typeName = object;
		        methodName = method;
		      }

		      if (method === '<anonymous>') {
		        methodName = null;
		        functionName = null;
		      }

		      var properties = {
		        fileName: lineMatch[2] || null,
		        lineNumber: parseInt(lineMatch[3], 10) || null,
		        functionName: functionName,
		        typeName: typeName,
		        methodName: methodName,
		        columnNumber: parseInt(lineMatch[4], 10) || null,
		        'native': isNative,
		      };

		      return self._createParsedCallSite(properties);
		    })
		    .filter(function(callSite) {
		      return !!callSite;
		    });
		};

		function CallSite(properties) {
		  for (var property in properties) {
		    this[property] = properties[property];
		  }
		}

		var strProperties = [
		  'this',
		  'typeName',
		  'functionName',
		  'methodName',
		  'fileName',
		  'lineNumber',
		  'columnNumber',
		  'function',
		  'evalOrigin'
		];
		var boolProperties = [
		  'topLevel',
		  'eval',
		  'native',
		  'constructor'
		];
		strProperties.forEach(function (property) {
		  CallSite.prototype[property] = null;
		  CallSite.prototype['get' + property[0].toUpperCase() + property.substr(1)] = function () {
		    return this[property];
		  };
		});
		boolProperties.forEach(function (property) {
		  CallSite.prototype[property] = false;
		  CallSite.prototype['is' + property[0].toUpperCase() + property.substr(1)] = function () {
		    return this[property];
		  };
		});

		exports._createParsedCallSite = function(properties) {
		  return new CallSite(properties);
		}; 
	} (stackTrace));
	return stackTrace;
}

/**
 * exception-stream.js: TODO: add file header handler.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var exceptionStream;
var hasRequiredExceptionStream;

function requireExceptionStream () {
	if (hasRequiredExceptionStream) return exceptionStream;
	hasRequiredExceptionStream = 1;

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
	function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }
	function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
	function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
	function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
	function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
	function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
	function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
	var _require = requireReadableBrowser(),
	  Writable = _require.Writable;

	/**
	 * TODO: add class description.
	 * @type {ExceptionStream}
	 * @extends {Writable}
	 */
	exceptionStream = /*#__PURE__*/function (_Writable) {
	  /**
	   * Constructor function for the ExceptionStream responsible for wrapping a
	   * TransportStream; only allowing writes of `info` objects with
	   * `info.exception` set to true.
	   * @param {!TransportStream} transport - Stream to filter to exceptions
	   */
	  function ExceptionStream(transport) {
	    var _this;
	    _classCallCheck(this, ExceptionStream);
	    _this = _callSuper(this, ExceptionStream, [{
	      objectMode: true
	    }]);
	    if (!transport) {
	      throw new Error('ExceptionStream requires a TransportStream instance.');
	    }

	    // Remark (indexzero): we set `handleExceptions` here because it's the
	    // predicate checked in ExceptionHandler.prototype.__getExceptionHandlers
	    _this.handleExceptions = true;
	    _this.transport = transport;
	    return _this;
	  }

	  /**
	   * Writes the info object to our transport instance if (and only if) the
	   * `exception` property is set on the info.
	   * @param {mixed} info - TODO: add param description.
	   * @param {mixed} enc - TODO: add param description.
	   * @param {mixed} callback - TODO: add param description.
	   * @returns {mixed} - TODO: add return description.
	   * @private
	   */
	  _inherits(ExceptionStream, _Writable);
	  return _createClass(ExceptionStream, [{
	    key: "_write",
	    value: function _write(info, enc, callback) {
	      if (info.exception) {
	        return this.transport.log(info, callback);
	      }
	      callback();
	      return true;
	    }
	  }]);
	}(Writable);
	return exceptionStream;
}

/**
 * exception-handler.js: Object for handling uncaughtException events.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var exceptionHandler;
var hasRequiredExceptionHandler;

function requireExceptionHandler () {
	if (hasRequiredExceptionHandler) return exceptionHandler;
	hasRequiredExceptionHandler = 1;

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
	function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }
	var os = os__default;
	var asyncForEach = requireForEach();
	var debug = requireBrowser()('winston:exception');
	var once = requireOneTime();
	var stackTrace = requireStackTrace();
	var ExceptionStream = requireExceptionStream();

	/**
	 * Object for handling uncaughtException events.
	 * @type {ExceptionHandler}
	 */
	exceptionHandler = /*#__PURE__*/function () {
	  /**
	   * TODO: add contructor description
	   * @param {!Logger} logger - TODO: add param description
	   */
	  function ExceptionHandler(logger) {
	    _classCallCheck(this, ExceptionHandler);
	    if (!logger) {
	      throw new Error('Logger is required to handle exceptions');
	    }
	    this.logger = logger;
	    this.handlers = new Map();
	  }

	  /**
	   * Handles `uncaughtException` events for the current process by adding any
	   * handlers passed in.
	   * @returns {undefined}
	   */
	  return _createClass(ExceptionHandler, [{
	    key: "handle",
	    value: function handle() {
	      var _this = this;
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	      args.forEach(function (arg) {
	        if (Array.isArray(arg)) {
	          return arg.forEach(function (handler) {
	            return _this._addHandler(handler);
	          });
	        }
	        _this._addHandler(arg);
	      });
	      if (!this.catcher) {
	        this.catcher = this._uncaughtException.bind(this);
	        process.on('uncaughtException', this.catcher);
	      }
	    }

	    /**
	     * Removes any handlers to `uncaughtException` events for the current
	     * process. This does not modify the state of the `this.handlers` set.
	     * @returns {undefined}
	     */
	  }, {
	    key: "unhandle",
	    value: function unhandle() {
	      var _this2 = this;
	      if (this.catcher) {
	        process.removeListener('uncaughtException', this.catcher);
	        this.catcher = false;
	        Array.from(this.handlers.values()).forEach(function (wrapper) {
	          return _this2.logger.unpipe(wrapper);
	        });
	      }
	    }

	    /**
	     * TODO: add method description
	     * @param {Error} err - Error to get information about.
	     * @returns {mixed} - TODO: add return description.
	     */
	  }, {
	    key: "getAllInfo",
	    value: function getAllInfo(err) {
	      var message = null;
	      if (err) {
	        message = typeof err === 'string' ? err : err.message;
	      }
	      return {
	        error: err,
	        // TODO (indexzero): how do we configure this?
	        level: 'error',
	        message: ["uncaughtException: ".concat(message || '(no error message)'), err && err.stack || '  No stack trace'].join('\n'),
	        stack: err && err.stack,
	        exception: true,
	        date: new Date().toString(),
	        process: this.getProcessInfo(),
	        os: this.getOsInfo(),
	        trace: this.getTrace(err)
	      };
	    }

	    /**
	     * Gets all relevant process information for the currently running process.
	     * @returns {mixed} - TODO: add return description.
	     */
	  }, {
	    key: "getProcessInfo",
	    value: function getProcessInfo() {
	      return {
	        pid: process.pid,
	        uid: process.getuid ? process.getuid() : null,
	        gid: process.getgid ? process.getgid() : null,
	        cwd: process.cwd(),
	        execPath: process.execPath,
	        version: process.version,
	        argv: process.argv,
	        memoryUsage: process.memoryUsage()
	      };
	    }

	    /**
	     * Gets all relevant OS information for the currently running process.
	     * @returns {mixed} - TODO: add return description.
	     */
	  }, {
	    key: "getOsInfo",
	    value: function getOsInfo() {
	      return {
	        loadavg: os.loadavg(),
	        uptime: os.uptime()
	      };
	    }

	    /**
	     * Gets a stack trace for the specified error.
	     * @param {mixed} err - TODO: add param description.
	     * @returns {mixed} - TODO: add return description.
	     */
	  }, {
	    key: "getTrace",
	    value: function getTrace(err) {
	      var trace = err ? stackTrace.parse(err) : stackTrace.get();
	      return trace.map(function (site) {
	        return {
	          column: site.getColumnNumber(),
	          file: site.getFileName(),
	          "function": site.getFunctionName(),
	          line: site.getLineNumber(),
	          method: site.getMethodName(),
	          "native": site.isNative()
	        };
	      });
	    }

	    /**
	     * Helper method to add a transport as an exception handler.
	     * @param {Transport} handler - The transport to add as an exception handler.
	     * @returns {void}
	     */
	  }, {
	    key: "_addHandler",
	    value: function _addHandler(handler) {
	      if (!this.handlers.has(handler)) {
	        handler.handleExceptions = true;
	        var wrapper = new ExceptionStream(handler);
	        this.handlers.set(handler, wrapper);
	        this.logger.pipe(wrapper);
	      }
	    }

	    /**
	     * Logs all relevant information around the `err` and exits the current
	     * process.
	     * @param {Error} err - Error to handle
	     * @returns {mixed} - TODO: add return description.
	     * @private
	     */
	  }, {
	    key: "_uncaughtException",
	    value: function _uncaughtException(err) {
	      var info = this.getAllInfo(err);
	      var handlers = this._getExceptionHandlers();
	      // Calculate if we should exit on this error
	      var doExit = typeof this.logger.exitOnError === 'function' ? this.logger.exitOnError(err) : this.logger.exitOnError;
	      var timeout;
	      if (!handlers.length && doExit) {
	        // eslint-disable-next-line no-console
	        console.warn('winston: exitOnError cannot be true with no exception handlers.');
	        // eslint-disable-next-line no-console
	        console.warn('winston: not exiting process.');
	        doExit = false;
	      }
	      function gracefulExit() {
	        debug('doExit', doExit);
	        debug('process._exiting', process._exiting);
	        if (doExit && !process._exiting) {
	          // Remark: Currently ignoring any exceptions from transports when
	          // catching uncaught exceptions.
	          if (timeout) {
	            clearTimeout(timeout);
	          }
	          // eslint-disable-next-line no-process-exit
	          process.exit(1);
	        }
	      }
	      if (!handlers || handlers.length === 0) {
	        return process.nextTick(gracefulExit);
	      }

	      // Log to all transports attempting to listen for when they are completed.
	      asyncForEach(handlers, function (handler, next) {
	        var done = once(next);
	        var transport = handler.transport || handler;

	        // Debug wrapping so that we can inspect what's going on under the covers.
	        function onDone(event) {
	          return function () {
	            debug(event);
	            done();
	          };
	        }
	        transport._ending = true;
	        transport.once('finish', onDone('finished'));
	        transport.once('error', onDone('error'));
	      }, function () {
	        return doExit && gracefulExit();
	      });
	      this.logger.log(info);

	      // If exitOnError is true, then only allow the logging of exceptions to
	      // take up to `3000ms`.
	      if (doExit) {
	        timeout = setTimeout(gracefulExit, 3000);
	      }
	    }

	    /**
	     * Returns the list of transports and exceptionHandlers for this instance.
	     * @returns {Array} - List of transports and exceptionHandlers for this
	     * instance.
	     * @private
	     */
	  }, {
	    key: "_getExceptionHandlers",
	    value: function _getExceptionHandlers() {
	      // Remark (indexzero): since `logger.transports` returns all of the pipes
	      // from the _readableState of the stream we actually get the join of the
	      // explicit handlers and the implicit transports with
	      // `handleExceptions: true`
	      return this.logger.transports.filter(function (wrap) {
	        var transport = wrap.transport || wrap;
	        return transport.handleExceptions;
	      });
	    }
	  }]);
	}();
	return exceptionHandler;
}

/**
 * rejection-stream.js: TODO: add file header handler.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var rejectionStream;
var hasRequiredRejectionStream;

function requireRejectionStream () {
	if (hasRequiredRejectionStream) return rejectionStream;
	hasRequiredRejectionStream = 1;

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
	function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }
	function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
	function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
	function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
	function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
	function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
	function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
	var _require = requireReadableBrowser(),
	  Writable = _require.Writable;

	/**
	 * TODO: add class description.
	 * @type {RejectionStream}
	 * @extends {Writable}
	 */
	rejectionStream = /*#__PURE__*/function (_Writable) {
	  /**
	   * Constructor function for the RejectionStream responsible for wrapping a
	   * TransportStream; only allowing writes of `info` objects with
	   * `info.rejection` set to true.
	   * @param {!TransportStream} transport - Stream to filter to rejections
	   */
	  function RejectionStream(transport) {
	    var _this;
	    _classCallCheck(this, RejectionStream);
	    _this = _callSuper(this, RejectionStream, [{
	      objectMode: true
	    }]);
	    if (!transport) {
	      throw new Error('RejectionStream requires a TransportStream instance.');
	    }
	    _this.handleRejections = true;
	    _this.transport = transport;
	    return _this;
	  }

	  /**
	   * Writes the info object to our transport instance if (and only if) the
	   * `rejection` property is set on the info.
	   * @param {mixed} info - TODO: add param description.
	   * @param {mixed} enc - TODO: add param description.
	   * @param {mixed} callback - TODO: add param description.
	   * @returns {mixed} - TODO: add return description.
	   * @private
	   */
	  _inherits(RejectionStream, _Writable);
	  return _createClass(RejectionStream, [{
	    key: "_write",
	    value: function _write(info, enc, callback) {
	      if (info.rejection) {
	        return this.transport.log(info, callback);
	      }
	      callback();
	      return true;
	    }
	  }]);
	}(Writable);
	return rejectionStream;
}

/**
 * exception-handler.js: Object for handling uncaughtException events.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var rejectionHandler;
var hasRequiredRejectionHandler;

function requireRejectionHandler () {
	if (hasRequiredRejectionHandler) return rejectionHandler;
	hasRequiredRejectionHandler = 1;

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
	function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }
	var os = os__default;
	var asyncForEach = requireForEach();
	var debug = requireBrowser()('winston:rejection');
	var once = requireOneTime();
	var stackTrace = requireStackTrace();
	var RejectionStream = requireRejectionStream();

	/**
	 * Object for handling unhandledRejection events.
	 * @type {RejectionHandler}
	 */
	rejectionHandler = /*#__PURE__*/function () {
	  /**
	   * TODO: add contructor description
	   * @param {!Logger} logger - TODO: add param description
	   */
	  function RejectionHandler(logger) {
	    _classCallCheck(this, RejectionHandler);
	    if (!logger) {
	      throw new Error('Logger is required to handle rejections');
	    }
	    this.logger = logger;
	    this.handlers = new Map();
	  }

	  /**
	   * Handles `unhandledRejection` events for the current process by adding any
	   * handlers passed in.
	   * @returns {undefined}
	   */
	  return _createClass(RejectionHandler, [{
	    key: "handle",
	    value: function handle() {
	      var _this = this;
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	      args.forEach(function (arg) {
	        if (Array.isArray(arg)) {
	          return arg.forEach(function (handler) {
	            return _this._addHandler(handler);
	          });
	        }
	        _this._addHandler(arg);
	      });
	      if (!this.catcher) {
	        this.catcher = this._unhandledRejection.bind(this);
	        process.on('unhandledRejection', this.catcher);
	      }
	    }

	    /**
	     * Removes any handlers to `unhandledRejection` events for the current
	     * process. This does not modify the state of the `this.handlers` set.
	     * @returns {undefined}
	     */
	  }, {
	    key: "unhandle",
	    value: function unhandle() {
	      var _this2 = this;
	      if (this.catcher) {
	        process.removeListener('unhandledRejection', this.catcher);
	        this.catcher = false;
	        Array.from(this.handlers.values()).forEach(function (wrapper) {
	          return _this2.logger.unpipe(wrapper);
	        });
	      }
	    }

	    /**
	     * TODO: add method description
	     * @param {Error} err - Error to get information about.
	     * @returns {mixed} - TODO: add return description.
	     */
	  }, {
	    key: "getAllInfo",
	    value: function getAllInfo(err) {
	      var message = null;
	      if (err) {
	        message = typeof err === 'string' ? err : err.message;
	      }
	      return {
	        error: err,
	        // TODO (indexzero): how do we configure this?
	        level: 'error',
	        message: ["unhandledRejection: ".concat(message || '(no error message)'), err && err.stack || '  No stack trace'].join('\n'),
	        stack: err && err.stack,
	        rejection: true,
	        date: new Date().toString(),
	        process: this.getProcessInfo(),
	        os: this.getOsInfo(),
	        trace: this.getTrace(err)
	      };
	    }

	    /**
	     * Gets all relevant process information for the currently running process.
	     * @returns {mixed} - TODO: add return description.
	     */
	  }, {
	    key: "getProcessInfo",
	    value: function getProcessInfo() {
	      return {
	        pid: process.pid,
	        uid: process.getuid ? process.getuid() : null,
	        gid: process.getgid ? process.getgid() : null,
	        cwd: process.cwd(),
	        execPath: process.execPath,
	        version: process.version,
	        argv: process.argv,
	        memoryUsage: process.memoryUsage()
	      };
	    }

	    /**
	     * Gets all relevant OS information for the currently running process.
	     * @returns {mixed} - TODO: add return description.
	     */
	  }, {
	    key: "getOsInfo",
	    value: function getOsInfo() {
	      return {
	        loadavg: os.loadavg(),
	        uptime: os.uptime()
	      };
	    }

	    /**
	     * Gets a stack trace for the specified error.
	     * @param {mixed} err - TODO: add param description.
	     * @returns {mixed} - TODO: add return description.
	     */
	  }, {
	    key: "getTrace",
	    value: function getTrace(err) {
	      var trace = err ? stackTrace.parse(err) : stackTrace.get();
	      return trace.map(function (site) {
	        return {
	          column: site.getColumnNumber(),
	          file: site.getFileName(),
	          "function": site.getFunctionName(),
	          line: site.getLineNumber(),
	          method: site.getMethodName(),
	          "native": site.isNative()
	        };
	      });
	    }

	    /**
	     * Helper method to add a transport as an exception handler.
	     * @param {Transport} handler - The transport to add as an exception handler.
	     * @returns {void}
	     */
	  }, {
	    key: "_addHandler",
	    value: function _addHandler(handler) {
	      if (!this.handlers.has(handler)) {
	        handler.handleRejections = true;
	        var wrapper = new RejectionStream(handler);
	        this.handlers.set(handler, wrapper);
	        this.logger.pipe(wrapper);
	      }
	    }

	    /**
	     * Logs all relevant information around the `err` and exits the current
	     * process.
	     * @param {Error} err - Error to handle
	     * @returns {mixed} - TODO: add return description.
	     * @private
	     */
	  }, {
	    key: "_unhandledRejection",
	    value: function _unhandledRejection(err) {
	      var info = this.getAllInfo(err);
	      var handlers = this._getRejectionHandlers();
	      // Calculate if we should exit on this error
	      var doExit = typeof this.logger.exitOnError === 'function' ? this.logger.exitOnError(err) : this.logger.exitOnError;
	      var timeout;
	      if (!handlers.length && doExit) {
	        // eslint-disable-next-line no-console
	        console.warn('winston: exitOnError cannot be true with no rejection handlers.');
	        // eslint-disable-next-line no-console
	        console.warn('winston: not exiting process.');
	        doExit = false;
	      }
	      function gracefulExit() {
	        debug('doExit', doExit);
	        debug('process._exiting', process._exiting);
	        if (doExit && !process._exiting) {
	          // Remark: Currently ignoring any rejections from transports when
	          // catching unhandled rejections.
	          if (timeout) {
	            clearTimeout(timeout);
	          }
	          // eslint-disable-next-line no-process-exit
	          process.exit(1);
	        }
	      }
	      if (!handlers || handlers.length === 0) {
	        return process.nextTick(gracefulExit);
	      }

	      // Log to all transports attempting to listen for when they are completed.
	      asyncForEach(handlers, function (handler, next) {
	        var done = once(next);
	        var transport = handler.transport || handler;

	        // Debug wrapping so that we can inspect what's going on under the covers.
	        function onDone(event) {
	          return function () {
	            debug(event);
	            done();
	          };
	        }
	        transport._ending = true;
	        transport.once('finish', onDone('finished'));
	        transport.once('error', onDone('error'));
	      }, function () {
	        return doExit && gracefulExit();
	      });
	      this.logger.log(info);

	      // If exitOnError is true, then only allow the logging of exceptions to
	      // take up to `3000ms`.
	      if (doExit) {
	        timeout = setTimeout(gracefulExit, 3000);
	      }
	    }

	    /**
	     * Returns the list of transports and exceptionHandlers for this instance.
	     * @returns {Array} - List of transports and exceptionHandlers for this
	     * instance.
	     * @private
	     */
	  }, {
	    key: "_getRejectionHandlers",
	    value: function _getRejectionHandlers() {
	      // Remark (indexzero): since `logger.transports` returns all of the pipes
	      // from the _readableState of the stream we actually get the join of the
	      // explicit handlers and the implicit transports with
	      // `handleRejections: true`
	      return this.logger.transports.filter(function (wrap) {
	        var transport = wrap.transport || wrap;
	        return transport.handleRejections;
	      });
	    }
	  }]);
	}();
	return rejectionHandler;
}

var legacy = {exports: {}};

var modern = {exports: {}};

var hasRequiredModern;

function requireModern () {
	if (hasRequiredModern) return modern.exports;
	hasRequiredModern = 1;

	const util = require$$0$1;
	const Writable = require_stream_writable();
	const { LEVEL } = requireTripleBeam();

	/**
	 * Constructor function for the TransportStream. This is the base prototype
	 * that all `winston >= 3` transports should inherit from.
	 * @param {Object} options - Options for this TransportStream instance
	 * @param {String} options.level - Highest level according to RFC5424.
	 * @param {Boolean} options.handleExceptions - If true, info with
	 * { exception: true } will be written.
	 * @param {Function} options.log - Custom log function for simple Transport
	 * creation
	 * @param {Function} options.close - Called on "unpipe" from parent.
	 */
	const TransportStream = modern.exports = function TransportStream(options = {}) {
	  Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });

	  this.format = options.format;
	  this.level = options.level;
	  this.handleExceptions = options.handleExceptions;
	  this.handleRejections = options.handleRejections;
	  this.silent = options.silent;

	  if (options.log) this.log = options.log;
	  if (options.logv) this.logv = options.logv;
	  if (options.close) this.close = options.close;

	  // Get the levels from the source we are piped from.
	  this.once('pipe', logger => {
	    // Remark (indexzero): this bookkeeping can only support multiple
	    // Logger parents with the same `levels`. This comes into play in
	    // the `winston.Container` code in which `container.add` takes
	    // a fully realized set of options with pre-constructed TransportStreams.
	    this.levels = logger.levels;
	    this.parent = logger;
	  });

	  // If and/or when the transport is removed from this instance
	  this.once('unpipe', src => {
	    // Remark (indexzero): this bookkeeping can only support multiple
	    // Logger parents with the same `levels`. This comes into play in
	    // the `winston.Container` code in which `container.add` takes
	    // a fully realized set of options with pre-constructed TransportStreams.
	    if (src === this.parent) {
	      this.parent = null;
	      if (this.close) {
	        this.close();
	      }
	    }
	  });
	};

	/*
	 * Inherit from Writeable using Node.js built-ins
	 */
	util.inherits(TransportStream, Writable);

	/**
	 * Writes the info object to our transport instance.
	 * @param {mixed} info - TODO: add param description.
	 * @param {mixed} enc - TODO: add param description.
	 * @param {function} callback - TODO: add param description.
	 * @returns {undefined}
	 * @private
	 */
	TransportStream.prototype._write = function _write(info, enc, callback) {
	  if (this.silent || (info.exception === true && !this.handleExceptions)) {
	    return callback(null);
	  }

	  // Remark: This has to be handled in the base transport now because we
	  // cannot conditionally write to our pipe targets as stream. We always
	  // prefer any explicit level set on the Transport itself falling back to
	  // any level set on the parent.
	  const level = this.level || (this.parent && this.parent.level);

	  if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
	    if (info && !this.format) {
	      return this.log(info, callback);
	    }

	    let errState;
	    let transformed;

	    // We trap(and re-throw) any errors generated by the user-provided format, but also
	    // guarantee that the streams callback is invoked so that we can continue flowing.
	    try {
	      transformed = this.format.transform(Object.assign({}, info), this.format.options);
	    } catch (err) {
	      errState = err;
	    }

	    if (errState || !transformed) {
	      // eslint-disable-next-line callback-return
	      callback();
	      if (errState) throw errState;
	      return;
	    }

	    return this.log(transformed, callback);
	  }
	  this._writableState.sync = false;
	  return callback(null);
	};

	/**
	 * Writes the batch of info objects (i.e. "object chunks") to our transport
	 * instance after performing any necessary filtering.
	 * @param {mixed} chunks - TODO: add params description.
	 * @param {function} callback - TODO: add params description.
	 * @returns {mixed} - TODO: add returns description.
	 * @private
	 */
	TransportStream.prototype._writev = function _writev(chunks, callback) {
	  if (this.logv) {
	    const infos = chunks.filter(this._accept, this);
	    if (!infos.length) {
	      return callback(null);
	    }

	    // Remark (indexzero): from a performance perspective if Transport
	    // implementers do choose to implement logv should we make it their
	    // responsibility to invoke their format?
	    return this.logv(infos, callback);
	  }

	  for (let i = 0; i < chunks.length; i++) {
	    if (!this._accept(chunks[i])) continue;

	    if (chunks[i].chunk && !this.format) {
	      this.log(chunks[i].chunk, chunks[i].callback);
	      continue;
	    }

	    let errState;
	    let transformed;

	    // We trap(and re-throw) any errors generated by the user-provided format, but also
	    // guarantee that the streams callback is invoked so that we can continue flowing.
	    try {
	      transformed = this.format.transform(
	        Object.assign({}, chunks[i].chunk),
	        this.format.options
	      );
	    } catch (err) {
	      errState = err;
	    }

	    if (errState || !transformed) {
	      // eslint-disable-next-line callback-return
	      chunks[i].callback();
	      if (errState) {
	        // eslint-disable-next-line callback-return
	        callback(null);
	        throw errState;
	      }
	    } else {
	      this.log(transformed, chunks[i].callback);
	    }
	  }

	  return callback(null);
	};

	/**
	 * Predicate function that returns true if the specfied `info` on the
	 * WriteReq, `write`, should be passed down into the derived
	 * TransportStream's I/O via `.log(info, callback)`.
	 * @param {WriteReq} write - winston@3 Node.js WriteReq for the `info` object
	 * representing the log message.
	 * @returns {Boolean} - Value indicating if the `write` should be accepted &
	 * logged.
	 */
	TransportStream.prototype._accept = function _accept(write) {
	  const info = write.chunk;
	  if (this.silent) {
	    return false;
	  }

	  // We always prefer any explicit level set on the Transport itself
	  // falling back to any level set on the parent.
	  const level = this.level || (this.parent && this.parent.level);

	  // Immediately check the average case: log level filtering.
	  if (
	    info.exception === true ||
	    !level ||
	    this.levels[level] >= this.levels[info[LEVEL]]
	  ) {
	    // Ensure the info object is valid based on `{ exception }`:
	    // 1. { handleExceptions: true }: all `info` objects are valid
	    // 2. { exception: false }: accepted by all transports.
	    if (this.handleExceptions || info.exception !== true) {
	      return true;
	    }
	  }

	  return false;
	};

	/**
	 * _nop is short for "No operation"
	 * @returns {Boolean} Intentionally false.
	 */
	TransportStream.prototype._nop = function _nop() {
	  // eslint-disable-next-line no-undefined
	  return void undefined;
	};
	return modern.exports;
}

var hasRequiredLegacy;

function requireLegacy () {
	if (hasRequiredLegacy) return legacy.exports;
	hasRequiredLegacy = 1;

	const util = require$$0$1;
	const { LEVEL } = requireTripleBeam();
	const TransportStream = requireModern();

	/**
	 * Constructor function for the LegacyTransportStream. This is an internal
	 * wrapper `winston >= 3` uses to wrap older transports implementing
	 * log(level, message, meta).
	 * @param {Object} options - Options for this TransportStream instance.
	 * @param {Transpot} options.transport - winston@2 or older Transport to wrap.
	 */

	const LegacyTransportStream = legacy.exports = function LegacyTransportStream(options = {}) {
	  TransportStream.call(this, options);
	  if (!options.transport || typeof options.transport.log !== 'function') {
	    throw new Error('Invalid transport, must be an object with a log method.');
	  }

	  this.transport = options.transport;
	  this.level = this.level || options.transport.level;
	  this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;

	  // Display our deprecation notice.
	  this._deprecated();

	  // Properly bubble up errors from the transport to the
	  // LegacyTransportStream instance, but only once no matter how many times
	  // this transport is shared.
	  function transportError(err) {
	    this.emit('error', err, this.transport);
	  }

	  if (!this.transport.__winstonError) {
	    this.transport.__winstonError = transportError.bind(this);
	    this.transport.on('error', this.transport.__winstonError);
	  }
	};

	/*
	 * Inherit from TransportStream using Node.js built-ins
	 */
	util.inherits(LegacyTransportStream, TransportStream);

	/**
	 * Writes the info object to our transport instance.
	 * @param {mixed} info - TODO: add param description.
	 * @param {mixed} enc - TODO: add param description.
	 * @param {function} callback - TODO: add param description.
	 * @returns {undefined}
	 * @private
	 */
	LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
	  if (this.silent || (info.exception === true && !this.handleExceptions)) {
	    return callback(null);
	  }

	  // Remark: This has to be handled in the base transport now because we
	  // cannot conditionally write to our pipe targets as stream.
	  if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
	    this.transport.log(info[LEVEL], info.message, info, this._nop);
	  }

	  callback(null);
	};

	/**
	 * Writes the batch of info objects (i.e. "object chunks") to our transport
	 * instance after performing any necessary filtering.
	 * @param {mixed} chunks - TODO: add params description.
	 * @param {function} callback - TODO: add params description.
	 * @returns {mixed} - TODO: add returns description.
	 * @private
	 */
	LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
	  for (let i = 0; i < chunks.length; i++) {
	    if (this._accept(chunks[i])) {
	      this.transport.log(
	        chunks[i].chunk[LEVEL],
	        chunks[i].chunk.message,
	        chunks[i].chunk,
	        this._nop
	      );
	      chunks[i].callback();
	    }
	  }

	  return callback(null);
	};

	/**
	 * Displays a deprecation notice. Defined as a function so it can be
	 * overriden in tests.
	 * @returns {undefined}
	 */
	LegacyTransportStream.prototype._deprecated = function _deprecated() {
	  // eslint-disable-next-line no-console
	  console.error([
	    `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
	    '- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md'
	  ].join('\n'));
	};

	/**
	 * Clean up error handling state on the legacy transport associated
	 * with this instance.
	 * @returns {undefined}
	 */
	LegacyTransportStream.prototype.close = function close() {
	  if (this.transport.close) {
	    this.transport.close();
	  }

	  if (this.transport.__winstonError) {
	    this.transport.removeListener('error', this.transport.__winstonError);
	    this.transport.__winstonError = null;
	  }
	};
	return legacy.exports;
}

/**
 * profiler.js: TODO: add file header description.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var profiler;
var hasRequiredProfiler;

function requireProfiler () {
	if (hasRequiredProfiler) return profiler;
	hasRequiredProfiler = 1;

	/**
	 * TODO: add class description.
	 * @type {Profiler}
	 * @private
	 */
	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
	function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }
	var Profiler = /*#__PURE__*/function () {
	  /**
	   * Constructor function for the Profiler instance used by
	   * `Logger.prototype.startTimer`. When done is called the timer will finish
	   * and log the duration.
	   * @param {!Logger} logger - TODO: add param description.
	   * @private
	   */
	  function Profiler(logger) {
	    _classCallCheck(this, Profiler);
	    var Logger = requireLogger();
	    if (_typeof(logger) !== 'object' || Array.isArray(logger) || !(logger instanceof Logger)) {
	      throw new Error('Logger is required for profiling');
	    } else {
	      this.logger = logger;
	      this.start = Date.now();
	    }
	  }

	  /**
	   * Ends the current timer (i.e. Profiler) instance and logs the `msg` along
	   * with the duration since creation.
	   * @returns {mixed} - TODO: add return description.
	   * @private
	   */
	  return _createClass(Profiler, [{
	    key: "done",
	    value: function done() {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	      if (typeof args[args.length - 1] === 'function') {
	        // eslint-disable-next-line no-console
	        console.warn('Callback function no longer supported as of winston@3.0.0');
	        args.pop();
	      }
	      var info = _typeof(args[args.length - 1]) === 'object' ? args.pop() : {};
	      info.level = info.level || 'info';
	      info.durationMs = Date.now() - this.start;
	      return this.logger.write(info);
	    }
	  }]);
	}();
	profiler = Profiler;
	return profiler;
}

var format$2;
var hasRequiredFormat$2;

function requireFormat$2 () {
	if (hasRequiredFormat$2) return format$2;
	hasRequiredFormat$2 = 1;

	/*
	 * Displays a helpful message and the source of
	 * the format when it is invalid.
	 */
	class InvalidFormatError extends Error {
	  constructor(formatFn) {
	    super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${formatFn.toString().split('\n')[0]}\n`);

	    Error.captureStackTrace(this, InvalidFormatError);
	  }
	}

	/*
	 * function format (formatFn)
	 * Returns a create function for the `formatFn`.
	 */
	format$2 = formatFn => {
	  if (formatFn.length > 2) {
	    throw new InvalidFormatError(formatFn);
	  }

	  /*
	   * function Format (options)
	   * Base prototype which calls a `_format`
	   * function and pushes the result.
	   */
	  function Format(options = {}) {
	    this.options = options;
	  }

	  Format.prototype.transform = formatFn;

	  //
	  // Create a function which returns new instances of
	  // FormatWrap for simple syntax like:
	  //
	  // require('winston').formats.json();
	  //
	  function createFormatWrap(opts) {
	    return new Format(opts);
	  }

	  //
	  // Expose the FormatWrap through the create function
	  // for testability.
	  //
	  createFormatWrap.Format = Format;
	  return createFormatWrap;
	};
	return format$2;
}

var json;
var hasRequiredJson;

function requireJson () {
	if (hasRequiredJson) return json;
	hasRequiredJson = 1;

	const format = requireFormat$2();
	const { MESSAGE } = requireTripleBeam();
	const stringify = requireSafeStableStringify();

	/*
	 * function replacer (key, value)
	 * Handles proper stringification of Buffer and bigint output.
	 */
	function replacer(key, value) {
	  // safe-stable-stringify does support BigInt, however, it doesn't wrap the value in quotes.
	  // Leading to a loss in fidelity if the resulting string is parsed.
	  // It would also be a breaking change for logform.
	  if (typeof value === 'bigint')
	    return value.toString();
	  return value;
	}

	/*
	 * function json (info)
	 * Returns a new instance of the JSON format that turns a log `info`
	 * object into pure JSON. This was previously exposed as { json: true }
	 * to transports in `winston < 3.0.0`.
	 */
	json = format((info, opts) => {
	  const jsonStringify = stringify.configure(opts);
	  info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
	  return info;
	});
	return json;
}

/**
 * logger.js: TODO: add file header description.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var logger;
var hasRequiredLogger;

function requireLogger () {
	if (hasRequiredLogger) return logger;
	hasRequiredLogger = 1;

	function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
	function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
	function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
	function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
	function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
	function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
	function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
	function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
	var _require = requireReadableBrowser(),
	  Stream = _require.Stream,
	  Transform = _require.Transform;
	var asyncForEach = requireForEach();
	var _require2 = requireTripleBeam(),
	  LEVEL = _require2.LEVEL,
	  SPLAT = _require2.SPLAT;
	var isStream = requireIsStream();
	var ExceptionHandler = requireExceptionHandler();
	var RejectionHandler = requireRejectionHandler();
	var LegacyTransportStream = requireLegacy();
	var Profiler = requireProfiler();
	var _require3 = requireCommon(),
	  warn = _require3.warn;
	var config = requireConfig();

	/**
	 * Captures the number of format (i.e. %s strings) in a given string.
	 * Based on `util.format`, see Node.js source:
	 * https://github.com/nodejs/node/blob/b1c8f15c5f169e021f7c46eb7b219de95fe97603/lib/util.js#L201-L230
	 * @type {RegExp}
	 */
	var formatRegExp = /%[scdjifoO%]/g;

	/**
	 * TODO: add class description.
	 * @type {Logger}
	 * @extends {Transform}
	 */
	var Logger = /*#__PURE__*/function (_Transform) {
	  /**
	   * Constructor function for the Logger object responsible for persisting log
	   * messages and metadata to one or more transports.
	   * @param {!Object} options - foo
	   */
	  function Logger(options) {
	    var _this;
	    _classCallCheck(this, Logger);
	    _this = _callSuper(this, Logger, [{
	      objectMode: true
	    }]);
	    _this.configure(options);
	    return _this;
	  }
	  _inherits(Logger, _Transform);
	  return _createClass(Logger, [{
	    key: "child",
	    value: function child(defaultRequestMetadata) {
	      var logger = this;
	      return Object.create(logger, {
	        write: {
	          value: function value(info) {
	            var infoClone = Object.assign({}, defaultRequestMetadata, info);

	            // Object.assign doesn't copy inherited Error
	            // properties so we have to do that explicitly
	            //
	            // Remark (indexzero): we should remove this
	            // since the errors format will handle this case.
	            //
	            if (info instanceof Error) {
	              infoClone.stack = info.stack;
	              infoClone.message = info.message;
	            }
	            logger.write(infoClone);
	          }
	        }
	      });
	    }

	    /**
	     * This will wholesale reconfigure this instance by:
	     * 1. Resetting all transports. Older transports will be removed implicitly.
	     * 2. Set all other options including levels, colors, rewriters, filters,
	     *    exceptionHandlers, etc.
	     * @param {!Object} options - TODO: add param description.
	     * @returns {undefined}
	     */
	  }, {
	    key: "configure",
	    value: function configure() {
	      var _this2 = this;
	      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        silent = _ref.silent,
	        format = _ref.format,
	        defaultMeta = _ref.defaultMeta,
	        levels = _ref.levels,
	        _ref$level = _ref.level,
	        level = _ref$level === void 0 ? 'info' : _ref$level,
	        _ref$exitOnError = _ref.exitOnError,
	        exitOnError = _ref$exitOnError === void 0 ? true : _ref$exitOnError,
	        transports = _ref.transports,
	        colors = _ref.colors,
	        emitErrs = _ref.emitErrs,
	        formatters = _ref.formatters,
	        padLevels = _ref.padLevels,
	        rewriters = _ref.rewriters,
	        stripColors = _ref.stripColors,
	        exceptionHandlers = _ref.exceptionHandlers,
	        rejectionHandlers = _ref.rejectionHandlers;
	      // Reset transports if we already have them
	      if (this.transports.length) {
	        this.clear();
	      }
	      this.silent = silent;
	      this.format = format || this.format || requireJson()();
	      this.defaultMeta = defaultMeta || null;
	      // Hoist other options onto this instance.
	      this.levels = levels || this.levels || config.npm.levels;
	      this.level = level;
	      if (this.exceptions) {
	        this.exceptions.unhandle();
	      }
	      if (this.rejections) {
	        this.rejections.unhandle();
	      }
	      this.exceptions = new ExceptionHandler(this);
	      this.rejections = new RejectionHandler(this);
	      this.profilers = {};
	      this.exitOnError = exitOnError;

	      // Add all transports we have been provided.
	      if (transports) {
	        transports = Array.isArray(transports) ? transports : [transports];
	        transports.forEach(function (transport) {
	          return _this2.add(transport);
	        });
	      }
	      if (colors || emitErrs || formatters || padLevels || rewriters || stripColors) {
	        throw new Error(['{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.', 'Use a custom winston.format(function) instead.', 'See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md'].join('\n'));
	      }
	      if (exceptionHandlers) {
	        this.exceptions.handle(exceptionHandlers);
	      }
	      if (rejectionHandlers) {
	        this.rejections.handle(rejectionHandlers);
	      }
	    }
	  }, {
	    key: "isLevelEnabled",
	    value: function isLevelEnabled(level) {
	      var _this3 = this;
	      var givenLevelValue = getLevelValue(this.levels, level);
	      if (givenLevelValue === null) {
	        return false;
	      }
	      var configuredLevelValue = getLevelValue(this.levels, this.level);
	      if (configuredLevelValue === null) {
	        return false;
	      }
	      if (!this.transports || this.transports.length === 0) {
	        return configuredLevelValue >= givenLevelValue;
	      }
	      var index = this.transports.findIndex(function (transport) {
	        var transportLevelValue = getLevelValue(_this3.levels, transport.level);
	        if (transportLevelValue === null) {
	          transportLevelValue = configuredLevelValue;
	        }
	        return transportLevelValue >= givenLevelValue;
	      });
	      return index !== -1;
	    }

	    /* eslint-disable valid-jsdoc */
	    /**
	     * Ensure backwards compatibility with a `log` method
	     * @param {mixed} level - Level the log message is written at.
	     * @param {mixed} msg - TODO: add param description.
	     * @param {mixed} meta - TODO: add param description.
	     * @returns {Logger} - TODO: add return description.
	     *
	     * @example
	     *    // Supports the existing API:
	     *    logger.log('info', 'Hello world', { custom: true });
	     *    logger.log('info', new Error('Yo, it\'s on fire'));
	     *
	     *    // Requires winston.format.splat()
	     *    logger.log('info', '%s %d%%', 'A string', 50, { thisIsMeta: true });
	     *
	     *    // And the new API with a single JSON literal:
	     *    logger.log({ level: 'info', message: 'Hello world', custom: true });
	     *    logger.log({ level: 'info', message: new Error('Yo, it\'s on fire') });
	     *
	     *    // Also requires winston.format.splat()
	     *    logger.log({
	     *      level: 'info',
	     *      message: '%s %d%%',
	     *      [SPLAT]: ['A string', 50],
	     *      meta: { thisIsMeta: true }
	     *    });
	     *
	     */
	    /* eslint-enable valid-jsdoc */
	  }, {
	    key: "log",
	    value: function log(level, msg) {
	      for (var _len = arguments.length, splat = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	        splat[_key - 2] = arguments[_key];
	      }
	      // eslint-disable-line max-params
	      // Optimize for the hotpath of logging JSON literals
	      if (arguments.length === 1) {
	        // Yo dawg, I heard you like levels ... seriously ...
	        // In this context the LHS `level` here is actually the `info` so read
	        // this as: info[LEVEL] = info.level;
	        level[LEVEL] = level.level;
	        this._addDefaultMeta(level);
	        this.write(level);
	        return this;
	      }

	      // Slightly less hotpath, but worth optimizing for.
	      if (arguments.length === 2) {
	        if (msg && _typeof(msg) === 'object') {
	          msg[LEVEL] = msg.level = level;
	          this._addDefaultMeta(msg);
	          this.write(msg);
	          return this;
	        }
	        msg = _defineProperty(_defineProperty(_defineProperty({}, LEVEL, level), "level", level), "message", msg);
	        this._addDefaultMeta(msg);
	        this.write(msg);
	        return this;
	      }
	      var meta = splat[0];
	      if (_typeof(meta) === 'object' && meta !== null) {
	        // Extract tokens, if none available default to empty array to
	        // ensure consistancy in expected results
	        var tokens = msg && msg.match && msg.match(formatRegExp);
	        if (!tokens) {
	          var info = Object.assign({}, this.defaultMeta, meta, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, LEVEL, level), SPLAT, splat), "level", level), "message", msg));
	          if (meta.message) info.message = "".concat(info.message, " ").concat(meta.message);
	          if (meta.stack) info.stack = meta.stack;
	          if (meta.cause) info.cause = meta.cause;
	          this.write(info);
	          return this;
	        }
	      }
	      this.write(Object.assign({}, this.defaultMeta, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, LEVEL, level), SPLAT, splat), "level", level), "message", msg)));
	      return this;
	    }

	    /**
	     * Pushes data so that it can be picked up by all of our pipe targets.
	     * @param {mixed} info - TODO: add param description.
	     * @param {mixed} enc - TODO: add param description.
	     * @param {mixed} callback - Continues stream processing.
	     * @returns {undefined}
	     * @private
	     */
	  }, {
	    key: "_transform",
	    value: function _transform(info, enc, callback) {
	      if (this.silent) {
	        return callback();
	      }

	      // [LEVEL] is only soft guaranteed to be set here since we are a proper
	      // stream. It is likely that `info` came in through `.log(info)` or
	      // `.info(info)`. If it is not defined, however, define it.
	      // This LEVEL symbol is provided by `triple-beam` and also used in:
	      // - logform
	      // - winston-transport
	      // - abstract-winston-transport
	      if (!info[LEVEL]) {
	        info[LEVEL] = info.level;
	      }

	      // Remark: really not sure what to do here, but this has been reported as
	      // very confusing by pre winston@2.0.0 users as quite confusing when using
	      // custom levels.
	      if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {
	        // eslint-disable-next-line no-console
	        console.error('[winston] Unknown logger level: %s', info[LEVEL]);
	      }

	      // Remark: not sure if we should simply error here.
	      if (!this._readableState.pipes) {
	        // eslint-disable-next-line no-console
	        console.error('[winston] Attempt to write logs with no transports, which can increase memory usage: %j', info);
	      }

	      // Here we write to the `format` pipe-chain, which on `readable` above will
	      // push the formatted `info` Object onto the buffer for this instance. We trap
	      // (and re-throw) any errors generated by the user-provided format, but also
	      // guarantee that the streams callback is invoked so that we can continue flowing.
	      try {
	        this.push(this.format.transform(info, this.format.options));
	      } finally {
	        this._writableState.sync = false;
	        // eslint-disable-next-line callback-return
	        callback();
	      }
	    }

	    /**
	     * Delays the 'finish' event until all transport pipe targets have
	     * also emitted 'finish' or are already finished.
	     * @param {mixed} callback - Continues stream processing.
	     */
	  }, {
	    key: "_final",
	    value: function _final(callback) {
	      var transports = this.transports.slice();
	      asyncForEach(transports, function (transport, next) {
	        if (!transport || transport.finished) return setImmediate(next);
	        transport.once('finish', next);
	        transport.end();
	      }, callback);
	    }

	    /**
	     * Adds the transport to this logger instance by piping to it.
	     * @param {mixed} transport - TODO: add param description.
	     * @returns {Logger} - TODO: add return description.
	     */
	  }, {
	    key: "add",
	    value: function add(transport) {
	      // Support backwards compatibility with all existing `winston < 3.x.x`
	      // transports which meet one of two criteria:
	      // 1. They inherit from winston.Transport in  < 3.x.x which is NOT a stream.
	      // 2. They expose a log method which has a length greater than 2 (i.e. more then
	      //    just `log(info, callback)`.
	      var target = !isStream(transport) || transport.log.length > 2 ? new LegacyTransportStream({
	        transport: transport
	      }) : transport;
	      if (!target._writableState || !target._writableState.objectMode) {
	        throw new Error('Transports must WritableStreams in objectMode. Set { objectMode: true }.');
	      }

	      // Listen for the `error` event and the `warn` event on the new Transport.
	      this._onEvent('error', target);
	      this._onEvent('warn', target);
	      this.pipe(target);
	      if (transport.handleExceptions) {
	        this.exceptions.handle();
	      }
	      if (transport.handleRejections) {
	        this.rejections.handle();
	      }
	      return this;
	    }

	    /**
	     * Removes the transport from this logger instance by unpiping from it.
	     * @param {mixed} transport - TODO: add param description.
	     * @returns {Logger} - TODO: add return description.
	     */
	  }, {
	    key: "remove",
	    value: function remove(transport) {
	      if (!transport) return this;
	      var target = transport;
	      if (!isStream(transport) || transport.log.length > 2) {
	        target = this.transports.filter(function (match) {
	          return match.transport === transport;
	        })[0];
	      }
	      if (target) {
	        this.unpipe(target);
	      }
	      return this;
	    }

	    /**
	     * Removes all transports from this logger instance.
	     * @returns {Logger} - TODO: add return description.
	     */
	  }, {
	    key: "clear",
	    value: function clear() {
	      this.unpipe();
	      return this;
	    }

	    /**
	     * Cleans up resources (streams, event listeners) for all transports
	     * associated with this instance (if necessary).
	     * @returns {Logger} - TODO: add return description.
	     */
	  }, {
	    key: "close",
	    value: function close() {
	      this.exceptions.unhandle();
	      this.rejections.unhandle();
	      this.clear();
	      this.emit('close');
	      return this;
	    }

	    /**
	     * Sets the `target` levels specified on this instance.
	     * @param {Object} Target levels to use on this instance.
	     */
	  }, {
	    key: "setLevels",
	    value: function setLevels() {
	      warn.deprecated('setLevels');
	    }

	    /**
	     * Queries the all transports for this instance with the specified `options`.
	     * This will aggregate each transport's results into one object containing
	     * a property per transport.
	     * @param {Object} options - Query options for this instance.
	     * @param {function} callback - Continuation to respond to when complete.
	     */
	  }, {
	    key: "query",
	    value: function query(options, callback) {
	      if (typeof options === 'function') {
	        callback = options;
	        options = {};
	      }
	      options = options || {};
	      var results = {};
	      var queryObject = Object.assign({}, options.query || {});

	      // Helper function to query a single transport
	      function queryTransport(transport, next) {
	        if (options.query && typeof transport.formatQuery === 'function') {
	          options.query = transport.formatQuery(queryObject);
	        }
	        transport.query(options, function (err, res) {
	          if (err) {
	            return next(err);
	          }
	          if (typeof transport.formatResults === 'function') {
	            res = transport.formatResults(res, options.format);
	          }
	          next(null, res);
	        });
	      }

	      // Helper function to accumulate the results from `queryTransport` into
	      // the `results`.
	      function addResults(transport, next) {
	        queryTransport(transport, function (err, result) {
	          // queryTransport could potentially invoke the callback multiple times
	          // since Transport code can be unpredictable.
	          if (next) {
	            result = err || result;
	            if (result) {
	              results[transport.name] = result;
	            }

	            // eslint-disable-next-line callback-return
	            next();
	          }
	          next = null;
	        });
	      }

	      // Iterate over the transports in parallel setting the appropriate key in
	      // the `results`.
	      asyncForEach(this.transports.filter(function (transport) {
	        return !!transport.query;
	      }), addResults, function () {
	        return callback(null, results);
	      });
	    }

	    /**
	     * Returns a log stream for all transports. Options object is optional.
	     * @param{Object} options={} - Stream options for this instance.
	     * @returns {Stream} - TODO: add return description.
	     */
	  }, {
	    key: "stream",
	    value: function stream() {
	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var out = new Stream();
	      var streams = [];
	      out._streams = streams;
	      out.destroy = function () {
	        var i = streams.length;
	        while (i--) {
	          streams[i].destroy();
	        }
	      };

	      // Create a list of all transports for this instance.
	      this.transports.filter(function (transport) {
	        return !!transport.stream;
	      }).forEach(function (transport) {
	        var str = transport.stream(options);
	        if (!str) {
	          return;
	        }
	        streams.push(str);
	        str.on('log', function (log) {
	          log.transport = log.transport || [];
	          log.transport.push(transport.name);
	          out.emit('log', log);
	        });
	        str.on('error', function (err) {
	          err.transport = err.transport || [];
	          err.transport.push(transport.name);
	          out.emit('error', err);
	        });
	      });
	      return out;
	    }

	    /**
	     * Returns an object corresponding to a specific timing. When done is called
	     * the timer will finish and log the duration. e.g.:
	     * @returns {Profile} - TODO: add return description.
	     * @example
	     *    const timer = winston.startTimer()
	     *    setTimeout(() => {
	     *      timer.done({
	     *        message: 'Logging message'
	     *      });
	     *    }, 1000);
	     */
	  }, {
	    key: "startTimer",
	    value: function startTimer() {
	      return new Profiler(this);
	    }

	    /**
	     * Tracks the time inbetween subsequent calls to this method with the same
	     * `id` parameter. The second call to this method will log the difference in
	     * milliseconds along with the message.
	     * @param {string} id Unique id of the profiler
	     * @returns {Logger} - TODO: add return description.
	     */
	  }, {
	    key: "profile",
	    value: function profile(id) {
	      var time = Date.now();
	      if (this.profilers[id]) {
	        var timeEnd = this.profilers[id];
	        delete this.profilers[id];

	        // Attempt to be kind to users if they are still using older APIs.
	        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	          args[_key2 - 1] = arguments[_key2];
	        }
	        if (typeof args[args.length - 2] === 'function') {
	          // eslint-disable-next-line no-console
	          console.warn('Callback function no longer supported as of winston@3.0.0');
	          args.pop();
	        }

	        // Set the duration property of the metadata
	        var info = _typeof(args[args.length - 1]) === 'object' ? args.pop() : {};
	        info.level = info.level || 'info';
	        info.durationMs = time - timeEnd;
	        info.message = info.message || id;
	        return this.write(info);
	      }
	      this.profilers[id] = time;
	      return this;
	    }

	    /**
	     * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
	     * @returns {undefined}
	     * @deprecated
	     */
	  }, {
	    key: "handleExceptions",
	    value: function handleExceptions() {
	      var _this$exceptions;
	      // eslint-disable-next-line no-console
	      console.warn('Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()');
	      (_this$exceptions = this.exceptions).handle.apply(_this$exceptions, arguments);
	    }

	    /**
	     * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
	     * @returns {undefined}
	     * @deprecated
	     */
	  }, {
	    key: "unhandleExceptions",
	    value: function unhandleExceptions() {
	      var _this$exceptions2;
	      // eslint-disable-next-line no-console
	      console.warn('Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()');
	      (_this$exceptions2 = this.exceptions).unhandle.apply(_this$exceptions2, arguments);
	    }

	    /**
	     * Throw a more meaningful deprecation notice
	     * @throws {Error} - TODO: add throws description.
	     */
	  }, {
	    key: "cli",
	    value: function cli() {
	      throw new Error(['Logger.cli() was removed in winston@3.0.0', 'Use a custom winston.formats.cli() instead.', 'See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md'].join('\n'));
	    }

	    /**
	     * Bubbles the `event` that occured on the specified `transport` up
	     * from this instance.
	     * @param {string} event - The event that occured
	     * @param {Object} transport - Transport on which the event occured
	     * @private
	     */
	  }, {
	    key: "_onEvent",
	    value: function _onEvent(event, transport) {
	      function transportEvent(err) {
	        // https://github.com/winstonjs/winston/issues/1364
	        if (event === 'error' && !this.transports.includes(transport)) {
	          this.add(transport);
	        }
	        this.emit(event, err, transport);
	      }
	      if (!transport['__winston' + event]) {
	        transport['__winston' + event] = transportEvent.bind(this);
	        transport.on(event, transport['__winston' + event]);
	      }
	    }
	  }, {
	    key: "_addDefaultMeta",
	    value: function _addDefaultMeta(msg) {
	      if (this.defaultMeta) {
	        Object.assign(msg, this.defaultMeta);
	      }
	    }
	  }]);
	}(Transform);
	function getLevelValue(levels, level) {
	  var value = levels[level];
	  if (!value && value !== 0) {
	    return null;
	  }
	  return value;
	}

	/**
	 * Represents the current readableState pipe targets for this Logger instance.
	 * @type {Array|Object}
	 */
	Object.defineProperty(Logger.prototype, 'transports', {
	  configurable: false,
	  enumerable: true,
	  get: function get() {
	    var pipes = this._readableState.pipes;
	    return !Array.isArray(pipes) ? [pipes].filter(Boolean) : pipes;
	  }
	});
	logger = Logger;
	return logger;
}

/**
 * create-logger.js: Logger factory for winston logger instances.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var createLogger;
var hasRequiredCreateLogger;

function requireCreateLogger () {
	if (hasRequiredCreateLogger) return createLogger;
	hasRequiredCreateLogger = 1;

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _createClass(e, r, t) { return Object.defineProperty(e, "prototype", { writable: !1 }), e; }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
	function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
	function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
	function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
	function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
	function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
	var _require = requireTripleBeam(),
	  LEVEL = _require.LEVEL;
	var config = requireConfig();
	var Logger = requireLogger();
	var debug = requireBrowser()('winston:create-logger');
	function isLevelEnabledFunctionName(level) {
	  return 'is' + level.charAt(0).toUpperCase() + level.slice(1) + 'Enabled';
	}

	/**
	 * Create a new instance of a winston Logger. Creates a new
	 * prototype for each instance.
	 * @param {!Object} opts - Options for the created logger.
	 * @returns {Logger} - A newly created logger instance.
	 */
	createLogger = function () {
	  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  //
	  // Default levels: npm
	  //
	  opts.levels = opts.levels || config.npm.levels;

	  /**
	   * DerivedLogger to attach the logs level methods.
	   * @type {DerivedLogger}
	   * @extends {Logger}
	   */
	  var DerivedLogger = /*#__PURE__*/function (_Logger) {
	    /**
	     * Create a new class derived logger for which the levels can be attached to
	     * the prototype of. This is a V8 optimization that is well know to increase
	     * performance of prototype functions.
	     * @param {!Object} options - Options for the created logger.
	     */
	    function DerivedLogger(options) {
	      _classCallCheck(this, DerivedLogger);
	      return _callSuper(this, DerivedLogger, [options]);
	    }
	    _inherits(DerivedLogger, _Logger);
	    return _createClass(DerivedLogger);
	  }(Logger);
	  var logger = new DerivedLogger(opts);

	  //
	  // Create the log level methods for the derived logger.
	  //
	  Object.keys(opts.levels).forEach(function (level) {
	    debug('Define prototype method for "%s"', level);
	    if (level === 'log') {
	      // eslint-disable-next-line no-console
	      console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
	      return;
	    }

	    //
	    // Define prototype methods for each log level e.g.:
	    // logger.log('info', msg) implies these methods are defined:
	    // - logger.info(msg)
	    // - logger.isInfoEnabled()
	    //
	    // Remark: to support logger.child this **MUST** be a function
	    // so it'll always be called on the instance instead of a fixed
	    // place in the prototype chain.
	    //
	    DerivedLogger.prototype[level] = function () {
	      // Prefer any instance scope, but default to "root" logger
	      var self = this || logger;

	      // Optimize the hot-path which is the single object.
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	      if (args.length === 1) {
	        var msg = args[0];
	        var info = msg && msg.message && msg || {
	          message: msg
	        };
	        info.level = info[LEVEL] = level;
	        self._addDefaultMeta(info);
	        self.write(info);
	        return this || logger;
	      }

	      // When provided nothing assume the empty string
	      if (args.length === 0) {
	        self.log(level, '');
	        return self;
	      }

	      // Otherwise build argument list which could potentially conform to
	      // either:
	      // . v3 API: log(obj)
	      // 2. v1/v2 API: log(level, msg, ... [string interpolate], [{metadata}], [callback])
	      return self.log.apply(self, [level].concat(args));
	    };
	    DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function () {
	      return (this || logger).isLevelEnabled(level);
	    };
	  });
	  return logger;
	};
	return createLogger;
}

/**
 * container.js: Inversion of control container for winston logger instances.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var container;
var hasRequiredContainer;

function requireContainer () {
	if (hasRequiredContainer) return container;
	hasRequiredContainer = 1;

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
	function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
	function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(t); }
	var createLogger = requireCreateLogger();

	/**
	 * Inversion of control container for winston logger instances.
	 * @type {Container}
	 */
	container = /*#__PURE__*/function () {
	  /**
	   * Constructor function for the Container object responsible for managing a
	   * set of `winston.Logger` instances based on string ids.
	   * @param {!Object} [options={}] - Default pass-thru options for Loggers.
	   */
	  function Container() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    _classCallCheck(this, Container);
	    this.loggers = new Map();
	    this.options = options;
	  }

	  /**
	   * Retrieves a `winston.Logger` instance for the specified `id`. If an
	   * instance does not exist, one is created.
	   * @param {!string} id - The id of the Logger to get.
	   * @param {?Object} [options] - Options for the Logger instance.
	   * @returns {Logger} - A configured Logger instance with a specified id.
	   */
	  return _createClass(Container, [{
	    key: "add",
	    value: function add(id, options) {
	      var _this = this;
	      if (!this.loggers.has(id)) {
	        // Remark: Simple shallow clone for configuration options in case we pass
	        // in instantiated protoypal objects
	        options = Object.assign({}, options || this.options);
	        var existing = options.transports || this.options.transports;

	        // Remark: Make sure if we have an array of transports we slice it to
	        // make copies of those references.
	        if (existing) {
	          options.transports = Array.isArray(existing) ? existing.slice() : [existing];
	        } else {
	          options.transports = [];
	        }
	        var logger = createLogger(options);
	        logger.on('close', function () {
	          return _this._delete(id);
	        });
	        this.loggers.set(id, logger);
	      }
	      return this.loggers.get(id);
	    }

	    /**
	     * Retreives a `winston.Logger` instance for the specified `id`. If
	     * an instance does not exist, one is created.
	     * @param {!string} id - The id of the Logger to get.
	     * @param {?Object} [options] - Options for the Logger instance.
	     * @returns {Logger} - A configured Logger instance with a specified id.
	     */
	  }, {
	    key: "get",
	    value: function get(id, options) {
	      return this.add(id, options);
	    }

	    /**
	     * Check if the container has a logger with the id.
	     * @param {?string} id - The id of the Logger instance to find.
	     * @returns {boolean} - Boolean value indicating if this instance has a
	     * logger with the specified `id`.
	     */
	  }, {
	    key: "has",
	    value: function has(id) {
	      return !!this.loggers.has(id);
	    }

	    /**
	     * Closes a `Logger` instance with the specified `id` if it exists.
	     * If no `id` is supplied then all Loggers are closed.
	     * @param {?string} id - The id of the Logger instance to close.
	     * @returns {undefined}
	     */
	  }, {
	    key: "close",
	    value: function close(id) {
	      var _this2 = this;
	      if (id) {
	        return this._removeLogger(id);
	      }
	      this.loggers.forEach(function (val, key) {
	        return _this2._removeLogger(key);
	      });
	    }

	    /**
	     * Remove a logger based on the id.
	     * @param {!string} id - The id of the logger to remove.
	     * @returns {undefined}
	     * @private
	     */
	  }, {
	    key: "_removeLogger",
	    value: function _removeLogger(id) {
	      if (!this.loggers.has(id)) {
	        return;
	      }
	      var logger = this.loggers.get(id);
	      logger.close();
	      this._delete(id);
	    }

	    /**
	     * Deletes a `Logger` instance with the specified `id`.
	     * @param {!string} id - The id of the Logger instance to delete from
	     * container.
	     * @returns {undefined}
	     * @private
	     */
	  }, {
	    key: "_delete",
	    value: function _delete(id) {
	      this.loggers["delete"](id);
	    }
	  }]);
	}();
	return container;
}

/**
 * winston.js: Top-level include defining Winston.
 *
 * (C) 2010 Charlie Robbins
 * MIT LICENCE
 */

var hasRequiredWinston;

function requireWinston () {
	if (hasRequiredWinston) return winston$1;
	hasRequiredWinston = 1;
	(function (exports) {

		var logform = requireBrowser$2();
		var _require = requireCommon(),
		  warn = _require.warn;

		/**
		 * Expose version. Use `require` method for `webpack` support.
		 * @type {string}
		 */
		exports.version = require$$2.version;
		/**
		 * Include transports defined by default by winston
		 * @type {Array}
		 */
		exports.transports = requireTransports();
		/**
		 * Expose utility methods
		 * @type {Object}
		 */
		exports.config = requireConfig();
		/**
		 * Hoist format-related functionality from logform.
		 * @type {Object}
		 */
		exports.addColors = logform.levels;
		/**
		 * Hoist format-related functionality from logform.
		 * @type {Object}
		 */
		exports.format = logform.format;
		/**
		 * Expose core Logging-related prototypes.
		 * @type {function}
		 */
		exports.createLogger = requireCreateLogger();
		/**
		 * Expose core Logging-related prototypes.
		 * @type {function}
		 */
		exports.Logger = requireLogger();
		/**
		 * Expose core Logging-related prototypes.
		 * @type {Object}
		 */
		exports.ExceptionHandler = requireExceptionHandler();
		/**
		 * Expose core Logging-related prototypes.
		 * @type {Object}
		 */
		exports.RejectionHandler = requireRejectionHandler();
		/**
		 * Expose core Logging-related prototypes.
		 * @type {Container}
		 */
		exports.Container = requireContainer();
		/**
		 * Expose core Logging-related prototypes.
		 * @type {Object}
		 */
		exports.Transport = requireDist$1();
		/**
		 * We create and expose a default `Container` to `winston.loggers` so that the
		 * programmer may manage multiple `winston.Logger` instances without any
		 * additional overhead.
		 * @example
		 *   // some-file1.js
		 *   const logger = require('winston').loggers.get('something');
		 *
		 *   // some-file2.js
		 *   const logger = require('winston').loggers.get('something');
		 */
		exports.loggers = new exports.Container();

		/**
		 * We create and expose a 'defaultLogger' so that the programmer may do the
		 * following without the need to create an instance of winston.Logger directly:
		 * @example
		 *   const winston = require('winston');
		 *   winston.log('info', 'some message');
		 *   winston.error('some error');
		 */
		var defaultLogger = exports.createLogger();

		// Pass through the target methods onto `winston.
		Object.keys(exports.config.npm.levels).concat(['log', 'query', 'stream', 'add', 'remove', 'clear', 'profile', 'startTimer', 'handleExceptions', 'unhandleExceptions', 'handleRejections', 'unhandleRejections', 'configure', 'child']).forEach(function (method) {
		  return exports[method] = function () {
		    return defaultLogger[method].apply(defaultLogger, arguments);
		  };
		});

		/**
		 * Define getter / setter for the default logger level which need to be exposed
		 * by winston.
		 * @type {string}
		 */
		Object.defineProperty(exports, 'level', {
		  get: function get() {
		    return defaultLogger.level;
		  },
		  set: function set(val) {
		    defaultLogger.level = val;
		  }
		});

		/**
		 * Define getter for `exceptions` which replaces `handleExceptions` and
		 * `unhandleExceptions`.
		 * @type {Object}
		 */
		Object.defineProperty(exports, 'exceptions', {
		  get: function get() {
		    return defaultLogger.exceptions;
		  }
		});

		/**
		 * Define getter for `rejections` which replaces `handleRejections` and
		 * `unhandleRejections`.
		 * @type {Object}
		 */
		Object.defineProperty(exports, 'rejections', {
		  get: function get() {
		    return defaultLogger.rejections;
		  }
		});

		/**
		 * Define getters / setters for appropriate properties of the default logger
		 * which need to be exposed by winston.
		 * @type {Logger}
		 */
		['exitOnError'].forEach(function (prop) {
		  Object.defineProperty(exports, prop, {
		    get: function get() {
		      return defaultLogger[prop];
		    },
		    set: function set(val) {
		      defaultLogger[prop] = val;
		    }
		  });
		});

		/**
		 * The default transports and exceptionHandlers for the default winston logger.
		 * @type {Object}
		 */
		Object.defineProperty(exports, 'default', {
		  get: function get() {
		    return {
		      exceptionHandlers: defaultLogger.exceptionHandlers,
		      rejectionHandlers: defaultLogger.rejectionHandlers,
		      transports: defaultLogger.transports
		    };
		  }
		});

		// Have friendlier breakage notices for properties that were exposed by default
		// on winston < 3.0.
		warn.deprecated(exports, 'setLevels');
		warn.forFunctions(exports, 'useFormat', ['cli']);
		warn.forProperties(exports, 'useFormat', ['padLevels', 'stripColors']);
		warn.forFunctions(exports, 'deprecated', ['addRewriter', 'addFilter', 'clone', 'extend']);
		warn.forProperties(exports, 'deprecated', ['emitErrs', 'levelLength']); 
	} (winston$1));
	return winston$1;
}

var winstonExports = requireWinston();
const winston = /*@__PURE__*/getDefaultExportFromCjs(winstonExports);

async function solveProblem(func, ...args) {
  return new Promise((resolve) => {
    try {
      const result = func(...args);
      resolve(result);
    } catch (e) {
      resolve(void 0);
    }
  });
}
async function solveAsyncProblem(func, ...args) {
  return new Promise((resolve) => {
    func(...args).then((result) => {
      resolve(result);
    }).catch(() => {
      resolve(void 0);
    });
  });
}
class FileNapCatOneBotUUID {
  static encodeModelId(peer, modelId, fileId, fileUUID = "", endString = "") {
    const data = `NapCatOneBot|ModelIdFile|${peer.chatType}|${peer.peerUid}|${modelId}|${fileId}|${fileUUID}`;
    const length = Buffer.alloc(4 + data.length);
    length.writeUInt32BE(data.length * 2, 0);
    length.write(data, 4);
    return length.toString("hex") + endString;
  }
  static decodeModelId(uuid) {
    const length = Buffer.from(uuid.slice(0, 8), "hex").readUInt32BE(0);
    const dataId = uuid.slice(8, 8 + length);
    const realData = Buffer.from(dataId, "hex").toString();
    if (!realData.startsWith("NapCatOneBot|ModelIdFile|")) return void 0;
    const data = realData.split("|");
    if (data.length < 6) return void 0;
    const [, , chatType, peerUid, modelId, fileId, fileUUID = void 0] = data;
    return {
      peer: {
        chatType: +chatType,
        peerUid
      },
      modelId,
      fileId,
      fileUUID
    };
  }
  static encode(peer, msgId, elementId, fileUUID = "", endString = "") {
    const data = `NapCatOneBot|MsgFile|${peer.chatType}|${peer.peerUid}|${msgId}|${elementId}|${fileUUID}`;
    const length = Buffer.alloc(4 + data.length);
    length.writeUInt32BE(data.length * 2, 0);
    length.write(data, 4);
    return length.toString("hex") + endString;
  }
  static decode(uuid) {
    const length = Buffer.from(uuid.slice(0, 8), "hex").readUInt32BE(0);
    const dataId = uuid.slice(8, 8 + length);
    const realData = Buffer.from(dataId, "hex").toString();
    if (!realData.startsWith("NapCatOneBot|MsgFile|")) return void 0;
    const data = realData.split("|");
    if (data.length < 6) return void 0;
    const [, , chatType, peerUid, msgId, elementId, fileUUID = void 0] = data;
    return {
      peer: {
        chatType: +chatType,
        peerUid
      },
      msgId,
      elementId,
      fileUUID
    };
  }
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function isNull(value) {
  return value === void 0 || value === null;
}
function isNumeric(str) {
  return /^\d+$/.test(str);
}
function truncateString(obj, maxLength = 500) {
  if (obj !== null && typeof obj === "object") {
    Object.keys(obj).forEach((key) => {
      if (typeof obj[key] === "string") {
        if (obj[key].length > maxLength) {
          obj[key] = obj[key].substring(0, maxLength) + "...";
        }
      } else if (typeof obj[key] === "object") {
        truncateString(obj[key], maxLength);
      }
    });
  }
  return obj;
}
function getDefaultQQVersionConfigInfo() {
  if (os$1.platform() === "linux") {
    return {
      baseVersion: "3.2.12.28060",
      curVersion: "3.2.12.28060",
      prevVersion: "",
      onErrorVersions: [],
      buildId: "27254"
    };
  }
  if (os$1.platform() === "darwin") {
    return {
      baseVersion: "6.9.53.28060",
      curVersion: "6.9.53.28060",
      prevVersion: "",
      onErrorVersions: [],
      buildId: "28060"
    };
  }
  return {
    baseVersion: "9.9.15-28131",
    curVersion: "9.9.15-28131",
    prevVersion: "",
    onErrorVersions: [],
    buildId: "28131"
  };
}
function getQQPackageInfoPath(exePath = "", version) {
  let packagePath;
  if (os$1.platform() === "darwin") {
    packagePath = path$1.join(path$1.dirname(exePath), "..", "Resources", "app", "package.json");
  } else if (os$1.platform() === "linux") {
    packagePath = path$1.join(path$1.dirname(exePath), "./resources/app/package.json");
  } else {
    packagePath = path$1.join(path$1.dirname(exePath), "./versions/" + version + "/resources/app/package.json");
  }
  if (!fs__default.existsSync(packagePath)) {
    packagePath = path$1.join(path$1.dirname(exePath), "./resources/app/versions/" + version + "/package.json");
  }
  return packagePath;
}
function getQQVersionConfigPath(exePath = "") {
  let configVersionInfoPath;
  if (os$1.platform() === "win32") {
    configVersionInfoPath = path$1.join(path$1.dirname(exePath), "versions", "config.json");
  } else if (os$1.platform() === "darwin") {
    const userPath = os$1.homedir();
    const appDataPath = path$1.resolve(userPath, "./Library/Application Support/QQ");
    configVersionInfoPath = path$1.resolve(appDataPath, "./versions/config.json");
  } else {
    const userPath = os$1.homedir();
    const appDataPath = path$1.resolve(userPath, "./.config/QQ");
    configVersionInfoPath = path$1.resolve(appDataPath, "./versions/config.json");
  }
  if (typeof configVersionInfoPath !== "string") {
    return void 0;
  }
  if (!fs__default.existsSync(configVersionInfoPath)) {
    configVersionInfoPath = path$1.join(path$1.dirname(exePath), "./resources/app/versions/config.json");
  }
  if (!fs__default.existsSync(configVersionInfoPath)) {
    return void 0;
  }
  return configVersionInfoPath;
}
function calcQQLevel(level) {
  if (!level) return 0;
  const { crownNum, sunNum, moonNum, starNum } = level;
  return crownNum * 64 + sunNum * 16 + moonNum * 4 + starNum;
}
function stringifyWithBigInt(obj) {
  return JSON.stringify(
    obj,
    (key, value) => typeof value === "bigint" ? value.toString() : value
  );
}
function parseAppidFromMajor(nodeMajor) {
  const hexSequence = "A4 09 00 00 00 35";
  const sequenceBytes = Buffer.from(hexSequence.replace(/ /g, ""), "hex");
  const filePath = path$1.resolve(nodeMajor);
  const fileContent = fs__default.readFileSync(filePath);
  let searchPosition = 0;
  while (true) {
    const index = fileContent.indexOf(sequenceBytes, searchPosition);
    if (index === -1) {
      break;
    }
    const start = index + sequenceBytes.length - 1;
    const end = fileContent.indexOf(0, start);
    if (end === -1) {
      break;
    }
    const content = fileContent.subarray(start, end);
    if (!content.every((byte) => byte === 0)) {
      try {
        return content.toString("utf-8");
      } catch (error) {
        break;
      }
    }
    searchPosition = end + 1;
  }
  return void 0;
}

var NTSex = /* @__PURE__ */ ((NTSex2) => {
  NTSex2[NTSex2["GENDER_UNKOWN"] = 0] = "GENDER_UNKOWN";
  NTSex2[NTSex2["GENDER_MALE"] = 1] = "GENDER_MALE";
  NTSex2[NTSex2["GENDER_FEMALE"] = 2] = "GENDER_FEMALE";
  NTSex2[NTSex2["GENDER_PRIVACY"] = 255] = "GENDER_PRIVACY";
  return NTSex2;
})(NTSex || {});
var BuddyListReqType = /* @__PURE__ */ ((BuddyListReqType2) => {
  BuddyListReqType2[BuddyListReqType2["KNOMAL"] = 0] = "KNOMAL";
  BuddyListReqType2[BuddyListReqType2["KLETTER"] = 1] = "KLETTER";
  return BuddyListReqType2;
})(BuddyListReqType || {});
var UserDetailSource = /* @__PURE__ */ ((UserDetailSource2) => {
  UserDetailSource2[UserDetailSource2["KDB"] = 0] = "KDB";
  UserDetailSource2[UserDetailSource2["KSERVER"] = 1] = "KSERVER";
  return UserDetailSource2;
})(UserDetailSource || {});
var ProfileBizType = /* @__PURE__ */ ((ProfileBizType2) => {
  ProfileBizType2[ProfileBizType2["KALL"] = 0] = "KALL";
  ProfileBizType2[ProfileBizType2["KBASEEXTEND"] = 1] = "KBASEEXTEND";
  ProfileBizType2[ProfileBizType2["KVAS"] = 2] = "KVAS";
  ProfileBizType2[ProfileBizType2["KQZONE"] = 3] = "KQZONE";
  ProfileBizType2[ProfileBizType2["KOTHER"] = 4] = "KOTHER";
  return ProfileBizType2;
})(ProfileBizType || {});

var GroupInfoSource = /* @__PURE__ */ ((GroupInfoSource2) => {
  GroupInfoSource2[GroupInfoSource2["KUNSPECIFIED"] = 0] = "KUNSPECIFIED";
  GroupInfoSource2[GroupInfoSource2["KBIGDATACARD"] = 1] = "KBIGDATACARD";
  GroupInfoSource2[GroupInfoSource2["KDATACARD"] = 2] = "KDATACARD";
  GroupInfoSource2[GroupInfoSource2["KNOTICE"] = 3] = "KNOTICE";
  GroupInfoSource2[GroupInfoSource2["KAIO"] = 4] = "KAIO";
  GroupInfoSource2[GroupInfoSource2["KRECENTCONTACT"] = 5] = "KRECENTCONTACT";
  GroupInfoSource2[GroupInfoSource2["KMOREPANEL"] = 6] = "KMOREPANEL";
  return GroupInfoSource2;
})(GroupInfoSource || {});
var NTGroupMemberRole = /* @__PURE__ */ ((NTGroupMemberRole2) => {
  NTGroupMemberRole2[NTGroupMemberRole2["KUNSPECIFIED"] = 0] = "KUNSPECIFIED";
  NTGroupMemberRole2[NTGroupMemberRole2["KSTRANGER"] = 1] = "KSTRANGER";
  NTGroupMemberRole2[NTGroupMemberRole2["KMEMBER"] = 2] = "KMEMBER";
  NTGroupMemberRole2[NTGroupMemberRole2["KADMIN"] = 3] = "KADMIN";
  NTGroupMemberRole2[NTGroupMemberRole2["KOWNER"] = 4] = "KOWNER";
  return NTGroupMemberRole2;
})(NTGroupMemberRole || {});

var ElementType = /* @__PURE__ */ ((ElementType2) => {
  ElementType2[ElementType2["UNKNOWN"] = 0] = "UNKNOWN";
  ElementType2[ElementType2["TEXT"] = 1] = "TEXT";
  ElementType2[ElementType2["PIC"] = 2] = "PIC";
  ElementType2[ElementType2["FILE"] = 3] = "FILE";
  ElementType2[ElementType2["PTT"] = 4] = "PTT";
  ElementType2[ElementType2["VIDEO"] = 5] = "VIDEO";
  ElementType2[ElementType2["FACE"] = 6] = "FACE";
  ElementType2[ElementType2["REPLY"] = 7] = "REPLY";
  ElementType2[ElementType2["GreyTip"] = 8] = "GreyTip";
  ElementType2[ElementType2["WALLET"] = 9] = "WALLET";
  ElementType2[ElementType2["ARK"] = 10] = "ARK";
  ElementType2[ElementType2["MFACE"] = 11] = "MFACE";
  ElementType2[ElementType2["LIVEGIFT"] = 12] = "LIVEGIFT";
  ElementType2[ElementType2["STRUCTLONGMSG"] = 13] = "STRUCTLONGMSG";
  ElementType2[ElementType2["MARKDOWN"] = 14] = "MARKDOWN";
  ElementType2[ElementType2["GIPHY"] = 15] = "GIPHY";
  ElementType2[ElementType2["MULTIFORWARD"] = 16] = "MULTIFORWARD";
  ElementType2[ElementType2["INLINEKEYBOARD"] = 17] = "INLINEKEYBOARD";
  ElementType2[ElementType2["INTEXTGIFT"] = 18] = "INTEXTGIFT";
  ElementType2[ElementType2["CALENDAR"] = 19] = "CALENDAR";
  ElementType2[ElementType2["YOLOGAMERESULT"] = 20] = "YOLOGAMERESULT";
  ElementType2[ElementType2["AVRECORD"] = 21] = "AVRECORD";
  ElementType2[ElementType2["FEED"] = 22] = "FEED";
  ElementType2[ElementType2["TOFURECORD"] = 23] = "TOFURECORD";
  ElementType2[ElementType2["ACEBUBBLE"] = 24] = "ACEBUBBLE";
  ElementType2[ElementType2["ACTIVITY"] = 25] = "ACTIVITY";
  ElementType2[ElementType2["TOFU"] = 26] = "TOFU";
  ElementType2[ElementType2["FACEBUBBLE"] = 27] = "FACEBUBBLE";
  ElementType2[ElementType2["SHARELOCATION"] = 28] = "SHARELOCATION";
  ElementType2[ElementType2["TASKTOPMSG"] = 29] = "TASKTOPMSG";
  ElementType2[ElementType2["RECOMMENDEDMSG"] = 43] = "RECOMMENDEDMSG";
  ElementType2[ElementType2["ACTIONBAR"] = 44] = "ACTIONBAR";
  return ElementType2;
})(ElementType || {});
var NTMsgType = /* @__PURE__ */ ((NTMsgType2) => {
  NTMsgType2[NTMsgType2["KMSGTYPEARKSTRUCT"] = 11] = "KMSGTYPEARKSTRUCT";
  NTMsgType2[NTMsgType2["KMSGTYPEFACEBUBBLE"] = 24] = "KMSGTYPEFACEBUBBLE";
  NTMsgType2[NTMsgType2["KMSGTYPEFILE"] = 3] = "KMSGTYPEFILE";
  NTMsgType2[NTMsgType2["KMSGTYPEGIFT"] = 14] = "KMSGTYPEGIFT";
  NTMsgType2[NTMsgType2["KMSGTYPEGIPHY"] = 13] = "KMSGTYPEGIPHY";
  NTMsgType2[NTMsgType2["KMSGTYPEGRAYTIPS"] = 5] = "KMSGTYPEGRAYTIPS";
  NTMsgType2[NTMsgType2["KMSGTYPEMIX"] = 2] = "KMSGTYPEMIX";
  NTMsgType2[NTMsgType2["KMSGTYPEMULTIMSGFORWARD"] = 8] = "KMSGTYPEMULTIMSGFORWARD";
  NTMsgType2[NTMsgType2["KMSGTYPENULL"] = 1] = "KMSGTYPENULL";
  NTMsgType2[NTMsgType2["KMSGTYPEONLINEFILE"] = 21] = "KMSGTYPEONLINEFILE";
  NTMsgType2[NTMsgType2["KMSGTYPEONLINEFOLDER"] = 27] = "KMSGTYPEONLINEFOLDER";
  NTMsgType2[NTMsgType2["KMSGTYPEPROLOGUE"] = 29] = "KMSGTYPEPROLOGUE";
  NTMsgType2[NTMsgType2["KMSGTYPEPTT"] = 6] = "KMSGTYPEPTT";
  NTMsgType2[NTMsgType2["KMSGTYPEREPLY"] = 9] = "KMSGTYPEREPLY";
  NTMsgType2[NTMsgType2["KMSGTYPESHARELOCATION"] = 25] = "KMSGTYPESHARELOCATION";
  NTMsgType2[NTMsgType2["KMSGTYPESTRUCT"] = 4] = "KMSGTYPESTRUCT";
  NTMsgType2[NTMsgType2["KMSGTYPESTRUCTLONGMSG"] = 12] = "KMSGTYPESTRUCTLONGMSG";
  NTMsgType2[NTMsgType2["KMSGTYPETEXTGIFT"] = 15] = "KMSGTYPETEXTGIFT";
  NTMsgType2[NTMsgType2["KMSGTYPEUNKNOWN"] = 0] = "KMSGTYPEUNKNOWN";
  NTMsgType2[NTMsgType2["KMSGTYPEVIDEO"] = 7] = "KMSGTYPEVIDEO";
  NTMsgType2[NTMsgType2["KMSGTYPEWALLET"] = 10] = "KMSGTYPEWALLET";
  return NTMsgType2;
})(NTMsgType || {});
var PicType = /* @__PURE__ */ ((PicType2) => {
  PicType2[PicType2["NEWPIC_APNG"] = 2001] = "NEWPIC_APNG";
  PicType2[PicType2["NEWPIC_BMP"] = 1005] = "NEWPIC_BMP";
  PicType2[PicType2["NEWPIC_GIF"] = 2e3] = "NEWPIC_GIF";
  PicType2[PicType2["NEWPIC_JPEG"] = 1e3] = "NEWPIC_JPEG";
  PicType2[PicType2["NEWPIC_PNG"] = 1001] = "NEWPIC_PNG";
  PicType2[PicType2["NEWPIC_PROGERSSIV_JPEG"] = 1003] = "NEWPIC_PROGERSSIV_JPEG";
  PicType2[PicType2["NEWPIC_SHARPP"] = 1004] = "NEWPIC_SHARPP";
  PicType2[PicType2["NEWPIC_WEBP"] = 1002] = "NEWPIC_WEBP";
  return PicType2;
})(PicType || {});
var NTMsgAtType = /* @__PURE__ */ ((NTMsgAtType2) => {
  NTMsgAtType2[NTMsgAtType2["ATTYPEALL"] = 1] = "ATTYPEALL";
  NTMsgAtType2[NTMsgAtType2["ATTYPECATEGORY"] = 512] = "ATTYPECATEGORY";
  NTMsgAtType2[NTMsgAtType2["ATTYPECHANNEL"] = 16] = "ATTYPECHANNEL";
  NTMsgAtType2[NTMsgAtType2["ATTYPEME"] = 4] = "ATTYPEME";
  NTMsgAtType2[NTMsgAtType2["ATTYPEONE"] = 2] = "ATTYPEONE";
  NTMsgAtType2[NTMsgAtType2["ATTYPEONLINE"] = 64] = "ATTYPEONLINE";
  NTMsgAtType2[NTMsgAtType2["ATTYPEROLE"] = 8] = "ATTYPEROLE";
  NTMsgAtType2[NTMsgAtType2["ATTYPESUMMON"] = 32] = "ATTYPESUMMON";
  NTMsgAtType2[NTMsgAtType2["ATTYPESUMMONONLINE"] = 128] = "ATTYPESUMMONONLINE";
  NTMsgAtType2[NTMsgAtType2["ATTYPESUMMONROLE"] = 256] = "ATTYPESUMMONROLE";
  NTMsgAtType2[NTMsgAtType2["ATTYPEUNKNOWN"] = 0] = "ATTYPEUNKNOWN";
  return NTMsgAtType2;
})(NTMsgAtType || {});
var ChatType = /* @__PURE__ */ ((ChatType2) => {
  ChatType2[ChatType2["KCHATTYPEADELIE"] = 42] = "KCHATTYPEADELIE";
  ChatType2[ChatType2["KCHATTYPEBUDDYNOTIFY"] = 5] = "KCHATTYPEBUDDYNOTIFY";
  ChatType2[ChatType2["KCHATTYPEC2C"] = 1] = "KCHATTYPEC2C";
  ChatType2[ChatType2["KCHATTYPECIRCLE"] = 113] = "KCHATTYPECIRCLE";
  ChatType2[ChatType2["KCHATTYPEDATALINE"] = 8] = "KCHATTYPEDATALINE";
  ChatType2[ChatType2["KCHATTYPEDATALINEMQQ"] = 134] = "KCHATTYPEDATALINEMQQ";
  ChatType2[ChatType2["KCHATTYPEDISC"] = 3] = "KCHATTYPEDISC";
  ChatType2[ChatType2["KCHATTYPEFAV"] = 41] = "KCHATTYPEFAV";
  ChatType2[ChatType2["KCHATTYPEGAMEMESSAGE"] = 105] = "KCHATTYPEGAMEMESSAGE";
  ChatType2[ChatType2["KCHATTYPEGAMEMESSAGEFOLDER"] = 116] = "KCHATTYPEGAMEMESSAGEFOLDER";
  ChatType2[ChatType2["KCHATTYPEGROUP"] = 2] = "KCHATTYPEGROUP";
  ChatType2[ChatType2["KCHATTYPEGROUPBLESS"] = 133] = "KCHATTYPEGROUPBLESS";
  ChatType2[ChatType2["KCHATTYPEGROUPGUILD"] = 9] = "KCHATTYPEGROUPGUILD";
  ChatType2[ChatType2["KCHATTYPEGROUPHELPER"] = 7] = "KCHATTYPEGROUPHELPER";
  ChatType2[ChatType2["KCHATTYPEGROUPNOTIFY"] = 6] = "KCHATTYPEGROUPNOTIFY";
  ChatType2[ChatType2["KCHATTYPEGUILD"] = 4] = "KCHATTYPEGUILD";
  ChatType2[ChatType2["KCHATTYPEGUILDMETA"] = 16] = "KCHATTYPEGUILDMETA";
  ChatType2[ChatType2["KCHATTYPEMATCHFRIEND"] = 104] = "KCHATTYPEMATCHFRIEND";
  ChatType2[ChatType2["KCHATTYPEMATCHFRIENDFOLDER"] = 109] = "KCHATTYPEMATCHFRIENDFOLDER";
  ChatType2[ChatType2["KCHATTYPENEARBY"] = 106] = "KCHATTYPENEARBY";
  ChatType2[ChatType2["KCHATTYPENEARBYASSISTANT"] = 107] = "KCHATTYPENEARBYASSISTANT";
  ChatType2[ChatType2["KCHATTYPENEARBYFOLDER"] = 110] = "KCHATTYPENEARBYFOLDER";
  ChatType2[ChatType2["KCHATTYPENEARBYHELLOFOLDER"] = 112] = "KCHATTYPENEARBYHELLOFOLDER";
  ChatType2[ChatType2["KCHATTYPENEARBYINTERACT"] = 108] = "KCHATTYPENEARBYINTERACT";
  ChatType2[ChatType2["KCHATTYPEQQNOTIFY"] = 132] = "KCHATTYPEQQNOTIFY";
  ChatType2[ChatType2["KCHATTYPERELATEACCOUNT"] = 131] = "KCHATTYPERELATEACCOUNT";
  ChatType2[ChatType2["KCHATTYPESERVICEASSISTANT"] = 118] = "KCHATTYPESERVICEASSISTANT";
  ChatType2[ChatType2["KCHATTYPESERVICEASSISTANTSUB"] = 201] = "KCHATTYPESERVICEASSISTANTSUB";
  ChatType2[ChatType2["KCHATTYPESQUAREPUBLIC"] = 115] = "KCHATTYPESQUAREPUBLIC";
  ChatType2[ChatType2["KCHATTYPESUBSCRIBEFOLDER"] = 30] = "KCHATTYPESUBSCRIBEFOLDER";
  ChatType2[ChatType2["KCHATTYPETEMPADDRESSBOOK"] = 111] = "KCHATTYPETEMPADDRESSBOOK";
  ChatType2[ChatType2["KCHATTYPETEMPBUSSINESSCRM"] = 102] = "KCHATTYPETEMPBUSSINESSCRM";
  ChatType2[ChatType2["KCHATTYPETEMPC2CFROMGROUP"] = 100] = "KCHATTYPETEMPC2CFROMGROUP";
  ChatType2[ChatType2["KCHATTYPETEMPC2CFROMUNKNOWN"] = 99] = "KCHATTYPETEMPC2CFROMUNKNOWN";
  ChatType2[ChatType2["KCHATTYPETEMPFRIENDVERIFY"] = 101] = "KCHATTYPETEMPFRIENDVERIFY";
  ChatType2[ChatType2["KCHATTYPETEMPNEARBYPRO"] = 119] = "KCHATTYPETEMPNEARBYPRO";
  ChatType2[ChatType2["KCHATTYPETEMPPUBLICACCOUNT"] = 103] = "KCHATTYPETEMPPUBLICACCOUNT";
  ChatType2[ChatType2["KCHATTYPETEMPWPA"] = 117] = "KCHATTYPETEMPWPA";
  ChatType2[ChatType2["KCHATTYPEUNKNOWN"] = 0] = "KCHATTYPEUNKNOWN";
  ChatType2[ChatType2["KCHATTYPEWEIYUN"] = 40] = "KCHATTYPEWEIYUN";
  return ChatType2;
})(ChatType || {});
var NTGrayTipElementSubTypeV2 = /* @__PURE__ */ ((NTGrayTipElementSubTypeV22) => {
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_AIOOP"] = 15] = "GRAYTIP_ELEMENT_SUBTYPE_AIOOP";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_BLOCK"] = 14] = "GRAYTIP_ELEMENT_SUBTYPE_BLOCK";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_BUDDY"] = 5] = "GRAYTIP_ELEMENT_SUBTYPE_BUDDY";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_BUDDYNOTIFY"] = 9] = "GRAYTIP_ELEMENT_SUBTYPE_BUDDYNOTIFY";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_EMOJIREPLY"] = 3] = "GRAYTIP_ELEMENT_SUBTYPE_EMOJIREPLY";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_ESSENCE"] = 7] = "GRAYTIP_ELEMENT_SUBTYPE_ESSENCE";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_FEED"] = 6] = "GRAYTIP_ELEMENT_SUBTYPE_FEED";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_FEEDCHANNELMSG"] = 11] = "GRAYTIP_ELEMENT_SUBTYPE_FEEDCHANNELMSG";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_FILE"] = 10] = "GRAYTIP_ELEMENT_SUBTYPE_FILE";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_GROUP"] = 4] = "GRAYTIP_ELEMENT_SUBTYPE_GROUP";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_GROUPNOTIFY"] = 8] = "GRAYTIP_ELEMENT_SUBTYPE_GROUPNOTIFY";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_JSON"] = 17] = "GRAYTIP_ELEMENT_SUBTYPE_JSON";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_LOCALMSG"] = 13] = "GRAYTIP_ELEMENT_SUBTYPE_LOCALMSG";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_PROCLAMATION"] = 2] = "GRAYTIP_ELEMENT_SUBTYPE_PROCLAMATION";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_REVOKE"] = 1] = "GRAYTIP_ELEMENT_SUBTYPE_REVOKE";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_UNKNOWN"] = 0] = "GRAYTIP_ELEMENT_SUBTYPE_UNKNOWN";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_WALLET"] = 16] = "GRAYTIP_ELEMENT_SUBTYPE_WALLET";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_XMLMSG"] = 12] = "GRAYTIP_ELEMENT_SUBTYPE_XMLMSG";
  return NTGrayTipElementSubTypeV22;
})(NTGrayTipElementSubTypeV2 || {});
var FaceIndex = /* @__PURE__ */ ((FaceIndex2) => {
  FaceIndex2[FaceIndex2["DICE"] = 358] = "DICE";
  FaceIndex2[FaceIndex2["RPS"] = 359] = "RPS";
  return FaceIndex2;
})(FaceIndex || {});
var SendStatusType = /* @__PURE__ */ ((SendStatusType2) => {
  SendStatusType2[SendStatusType2["KSEND_STATUS_FAILED"] = 0] = "KSEND_STATUS_FAILED";
  SendStatusType2[SendStatusType2["KSEND_STATUS_SENDING"] = 1] = "KSEND_STATUS_SENDING";
  SendStatusType2[SendStatusType2["KSEND_STATUS_SUCCESS"] = 2] = "KSEND_STATUS_SUCCESS";
  SendStatusType2[SendStatusType2["KSEND_STATUS_SUCCESS_NOSEQ"] = 3] = "KSEND_STATUS_SUCCESS_NOSEQ";
  return SendStatusType2;
})(SendStatusType || {});
var FaceType = /* @__PURE__ */ ((FaceType2) => {
  FaceType2[FaceType2["Unknown"] = 0] = "Unknown";
  FaceType2[FaceType2["OldFace"] = 1] = "OldFace";
  FaceType2[FaceType2["Normal"] = 2] = "Normal";
  FaceType2[FaceType2["AniSticke"] = 3] = "AniSticke";
  FaceType2[FaceType2["Lottie"] = 4] = "Lottie";
  FaceType2[FaceType2["Poke"] = 5] = "Poke";
  return FaceType2;
})(FaceType || {});

var GroupNotifyMsgType = /* @__PURE__ */ ((GroupNotifyMsgType2) => {
  GroupNotifyMsgType2[GroupNotifyMsgType2["UN_SPECIFIED"] = 0] = "UN_SPECIFIED";
  GroupNotifyMsgType2[GroupNotifyMsgType2["INVITED_BY_MEMBER"] = 1] = "INVITED_BY_MEMBER";
  GroupNotifyMsgType2[GroupNotifyMsgType2["REFUSE_INVITED"] = 2] = "REFUSE_INVITED";
  GroupNotifyMsgType2[GroupNotifyMsgType2["REFUSED_BY_ADMINI_STRATOR"] = 3] = "REFUSED_BY_ADMINI_STRATOR";
  GroupNotifyMsgType2[GroupNotifyMsgType2["AGREED_TOJOIN_DIRECT"] = 4] = "AGREED_TOJOIN_DIRECT";
  GroupNotifyMsgType2[GroupNotifyMsgType2["INVITED_NEED_ADMINI_STRATOR_PASS"] = 5] = "INVITED_NEED_ADMINI_STRATOR_PASS";
  GroupNotifyMsgType2[GroupNotifyMsgType2["AGREED_TO_JOIN_BY_ADMINI_STRATOR"] = 6] = "AGREED_TO_JOIN_BY_ADMINI_STRATOR";
  GroupNotifyMsgType2[GroupNotifyMsgType2["REQUEST_JOIN_NEED_ADMINI_STRATOR_PASS"] = 7] = "REQUEST_JOIN_NEED_ADMINI_STRATOR_PASS";
  GroupNotifyMsgType2[GroupNotifyMsgType2["SET_ADMIN"] = 8] = "SET_ADMIN";
  GroupNotifyMsgType2[GroupNotifyMsgType2["KICK_MEMBER_NOTIFY_ADMIN"] = 9] = "KICK_MEMBER_NOTIFY_ADMIN";
  GroupNotifyMsgType2[GroupNotifyMsgType2["KICK_MEMBER_NOTIFY_KICKED"] = 10] = "KICK_MEMBER_NOTIFY_KICKED";
  GroupNotifyMsgType2[GroupNotifyMsgType2["MEMBER_LEAVE_NOTIFY_ADMIN"] = 11] = "MEMBER_LEAVE_NOTIFY_ADMIN";
  GroupNotifyMsgType2[GroupNotifyMsgType2["CANCEL_ADMIN_NOTIFY_CANCELED"] = 12] = "CANCEL_ADMIN_NOTIFY_CANCELED";
  GroupNotifyMsgType2[GroupNotifyMsgType2["CANCEL_ADMIN_NOTIFY_ADMIN"] = 13] = "CANCEL_ADMIN_NOTIFY_ADMIN";
  GroupNotifyMsgType2[GroupNotifyMsgType2["TRANSFER_GROUP_NOTIFY_OLDOWNER"] = 14] = "TRANSFER_GROUP_NOTIFY_OLDOWNER";
  GroupNotifyMsgType2[GroupNotifyMsgType2["TRANSFER_GROUP_NOTIFY_ADMIN"] = 15] = "TRANSFER_GROUP_NOTIFY_ADMIN";
  return GroupNotifyMsgType2;
})(GroupNotifyMsgType || {});
var GroupNotifyMsgStatus = /* @__PURE__ */ ((GroupNotifyMsgStatus2) => {
  GroupNotifyMsgStatus2[GroupNotifyMsgStatus2["KINIT"] = 0] = "KINIT";
  GroupNotifyMsgStatus2[GroupNotifyMsgStatus2["KUNHANDLE"] = 1] = "KUNHANDLE";
  GroupNotifyMsgStatus2[GroupNotifyMsgStatus2["KAGREED"] = 2] = "KAGREED";
  GroupNotifyMsgStatus2[GroupNotifyMsgStatus2["KREFUSED"] = 3] = "KREFUSED";
  GroupNotifyMsgStatus2[GroupNotifyMsgStatus2["KIGNORED"] = 4] = "KIGNORED";
  return GroupNotifyMsgStatus2;
})(GroupNotifyMsgStatus || {});
var NTGroupRequestOperateTypes = /* @__PURE__ */ ((NTGroupRequestOperateTypes2) => {
  NTGroupRequestOperateTypes2[NTGroupRequestOperateTypes2["KUNSPECIFIED"] = 0] = "KUNSPECIFIED";
  NTGroupRequestOperateTypes2[NTGroupRequestOperateTypes2["KAGREE"] = 1] = "KAGREE";
  NTGroupRequestOperateTypes2[NTGroupRequestOperateTypes2["KREFUSE"] = 2] = "KREFUSE";
  NTGroupRequestOperateTypes2[NTGroupRequestOperateTypes2["KIGNORE"] = 3] = "KIGNORE";
  NTGroupRequestOperateTypes2[NTGroupRequestOperateTypes2["KDELETE"] = 4] = "KDELETE";
  return NTGroupRequestOperateTypes2;
})(NTGroupRequestOperateTypes || {});
var BuddyReqType = /* @__PURE__ */ ((BuddyReqType2) => {
  BuddyReqType2[BuddyReqType2["KMEINITIATOR"] = 0] = "KMEINITIATOR";
  BuddyReqType2[BuddyReqType2["KPEERINITIATOR"] = 1] = "KPEERINITIATOR";
  BuddyReqType2[BuddyReqType2["KMEAGREED"] = 2] = "KMEAGREED";
  BuddyReqType2[BuddyReqType2["KMEAGREEDANDADDED"] = 3] = "KMEAGREEDANDADDED";
  BuddyReqType2[BuddyReqType2["KPEERAGREED"] = 4] = "KPEERAGREED";
  BuddyReqType2[BuddyReqType2["KPEERAGREEDANDADDED"] = 5] = "KPEERAGREEDANDADDED";
  BuddyReqType2[BuddyReqType2["KPEERREFUSED"] = 6] = "KPEERREFUSED";
  BuddyReqType2[BuddyReqType2["KMEREFUSED"] = 7] = "KMEREFUSED";
  BuddyReqType2[BuddyReqType2["KMEIGNORED"] = 8] = "KMEIGNORED";
  BuddyReqType2[BuddyReqType2["KMEAGREEANYONE"] = 9] = "KMEAGREEANYONE";
  BuddyReqType2[BuddyReqType2["KMESETQUESTION"] = 10] = "KMESETQUESTION";
  BuddyReqType2[BuddyReqType2["KMEAGREEANDADDFAILED"] = 11] = "KMEAGREEANDADDFAILED";
  BuddyReqType2[BuddyReqType2["KMSGINFO"] = 12] = "KMSGINFO";
  BuddyReqType2[BuddyReqType2["KMEINITIATORWAITPEERCONFIRM"] = 13] = "KMEINITIATORWAITPEERCONFIRM";
  return BuddyReqType2;
})(BuddyReqType || {});
var MemberExtSourceType = /* @__PURE__ */ ((MemberExtSourceType2) => {
  MemberExtSourceType2[MemberExtSourceType2["DEFAULTTYPE"] = 0] = "DEFAULTTYPE";
  MemberExtSourceType2[MemberExtSourceType2["TITLETYPE"] = 1] = "TITLETYPE";
  MemberExtSourceType2[MemberExtSourceType2["NEWGROUPTYPE"] = 2] = "NEWGROUPTYPE";
  return MemberExtSourceType2;
})(MemberExtSourceType || {});

var WebHonorType = /* @__PURE__ */ ((WebHonorType2) => {
  WebHonorType2["ALL"] = "all";
  WebHonorType2["TALKATIVE"] = "talkative";
  WebHonorType2["PERFORMER"] = "performer";
  WebHonorType2["LEGEND"] = "legend";
  WebHonorType2["STRONG_NEWBIE"] = "strong_newbie";
  WebHonorType2["EMOTION"] = "emotion";
  return WebHonorType2;
})(WebHonorType || {});

const IMAGE_HTTP_HOST = "https://gchat.qpic.cn";
const IMAGE_HTTP_HOST_NT = "https://multimedia.nt.qq.com.cn";

var JsonGrayBusiId = /* @__PURE__ */ ((JsonGrayBusiId2) => {
  JsonGrayBusiId2[JsonGrayBusiId2["AIO_AV_C2C_NOTICE"] = 2021] = "AIO_AV_C2C_NOTICE";
  JsonGrayBusiId2[JsonGrayBusiId2["AIO_AV_GROUP_NOTICE"] = 2022] = "AIO_AV_GROUP_NOTICE";
  JsonGrayBusiId2[JsonGrayBusiId2["AIO_C2C_DONT_DISTURB"] = 2100] = "AIO_C2C_DONT_DISTURB";
  JsonGrayBusiId2[JsonGrayBusiId2["AIO_CRM_FLAGS_TIPS"] = 2050] = "AIO_CRM_FLAGS_TIPS";
  JsonGrayBusiId2[JsonGrayBusiId2["AIO_GROUP_ESSENCE_MSG_TIP"] = 2401] = "AIO_GROUP_ESSENCE_MSG_TIP";
  JsonGrayBusiId2[JsonGrayBusiId2["AIO_NUDGE_CUSTOM_GUIDE"] = 2041] = "AIO_NUDGE_CUSTOM_GUIDE";
  JsonGrayBusiId2[JsonGrayBusiId2["AIO_PUSH_GUIDE_GRAY_TIPS"] = 2701] = "AIO_PUSH_GUIDE_GRAY_TIPS";
  JsonGrayBusiId2[JsonGrayBusiId2["AIO_RECALL_MSGCUSTOM_WORDINGGUIDE"] = 2e3] = "AIO_RECALL_MSGCUSTOM_WORDINGGUIDE";
  JsonGrayBusiId2[JsonGrayBusiId2["AIO_ROBOT_SAFETY_TIP"] = 2201] = "AIO_ROBOT_SAFETY_TIP";
  JsonGrayBusiId2[JsonGrayBusiId2["AIO_ZPLAN_EMOTICON_GUIDE"] = 2301] = "AIO_ZPLAN_EMOTICON_GUIDE";
  JsonGrayBusiId2[JsonGrayBusiId2["AIO_ZPLAN_SCENE_LINKAGE"] = 2302] = "AIO_ZPLAN_SCENE_LINKAGE";
  JsonGrayBusiId2[JsonGrayBusiId2["AIO_ZPLAN_SEND_MEME"] = 2300] = "AIO_ZPLAN_SEND_MEME";
  JsonGrayBusiId2[JsonGrayBusiId2["DISBAND_DISCUSSION_GRAY_TIP_ID"] = 2603] = "DISBAND_DISCUSSION_GRAY_TIP_ID";
  JsonGrayBusiId2[JsonGrayBusiId2["FILE_SENDING_SIZE_4GB_LIMIT"] = 3003] = "FILE_SENDING_SIZE_4GB_LIMIT";
  JsonGrayBusiId2[JsonGrayBusiId2["GROUP_AIO_CONFIGURABLE_GRAY_TIPS"] = 2407] = "GROUP_AIO_CONFIGURABLE_GRAY_TIPS";
  JsonGrayBusiId2[JsonGrayBusiId2["GROUP_AIO_HOME_SCHOOL_WELCOME_GRAY_TIP_ID"] = 2404] = "GROUP_AIO_HOME_SCHOOL_WELCOME_GRAY_TIP_ID";
  JsonGrayBusiId2[JsonGrayBusiId2["GROUP_AIO_MSG_FREQUENCY_GRAY_TIP_ID"] = 2406] = "GROUP_AIO_MSG_FREQUENCY_GRAY_TIP_ID";
  JsonGrayBusiId2[JsonGrayBusiId2["GROUP_AIO_SHUTUP_GRAY_TIP_ID"] = 2402] = "GROUP_AIO_SHUTUP_GRAY_TIP_ID";
  JsonGrayBusiId2[JsonGrayBusiId2["GROUP_AIO_TEMPORARY_GRAY_TIP_ID"] = 2405] = "GROUP_AIO_TEMPORARY_GRAY_TIP_ID";
  JsonGrayBusiId2[JsonGrayBusiId2["GROUP_AIO_UNREAD_MSG_AI_SUMMARY"] = 2408] = "GROUP_AIO_UNREAD_MSG_AI_SUMMARY";
  JsonGrayBusiId2[JsonGrayBusiId2["GROUP_AIO_UPLOAD_PERMISSIONS_GRAY_TIP_ID"] = 2403] = "GROUP_AIO_UPLOAD_PERMISSIONS_GRAY_TIP_ID";
  JsonGrayBusiId2[JsonGrayBusiId2["LITE_ACTION"] = 86] = "LITE_ACTION";
  JsonGrayBusiId2[JsonGrayBusiId2["ONLINE_FILE_CANCEL_RECV_ON_RECVING"] = 4] = "ONLINE_FILE_CANCEL_RECV_ON_RECVING";
  JsonGrayBusiId2[JsonGrayBusiId2["ONLINE_FILE_GO_OFFLINE"] = 11] = "ONLINE_FILE_GO_OFFLINE";
  JsonGrayBusiId2[JsonGrayBusiId2["ONLINE_FILE_GO_OFFLINE_ALL"] = 12] = "ONLINE_FILE_GO_OFFLINE_ALL";
  JsonGrayBusiId2[JsonGrayBusiId2["ONLINE_FILE_RECV_BY_MOBILE"] = 13] = "ONLINE_FILE_RECV_BY_MOBILE";
  JsonGrayBusiId2[JsonGrayBusiId2["ONLINE_FILE_RECV_ERROR"] = 10] = "ONLINE_FILE_RECV_ERROR";
  JsonGrayBusiId2[JsonGrayBusiId2["ONLINE_FILE_REFUSE_ALL_RECV"] = 7] = "ONLINE_FILE_REFUSE_ALL_RECV";
  JsonGrayBusiId2[JsonGrayBusiId2["ONLINE_FILE_REFUSE_ALL_RECV_ON_RECVING"] = 8] = "ONLINE_FILE_REFUSE_ALL_RECV_ON_RECVING";
  JsonGrayBusiId2[JsonGrayBusiId2["ONLINE_FILE_REFUSE_RECV"] = 3] = "ONLINE_FILE_REFUSE_RECV";
  JsonGrayBusiId2[JsonGrayBusiId2["ONLINE_FILE_SEND_ERROR"] = 9] = "ONLINE_FILE_SEND_ERROR";
  JsonGrayBusiId2[JsonGrayBusiId2["ONLINE_FILE_STOP_ALL_SEND"] = 5] = "ONLINE_FILE_STOP_ALL_SEND";
  JsonGrayBusiId2[JsonGrayBusiId2["ONLINE_FILE_STOP_ALL_SEND_ON_SENDING"] = 6] = "ONLINE_FILE_STOP_ALL_SEND_ON_SENDING";
  JsonGrayBusiId2[JsonGrayBusiId2["ONLINE_FILE_STOP_SEND"] = 1] = "ONLINE_FILE_STOP_SEND";
  JsonGrayBusiId2[JsonGrayBusiId2["ONLINE_FILE_STOP_SEND_ON_SENDING"] = 2] = "ONLINE_FILE_STOP_SEND_ON_SENDING";
  JsonGrayBusiId2[JsonGrayBusiId2["ONLINE_GROUP_HOME_WORK"] = 51] = "ONLINE_GROUP_HOME_WORK";
  JsonGrayBusiId2[JsonGrayBusiId2["PTT_AUTO_CHANGE_GUIDE"] = 2060] = "PTT_AUTO_CHANGE_GUIDE";
  JsonGrayBusiId2[JsonGrayBusiId2["QCIRCLE_SHOW_FULE_TIPS"] = 2601] = "QCIRCLE_SHOW_FULE_TIPS";
  JsonGrayBusiId2[JsonGrayBusiId2["QWALLET_GRAY_TIP_ID"] = 2602] = "QWALLET_GRAY_TIP_ID";
  JsonGrayBusiId2[JsonGrayBusiId2["RED_BAG"] = 81] = "RED_BAG";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_C2C_GROUP_AIO_SETUP_GROUP_AND_REMARK"] = 1005] = "RELATION_C2C_GROUP_AIO_SETUP_GROUP_AND_REMARK";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_C2C_LOVER_BONUS"] = 1003] = "RELATION_C2C_LOVER_BONUS";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_C2C_MEMBER_ADD"] = 1017] = "RELATION_C2C_MEMBER_ADD";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_C2C_REACTIVE_DEGRADE_MSG"] = 1019] = "RELATION_C2C_REACTIVE_DEGRADE_MSG";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_C2C_REACTIVE_UPGRADE_MSG"] = 1018] = "RELATION_C2C_REACTIVE_UPGRADE_MSG";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_C2C_SAY_HELLO"] = 1004] = "RELATION_C2C_SAY_HELLO";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_CHAIN_BLACKED"] = 1e3] = "RELATION_CHAIN_BLACKED";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_CHAIN_MATCH_FRIEND"] = 1007] = "RELATION_CHAIN_MATCH_FRIEND";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_CREATE_GROUP_GRAY_TIP_ID"] = 1009] = "RELATION_CREATE_GROUP_GRAY_TIP_ID";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_EMOJIEGG_SHOW"] = 1001] = "RELATION_EMOJIEGG_SHOW";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_EMOJIEGG_WILL_DEGRADE"] = 1002] = "RELATION_EMOJIEGG_WILL_DEGRADE";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_FRIEND_CLONE_INFO"] = 1006] = "RELATION_FRIEND_CLONE_INFO";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_GROUP_BATCH_ADD_FRIEND"] = 1020] = "RELATION_GROUP_BATCH_ADD_FRIEND";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_GROUP_MEMBER_ADD"] = 1022] = "RELATION_GROUP_MEMBER_ADD";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_GROUP_MEMBER_ADD_WITH_MODIFY_NAME"] = 1015] = "RELATION_GROUP_MEMBER_ADD_WITH_MODIFY_NAME";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_GROUP_MEMBER_ADD_WITH_WELCOME"] = 1016] = "RELATION_GROUP_MEMBER_ADD_WITH_WELCOME";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_GROUP_MEMBER_RECOMMEND"] = 1021] = "RELATION_GROUP_MEMBER_RECOMMEND";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_GROUP_SHUT_UP"] = 1014] = "RELATION_GROUP_SHUT_UP";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_LIMIT_TMP_CONVERSATION_SET"] = 1011] = "RELATION_LIMIT_TMP_CONVERSATION_SET";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_NEARBY_GOTO_VERIFY"] = 1008] = "RELATION_NEARBY_GOTO_VERIFY";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_ONEWAY_FRIEND_GRAY_TIP_ID"] = 1012] = "RELATION_ONEWAY_FRIEND_GRAY_TIP_ID";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_ONEWAY_FRIEND_NEW_GRAY_TIP_ID"] = 1013] = "RELATION_ONEWAY_FRIEND_NEW_GRAY_TIP_ID";
  JsonGrayBusiId2[JsonGrayBusiId2["RELATION_YQT"] = 1010] = "RELATION_YQT";
  JsonGrayBusiId2[JsonGrayBusiId2["TROOP_ADD_FRIEND_ACTIVE"] = 19264] = "TROOP_ADD_FRIEND_ACTIVE";
  JsonGrayBusiId2[JsonGrayBusiId2["TROOP_ADD_FRIEND_HOT_CHAT"] = 19265] = "TROOP_ADD_FRIEND_HOT_CHAT";
  JsonGrayBusiId2[JsonGrayBusiId2["TROOP_ADD_FRIEND_NEW_MEMBER"] = 19267] = "TROOP_ADD_FRIEND_NEW_MEMBER";
  JsonGrayBusiId2[JsonGrayBusiId2["TROOP_ADD_FRIEND_REPLY_OR_AT"] = 19266] = "TROOP_ADD_FRIEND_REPLY_OR_AT";
  JsonGrayBusiId2[JsonGrayBusiId2["TROOP_BREAK_ICE"] = 10405] = "TROOP_BREAK_ICE";
  JsonGrayBusiId2[JsonGrayBusiId2["TROOP_FLAME_IGNITED"] = 19273] = "TROOP_FLAME_IGNITED";
  JsonGrayBusiId2[JsonGrayBusiId2["UI_RESERVE_100000_110000"] = 1e5] = "UI_RESERVE_100000_110000";
  JsonGrayBusiId2[JsonGrayBusiId2["VAS_FILE_UPLOAD_OVER_1G"] = 3002] = "VAS_FILE_UPLOAD_OVER_1G";
  JsonGrayBusiId2[JsonGrayBusiId2["VAS_FILE_UPLOAD_OVER_LIMIT"] = 3001] = "VAS_FILE_UPLOAD_OVER_LIMIT";
  return JsonGrayBusiId2;
})(JsonGrayBusiId || {});

const defaultMessages = 'End-Of-Stream';
/**
 * Thrown on read operation of the end of file or stream has been reached
 */
class EndOfStreamError extends Error {
    constructor() {
        super(defaultMessages);
    }
}

class Deferred {
    constructor() {
        this.resolve = () => null;
        this.reject = () => null;
        this.promise = new Promise((resolve, reject) => {
            this.reject = reject;
            this.resolve = resolve;
        });
    }
}

class AbstractStreamReader {
    constructor() {
        /**
         * Maximum request length on read-stream operation
         */
        this.maxStreamReadSize = 1 * 1024 * 1024;
        this.endOfStream = false;
        /**
         * Store peeked data
         * @type {Array}
         */
        this.peekQueue = [];
    }
    async peek(uint8Array, offset, length) {
        const bytesRead = await this.read(uint8Array, offset, length);
        this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer
        return bytesRead;
    }
    async read(buffer, offset, length) {
        if (length === 0) {
            return 0;
        }
        let bytesRead = this.readFromPeekBuffer(buffer, offset, length);
        bytesRead += await this.readRemainderFromStream(buffer, offset + bytesRead, length - bytesRead);
        if (bytesRead === 0) {
            throw new EndOfStreamError();
        }
        return bytesRead;
    }
    /**
     * Read chunk from stream
     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
     * @param offset - Offset target
     * @param length - Number of bytes to read
     * @returns Number of bytes read
     */
    readFromPeekBuffer(buffer, offset, length) {
        let remaining = length;
        let bytesRead = 0;
        // consume peeked data first
        while (this.peekQueue.length > 0 && remaining > 0) {
            const peekData = this.peekQueue.pop(); // Front of queue
            if (!peekData)
                throw new Error('peekData should be defined');
            const lenCopy = Math.min(peekData.length, remaining);
            buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
            bytesRead += lenCopy;
            remaining -= lenCopy;
            if (lenCopy < peekData.length) {
                // remainder back to queue
                this.peekQueue.push(peekData.subarray(lenCopy));
            }
        }
        return bytesRead;
    }
    async readRemainderFromStream(buffer, offset, initialRemaining) {
        let remaining = initialRemaining;
        let bytesRead = 0;
        // Continue reading from stream if required
        while (remaining > 0 && !this.endOfStream) {
            const reqLen = Math.min(remaining, this.maxStreamReadSize);
            const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
            if (chunkLen === 0)
                break;
            bytesRead += chunkLen;
            remaining -= chunkLen;
        }
        return bytesRead;
    }
}

/**
 * Node.js Readable Stream Reader
 * Ref: https://nodejs.org/api/stream.html#readable-streams
 */
class StreamReader extends AbstractStreamReader {
    constructor(s) {
        super();
        this.s = s;
        /**
         * Deferred used for postponed read request (as not data is yet available to read)
         */
        this.deferred = null;
        if (!s.read || !s.once) {
            throw new Error('Expected an instance of stream.Readable');
        }
        this.s.once('end', () => this.reject(new EndOfStreamError()));
        this.s.once('error', err => this.reject(err));
        this.s.once('close', () => this.reject(new Error('Stream closed')));
    }
    /**
     * Read chunk from stream
     * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
     * @param offset Offset target
     * @param length Number of bytes to read
     * @returns Number of bytes read
     */
    async readFromStream(buffer, offset, length) {
        if (this.endOfStream) {
            return 0;
        }
        const readBuffer = this.s.read(length);
        if (readBuffer) {
            buffer.set(readBuffer, offset);
            return readBuffer.length;
        }
        const request = {
            buffer,
            offset,
            length,
            deferred: new Deferred()
        };
        this.deferred = request.deferred;
        this.s.once('readable', () => {
            this.readDeferred(request);
        });
        return request.deferred.promise;
    }
    /**
     * Process deferred read request
     * @param request Deferred read request
     */
    readDeferred(request) {
        const readBuffer = this.s.read(request.length);
        if (readBuffer) {
            request.buffer.set(readBuffer, request.offset);
            request.deferred.resolve(readBuffer.length);
            this.deferred = null;
        }
        else {
            this.s.once('readable', () => {
                this.readDeferred(request);
            });
        }
    }
    reject(err) {
        this.endOfStream = true;
        if (this.deferred) {
            this.deferred.reject(err);
            this.deferred = null;
        }
    }
    async abort() {
        this.s.destroy();
    }
}

/**
 * Read from a WebStream
 * Reference: https://nodejs.org/api/webstreams.html#class-readablestreambyobreader
 */
class WebStreamReader extends AbstractStreamReader {
    constructor(stream) {
        super();
        this.reader = stream.getReader({ mode: 'byob' });
    }
    async readFromStream(buffer, offset, length) {
        if (this.endOfStream) {
            throw new EndOfStreamError();
        }
        const result = await this.reader.read(new Uint8Array(length));
        if (result.done) {
            this.endOfStream = result.done;
        }
        if (result.value) {
            buffer.set(result.value, offset);
            return result.value.byteLength;
        }
        return 0;
    }
    async abort() {
        await this.reader.cancel(); // Signals a loss of interest in the stream by a consumer
        this.reader.releaseLock();
    }
}

/**
 * Core tokenizer
 */
class AbstractTokenizer {
    /**
     * Constructor
     * @param options Tokenizer options
     * @protected
     */
    constructor(options) {
        this.numBuffer = new Uint8Array(8);
        /**
         * Tokenizer-stream position
         */
        this.position = 0;
        this.onClose = options?.onClose;
        if (options?.abortSignal) {
            options.abortSignal.addEventListener('abort', () => {
                this.abort();
            });
        }
    }
    /**
     * Read a token from the tokenizer-stream
     * @param token - The token to read
     * @param position - If provided, the desired position in the tokenizer-stream
     * @returns Promise with token data
     */
    async readToken(token, position = this.position) {
        const uint8Array = new Uint8Array(token.len);
        const len = await this.readBuffer(uint8Array, { position });
        if (len < token.len)
            throw new EndOfStreamError();
        return token.get(uint8Array, 0);
    }
    /**
     * Peek a token from the tokenizer-stream.
     * @param token - Token to peek from the tokenizer-stream.
     * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
     * @returns Promise with token data
     */
    async peekToken(token, position = this.position) {
        const uint8Array = new Uint8Array(token.len);
        const len = await this.peekBuffer(uint8Array, { position });
        if (len < token.len)
            throw new EndOfStreamError();
        return token.get(uint8Array, 0);
    }
    /**
     * Read a numeric token from the stream
     * @param token - Numeric token
     * @returns Promise with number
     */
    async readNumber(token) {
        const len = await this.readBuffer(this.numBuffer, { length: token.len });
        if (len < token.len)
            throw new EndOfStreamError();
        return token.get(this.numBuffer, 0);
    }
    /**
     * Read a numeric token from the stream
     * @param token - Numeric token
     * @returns Promise with number
     */
    async peekNumber(token) {
        const len = await this.peekBuffer(this.numBuffer, { length: token.len });
        if (len < token.len)
            throw new EndOfStreamError();
        return token.get(this.numBuffer, 0);
    }
    /**
     * Ignore number of bytes, advances the pointer in under tokenizer-stream.
     * @param length - Number of bytes to ignore
     * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
     */
    async ignore(length) {
        if (this.fileInfo.size !== undefined) {
            const bytesLeft = this.fileInfo.size - this.position;
            if (length > bytesLeft) {
                this.position += bytesLeft;
                return bytesLeft;
            }
        }
        this.position += length;
        return length;
    }
    async close() {
        await this.abort();
        await this.onClose?.();
    }
    normalizeOptions(uint8Array, options) {
        if (options && options.position !== undefined && options.position < this.position) {
            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
        }
        if (options) {
            return {
                mayBeLess: options.mayBeLess === true,
                offset: options.offset ? options.offset : 0,
                length: options.length ? options.length : (uint8Array.length - (options.offset ? options.offset : 0)),
                position: options.position ? options.position : this.position
            };
        }
        return {
            mayBeLess: false,
            offset: 0,
            length: uint8Array.length,
            position: this.position
        };
    }
    abort() {
        return Promise.resolve(); // Ignore abort signal
    }
}

const maxBufferSize = 256000;
class ReadStreamTokenizer extends AbstractTokenizer {
    /**
     * Constructor
     * @param streamReader stream-reader to read from
     * @param options Tokenizer options
     */
    constructor(streamReader, options) {
        super(options);
        this.streamReader = streamReader;
        this.fileInfo = options?.fileInfo ?? {};
    }
    /**
     * Read buffer from tokenizer
     * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
     * @param options - Read behaviour options
     * @returns Promise with number of bytes read
     */
    async readBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
            await this.ignore(skipBytes);
            return this.readBuffer(uint8Array, options);
        }
        if (skipBytes < 0) {
            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
        }
        if (normOptions.length === 0) {
            return 0;
        }
        const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
        this.position += bytesRead;
        if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
            throw new EndOfStreamError();
        }
        return bytesRead;
    }
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param uint8Array - Uint8Array (or Buffer) to write data to
     * @param options - Read behaviour options
     * @returns Promise with number of bytes peeked
     */
    async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        let bytesRead = 0;
        if (normOptions.position) {
            const skipBytes = normOptions.position - this.position;
            if (skipBytes > 0) {
                const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
                bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
                uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
                return bytesRead - skipBytes;
            }
            if (skipBytes < 0) {
                throw new Error('Cannot peek from a negative offset in a stream');
            }
        }
        if (normOptions.length > 0) {
            try {
                bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
            }
            catch (err) {
                if (options?.mayBeLess && err instanceof EndOfStreamError) {
                    return 0;
                }
                throw err;
            }
            if ((!normOptions.mayBeLess) && bytesRead < normOptions.length) {
                throw new EndOfStreamError();
            }
        }
        return bytesRead;
    }
    async ignore(length) {
        // debug(`ignore ${this.position}...${this.position + length - 1}`);
        const bufSize = Math.min(maxBufferSize, length);
        const buf = new Uint8Array(bufSize);
        let totBytesRead = 0;
        while (totBytesRead < length) {
            const remaining = length - totBytesRead;
            const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
            if (bytesRead < 0) {
                return bytesRead;
            }
            totBytesRead += bytesRead;
        }
        return totBytesRead;
    }
    abort() {
        return this.streamReader.abort();
    }
    supportsRandomAccess() {
        return false;
    }
}

class BufferTokenizer extends AbstractTokenizer {
    /**
     * Construct BufferTokenizer
     * @param uint8Array - Uint8Array to tokenize
     * @param options Tokenizer options
     */
    constructor(uint8Array, options) {
        super(options);
        this.uint8Array = uint8Array;
        this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: uint8Array.length } };
    }
    /**
     * Read buffer from tokenizer
     * @param uint8Array - Uint8Array to tokenize
     * @param options - Read behaviour options
     * @returns {Promise<number>}
     */
    async readBuffer(uint8Array, options) {
        if (options?.position) {
            if (options.position < this.position) {
                throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
            }
            this.position = options.position;
        }
        const bytesRead = await this.peekBuffer(uint8Array, options);
        this.position += bytesRead;
        return bytesRead;
    }
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param uint8Array
     * @param options - Read behaviour options
     * @returns {Promise<number>}
     */
    async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
        if ((!normOptions.mayBeLess) && bytes2read < normOptions.length) {
            throw new EndOfStreamError();
        }
        uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
        return bytes2read;
    }
    close() {
        return super.close();
    }
    supportsRandomAccess() {
        return true;
    }
    setPosition(position) {
        this.position = position;
    }
}

/**
 * Construct ReadStreamTokenizer from given Stream.
 * Will set fileSize, if provided given Stream has set the .path property/
 * @param stream - Read from Node.js Stream.Readable
 * @param options - Tokenizer options
 * @returns ReadStreamTokenizer
 */
function fromStream$1(stream, options) {
    return new ReadStreamTokenizer(new StreamReader(stream), options);
}
/**
 * Construct ReadStreamTokenizer from given ReadableStream (WebStream API).
 * Will set fileSize, if provided given Stream has set the .path property/
 * @param webStream - Read from Node.js Stream.Readable (must be a byte stream)
 * @param options - Tokenizer options
 * @returns ReadStreamTokenizer
 */
function fromWebStream(webStream, options) {
    return new ReadStreamTokenizer(new WebStreamReader(webStream), options);
}
/**
 * Construct ReadStreamTokenizer from given Buffer.
 * @param uint8Array - Uint8Array to tokenize
 * @param options - Tokenizer options
 * @returns BufferTokenizer
 */
function fromBuffer(uint8Array, options) {
    return new BufferTokenizer(uint8Array, options);
}

class FileTokenizer extends AbstractTokenizer {
    /**
     * Create tokenizer from provided file path
     * @param sourceFilePath File path
     */
    static async fromFile(sourceFilePath) {
        const fileHandle = await open(sourceFilePath, 'r');
        const stat = await fileHandle.stat();
        return new FileTokenizer(fileHandle, { fileInfo: { path: sourceFilePath, size: stat.size } });
    }
    constructor(fileHandle, options) {
        super(options);
        this.fileHandle = fileHandle;
        this.fileInfo = options.fileInfo;
    }
    /**
     * Read buffer from file
     * @param uint8Array - Uint8Array to write result to
     * @param options - Read behaviour options
     * @returns Promise number of bytes read
     */
    async readBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        this.position = normOptions.position;
        if (normOptions.length === 0)
            return 0;
        const res = await this.fileHandle.read(uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        this.position += res.bytesRead;
        if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
            throw new EndOfStreamError();
        }
        return res.bytesRead;
    }
    /**
     * Peek buffer from file
     * @param uint8Array - Uint8Array (or Buffer) to write data to
     * @param options - Read behaviour options
     * @returns Promise number of bytes read
     */
    async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const res = await this.fileHandle.read(uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        if ((!normOptions.mayBeLess) && res.bytesRead < normOptions.length) {
            throw new EndOfStreamError();
        }
        return res.bytesRead;
    }
    async close() {
        await this.fileHandle.close();
        return super.close();
    }
    setPosition(position) {
        this.position = position;
    }
    supportsRandomAccess() {
        return true;
    }
}

/**
 * Construct ReadStreamTokenizer from given Stream.
 * Will set fileSize, if provided given Stream has set the .path property.
 * @param stream - Node.js Stream.Readable
 * @param options - Pass additional file information to the tokenizer
 * @returns Tokenizer
 */
async function fromStream(stream, options) {
    const rst = fromStream$1(stream, options);
    if (stream.path) {
        const stat$1 = await stat(stream.path);
        rst.fileInfo.path = stream.path;
        rst.fileInfo.size = stat$1.size;
    }
    return rst;
}
const fromFile = FileTokenizer.fromFile;

var ieee754 = {};

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredIeee754;

function requireIeee754 () {
	if (hasRequiredIeee754) return ieee754;
	hasRequiredIeee754 = 1;
	ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = (nBytes * 8) - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	};

	ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = (nBytes * 8) - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = ((value * c) - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	};
	return ieee754;
}

requireIeee754();

// Primitive types
function dv(array) {
    return new DataView(array.buffer, array.byteOffset);
}
/**
 * 8-bit unsigned integer
 */
const UINT8 = {
    len: 1,
    get(array, offset) {
        return dv(array).getUint8(offset);
    },
    put(array, offset, value) {
        dv(array).setUint8(offset, value);
        return offset + 1;
    }
};
/**
 * 16-bit unsigned integer, Little Endian byte order
 */
const UINT16_LE = {
    len: 2,
    get(array, offset) {
        return dv(array).getUint16(offset, true);
    },
    put(array, offset, value) {
        dv(array).setUint16(offset, value, true);
        return offset + 2;
    }
};
/**
 * 16-bit unsigned integer, Big Endian byte order
 */
const UINT16_BE = {
    len: 2,
    get(array, offset) {
        return dv(array).getUint16(offset);
    },
    put(array, offset, value) {
        dv(array).setUint16(offset, value);
        return offset + 2;
    }
};
/**
 * 32-bit unsigned integer, Little Endian byte order
 */
const UINT32_LE = {
    len: 4,
    get(array, offset) {
        return dv(array).getUint32(offset, true);
    },
    put(array, offset, value) {
        dv(array).setUint32(offset, value, true);
        return offset + 4;
    }
};
/**
 * 32-bit unsigned integer, Big Endian byte order
 */
const UINT32_BE = {
    len: 4,
    get(array, offset) {
        return dv(array).getUint32(offset);
    },
    put(array, offset, value) {
        dv(array).setUint32(offset, value);
        return offset + 4;
    }
};
/**
 * 32-bit signed integer, Big Endian byte order
 */
const INT32_BE = {
    len: 4,
    get(array, offset) {
        return dv(array).getInt32(offset);
    },
    put(array, offset, value) {
        dv(array).setInt32(offset, value);
        return offset + 4;
    }
};
/**
 * 64-bit unsigned integer, Little Endian byte order
 */
const UINT64_LE = {
    len: 8,
    get(array, offset) {
        return dv(array).getBigUint64(offset, true);
    },
    put(array, offset, value) {
        dv(array).setBigUint64(offset, value, true);
        return offset + 8;
    }
};
/**
 * Consume a fixed number of bytes from the stream and return a string with a specified encoding.
 */
class StringType {
    constructor(len, encoding) {
        this.len = len;
        this.encoding = encoding;
        this.textDecoder = new TextDecoder(encoding);
    }
    get(uint8Array, offset) {
        return this.textDecoder.decode(uint8Array.subarray(offset, offset + this.len));
    }
}

({
	utf8: new globalThis.TextDecoder('utf8'),
});

new globalThis.TextEncoder();

Array.from({length: 256}, (_, index) => index.toString(16).padStart(2, '0'));

/**
@param {DataView} view
@returns {number}
*/
function getUintBE(view) {
	const {byteLength} = view;

	if (byteLength === 6) {
		return (view.getUint16(0) * (2 ** 32)) + view.getUint32(2);
	}

	if (byteLength === 5) {
		return (view.getUint8(0) * (2 ** 32)) + view.getUint32(1);
	}

	if (byteLength === 4) {
		return view.getUint32(0);
	}

	if (byteLength === 3) {
		return (view.getUint8(0) * (2 ** 16)) + view.getUint16(1);
	}

	if (byteLength === 2) {
		return view.getUint16(0);
	}

	if (byteLength === 1) {
		return view.getUint8(0);
	}
}

/**
@param {Uint8Array} array
@param {Uint8Array} value
@returns {number}
*/
function indexOf(array, value) {
	const arrayLength = array.length;
	const valueLength = value.length;

	if (valueLength === 0) {
		return -1;
	}

	if (valueLength > arrayLength) {
		return -1;
	}

	const validOffsetLength = arrayLength - valueLength;

	for (let index = 0; index <= validOffsetLength; index++) {
		let isMatch = true;
		for (let index2 = 0; index2 < valueLength; index2++) {
			if (array[index + index2] !== value[index2]) {
				isMatch = false;
				break;
			}
		}

		if (isMatch) {
			return index;
		}
	}

	return -1;
}

/**
@param {Uint8Array} array
@param {Uint8Array} value
@returns {boolean}
*/
function includes(array, value) {
	return indexOf(array, value) !== -1;
}

function stringToBytes(string) {
	return [...string].map(character => character.charCodeAt(0)); // eslint-disable-line unicorn/prefer-code-point
}

/**
Checks whether the TAR checksum is valid.

@param {Uint8Array} arrayBuffer - The TAR header `[offset ... offset + 512]`.
@param {number} offset - TAR header offset.
@returns {boolean} `true` if the TAR checksum is valid, otherwise `false`.
*/
function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
	const readSum = Number.parseInt(new StringType(6).get(arrayBuffer, 148).replace(/\0.*$/, '').trim(), 8); // Read sum in header
	if (Number.isNaN(readSum)) {
		return false;
	}

	let sum = 8 * 0x20; // Initialize signed bit sum

	for (let index = offset; index < offset + 148; index++) {
		sum += arrayBuffer[index];
	}

	for (let index = offset + 156; index < offset + 512; index++) {
		sum += arrayBuffer[index];
	}

	return readSum === sum;
}

/**
ID3 UINT32 sync-safe tokenizer token.
28 bits (representing up to 256MB) integer, the msb is 0 to avoid "false syncsignals".
*/
const uint32SyncSafeToken = {
	get: (buffer, offset) => (buffer[offset + 3] & 0x7F) | ((buffer[offset + 2]) << 7) | ((buffer[offset + 1]) << 14) | ((buffer[offset]) << 21),
	len: 4,
};

const extensions = [
	'jpg',
	'png',
	'apng',
	'gif',
	'webp',
	'flif',
	'xcf',
	'cr2',
	'cr3',
	'orf',
	'arw',
	'dng',
	'nef',
	'rw2',
	'raf',
	'tif',
	'bmp',
	'icns',
	'jxr',
	'psd',
	'indd',
	'zip',
	'tar',
	'rar',
	'gz',
	'bz2',
	'7z',
	'dmg',
	'mp4',
	'mid',
	'mkv',
	'webm',
	'mov',
	'avi',
	'mpg',
	'mp2',
	'mp3',
	'm4a',
	'oga',
	'ogg',
	'ogv',
	'opus',
	'flac',
	'wav',
	'spx',
	'amr',
	'pdf',
	'epub',
	'elf',
	'macho',
	'exe',
	'swf',
	'rtf',
	'wasm',
	'woff',
	'woff2',
	'eot',
	'ttf',
	'otf',
	'ico',
	'flv',
	'ps',
	'xz',
	'sqlite',
	'nes',
	'crx',
	'xpi',
	'cab',
	'deb',
	'ar',
	'rpm',
	'Z',
	'lz',
	'cfb',
	'mxf',
	'mts',
	'blend',
	'bpg',
	'docx',
	'pptx',
	'xlsx',
	'3gp',
	'3g2',
	'j2c',
	'jp2',
	'jpm',
	'jpx',
	'mj2',
	'aif',
	'qcp',
	'odt',
	'ods',
	'odp',
	'xml',
	'mobi',
	'heic',
	'cur',
	'ktx',
	'ape',
	'wv',
	'dcm',
	'ics',
	'glb',
	'pcap',
	'dsf',
	'lnk',
	'alias',
	'voc',
	'ac3',
	'm4v',
	'm4p',
	'm4b',
	'f4v',
	'f4p',
	'f4b',
	'f4a',
	'mie',
	'asf',
	'ogm',
	'ogx',
	'mpc',
	'arrow',
	'shp',
	'aac',
	'mp1',
	'it',
	's3m',
	'xm',
	'ai',
	'skp',
	'avif',
	'eps',
	'lzh',
	'pgp',
	'asar',
	'stl',
	'chm',
	'3mf',
	'zst',
	'jxl',
	'vcf',
	'jls',
	'pst',
	'dwg',
	'parquet',
	'class',
	'arj',
	'cpio',
	'ace',
	'avro',
	'icc',
	'fbx',
	'vsdx',
	'vtt',
	'apk',
];

const mimeTypes = [
	'image/jpeg',
	'image/png',
	'image/gif',
	'image/webp',
	'image/flif',
	'image/x-xcf',
	'image/x-canon-cr2',
	'image/x-canon-cr3',
	'image/tiff',
	'image/bmp',
	'image/vnd.ms-photo',
	'image/vnd.adobe.photoshop',
	'application/x-indesign',
	'application/epub+zip',
	'application/x-xpinstall',
	'application/vnd.oasis.opendocument.text',
	'application/vnd.oasis.opendocument.spreadsheet',
	'application/vnd.oasis.opendocument.presentation',
	'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
	'application/vnd.openxmlformats-officedocument.presentationml.presentation',
	'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
	'application/zip',
	'application/x-tar',
	'application/x-rar-compressed',
	'application/gzip',
	'application/x-bzip2',
	'application/x-7z-compressed',
	'application/x-apple-diskimage',
	'application/x-apache-arrow',
	'video/mp4',
	'audio/midi',
	'video/x-matroska',
	'video/webm',
	'video/quicktime',
	'video/vnd.avi',
	'audio/wav',
	'audio/qcelp',
	'audio/x-ms-asf',
	'video/x-ms-asf',
	'application/vnd.ms-asf',
	'video/mpeg',
	'video/3gpp',
	'audio/mpeg',
	'audio/mp4', // RFC 4337
	'video/ogg',
	'audio/ogg',
	'audio/ogg; codecs=opus',
	'application/ogg',
	'audio/x-flac',
	'audio/ape',
	'audio/wavpack',
	'audio/amr',
	'application/pdf',
	'application/x-elf',
	'application/x-mach-binary',
	'application/x-msdownload',
	'application/x-shockwave-flash',
	'application/rtf',
	'application/wasm',
	'font/woff',
	'font/woff2',
	'application/vnd.ms-fontobject',
	'font/ttf',
	'font/otf',
	'image/x-icon',
	'video/x-flv',
	'application/postscript',
	'application/eps',
	'application/x-xz',
	'application/x-sqlite3',
	'application/x-nintendo-nes-rom',
	'application/x-google-chrome-extension',
	'application/vnd.ms-cab-compressed',
	'application/x-deb',
	'application/x-unix-archive',
	'application/x-rpm',
	'application/x-compress',
	'application/x-lzip',
	'application/x-cfb',
	'application/x-mie',
	'application/mxf',
	'video/mp2t',
	'application/x-blender',
	'image/bpg',
	'image/j2c',
	'image/jp2',
	'image/jpx',
	'image/jpm',
	'image/mj2',
	'audio/aiff',
	'application/xml',
	'application/x-mobipocket-ebook',
	'image/heif',
	'image/heif-sequence',
	'image/heic',
	'image/heic-sequence',
	'image/icns',
	'image/ktx',
	'application/dicom',
	'audio/x-musepack',
	'text/calendar',
	'text/vcard',
	'text/vtt',
	'model/gltf-binary',
	'application/vnd.tcpdump.pcap',
	'audio/x-dsf', // Non-standard
	'application/x.ms.shortcut', // Invented by us
	'application/x.apple.alias', // Invented by us
	'audio/x-voc',
	'audio/vnd.dolby.dd-raw',
	'audio/x-m4a',
	'image/apng',
	'image/x-olympus-orf',
	'image/x-sony-arw',
	'image/x-adobe-dng',
	'image/x-nikon-nef',
	'image/x-panasonic-rw2',
	'image/x-fujifilm-raf',
	'video/x-m4v',
	'video/3gpp2',
	'application/x-esri-shape',
	'audio/aac',
	'audio/x-it',
	'audio/x-s3m',
	'audio/x-xm',
	'video/MP1S',
	'video/MP2P',
	'application/vnd.sketchup.skp',
	'image/avif',
	'application/x-lzh-compressed',
	'application/pgp-encrypted',
	'application/x-asar',
	'model/stl',
	'application/vnd.ms-htmlhelp',
	'model/3mf',
	'image/jxl',
	'application/zstd',
	'image/jls',
	'application/vnd.ms-outlook',
	'image/vnd.dwg',
	'application/x-parquet',
	'application/java-vm',
	'application/x-arj',
	'application/x-cpio',
	'application/x-ace-compressed',
	'application/avro',
	'application/vnd.iccprofile',
	'application/x.autodesk.fbx', // Invented by us
	'application/vnd.visio',
	'application/vnd.android.package-archive',
];

/**
Primary entry point, Node.js specific entry point is index.js
*/


const reasonableDetectionSizeInBytes = 4100; // A fair amount of file-types are detectable within this range.

function _check(buffer, headers, options) {
	options = {
		offset: 0,
		...options,
	};

	for (const [index, header] of headers.entries()) {
		// If a bitmask is set
		if (options.mask) {
			// If header doesn't equal `buf` with bits masked off
			if (header !== (options.mask[index] & buffer[index + options.offset])) {
				return false;
			}
		} else if (header !== buffer[index + options.offset]) {
			return false;
		}
	}

	return true;
}

class FileTypeParser {
	constructor(options) {
		this.detectors = options?.customDetectors;
		this.tokenizerOptions = {
			abortSignal: options?.signal,
		};
		this.fromTokenizer = this.fromTokenizer.bind(this);
		this.fromBuffer = this.fromBuffer.bind(this);
		this.parse = this.parse.bind(this);
	}

	async fromTokenizer(tokenizer) {
		const initialPosition = tokenizer.position;

		for (const detector of this.detectors || []) {
			const fileType = await detector(tokenizer);
			if (fileType) {
				return fileType;
			}

			if (initialPosition !== tokenizer.position) {
				return undefined; // Cannot proceed scanning of the tokenizer is at an arbitrary position
			}
		}

		return this.parse(tokenizer);
	}

	async fromBuffer(input) {
		if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
			throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
		}

		const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);

		if (!(buffer?.length > 1)) {
			return;
		}

		return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
	}

	async fromBlob(blob) {
		return this.fromStream(blob.stream());
	}

	async fromStream(stream) {
		const tokenizer = await fromWebStream(stream, this.tokenizerOptions);
		try {
			return await this.fromTokenizer(tokenizer);
		} finally {
			await tokenizer.close();
		}
	}

	async toDetectionStream(stream, options) {
		const {sampleSize = reasonableDetectionSizeInBytes} = options;
		let detectedFileType;
		let firstChunk;

		const reader = stream.getReader({mode: 'byob'});
		try {
			// Read the first chunk from the stream
			const {value: chunk, done} = await reader.read(new Uint8Array(sampleSize));
			firstChunk = chunk;
			if (!done && chunk) {
				try {
					// Attempt to detect the file type from the chunk
					detectedFileType = await this.fromBuffer(chunk.slice(0, sampleSize));
				} catch (error) {
					if (!(error instanceof EndOfStreamError)) {
						throw error; // Re-throw non-EndOfStreamError
					}

					detectedFileType = undefined;
				}
			}

			firstChunk = chunk;
		} finally {
			reader.releaseLock(); // Ensure the reader is released
		}

		// Create a new ReadableStream to manage locking issues
		const transformStream = new TransformStream({
			async start(controller) {
				controller.enqueue(firstChunk); // Enqueue the initial chunk
			},
			transform(chunk, controller) {
				// Pass through the chunks without modification
				controller.enqueue(chunk);
			},
		});

		const newStream = stream.pipeThrough(transformStream);
		newStream.fileType = detectedFileType;

		return newStream;
	}

	check(header, options) {
		return _check(this.buffer, header, options);
	}

	checkString(header, options) {
		return this.check(stringToBytes(header), options);
	}

	async parse(tokenizer) {
		this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);

		// Keep reading until EOF if the file size is unknown.
		if (tokenizer.fileInfo.size === undefined) {
			tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
		}

		this.tokenizer = tokenizer;

		await tokenizer.peekBuffer(this.buffer, {length: 12, mayBeLess: true});

		// -- 2-byte signatures --

		if (this.check([0x42, 0x4D])) {
			return {
				ext: 'bmp',
				mime: 'image/bmp',
			};
		}

		if (this.check([0x0B, 0x77])) {
			return {
				ext: 'ac3',
				mime: 'audio/vnd.dolby.dd-raw',
			};
		}

		if (this.check([0x78, 0x01])) {
			return {
				ext: 'dmg',
				mime: 'application/x-apple-diskimage',
			};
		}

		if (this.check([0x4D, 0x5A])) {
			return {
				ext: 'exe',
				mime: 'application/x-msdownload',
			};
		}

		if (this.check([0x25, 0x21])) {
			await tokenizer.peekBuffer(this.buffer, {length: 24, mayBeLess: true});

			if (
				this.checkString('PS-Adobe-', {offset: 2})
				&& this.checkString(' EPSF-', {offset: 14})
			) {
				return {
					ext: 'eps',
					mime: 'application/eps',
				};
			}

			return {
				ext: 'ps',
				mime: 'application/postscript',
			};
		}

		if (
			this.check([0x1F, 0xA0])
			|| this.check([0x1F, 0x9D])
		) {
			return {
				ext: 'Z',
				mime: 'application/x-compress',
			};
		}

		if (this.check([0xC7, 0x71])) {
			return {
				ext: 'cpio',
				mime: 'application/x-cpio',
			};
		}

		if (this.check([0x60, 0xEA])) {
			return {
				ext: 'arj',
				mime: 'application/x-arj',
			};
		}

		// -- 3-byte signatures --

		if (this.check([0xEF, 0xBB, 0xBF])) { // UTF-8-BOM
			// Strip off UTF-8-BOM
			this.tokenizer.ignore(3);
			return this.parse(tokenizer);
		}

		if (this.check([0x47, 0x49, 0x46])) {
			return {
				ext: 'gif',
				mime: 'image/gif',
			};
		}

		if (this.check([0x49, 0x49, 0xBC])) {
			return {
				ext: 'jxr',
				mime: 'image/vnd.ms-photo',
			};
		}

		if (this.check([0x1F, 0x8B, 0x8])) {
			return {
				ext: 'gz',
				mime: 'application/gzip',
			};
		}

		if (this.check([0x42, 0x5A, 0x68])) {
			return {
				ext: 'bz2',
				mime: 'application/x-bzip2',
			};
		}

		if (this.checkString('ID3')) {
			await tokenizer.ignore(6); // Skip ID3 header until the header size
			const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
			if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
				// Guess file type based on ID3 header for backward compatibility
				return {
					ext: 'mp3',
					mime: 'audio/mpeg',
				};
			}

			await tokenizer.ignore(id3HeaderLength);
			return this.fromTokenizer(tokenizer); // Skip ID3 header, recursion
		}

		// Musepack, SV7
		if (this.checkString('MP+')) {
			return {
				ext: 'mpc',
				mime: 'audio/x-musepack',
			};
		}

		if (
			(this.buffer[0] === 0x43 || this.buffer[0] === 0x46)
			&& this.check([0x57, 0x53], {offset: 1})
		) {
			return {
				ext: 'swf',
				mime: 'application/x-shockwave-flash',
			};
		}

		// -- 4-byte signatures --

		// Requires a sample size of 4 bytes
		if (this.check([0xFF, 0xD8, 0xFF])) {
			if (this.check([0xF7], {offset: 3})) { // JPG7/SOF55, indicating a ISO/IEC 14495 / JPEG-LS file
				return {
					ext: 'jls',
					mime: 'image/jls',
				};
			}

			return {
				ext: 'jpg',
				mime: 'image/jpeg',
			};
		}

		if (this.check([0x4F, 0x62, 0x6A, 0x01])) {
			return {
				ext: 'avro',
				mime: 'application/avro',
			};
		}

		if (this.checkString('FLIF')) {
			return {
				ext: 'flif',
				mime: 'image/flif',
			};
		}

		if (this.checkString('8BPS')) {
			return {
				ext: 'psd',
				mime: 'image/vnd.adobe.photoshop',
			};
		}

		if (this.checkString('WEBP', {offset: 8})) {
			return {
				ext: 'webp',
				mime: 'image/webp',
			};
		}

		// Musepack, SV8
		if (this.checkString('MPCK')) {
			return {
				ext: 'mpc',
				mime: 'audio/x-musepack',
			};
		}

		if (this.checkString('FORM')) {
			return {
				ext: 'aif',
				mime: 'audio/aiff',
			};
		}

		if (this.checkString('icns', {offset: 0})) {
			return {
				ext: 'icns',
				mime: 'image/icns',
			};
		}

		// Zip-based file formats
		// Need to be before the `zip` check
		if (this.check([0x50, 0x4B, 0x3, 0x4])) { // Local file header signature
			try {
				while (tokenizer.position + 30 < tokenizer.fileInfo.size) {
					await tokenizer.readBuffer(this.buffer, {length: 30});

					const view = new DataView(this.buffer.buffer);

					// https://en.wikipedia.org/wiki/Zip_(file_format)#File_headers
					const zipHeader = {
						compressedSize: view.getUint32(18, true),
						uncompressedSize: view.getUint32(22, true),
						filenameLength: view.getUint16(26, true),
						extraFieldLength: view.getUint16(28, true),
					};

					zipHeader.filename = await tokenizer.readToken(new StringType(zipHeader.filenameLength, 'utf-8'));
					await tokenizer.ignore(zipHeader.extraFieldLength);

					if (/classes\d*\.dex/.test(zipHeader.filename)) {
						return {
							ext: 'apk',
							mime: 'application/vnd.android.package-archive',
						};
					}

					// Assumes signed `.xpi` from addons.mozilla.org
					if (zipHeader.filename === 'META-INF/mozilla.rsa') {
						return {
							ext: 'xpi',
							mime: 'application/x-xpinstall',
						};
					}

					if (zipHeader.filename.endsWith('.rels') || zipHeader.filename.endsWith('.xml')) {
						const type = zipHeader.filename.split('/')[0];
						switch (type) {
							case '_rels':
								break;
							case 'word':
								return {
									ext: 'docx',
									mime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
								};
							case 'ppt':
								return {
									ext: 'pptx',
									mime: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
								};
							case 'xl':
								return {
									ext: 'xlsx',
									mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
								};
							case 'visio':
								return {
									ext: 'vsdx',
									mime: 'application/vnd.visio',
								};
							default:
								break;
						}
					}

					if (zipHeader.filename.startsWith('xl/')) {
						return {
							ext: 'xlsx',
							mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
						};
					}

					if (zipHeader.filename.startsWith('3D/') && zipHeader.filename.endsWith('.model')) {
						return {
							ext: '3mf',
							mime: 'model/3mf',
						};
					}

					// The docx, xlsx and pptx file types extend the Office Open XML file format:
					// https://en.wikipedia.org/wiki/Office_Open_XML_file_formats
					// We look for:
					// - one entry named '[Content_Types].xml' or '_rels/.rels',
					// - one entry indicating specific type of file.
					// MS Office, OpenOffice and LibreOffice may put the parts in different order, so the check should not rely on it.
					if (zipHeader.filename === 'mimetype' && zipHeader.compressedSize === zipHeader.uncompressedSize) {
						let mimeType = await tokenizer.readToken(new StringType(zipHeader.compressedSize, 'utf-8'));
						mimeType = mimeType.trim();

						switch (mimeType) {
							case 'application/epub+zip':
								return {
									ext: 'epub',
									mime: 'application/epub+zip',
								};
							case 'application/vnd.oasis.opendocument.text':
								return {
									ext: 'odt',
									mime: 'application/vnd.oasis.opendocument.text',
								};
							case 'application/vnd.oasis.opendocument.spreadsheet':
								return {
									ext: 'ods',
									mime: 'application/vnd.oasis.opendocument.spreadsheet',
								};
							case 'application/vnd.oasis.opendocument.presentation':
								return {
									ext: 'odp',
									mime: 'application/vnd.oasis.opendocument.presentation',
								};
							default:
						}
					}

					// Try to find next header manually when current one is corrupted
					if (zipHeader.compressedSize === 0) {
						let nextHeaderIndex = -1;

						while (nextHeaderIndex < 0 && (tokenizer.position < tokenizer.fileInfo.size)) {
							await tokenizer.peekBuffer(this.buffer, {mayBeLess: true});

							nextHeaderIndex = indexOf(this.buffer, new Uint8Array([0x50, 0x4B, 0x03, 0x04]));

							// Move position to the next header if found, skip the whole buffer otherwise
							await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : this.buffer.length);
						}
					} else {
						await tokenizer.ignore(zipHeader.compressedSize);
					}
				}
			} catch (error) {
				if (!(error instanceof EndOfStreamError)) {
					throw error;
				}
			}

			return {
				ext: 'zip',
				mime: 'application/zip',
			};
		}

		if (this.checkString('OggS')) {
			// This is an OGG container
			await tokenizer.ignore(28);
			const type = new Uint8Array(8);
			await tokenizer.readBuffer(type);

			// Needs to be before `ogg` check
			if (_check(type, [0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64])) {
				return {
					ext: 'opus',
					mime: 'audio/ogg; codecs=opus',
				};
			}

			// If ' theora' in header.
			if (_check(type, [0x80, 0x74, 0x68, 0x65, 0x6F, 0x72, 0x61])) {
				return {
					ext: 'ogv',
					mime: 'video/ogg',
				};
			}

			// If '\x01video' in header.
			if (_check(type, [0x01, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x00])) {
				return {
					ext: 'ogm',
					mime: 'video/ogg',
				};
			}

			// If ' FLAC' in header  https://xiph.org/flac/faq.html
			if (_check(type, [0x7F, 0x46, 0x4C, 0x41, 0x43])) {
				return {
					ext: 'oga',
					mime: 'audio/ogg',
				};
			}

			// 'Speex  ' in header https://en.wikipedia.org/wiki/Speex
			if (_check(type, [0x53, 0x70, 0x65, 0x65, 0x78, 0x20, 0x20])) {
				return {
					ext: 'spx',
					mime: 'audio/ogg',
				};
			}

			// If '\x01vorbis' in header
			if (_check(type, [0x01, 0x76, 0x6F, 0x72, 0x62, 0x69, 0x73])) {
				return {
					ext: 'ogg',
					mime: 'audio/ogg',
				};
			}

			// Default OGG container https://www.iana.org/assignments/media-types/application/ogg
			return {
				ext: 'ogx',
				mime: 'application/ogg',
			};
		}

		if (
			this.check([0x50, 0x4B])
			&& (this.buffer[2] === 0x3 || this.buffer[2] === 0x5 || this.buffer[2] === 0x7)
			&& (this.buffer[3] === 0x4 || this.buffer[3] === 0x6 || this.buffer[3] === 0x8)
		) {
			return {
				ext: 'zip',
				mime: 'application/zip',
			};
		}

		//

		// File Type Box (https://en.wikipedia.org/wiki/ISO_base_media_file_format)
		// It's not required to be first, but it's recommended to be. Almost all ISO base media files start with `ftyp` box.
		// `ftyp` box must contain a brand major identifier, which must consist of ISO 8859-1 printable characters.
		// Here we check for 8859-1 printable characters (for simplicity, it's a mask which also catches one non-printable character).
		if (
			this.checkString('ftyp', {offset: 4})
			&& (this.buffer[8] & 0x60) !== 0x00 // Brand major, first character ASCII?
		) {
			// They all can have MIME `video/mp4` except `application/mp4` special-case which is hard to detect.
			// For some cases, we're specific, everything else falls to `video/mp4` with `mp4` extension.
			const brandMajor = new StringType(4, 'latin1').get(this.buffer, 8).replace('\0', ' ').trim();
			switch (brandMajor) {
				case 'avif':
				case 'avis':
					return {ext: 'avif', mime: 'image/avif'};
				case 'mif1':
					return {ext: 'heic', mime: 'image/heif'};
				case 'msf1':
					return {ext: 'heic', mime: 'image/heif-sequence'};
				case 'heic':
				case 'heix':
					return {ext: 'heic', mime: 'image/heic'};
				case 'hevc':
				case 'hevx':
					return {ext: 'heic', mime: 'image/heic-sequence'};
				case 'qt':
					return {ext: 'mov', mime: 'video/quicktime'};
				case 'M4V':
				case 'M4VH':
				case 'M4VP':
					return {ext: 'm4v', mime: 'video/x-m4v'};
				case 'M4P':
					return {ext: 'm4p', mime: 'video/mp4'};
				case 'M4B':
					return {ext: 'm4b', mime: 'audio/mp4'};
				case 'M4A':
					return {ext: 'm4a', mime: 'audio/x-m4a'};
				case 'F4V':
					return {ext: 'f4v', mime: 'video/mp4'};
				case 'F4P':
					return {ext: 'f4p', mime: 'video/mp4'};
				case 'F4A':
					return {ext: 'f4a', mime: 'audio/mp4'};
				case 'F4B':
					return {ext: 'f4b', mime: 'audio/mp4'};
				case 'crx':
					return {ext: 'cr3', mime: 'image/x-canon-cr3'};
				default:
					if (brandMajor.startsWith('3g')) {
						if (brandMajor.startsWith('3g2')) {
							return {ext: '3g2', mime: 'video/3gpp2'};
						}

						return {ext: '3gp', mime: 'video/3gpp'};
					}

					return {ext: 'mp4', mime: 'video/mp4'};
			}
		}

		if (this.checkString('MThd')) {
			return {
				ext: 'mid',
				mime: 'audio/midi',
			};
		}

		if (
			this.checkString('wOFF')
			&& (
				this.check([0x00, 0x01, 0x00, 0x00], {offset: 4})
				|| this.checkString('OTTO', {offset: 4})
			)
		) {
			return {
				ext: 'woff',
				mime: 'font/woff',
			};
		}

		if (
			this.checkString('wOF2')
			&& (
				this.check([0x00, 0x01, 0x00, 0x00], {offset: 4})
				|| this.checkString('OTTO', {offset: 4})
			)
		) {
			return {
				ext: 'woff2',
				mime: 'font/woff2',
			};
		}

		if (this.check([0xD4, 0xC3, 0xB2, 0xA1]) || this.check([0xA1, 0xB2, 0xC3, 0xD4])) {
			return {
				ext: 'pcap',
				mime: 'application/vnd.tcpdump.pcap',
			};
		}

		// Sony DSD Stream File (DSF)
		if (this.checkString('DSD ')) {
			return {
				ext: 'dsf',
				mime: 'audio/x-dsf', // Non-standard
			};
		}

		if (this.checkString('LZIP')) {
			return {
				ext: 'lz',
				mime: 'application/x-lzip',
			};
		}

		if (this.checkString('fLaC')) {
			return {
				ext: 'flac',
				mime: 'audio/x-flac',
			};
		}

		if (this.check([0x42, 0x50, 0x47, 0xFB])) {
			return {
				ext: 'bpg',
				mime: 'image/bpg',
			};
		}

		if (this.checkString('wvpk')) {
			return {
				ext: 'wv',
				mime: 'audio/wavpack',
			};
		}

		if (this.checkString('%PDF')) {
			try {
				await tokenizer.ignore(1350);
				const maxBufferSize = 10 * 1024 * 1024;
				const buffer = new Uint8Array(Math.min(maxBufferSize, tokenizer.fileInfo.size));
				await tokenizer.readBuffer(buffer, {mayBeLess: true});

				// Check if this is an Adobe Illustrator file
				if (includes(buffer, new TextEncoder().encode('AIPrivateData'))) {
					return {
						ext: 'ai',
						mime: 'application/postscript',
					};
				}
			} catch (error) {
				// Swallow end of stream error if file is too small for the Adobe AI check
				if (!(error instanceof EndOfStreamError)) {
					throw error;
				}
			}

			// Assume this is just a normal PDF
			return {
				ext: 'pdf',
				mime: 'application/pdf',
			};
		}

		if (this.check([0x00, 0x61, 0x73, 0x6D])) {
			return {
				ext: 'wasm',
				mime: 'application/wasm',
			};
		}

		// TIFF, little-endian type
		if (this.check([0x49, 0x49])) {
			const fileType = await this.readTiffHeader(false);
			if (fileType) {
				return fileType;
			}
		}

		// TIFF, big-endian type
		if (this.check([0x4D, 0x4D])) {
			const fileType = await this.readTiffHeader(true);
			if (fileType) {
				return fileType;
			}
		}

		if (this.checkString('MAC ')) {
			return {
				ext: 'ape',
				mime: 'audio/ape',
			};
		}

		// https://github.com/file/file/blob/master/magic/Magdir/matroska
		if (this.check([0x1A, 0x45, 0xDF, 0xA3])) { // Root element: EBML
			async function readField() {
				const msb = await tokenizer.peekNumber(UINT8);
				let mask = 0x80;
				let ic = 0; // 0 = A, 1 = B, 2 = C, 3 = D

				while ((msb & mask) === 0 && mask !== 0) {
					++ic;
					mask >>= 1;
				}

				const id = new Uint8Array(ic + 1);
				await tokenizer.readBuffer(id);
				return id;
			}

			async function readElement() {
				const idField = await readField();
				const lengthField = await readField();

				lengthField[0] ^= 0x80 >> (lengthField.length - 1);
				const nrLength = Math.min(6, lengthField.length); // JavaScript can max read 6 bytes integer

				const idView = new DataView(idField.buffer);
				const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);

				return {
					id: getUintBE(idView),
					len: getUintBE(lengthView),
				};
			}

			async function readChildren(children) {
				while (children > 0) {
					const element = await readElement();
					if (element.id === 0x42_82) {
						const rawValue = await tokenizer.readToken(new StringType(element.len));
						return rawValue.replaceAll(/\00.*$/g, ''); // Return DocType
					}

					await tokenizer.ignore(element.len); // ignore payload
					--children;
				}
			}

			const re = await readElement();
			const docType = await readChildren(re.len);

			switch (docType) {
				case 'webm':
					return {
						ext: 'webm',
						mime: 'video/webm',
					};

				case 'matroska':
					return {
						ext: 'mkv',
						mime: 'video/x-matroska',
					};

				default:
					return;
			}
		}

		// RIFF file format which might be AVI, WAV, QCP, etc
		if (this.check([0x52, 0x49, 0x46, 0x46])) {
			if (this.check([0x41, 0x56, 0x49], {offset: 8})) {
				return {
					ext: 'avi',
					mime: 'video/vnd.avi',
				};
			}

			if (this.check([0x57, 0x41, 0x56, 0x45], {offset: 8})) {
				return {
					ext: 'wav',
					mime: 'audio/wav',
				};
			}

			// QLCM, QCP file
			if (this.check([0x51, 0x4C, 0x43, 0x4D], {offset: 8})) {
				return {
					ext: 'qcp',
					mime: 'audio/qcelp',
				};
			}
		}

		if (this.checkString('SQLi')) {
			return {
				ext: 'sqlite',
				mime: 'application/x-sqlite3',
			};
		}

		if (this.check([0x4E, 0x45, 0x53, 0x1A])) {
			return {
				ext: 'nes',
				mime: 'application/x-nintendo-nes-rom',
			};
		}

		if (this.checkString('Cr24')) {
			return {
				ext: 'crx',
				mime: 'application/x-google-chrome-extension',
			};
		}

		if (
			this.checkString('MSCF')
			|| this.checkString('ISc(')
		) {
			return {
				ext: 'cab',
				mime: 'application/vnd.ms-cab-compressed',
			};
		}

		if (this.check([0xED, 0xAB, 0xEE, 0xDB])) {
			return {
				ext: 'rpm',
				mime: 'application/x-rpm',
			};
		}

		if (this.check([0xC5, 0xD0, 0xD3, 0xC6])) {
			return {
				ext: 'eps',
				mime: 'application/eps',
			};
		}

		if (this.check([0x28, 0xB5, 0x2F, 0xFD])) {
			return {
				ext: 'zst',
				mime: 'application/zstd',
			};
		}

		if (this.check([0x7F, 0x45, 0x4C, 0x46])) {
			return {
				ext: 'elf',
				mime: 'application/x-elf',
			};
		}

		if (this.check([0x21, 0x42, 0x44, 0x4E])) {
			return {
				ext: 'pst',
				mime: 'application/vnd.ms-outlook',
			};
		}

		if (this.checkString('PAR1')) {
			return {
				ext: 'parquet',
				mime: 'application/x-parquet',
			};
		}

		if (this.check([0xCF, 0xFA, 0xED, 0xFE])) {
			return {
				ext: 'macho',
				mime: 'application/x-mach-binary',
			};
		}

		// -- 5-byte signatures --

		if (this.check([0x4F, 0x54, 0x54, 0x4F, 0x00])) {
			return {
				ext: 'otf',
				mime: 'font/otf',
			};
		}

		if (this.checkString('#!AMR')) {
			return {
				ext: 'amr',
				mime: 'audio/amr',
			};
		}

		if (this.checkString('{\\rtf')) {
			return {
				ext: 'rtf',
				mime: 'application/rtf',
			};
		}

		if (this.check([0x46, 0x4C, 0x56, 0x01])) {
			return {
				ext: 'flv',
				mime: 'video/x-flv',
			};
		}

		if (this.checkString('IMPM')) {
			return {
				ext: 'it',
				mime: 'audio/x-it',
			};
		}

		if (
			this.checkString('-lh0-', {offset: 2})
			|| this.checkString('-lh1-', {offset: 2})
			|| this.checkString('-lh2-', {offset: 2})
			|| this.checkString('-lh3-', {offset: 2})
			|| this.checkString('-lh4-', {offset: 2})
			|| this.checkString('-lh5-', {offset: 2})
			|| this.checkString('-lh6-', {offset: 2})
			|| this.checkString('-lh7-', {offset: 2})
			|| this.checkString('-lzs-', {offset: 2})
			|| this.checkString('-lz4-', {offset: 2})
			|| this.checkString('-lz5-', {offset: 2})
			|| this.checkString('-lhd-', {offset: 2})
		) {
			return {
				ext: 'lzh',
				mime: 'application/x-lzh-compressed',
			};
		}

		// MPEG program stream (PS or MPEG-PS)
		if (this.check([0x00, 0x00, 0x01, 0xBA])) {
			//  MPEG-PS, MPEG-1 Part 1
			if (this.check([0x21], {offset: 4, mask: [0xF1]})) {
				return {
					ext: 'mpg', // May also be .ps, .mpeg
					mime: 'video/MP1S',
				};
			}

			// MPEG-PS, MPEG-2 Part 1
			if (this.check([0x44], {offset: 4, mask: [0xC4]})) {
				return {
					ext: 'mpg', // May also be .mpg, .m2p, .vob or .sub
					mime: 'video/MP2P',
				};
			}
		}

		if (this.checkString('ITSF')) {
			return {
				ext: 'chm',
				mime: 'application/vnd.ms-htmlhelp',
			};
		}

		if (this.check([0xCA, 0xFE, 0xBA, 0xBE])) {
			return {
				ext: 'class',
				mime: 'application/java-vm',
			};
		}

		// -- 6-byte signatures --

		if (this.check([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])) {
			return {
				ext: 'xz',
				mime: 'application/x-xz',
			};
		}

		if (this.checkString('<?xml ')) {
			return {
				ext: 'xml',
				mime: 'application/xml',
			};
		}

		if (this.check([0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C])) {
			return {
				ext: '7z',
				mime: 'application/x-7z-compressed',
			};
		}

		if (
			this.check([0x52, 0x61, 0x72, 0x21, 0x1A, 0x7])
			&& (this.buffer[6] === 0x0 || this.buffer[6] === 0x1)
		) {
			return {
				ext: 'rar',
				mime: 'application/x-rar-compressed',
			};
		}

		if (this.checkString('solid ')) {
			return {
				ext: 'stl',
				mime: 'model/stl',
			};
		}

		if (this.checkString('AC')) {
			const version = new StringType(4, 'latin1').get(this.buffer, 2);
			if (version.match('^d*') && version >= 1000 && version <= 1050) {
				return {
					ext: 'dwg',
					mime: 'image/vnd.dwg',
				};
			}
		}

		if (this.checkString('070707')) {
			return {
				ext: 'cpio',
				mime: 'application/x-cpio',
			};
		}

		// -- 7-byte signatures --

		if (this.checkString('BLENDER')) {
			return {
				ext: 'blend',
				mime: 'application/x-blender',
			};
		}

		if (this.checkString('!<arch>')) {
			await tokenizer.ignore(8);
			const string = await tokenizer.readToken(new StringType(13, 'ascii'));
			if (string === 'debian-binary') {
				return {
					ext: 'deb',
					mime: 'application/x-deb',
				};
			}

			return {
				ext: 'ar',
				mime: 'application/x-unix-archive',
			};
		}

		if (
			this.checkString('WEBVTT')
			&&	(
				// One of LF, CR, tab, space, or end of file must follow "WEBVTT" per the spec (see `fixture/fixture-vtt-*.vtt` for examples). Note that `\0` is technically the null character (there is no such thing as an EOF character). However, checking for `\0` gives us the same result as checking for the end of the stream.
				(['\n', '\r', '\t', ' ', '\0'].some(char7 => this.checkString(char7, {offset: 6}))))
		) {
			return {
				ext: 'vtt',
				mime: 'text/vtt',
			};
		}

		// -- 8-byte signatures --

		if (this.check([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])) {
			// APNG format (https://wiki.mozilla.org/APNG_Specification)
			// 1. Find the first IDAT (image data) chunk (49 44 41 54)
			// 2. Check if there is an "acTL" chunk before the IDAT one (61 63 54 4C)

			// Offset calculated as follows:
			// - 8 bytes: PNG signature
			// - 4 (length) + 4 (chunk type) + 13 (chunk data) + 4 (CRC): IHDR chunk

			await tokenizer.ignore(8); // ignore PNG signature

			async function readChunkHeader() {
				return {
					length: await tokenizer.readToken(INT32_BE),
					type: await tokenizer.readToken(new StringType(4, 'latin1')),
				};
			}

			do {
				const chunk = await readChunkHeader();
				if (chunk.length < 0) {
					return; // Invalid chunk length
				}

				switch (chunk.type) {
					case 'IDAT':
						return {
							ext: 'png',
							mime: 'image/png',
						};
					case 'acTL':
						return {
							ext: 'apng',
							mime: 'image/apng',
						};
					default:
						await tokenizer.ignore(chunk.length + 4); // Ignore chunk-data + CRC
				}
			} while (tokenizer.position + 8 < tokenizer.fileInfo.size);

			return {
				ext: 'png',
				mime: 'image/png',
			};
		}

		if (this.check([0x41, 0x52, 0x52, 0x4F, 0x57, 0x31, 0x00, 0x00])) {
			return {
				ext: 'arrow',
				mime: 'application/x-apache-arrow',
			};
		}

		if (this.check([0x67, 0x6C, 0x54, 0x46, 0x02, 0x00, 0x00, 0x00])) {
			return {
				ext: 'glb',
				mime: 'model/gltf-binary',
			};
		}

		// `mov` format variants
		if (
			this.check([0x66, 0x72, 0x65, 0x65], {offset: 4}) // `free`
			|| this.check([0x6D, 0x64, 0x61, 0x74], {offset: 4}) // `mdat` MJPEG
			|| this.check([0x6D, 0x6F, 0x6F, 0x76], {offset: 4}) // `moov`
			|| this.check([0x77, 0x69, 0x64, 0x65], {offset: 4}) // `wide`
		) {
			return {
				ext: 'mov',
				mime: 'video/quicktime',
			};
		}

		// -- 9-byte signatures --

		if (this.check([0x49, 0x49, 0x52, 0x4F, 0x08, 0x00, 0x00, 0x00, 0x18])) {
			return {
				ext: 'orf',
				mime: 'image/x-olympus-orf',
			};
		}

		if (this.checkString('gimp xcf ')) {
			return {
				ext: 'xcf',
				mime: 'image/x-xcf',
			};
		}

		// -- 12-byte signatures --

		if (this.check([0x49, 0x49, 0x55, 0x00, 0x18, 0x00, 0x00, 0x00, 0x88, 0xE7, 0x74, 0xD8])) {
			return {
				ext: 'rw2',
				mime: 'image/x-panasonic-rw2',
			};
		}

		// ASF_Header_Object first 80 bytes
		if (this.check([0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9])) {
			async function readHeader() {
				const guid = new Uint8Array(16);
				await tokenizer.readBuffer(guid);
				return {
					id: guid,
					size: Number(await tokenizer.readToken(UINT64_LE)),
				};
			}

			await tokenizer.ignore(30);
			// Search for header should be in first 1KB of file.
			while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
				const header = await readHeader();
				let payload = header.size - 24;
				if (_check(header.id, [0x91, 0x07, 0xDC, 0xB7, 0xB7, 0xA9, 0xCF, 0x11, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65])) {
					// Sync on Stream-Properties-Object (B7DC0791-A9B7-11CF-8EE6-00C00C205365)
					const typeId = new Uint8Array(16);
					payload -= await tokenizer.readBuffer(typeId);

					if (_check(typeId, [0x40, 0x9E, 0x69, 0xF8, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {
						// Found audio:
						return {
							ext: 'asf',
							mime: 'audio/x-ms-asf',
						};
					}

					if (_check(typeId, [0xC0, 0xEF, 0x19, 0xBC, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {
						// Found video:
						return {
							ext: 'asf',
							mime: 'video/x-ms-asf',
						};
					}

					break;
				}

				await tokenizer.ignore(payload);
			}

			// Default to ASF generic extension
			return {
				ext: 'asf',
				mime: 'application/vnd.ms-asf',
			};
		}

		if (this.check([0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A])) {
			return {
				ext: 'ktx',
				mime: 'image/ktx',
			};
		}

		if ((this.check([0x7E, 0x10, 0x04]) || this.check([0x7E, 0x18, 0x04])) && this.check([0x30, 0x4D, 0x49, 0x45], {offset: 4})) {
			return {
				ext: 'mie',
				mime: 'application/x-mie',
			};
		}

		if (this.check([0x27, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], {offset: 2})) {
			return {
				ext: 'shp',
				mime: 'application/x-esri-shape',
			};
		}

		if (this.check([0xFF, 0x4F, 0xFF, 0x51])) {
			return {
				ext: 'j2c',
				mime: 'image/j2c',
			};
		}

		if (this.check([0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A])) {
			// JPEG-2000 family

			await tokenizer.ignore(20);
			const type = await tokenizer.readToken(new StringType(4, 'ascii'));
			switch (type) {
				case 'jp2 ':
					return {
						ext: 'jp2',
						mime: 'image/jp2',
					};
				case 'jpx ':
					return {
						ext: 'jpx',
						mime: 'image/jpx',
					};
				case 'jpm ':
					return {
						ext: 'jpm',
						mime: 'image/jpm',
					};
				case 'mjp2':
					return {
						ext: 'mj2',
						mime: 'image/mj2',
					};
				default:
					return;
			}
		}

		if (
			this.check([0xFF, 0x0A])
			|| this.check([0x00, 0x00, 0x00, 0x0C, 0x4A, 0x58, 0x4C, 0x20, 0x0D, 0x0A, 0x87, 0x0A])
		) {
			return {
				ext: 'jxl',
				mime: 'image/jxl',
			};
		}

		if (this.check([0xFE, 0xFF])) { // UTF-16-BOM-LE
			if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], {offset: 2})) {
				return {
					ext: 'xml',
					mime: 'application/xml',
				};
			}

			return undefined; // Some unknown text based format
		}

		// -- Unsafe signatures --

		if (
			this.check([0x0, 0x0, 0x1, 0xBA])
			|| this.check([0x0, 0x0, 0x1, 0xB3])
		) {
			return {
				ext: 'mpg',
				mime: 'video/mpeg',
			};
		}

		if (this.check([0x00, 0x01, 0x00, 0x00, 0x00])) {
			return {
				ext: 'ttf',
				mime: 'font/ttf',
			};
		}

		if (this.check([0x00, 0x00, 0x01, 0x00])) {
			return {
				ext: 'ico',
				mime: 'image/x-icon',
			};
		}

		if (this.check([0x00, 0x00, 0x02, 0x00])) {
			return {
				ext: 'cur',
				mime: 'image/x-icon',
			};
		}

		if (this.check([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1])) {
			// Detected Microsoft Compound File Binary File (MS-CFB) Format.
			return {
				ext: 'cfb',
				mime: 'application/x-cfb',
			};
		}

		// Increase sample size from 12 to 256.
		await tokenizer.peekBuffer(this.buffer, {length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true});

		if (this.check([0x61, 0x63, 0x73, 0x70], {offset: 36})) {
			return {
				ext: 'icc',
				mime: 'application/vnd.iccprofile',
			};
		}

		// ACE: requires 14 bytes in the buffer
		if (this.checkString('**ACE', {offset: 7}) && this.checkString('**', {offset: 12})) {
			return {
				ext: 'ace',
				mime: 'application/x-ace-compressed',
			};
		}

		// -- 15-byte signatures --

		if (this.checkString('BEGIN:')) {
			if (this.checkString('VCARD', {offset: 6})) {
				return {
					ext: 'vcf',
					mime: 'text/vcard',
				};
			}

			if (this.checkString('VCALENDAR', {offset: 6})) {
				return {
					ext: 'ics',
					mime: 'text/calendar',
				};
			}
		}

		// `raf` is here just to keep all the raw image detectors together.
		if (this.checkString('FUJIFILMCCD-RAW')) {
			return {
				ext: 'raf',
				mime: 'image/x-fujifilm-raf',
			};
		}

		if (this.checkString('Extended Module:')) {
			return {
				ext: 'xm',
				mime: 'audio/x-xm',
			};
		}

		if (this.checkString('Creative Voice File')) {
			return {
				ext: 'voc',
				mime: 'audio/x-voc',
			};
		}

		if (this.check([0x04, 0x00, 0x00, 0x00]) && this.buffer.length >= 16) { // Rough & quick check Pickle/ASAR
			const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);

			if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
				try {
					const header = new TextDecoder().decode(this.buffer.slice(16, jsonSize + 16));
					const json = JSON.parse(header);
					// Check if Pickle is ASAR
					if (json.files) { // Final check, assuring Pickle/ASAR format
						return {
							ext: 'asar',
							mime: 'application/x-asar',
						};
					}
				} catch {}
			}
		}

		if (this.check([0x06, 0x0E, 0x2B, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x01, 0x02])) {
			return {
				ext: 'mxf',
				mime: 'application/mxf',
			};
		}

		if (this.checkString('SCRM', {offset: 44})) {
			return {
				ext: 's3m',
				mime: 'audio/x-s3m',
			};
		}

		// Raw MPEG-2 transport stream (188-byte packets)
		if (this.check([0x47]) && this.check([0x47], {offset: 188})) {
			return {
				ext: 'mts',
				mime: 'video/mp2t',
			};
		}

		// Blu-ray Disc Audio-Video (BDAV) MPEG-2 transport stream has 4-byte TP_extra_header before each 188-byte packet
		if (this.check([0x47], {offset: 4}) && this.check([0x47], {offset: 196})) {
			return {
				ext: 'mts',
				mime: 'video/mp2t',
			};
		}

		if (this.check([0x42, 0x4F, 0x4F, 0x4B, 0x4D, 0x4F, 0x42, 0x49], {offset: 60})) {
			return {
				ext: 'mobi',
				mime: 'application/x-mobipocket-ebook',
			};
		}

		if (this.check([0x44, 0x49, 0x43, 0x4D], {offset: 128})) {
			return {
				ext: 'dcm',
				mime: 'application/dicom',
			};
		}

		if (this.check([0x4C, 0x00, 0x00, 0x00, 0x01, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46])) {
			return {
				ext: 'lnk',
				mime: 'application/x.ms.shortcut', // Invented by us
			};
		}

		if (this.check([0x62, 0x6F, 0x6F, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x72, 0x6B, 0x00, 0x00, 0x00, 0x00])) {
			return {
				ext: 'alias',
				mime: 'application/x.apple.alias', // Invented by us
			};
		}

		if (this.checkString('Kaydara FBX Binary  \u0000')) {
			return {
				ext: 'fbx',
				mime: 'application/x.autodesk.fbx', // Invented by us
			};
		}

		if (
			this.check([0x4C, 0x50], {offset: 34})
			&& (
				this.check([0x00, 0x00, 0x01], {offset: 8})
				|| this.check([0x01, 0x00, 0x02], {offset: 8})
				|| this.check([0x02, 0x00, 0x02], {offset: 8})
			)
		) {
			return {
				ext: 'eot',
				mime: 'application/vnd.ms-fontobject',
			};
		}

		if (this.check([0x06, 0x06, 0xED, 0xF5, 0xD8, 0x1D, 0x46, 0xE5, 0xBD, 0x31, 0xEF, 0xE7, 0xFE, 0x74, 0xB7, 0x1D])) {
			return {
				ext: 'indd',
				mime: 'application/x-indesign',
			};
		}

		// Increase sample size from 256 to 512
		await tokenizer.peekBuffer(this.buffer, {length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true});

		// Requires a buffer size of 512 bytes
		if (tarHeaderChecksumMatches(this.buffer)) {
			return {
				ext: 'tar',
				mime: 'application/x-tar',
			};
		}

		if (this.check([0xFF, 0xFE])) { // UTF-16-BOM-BE
			if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], {offset: 2})) {
				return {
					ext: 'xml',
					mime: 'application/xml',
				};
			}

			if (this.check([0xFF, 0x0E, 0x53, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x74, 0x00, 0x63, 0x00, 0x68, 0x00, 0x55, 0x00, 0x70, 0x00, 0x20, 0x00, 0x4D, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x65, 0x00, 0x6C, 0x00], {offset: 2})) {
				return {
					ext: 'skp',
					mime: 'application/vnd.sketchup.skp',
				};
			}

			return undefined; // Some text based format
		}

		if (this.checkString('-----BEGIN PGP MESSAGE-----')) {
			return {
				ext: 'pgp',
				mime: 'application/pgp-encrypted',
			};
		}

		// Check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE)
		if (this.buffer.length >= 2 && this.check([0xFF, 0xE0], {offset: 0, mask: [0xFF, 0xE0]})) {
			if (this.check([0x10], {offset: 1, mask: [0x16]})) {
				// Check for (ADTS) MPEG-2
				if (this.check([0x08], {offset: 1, mask: [0x08]})) {
					return {
						ext: 'aac',
						mime: 'audio/aac',
					};
				}

				// Must be (ADTS) MPEG-4
				return {
					ext: 'aac',
					mime: 'audio/aac',
				};
			}

			// MPEG 1 or 2 Layer 3 header
			// Check for MPEG layer 3
			if (this.check([0x02], {offset: 1, mask: [0x06]})) {
				return {
					ext: 'mp3',
					mime: 'audio/mpeg',
				};
			}

			// Check for MPEG layer 2
			if (this.check([0x04], {offset: 1, mask: [0x06]})) {
				return {
					ext: 'mp2',
					mime: 'audio/mpeg',
				};
			}

			// Check for MPEG layer 1
			if (this.check([0x06], {offset: 1, mask: [0x06]})) {
				return {
					ext: 'mp1',
					mime: 'audio/mpeg',
				};
			}
		}
	}

	async readTiffTag(bigEndian) {
		const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
		this.tokenizer.ignore(10);
		switch (tagId) {
			case 50_341:
				return {
					ext: 'arw',
					mime: 'image/x-sony-arw',
				};
			case 50_706:
				return {
					ext: 'dng',
					mime: 'image/x-adobe-dng',
				};
		}
	}

	async readTiffIFD(bigEndian) {
		const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
		for (let n = 0; n < numberOfTags; ++n) {
			const fileType = await this.readTiffTag(bigEndian);
			if (fileType) {
				return fileType;
			}
		}
	}

	async readTiffHeader(bigEndian) {
		const version = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
		const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);

		if (version === 42) {
			// TIFF file header
			if (ifdOffset >= 6) {
				if (this.checkString('CR', {offset: 8})) {
					return {
						ext: 'cr2',
						mime: 'image/x-canon-cr2',
					};
				}

				if (ifdOffset >= 8 && (this.check([0x1C, 0x00, 0xFE, 0x00], {offset: 8}) || this.check([0x1F, 0x00, 0x0B, 0x00], {offset: 8}))) {
					return {
						ext: 'nef',
						mime: 'image/x-nikon-nef',
					};
				}
			}

			await this.tokenizer.ignore(ifdOffset);
			const fileType = await this.readTiffIFD(bigEndian);
			return fileType ?? {
				ext: 'tif',
				mime: 'image/tiff',
			};
		}

		if (version === 43) {	// Big TIFF file header
			return {
				ext: 'tif',
				mime: 'image/tiff',
			};
		}
	}
}

new Set(extensions);
new Set(mimeTypes);

/**
Node.js specific entry point.
*/


class NodeFileTypeParser extends FileTypeParser {
	async fromStream(stream) {
		const tokenizer = await (stream instanceof ReadableStream ? fromWebStream(stream, this.tokenizerOptions) : fromStream(stream, this.tokenizerOptions));
		try {
			return await super.fromTokenizer(tokenizer);
		} finally {
			await tokenizer.close();
		}
	}

	async fromFile(path) {
		const tokenizer = await fromFile(path);
		try {
			return await super.fromTokenizer(tokenizer);
		} finally {
			await tokenizer.close();
		}
	}

	async toDetectionStream(readableStream, options = {}) {
		if (!(readableStream instanceof Readable)) {
			return super.toDetectionStream(readableStream, options);
		}

		const {sampleSize = reasonableDetectionSizeInBytes} = options;

		return new Promise((resolve, reject) => {
			readableStream.on('error', reject);

			readableStream.once('readable', () => {
				(async () => {
					try {
						// Set up output stream
						const pass = new PassThrough();
						const outputStream = pipeline ? pipeline(readableStream, pass, () => {}) : readableStream.pipe(pass);

						// Read the input stream and detect the filetype
						const chunk = readableStream.read(sampleSize) ?? readableStream.read() ?? new Uint8Array(0);
						try {
							pass.fileType = await this.fromBuffer(chunk);
						} catch (error) {
							if (error instanceof EndOfStreamError) {
								pass.fileType = undefined;
							} else {
								reject(error);
							}
						}

						resolve(outputStream);
					} catch (error) {
						reject(error);
					}
				})();
			});
		});
	}
}

async function fileTypeFromFile(path, fileTypeOptions) {
	return (new NodeFileTypeParser(fileTypeOptions)).fromFile(path, fileTypeOptions);
}

var dist = {exports: {}};

var queue = {exports: {}};

var hasRequiredQueue;

function requireQueue () {
	if (hasRequiredQueue) return queue.exports;
	hasRequiredQueue = 1;
	var inherits = requireInherits_browser();
	var EventEmitter = require$$0$2.EventEmitter;

	queue.exports = Queue;
	queue.exports.default = Queue;

	function Queue (options) {
	  if (!(this instanceof Queue)) {
	    return new Queue(options)
	  }

	  EventEmitter.call(this);
	  options = options || {};
	  this.concurrency = options.concurrency || Infinity;
	  this.timeout = options.timeout || 0;
	  this.autostart = options.autostart || false;
	  this.results = options.results || null;
	  this.pending = 0;
	  this.session = 0;
	  this.running = false;
	  this.jobs = [];
	  this.timers = {};
	}
	inherits(Queue, EventEmitter);

	var arrayMethods = [
	  'pop',
	  'shift',
	  'indexOf',
	  'lastIndexOf'
	];

	arrayMethods.forEach(function (method) {
	  Queue.prototype[method] = function () {
	    return Array.prototype[method].apply(this.jobs, arguments)
	  };
	});

	Queue.prototype.slice = function (begin, end) {
	  this.jobs = this.jobs.slice(begin, end);
	  return this
	};

	Queue.prototype.reverse = function () {
	  this.jobs.reverse();
	  return this
	};

	var arrayAddMethods = [
	  'push',
	  'unshift',
	  'splice'
	];

	arrayAddMethods.forEach(function (method) {
	  Queue.prototype[method] = function () {
	    var methodResult = Array.prototype[method].apply(this.jobs, arguments);
	    if (this.autostart) {
	      this.start();
	    }
	    return methodResult
	  };
	});

	Object.defineProperty(Queue.prototype, 'length', {
	  get: function () {
	    return this.pending + this.jobs.length
	  }
	});

	Queue.prototype.start = function (cb) {
	  if (cb) {
	    callOnErrorOrEnd.call(this, cb);
	  }

	  this.running = true;

	  if (this.pending >= this.concurrency) {
	    return
	  }

	  if (this.jobs.length === 0) {
	    if (this.pending === 0) {
	      done.call(this);
	    }
	    return
	  }

	  var self = this;
	  var job = this.jobs.shift();
	  var once = true;
	  var session = this.session;
	  var timeoutId = null;
	  var didTimeout = false;
	  var resultIndex = null;
	  var timeout = job.hasOwnProperty('timeout') ? job.timeout : this.timeout;

	  function next (err, result) {
	    if (once && self.session === session) {
	      once = false;
	      self.pending--;
	      if (timeoutId !== null) {
	        delete self.timers[timeoutId];
	        clearTimeout(timeoutId);
	      }

	      if (err) {
	        self.emit('error', err, job);
	      } else if (didTimeout === false) {
	        if (resultIndex !== null) {
	          self.results[resultIndex] = Array.prototype.slice.call(arguments, 1);
	        }
	        self.emit('success', result, job);
	      }

	      if (self.session === session) {
	        if (self.pending === 0 && self.jobs.length === 0) {
	          done.call(self);
	        } else if (self.running) {
	          self.start();
	        }
	      }
	    }
	  }

	  if (timeout) {
	    timeoutId = setTimeout(function () {
	      didTimeout = true;
	      if (self.listeners('timeout').length > 0) {
	        self.emit('timeout', next, job);
	      } else {
	        next();
	      }
	    }, timeout);
	    this.timers[timeoutId] = timeoutId;
	  }

	  if (this.results) {
	    resultIndex = this.results.length;
	    this.results[resultIndex] = null;
	  }

	  this.pending++;
	  self.emit('start', job);
	  var promise = job(next);
	  if (promise && promise.then && typeof promise.then === 'function') {
	    promise.then(function (result) {
	      return next(null, result)
	    }).catch(function (err) {
	      return next(err || true)
	    });
	  }

	  if (this.running && this.jobs.length > 0) {
	    this.start();
	  }
	};

	Queue.prototype.stop = function () {
	  this.running = false;
	};

	Queue.prototype.end = function (err) {
	  clearTimers.call(this);
	  this.jobs.length = 0;
	  this.pending = 0;
	  done.call(this, err);
	};

	function clearTimers () {
	  for (var key in this.timers) {
	    var timeoutId = this.timers[key];
	    delete this.timers[key];
	    clearTimeout(timeoutId);
	  }
	}

	function callOnErrorOrEnd (cb) {
	  var self = this;
	  this.on('error', onerror);
	  this.on('end', onend);

	  function onerror (err) { self.end(err); }
	  function onend (err) {
	    self.removeListener('error', onerror);
	    self.removeListener('end', onend);
	    cb(err, this.results);
	  }
	}

	function done (err) {
	  this.session++;
	  this.running = false;
	  this.emit('end', err);
	}
	return queue.exports;
}

var types$1 = {};

var bmp = {};

var utils$1 = {};

var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$1;
	hasRequiredUtils$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.findBox = exports.readUInt = exports.readUInt32LE = exports.readUInt32BE = exports.readInt32LE = exports.readUInt24LE = exports.readUInt16LE = exports.readUInt16BE = exports.readInt16LE = exports.toHexString = exports.toUTF8String = void 0;
		const decoder = new TextDecoder();
		const toUTF8String = (input, start = 0, end = input.length) => decoder.decode(input.slice(start, end));
		exports.toUTF8String = toUTF8String;
		const toHexString = (input, start = 0, end = input.length) => input
		    .slice(start, end)
		    .reduce((memo, i) => memo + ('0' + i.toString(16)).slice(-2), '');
		exports.toHexString = toHexString;
		const readInt16LE = (input, offset = 0) => {
		    const val = input[offset] + input[offset + 1] * 2 ** 8;
		    return val | ((val & (2 ** 15)) * 0x1fffe);
		};
		exports.readInt16LE = readInt16LE;
		const readUInt16BE = (input, offset = 0) => input[offset] * 2 ** 8 + input[offset + 1];
		exports.readUInt16BE = readUInt16BE;
		const readUInt16LE = (input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8;
		exports.readUInt16LE = readUInt16LE;
		const readUInt24LE = (input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8 + input[offset + 2] * 2 ** 16;
		exports.readUInt24LE = readUInt24LE;
		const readInt32LE = (input, offset = 0) => input[offset] +
		    input[offset + 1] * 2 ** 8 +
		    input[offset + 2] * 2 ** 16 +
		    (input[offset + 3] << 24);
		exports.readInt32LE = readInt32LE;
		const readUInt32BE = (input, offset = 0) => input[offset] * 2 ** 24 +
		    input[offset + 1] * 2 ** 16 +
		    input[offset + 2] * 2 ** 8 +
		    input[offset + 3];
		exports.readUInt32BE = readUInt32BE;
		const readUInt32LE = (input, offset = 0) => input[offset] +
		    input[offset + 1] * 2 ** 8 +
		    input[offset + 2] * 2 ** 16 +
		    input[offset + 3] * 2 ** 24;
		exports.readUInt32LE = readUInt32LE;
		// Abstract reading multi-byte unsigned integers
		const methods = {
		    readUInt16BE: exports.readUInt16BE,
		    readUInt16LE: exports.readUInt16LE,
		    readUInt32BE: exports.readUInt32BE,
		    readUInt32LE: exports.readUInt32LE,
		};
		function readUInt(input, bits, offset, isBigEndian) {
		    offset = offset || 0;
		    const endian = isBigEndian ? 'BE' : 'LE';
		    const methodName = ('readUInt' + bits + endian);
		    return methods[methodName](input, offset);
		}
		exports.readUInt = readUInt;
		function readBox(buffer, offset) {
		    if (buffer.length - offset < 4)
		        return;
		    const boxSize = (0, exports.readUInt32BE)(buffer, offset);
		    if (buffer.length - offset < boxSize)
		        return;
		    return {
		        name: (0, exports.toUTF8String)(buffer, 4 + offset, 8 + offset),
		        offset,
		        size: boxSize,
		    };
		}
		function findBox(buffer, boxName, offset) {
		    while (offset < buffer.length) {
		        const box = readBox(buffer, offset);
		        if (!box)
		            break;
		        if (box.name === boxName)
		            return box;
		        offset += box.size;
		    }
		}
		exports.findBox = findBox; 
	} (utils$1));
	return utils$1;
}

var hasRequiredBmp;

function requireBmp () {
	if (hasRequiredBmp) return bmp;
	hasRequiredBmp = 1;
	Object.defineProperty(bmp, "__esModule", { value: true });
	bmp.BMP = void 0;
	const utils_1 = requireUtils$1();
	bmp.BMP = {
	    validate: (input) => (0, utils_1.toUTF8String)(input, 0, 2) === 'BM',
	    calculate: (input) => ({
	        height: Math.abs((0, utils_1.readInt32LE)(input, 22)),
	        width: (0, utils_1.readUInt32LE)(input, 18),
	    }),
	};
	return bmp;
}

var cur = {};

var ico = {};

var hasRequiredIco;

function requireIco () {
	if (hasRequiredIco) return ico;
	hasRequiredIco = 1;
	Object.defineProperty(ico, "__esModule", { value: true });
	ico.ICO = void 0;
	const utils_1 = requireUtils$1();
	const TYPE_ICON = 1;
	/**
	 * ICON Header
	 *
	 * | Offset | Size | Purpose |
	 * | 0	    | 2    | Reserved. Must always be 0.  |
	 * | 2      | 2    | Image type: 1 for icon (.ICO) image, 2 for cursor (.CUR) image. Other values are invalid. |
	 * | 4      | 2    | Number of images in the file. |
	 *
	 */
	const SIZE_HEADER = 2 + 2 + 2; // 6
	/**
	 * Image Entry
	 *
	 * | Offset | Size | Purpose |
	 * | 0	    | 1    | Image width in pixels. Can be any number between 0 and 255. Value 0 means width is 256 pixels. |
	 * | 1      | 1    | Image height in pixels. Can be any number between 0 and 255. Value 0 means height is 256 pixels. |
	 * | 2      | 1    | Number of colors in the color palette. Should be 0 if the image does not use a color palette. |
	 * | 3      | 1    | Reserved. Should be 0. |
	 * | 4      | 2    | ICO format: Color planes. Should be 0 or 1. |
	 * |        |      | CUR format: The horizontal coordinates of the hotspot in number of pixels from the left. |
	 * | 6      | 2    | ICO format: Bits per pixel. |
	 * |        |      | CUR format: The vertical coordinates of the hotspot in number of pixels from the top. |
	 * | 8      | 4    | The size of the image's data in bytes |
	 * | 12     | 4    | The offset of BMP or PNG data from the beginning of the ICO/CUR file |
	 *
	 */
	const SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4; // 16
	function getSizeFromOffset(input, offset) {
	    const value = input[offset];
	    return value === 0 ? 256 : value;
	}
	function getImageSize(input, imageIndex) {
	    const offset = SIZE_HEADER + imageIndex * SIZE_IMAGE_ENTRY;
	    return {
	        height: getSizeFromOffset(input, offset + 1),
	        width: getSizeFromOffset(input, offset),
	    };
	}
	ico.ICO = {
	    validate(input) {
	        const reserved = (0, utils_1.readUInt16LE)(input, 0);
	        const imageCount = (0, utils_1.readUInt16LE)(input, 4);
	        if (reserved !== 0 || imageCount === 0)
	            return false;
	        const imageType = (0, utils_1.readUInt16LE)(input, 2);
	        return imageType === TYPE_ICON;
	    },
	    calculate(input) {
	        const nbImages = (0, utils_1.readUInt16LE)(input, 4);
	        const imageSize = getImageSize(input, 0);
	        if (nbImages === 1)
	            return imageSize;
	        const imgs = [imageSize];
	        for (let imageIndex = 1; imageIndex < nbImages; imageIndex += 1) {
	            imgs.push(getImageSize(input, imageIndex));
	        }
	        return {
	            height: imageSize.height,
	            images: imgs,
	            width: imageSize.width,
	        };
	    },
	};
	return ico;
}

var hasRequiredCur;

function requireCur () {
	if (hasRequiredCur) return cur;
	hasRequiredCur = 1;
	Object.defineProperty(cur, "__esModule", { value: true });
	cur.CUR = void 0;
	const ico_1 = requireIco();
	const utils_1 = requireUtils$1();
	const TYPE_CURSOR = 2;
	cur.CUR = {
	    validate(input) {
	        const reserved = (0, utils_1.readUInt16LE)(input, 0);
	        const imageCount = (0, utils_1.readUInt16LE)(input, 4);
	        if (reserved !== 0 || imageCount === 0)
	            return false;
	        const imageType = (0, utils_1.readUInt16LE)(input, 2);
	        return imageType === TYPE_CURSOR;
	    },
	    calculate: (input) => ico_1.ICO.calculate(input),
	};
	return cur;
}

var dds = {};

var hasRequiredDds;

function requireDds () {
	if (hasRequiredDds) return dds;
	hasRequiredDds = 1;
	Object.defineProperty(dds, "__esModule", { value: true });
	dds.DDS = void 0;
	const utils_1 = requireUtils$1();
	dds.DDS = {
	    validate: (input) => (0, utils_1.readUInt32LE)(input, 0) === 0x20534444,
	    calculate: (input) => ({
	        height: (0, utils_1.readUInt32LE)(input, 12),
	        width: (0, utils_1.readUInt32LE)(input, 16),
	    }),
	};
	return dds;
}

var gif = {};

var hasRequiredGif;

function requireGif () {
	if (hasRequiredGif) return gif;
	hasRequiredGif = 1;
	Object.defineProperty(gif, "__esModule", { value: true });
	gif.GIF = void 0;
	const utils_1 = requireUtils$1();
	const gifRegexp = /^GIF8[79]a/;
	gif.GIF = {
	    validate: (input) => gifRegexp.test((0, utils_1.toUTF8String)(input, 0, 6)),
	    calculate: (input) => ({
	        height: (0, utils_1.readUInt16LE)(input, 8),
	        width: (0, utils_1.readUInt16LE)(input, 6),
	    }),
	};
	return gif;
}

var heif = {};

var hasRequiredHeif;

function requireHeif () {
	if (hasRequiredHeif) return heif;
	hasRequiredHeif = 1;
	Object.defineProperty(heif, "__esModule", { value: true });
	heif.HEIF = void 0;
	const utils_1 = requireUtils$1();
	const brandMap = {
	    avif: 'avif',
	    mif1: 'heif',
	    msf1: 'heif', // hief-sequence
	    heic: 'heic',
	    heix: 'heic',
	    hevc: 'heic', // heic-sequence
	    hevx: 'heic', // heic-sequence
	};
	heif.HEIF = {
	    validate(buffer) {
	        const ftype = (0, utils_1.toUTF8String)(buffer, 4, 8);
	        const brand = (0, utils_1.toUTF8String)(buffer, 8, 12);
	        return 'ftyp' === ftype && brand in brandMap;
	    },
	    calculate(buffer) {
	        // Based on https://nokiatech.github.io/heif/technical.html
	        const metaBox = (0, utils_1.findBox)(buffer, 'meta', 0);
	        const iprpBox = metaBox && (0, utils_1.findBox)(buffer, 'iprp', metaBox.offset + 12);
	        const ipcoBox = iprpBox && (0, utils_1.findBox)(buffer, 'ipco', iprpBox.offset + 8);
	        const ispeBox = ipcoBox && (0, utils_1.findBox)(buffer, 'ispe', ipcoBox.offset + 8);
	        if (ispeBox) {
	            return {
	                height: (0, utils_1.readUInt32BE)(buffer, ispeBox.offset + 16),
	                width: (0, utils_1.readUInt32BE)(buffer, ispeBox.offset + 12),
	                type: (0, utils_1.toUTF8String)(buffer, 8, 12),
	            };
	        }
	        throw new TypeError('Invalid HEIF, no size found');
	    }
	};
	return heif;
}

var icns = {};

var hasRequiredIcns;

function requireIcns () {
	if (hasRequiredIcns) return icns;
	hasRequiredIcns = 1;
	Object.defineProperty(icns, "__esModule", { value: true });
	icns.ICNS = void 0;
	const utils_1 = requireUtils$1();
	/**
	 * ICNS Header
	 *
	 * | Offset | Size | Purpose                                                |
	 * | 0	    | 4    | Magic literal, must be "icns" (0x69, 0x63, 0x6e, 0x73) |
	 * | 4      | 4    | Length of file, in bytes, msb first.                   |
	 *
	 */
	const SIZE_HEADER = 4 + 4; // 8
	const FILE_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN
	/**
	 * Image Entry
	 *
	 * | Offset | Size | Purpose                                                          |
	 * | 0	    | 4    | Icon type, see OSType below.                                     |
	 * | 4      | 4    | Length of data, in bytes (including type and length), msb first. |
	 * | 8      | n    | Icon data                                                        |
	 */
	const ENTRY_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN
	const ICON_TYPE_SIZE = {
	    ICON: 32,
	    'ICN#': 32,
	    // m => 16 x 16
	    'icm#': 16,
	    icm4: 16,
	    icm8: 16,
	    // s => 16 x 16
	    'ics#': 16,
	    ics4: 16,
	    ics8: 16,
	    is32: 16,
	    s8mk: 16,
	    icp4: 16,
	    // l => 32 x 32
	    icl4: 32,
	    icl8: 32,
	    il32: 32,
	    l8mk: 32,
	    icp5: 32,
	    ic11: 32,
	    // h => 48 x 48
	    ich4: 48,
	    ich8: 48,
	    ih32: 48,
	    h8mk: 48,
	    // . => 64 x 64
	    icp6: 64,
	    ic12: 32,
	    // t => 128 x 128
	    it32: 128,
	    t8mk: 128,
	    ic07: 128,
	    // . => 256 x 256
	    ic08: 256,
	    ic13: 256,
	    // . => 512 x 512
	    ic09: 512,
	    ic14: 512,
	    // . => 1024 x 1024
	    ic10: 1024,
	};
	function readImageHeader(input, imageOffset) {
	    const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;
	    return [
	        (0, utils_1.toUTF8String)(input, imageOffset, imageLengthOffset),
	        (0, utils_1.readUInt32BE)(input, imageLengthOffset),
	    ];
	}
	function getImageSize(type) {
	    const size = ICON_TYPE_SIZE[type];
	    return { width: size, height: size, type };
	}
	icns.ICNS = {
	    validate: (input) => (0, utils_1.toUTF8String)(input, 0, 4) === 'icns',
	    calculate(input) {
	        const inputLength = input.length;
	        const fileLength = (0, utils_1.readUInt32BE)(input, FILE_LENGTH_OFFSET);
	        let imageOffset = SIZE_HEADER;
	        let imageHeader = readImageHeader(input, imageOffset);
	        let imageSize = getImageSize(imageHeader[0]);
	        imageOffset += imageHeader[1];
	        if (imageOffset === fileLength)
	            return imageSize;
	        const result = {
	            height: imageSize.height,
	            images: [imageSize],
	            width: imageSize.width,
	        };
	        while (imageOffset < fileLength && imageOffset < inputLength) {
	            imageHeader = readImageHeader(input, imageOffset);
	            imageSize = getImageSize(imageHeader[0]);
	            imageOffset += imageHeader[1];
	            result.images.push(imageSize);
	        }
	        return result;
	    },
	};
	return icns;
}

var j2c = {};

var hasRequiredJ2c;

function requireJ2c () {
	if (hasRequiredJ2c) return j2c;
	hasRequiredJ2c = 1;
	Object.defineProperty(j2c, "__esModule", { value: true });
	j2c.J2C = void 0;
	const utils_1 = requireUtils$1();
	j2c.J2C = {
	    // TODO: this doesn't seem right. SIZ marker doesn't have to be right after the SOC
	    validate: (input) => (0, utils_1.toHexString)(input, 0, 4) === 'ff4fff51',
	    calculate: (input) => ({
	        height: (0, utils_1.readUInt32BE)(input, 12),
	        width: (0, utils_1.readUInt32BE)(input, 8),
	    }),
	};
	return j2c;
}

var jp2 = {};

var hasRequiredJp2;

function requireJp2 () {
	if (hasRequiredJp2) return jp2;
	hasRequiredJp2 = 1;
	Object.defineProperty(jp2, "__esModule", { value: true });
	jp2.JP2 = void 0;
	const utils_1 = requireUtils$1();
	jp2.JP2 = {
	    validate(input) {
	        if ((0, utils_1.readUInt32BE)(input, 4) !== 0x6a502020 || (0, utils_1.readUInt32BE)(input, 0) < 1)
	            return false;
	        const ftypBox = (0, utils_1.findBox)(input, 'ftyp', 0);
	        if (!ftypBox)
	            return false;
	        return (0, utils_1.readUInt32BE)(input, ftypBox.offset + 4) === 0x66747970;
	    },
	    calculate(input) {
	        const jp2hBox = (0, utils_1.findBox)(input, 'jp2h', 0);
	        const ihdrBox = jp2hBox && (0, utils_1.findBox)(input, 'ihdr', jp2hBox.offset + 8);
	        if (ihdrBox) {
	            return {
	                height: (0, utils_1.readUInt32BE)(input, ihdrBox.offset + 8),
	                width: (0, utils_1.readUInt32BE)(input, ihdrBox.offset + 12),
	            };
	        }
	        throw new TypeError('Unsupported JPEG 2000 format');
	    },
	};
	return jp2;
}

var jpg = {};

var hasRequiredJpg;

function requireJpg () {
	if (hasRequiredJpg) return jpg;
	hasRequiredJpg = 1;
	// NOTE: we only support baseline and progressive JPGs here
	// due to the structure of the loader class, we only get a buffer
	// with a maximum size of 4096 bytes. so if the SOF marker is outside
	// if this range we can't detect the file size correctly.
	Object.defineProperty(jpg, "__esModule", { value: true });
	jpg.JPG = void 0;
	const utils_1 = requireUtils$1();
	const EXIF_MARKER = '45786966';
	const APP1_DATA_SIZE_BYTES = 2;
	const EXIF_HEADER_BYTES = 6;
	const TIFF_BYTE_ALIGN_BYTES = 2;
	const BIG_ENDIAN_BYTE_ALIGN = '4d4d';
	const LITTLE_ENDIAN_BYTE_ALIGN = '4949';
	// Each entry is exactly 12 bytes
	const IDF_ENTRY_BYTES = 12;
	const NUM_DIRECTORY_ENTRIES_BYTES = 2;
	function isEXIF(input) {
	    return (0, utils_1.toHexString)(input, 2, 6) === EXIF_MARKER;
	}
	function extractSize(input, index) {
	    return {
	        height: (0, utils_1.readUInt16BE)(input, index),
	        width: (0, utils_1.readUInt16BE)(input, index + 2),
	    };
	}
	function extractOrientation(exifBlock, isBigEndian) {
	    // TODO: assert that this contains 0x002A
	    // let STATIC_MOTOROLA_TIFF_HEADER_BYTES = 2
	    // let TIFF_IMAGE_FILE_DIRECTORY_BYTES = 4
	    // TODO: derive from TIFF_IMAGE_FILE_DIRECTORY_BYTES
	    const idfOffset = 8;
	    // IDF osset works from right after the header bytes
	    // (so the offset includes the tiff byte align)
	    const offset = EXIF_HEADER_BYTES + idfOffset;
	    const idfDirectoryEntries = (0, utils_1.readUInt)(exifBlock, 16, offset, isBigEndian);
	    for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {
	        const start = offset +
	            NUM_DIRECTORY_ENTRIES_BYTES +
	            directoryEntryNumber * IDF_ENTRY_BYTES;
	        const end = start + IDF_ENTRY_BYTES;
	        // Skip on corrupt EXIF blocks
	        if (start > exifBlock.length) {
	            return;
	        }
	        const block = exifBlock.slice(start, end);
	        const tagNumber = (0, utils_1.readUInt)(block, 16, 0, isBigEndian);
	        // 0x0112 (decimal: 274) is the `orientation` tag ID
	        if (tagNumber === 274) {
	            const dataFormat = (0, utils_1.readUInt)(block, 16, 2, isBigEndian);
	            if (dataFormat !== 3) {
	                return;
	            }
	            // unsinged int has 2 bytes per component
	            // if there would more than 4 bytes in total it's a pointer
	            const numberOfComponents = (0, utils_1.readUInt)(block, 32, 4, isBigEndian);
	            if (numberOfComponents !== 1) {
	                return;
	            }
	            return (0, utils_1.readUInt)(block, 16, 8, isBigEndian);
	        }
	    }
	}
	function validateExifBlock(input, index) {
	    // Skip APP1 Data Size
	    const exifBlock = input.slice(APP1_DATA_SIZE_BYTES, index);
	    // Consider byte alignment
	    const byteAlign = (0, utils_1.toHexString)(exifBlock, EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);
	    // Ignore Empty EXIF. Validate byte alignment
	    const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;
	    const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;
	    if (isBigEndian || isLittleEndian) {
	        return extractOrientation(exifBlock, isBigEndian);
	    }
	}
	function validateInput(input, index) {
	    // index should be within buffer limits
	    if (index > input.length) {
	        throw new TypeError('Corrupt JPG, exceeded buffer limits');
	    }
	}
	jpg.JPG = {
	    validate: (input) => (0, utils_1.toHexString)(input, 0, 2) === 'ffd8',
	    calculate(input) {
	        // Skip 4 chars, they are for signature
	        input = input.slice(4);
	        let orientation;
	        let next;
	        while (input.length) {
	            // read length of the next block
	            const i = (0, utils_1.readUInt16BE)(input, 0);
	            // Every JPEG block must begin with a 0xFF
	            if (input[i] !== 0xff) {
	                input = input.slice(1);
	                continue;
	            }
	            if (isEXIF(input)) {
	                orientation = validateExifBlock(input, i);
	            }
	            // ensure correct format
	            validateInput(input, i);
	            // 0xFFC0 is baseline standard(SOF)
	            // 0xFFC1 is baseline optimized(SOF)
	            // 0xFFC2 is progressive(SOF2)
	            next = input[i + 1];
	            if (next === 0xc0 || next === 0xc1 || next === 0xc2) {
	                const size = extractSize(input, i + 5);
	                // TODO: is orientation=0 a valid answer here?
	                if (!orientation) {
	                    return size;
	                }
	                return {
	                    height: size.height,
	                    orientation,
	                    width: size.width,
	                };
	            }
	            // move to the next block
	            input = input.slice(i + 2);
	        }
	        throw new TypeError('Invalid JPG, no size found');
	    },
	};
	return jpg;
}

var ktx = {};

var hasRequiredKtx;

function requireKtx () {
	if (hasRequiredKtx) return ktx;
	hasRequiredKtx = 1;
	Object.defineProperty(ktx, "__esModule", { value: true });
	ktx.KTX = void 0;
	const utils_1 = requireUtils$1();
	ktx.KTX = {
	    validate: (input) => {
	        const signature = (0, utils_1.toUTF8String)(input, 1, 7);
	        return ['KTX 11', 'KTX 20'].includes(signature);
	    },
	    calculate: (input) => {
	        const type = input[5] === 0x31 ? 'ktx' : 'ktx2';
	        const offset = type === 'ktx' ? 36 : 20;
	        return ({
	            height: (0, utils_1.readUInt32LE)(input, offset + 4),
	            width: (0, utils_1.readUInt32LE)(input, offset),
	            type,
	        });
	    },
	};
	return ktx;
}

var png = {};

var hasRequiredPng;

function requirePng () {
	if (hasRequiredPng) return png;
	hasRequiredPng = 1;
	Object.defineProperty(png, "__esModule", { value: true });
	png.PNG = void 0;
	const utils_1 = requireUtils$1();
	const pngSignature = 'PNG\r\n\x1a\n';
	const pngImageHeaderChunkName = 'IHDR';
	// Used to detect "fried" png's: http://www.jongware.com/pngdefry.html
	const pngFriedChunkName = 'CgBI';
	png.PNG = {
	    validate(input) {
	        if (pngSignature === (0, utils_1.toUTF8String)(input, 1, 8)) {
	            let chunkName = (0, utils_1.toUTF8String)(input, 12, 16);
	            if (chunkName === pngFriedChunkName) {
	                chunkName = (0, utils_1.toUTF8String)(input, 28, 32);
	            }
	            if (chunkName !== pngImageHeaderChunkName) {
	                throw new TypeError('Invalid PNG');
	            }
	            return true;
	        }
	        return false;
	    },
	    calculate(input) {
	        if ((0, utils_1.toUTF8String)(input, 12, 16) === pngFriedChunkName) {
	            return {
	                height: (0, utils_1.readUInt32BE)(input, 36),
	                width: (0, utils_1.readUInt32BE)(input, 32),
	            };
	        }
	        return {
	            height: (0, utils_1.readUInt32BE)(input, 20),
	            width: (0, utils_1.readUInt32BE)(input, 16),
	        };
	    },
	};
	return png;
}

var pnm = {};

var hasRequiredPnm;

function requirePnm () {
	if (hasRequiredPnm) return pnm;
	hasRequiredPnm = 1;
	Object.defineProperty(pnm, "__esModule", { value: true });
	pnm.PNM = void 0;
	const utils_1 = requireUtils$1();
	const PNMTypes = {
	    P1: 'pbm/ascii',
	    P2: 'pgm/ascii',
	    P3: 'ppm/ascii',
	    P4: 'pbm',
	    P5: 'pgm',
	    P6: 'ppm',
	    P7: 'pam',
	    PF: 'pfm',
	};
	const handlers = {
	    default: (lines) => {
	        let dimensions = [];
	        while (lines.length > 0) {
	            const line = lines.shift();
	            if (line[0] === '#') {
	                continue;
	            }
	            dimensions = line.split(' ');
	            break;
	        }
	        if (dimensions.length === 2) {
	            return {
	                height: parseInt(dimensions[1], 10),
	                width: parseInt(dimensions[0], 10),
	            };
	        }
	        else {
	            throw new TypeError('Invalid PNM');
	        }
	    },
	    pam: (lines) => {
	        const size = {};
	        while (lines.length > 0) {
	            const line = lines.shift();
	            if (line.length > 16 || line.charCodeAt(0) > 128) {
	                continue;
	            }
	            const [key, value] = line.split(' ');
	            if (key && value) {
	                size[key.toLowerCase()] = parseInt(value, 10);
	            }
	            if (size.height && size.width) {
	                break;
	            }
	        }
	        if (size.height && size.width) {
	            return {
	                height: size.height,
	                width: size.width,
	            };
	        }
	        else {
	            throw new TypeError('Invalid PAM');
	        }
	    },
	};
	pnm.PNM = {
	    validate: (input) => (0, utils_1.toUTF8String)(input, 0, 2) in PNMTypes,
	    calculate(input) {
	        const signature = (0, utils_1.toUTF8String)(input, 0, 2);
	        const type = PNMTypes[signature];
	        // TODO: this probably generates garbage. move to a stream based parser
	        const lines = (0, utils_1.toUTF8String)(input, 3).split(/[\r\n]+/);
	        const handler = handlers[type] || handlers.default;
	        return handler(lines);
	    },
	};
	return pnm;
}

var psd = {};

var hasRequiredPsd;

function requirePsd () {
	if (hasRequiredPsd) return psd;
	hasRequiredPsd = 1;
	Object.defineProperty(psd, "__esModule", { value: true });
	psd.PSD = void 0;
	const utils_1 = requireUtils$1();
	psd.PSD = {
	    validate: (input) => (0, utils_1.toUTF8String)(input, 0, 4) === '8BPS',
	    calculate: (input) => ({
	        height: (0, utils_1.readUInt32BE)(input, 14),
	        width: (0, utils_1.readUInt32BE)(input, 18),
	    }),
	};
	return psd;
}

var svg = {};

var hasRequiredSvg;

function requireSvg () {
	if (hasRequiredSvg) return svg;
	hasRequiredSvg = 1;
	Object.defineProperty(svg, "__esModule", { value: true });
	svg.SVG = void 0;
	const utils_1 = requireUtils$1();
	const svgReg = /<svg\s([^>"']|"[^"]*"|'[^']*')*>/;
	const extractorRegExps = {
	    height: /\sheight=(['"])([^%]+?)\1/,
	    root: svgReg,
	    viewbox: /\sviewBox=(['"])(.+?)\1/i,
	    width: /\swidth=(['"])([^%]+?)\1/,
	};
	const INCH_CM = 2.54;
	const units = {
	    in: 96,
	    cm: 96 / INCH_CM,
	    em: 16,
	    ex: 8,
	    m: (96 / INCH_CM) * 100,
	    mm: 96 / INCH_CM / 10,
	    pc: 96 / 72 / 12,
	    pt: 96 / 72,
	    px: 1,
	};
	const unitsReg = new RegExp(`^([0-9.]+(?:e\\d+)?)(${Object.keys(units).join('|')})?$`);
	function parseLength(len) {
	    const m = unitsReg.exec(len);
	    if (!m) {
	        return undefined;
	    }
	    return Math.round(Number(m[1]) * (units[m[2]] || 1));
	}
	function parseViewbox(viewbox) {
	    const bounds = viewbox.split(' ');
	    return {
	        height: parseLength(bounds[3]),
	        width: parseLength(bounds[2]),
	    };
	}
	function parseAttributes(root) {
	    const width = root.match(extractorRegExps.width);
	    const height = root.match(extractorRegExps.height);
	    const viewbox = root.match(extractorRegExps.viewbox);
	    return {
	        height: height && parseLength(height[2]),
	        viewbox: viewbox && parseViewbox(viewbox[2]),
	        width: width && parseLength(width[2]),
	    };
	}
	function calculateByDimensions(attrs) {
	    return {
	        height: attrs.height,
	        width: attrs.width,
	    };
	}
	function calculateByViewbox(attrs, viewbox) {
	    const ratio = viewbox.width / viewbox.height;
	    if (attrs.width) {
	        return {
	            height: Math.floor(attrs.width / ratio),
	            width: attrs.width,
	        };
	    }
	    if (attrs.height) {
	        return {
	            height: attrs.height,
	            width: Math.floor(attrs.height * ratio),
	        };
	    }
	    return {
	        height: viewbox.height,
	        width: viewbox.width,
	    };
	}
	svg.SVG = {
	    // Scan only the first kilo-byte to speed up the check on larger files
	    validate: (input) => svgReg.test((0, utils_1.toUTF8String)(input, 0, 1000)),
	    calculate(input) {
	        const root = (0, utils_1.toUTF8String)(input).match(extractorRegExps.root);
	        if (root) {
	            const attrs = parseAttributes(root[0]);
	            if (attrs.width && attrs.height) {
	                return calculateByDimensions(attrs);
	            }
	            if (attrs.viewbox) {
	                return calculateByViewbox(attrs, attrs.viewbox);
	            }
	        }
	        throw new TypeError('Invalid SVG');
	    },
	};
	return svg;
}

var tga = {};

var hasRequiredTga;

function requireTga () {
	if (hasRequiredTga) return tga;
	hasRequiredTga = 1;
	Object.defineProperty(tga, "__esModule", { value: true });
	tga.TGA = void 0;
	const utils_1 = requireUtils$1();
	tga.TGA = {
	    validate(input) {
	        return (0, utils_1.readUInt16LE)(input, 0) === 0 && (0, utils_1.readUInt16LE)(input, 4) === 0;
	    },
	    calculate(input) {
	        return {
	            height: (0, utils_1.readUInt16LE)(input, 14),
	            width: (0, utils_1.readUInt16LE)(input, 12),
	        };
	    },
	};
	return tga;
}

var tiff = {};

var hasRequiredTiff;

function requireTiff () {
	if (hasRequiredTiff) return tiff;
	hasRequiredTiff = 1;
	Object.defineProperty(tiff, "__esModule", { value: true });
	tiff.TIFF = void 0;
	// based on http://www.compix.com/fileformattif.htm
	// TO-DO: support big-endian as well
	const fs = fs__default;
	const utils_1 = requireUtils$1();
	// Read IFD (image-file-directory) into a buffer
	function readIFD(input, filepath, isBigEndian) {
	    const ifdOffset = (0, utils_1.readUInt)(input, 32, 4, isBigEndian);
	    // read only till the end of the file
	    let bufferSize = 1024;
	    const fileSize = fs.statSync(filepath).size;
	    if (ifdOffset + bufferSize > fileSize) {
	        bufferSize = fileSize - ifdOffset - 10;
	    }
	    // populate the buffer
	    const endBuffer = new Uint8Array(bufferSize);
	    const descriptor = fs.openSync(filepath, 'r');
	    fs.readSync(descriptor, endBuffer, 0, bufferSize, ifdOffset);
	    fs.closeSync(descriptor);
	    return endBuffer.slice(2);
	}
	// TIFF values seem to be messed up on Big-Endian, this helps
	function readValue(input, isBigEndian) {
	    const low = (0, utils_1.readUInt)(input, 16, 8, isBigEndian);
	    const high = (0, utils_1.readUInt)(input, 16, 10, isBigEndian);
	    return (high << 16) + low;
	}
	// move to the next tag
	function nextTag(input) {
	    if (input.length > 24) {
	        return input.slice(12);
	    }
	}
	// Extract IFD tags from TIFF metadata
	function extractTags(input, isBigEndian) {
	    const tags = {};
	    let temp = input;
	    while (temp && temp.length) {
	        const code = (0, utils_1.readUInt)(temp, 16, 0, isBigEndian);
	        const type = (0, utils_1.readUInt)(temp, 16, 2, isBigEndian);
	        const length = (0, utils_1.readUInt)(temp, 32, 4, isBigEndian);
	        // 0 means end of IFD
	        if (code === 0) {
	            break;
	        }
	        else {
	            // 256 is width, 257 is height
	            // if (code === 256 || code === 257) {
	            if (length === 1 && (type === 3 || type === 4)) {
	                tags[code] = readValue(temp, isBigEndian);
	            }
	            // move to the next tag
	            temp = nextTag(temp);
	        }
	    }
	    return tags;
	}
	// Test if the TIFF is Big Endian or Little Endian
	function determineEndianness(input) {
	    const signature = (0, utils_1.toUTF8String)(input, 0, 2);
	    if ('II' === signature) {
	        return 'LE';
	    }
	    else if ('MM' === signature) {
	        return 'BE';
	    }
	}
	const signatures = [
	    // '492049', // currently not supported
	    '49492a00', // Little endian
	    '4d4d002a', // Big Endian
	    // '4d4d002a', // BigTIFF > 4GB. currently not supported
	];
	tiff.TIFF = {
	    validate: (input) => signatures.includes((0, utils_1.toHexString)(input, 0, 4)),
	    calculate(input, filepath) {
	        if (!filepath) {
	            throw new TypeError('Tiff doesn\'t support buffer');
	        }
	        // Determine BE/LE
	        const isBigEndian = determineEndianness(input) === 'BE';
	        // read the IFD
	        const ifdBuffer = readIFD(input, filepath, isBigEndian);
	        // extract the tags from the IFD
	        const tags = extractTags(ifdBuffer, isBigEndian);
	        const width = tags[256];
	        const height = tags[257];
	        if (!width || !height) {
	            throw new TypeError('Invalid Tiff. Missing tags');
	        }
	        return { height, width };
	    },
	};
	return tiff;
}

var webp = {};

var hasRequiredWebp;

function requireWebp () {
	if (hasRequiredWebp) return webp;
	hasRequiredWebp = 1;
	Object.defineProperty(webp, "__esModule", { value: true });
	webp.WEBP = void 0;
	const utils_1 = requireUtils$1();
	function calculateExtended(input) {
	    return {
	        height: 1 + (0, utils_1.readUInt24LE)(input, 7),
	        width: 1 + (0, utils_1.readUInt24LE)(input, 4),
	    };
	}
	function calculateLossless(input) {
	    return {
	        height: 1 +
	            (((input[4] & 0xf) << 10) | (input[3] << 2) | ((input[2] & 0xc0) >> 6)),
	        width: 1 + (((input[2] & 0x3f) << 8) | input[1]),
	    };
	}
	function calculateLossy(input) {
	    // `& 0x3fff` returns the last 14 bits
	    // TO-DO: include webp scaling in the calculations
	    return {
	        height: (0, utils_1.readInt16LE)(input, 8) & 0x3fff,
	        width: (0, utils_1.readInt16LE)(input, 6) & 0x3fff,
	    };
	}
	webp.WEBP = {
	    validate(input) {
	        const riffHeader = 'RIFF' === (0, utils_1.toUTF8String)(input, 0, 4);
	        const webpHeader = 'WEBP' === (0, utils_1.toUTF8String)(input, 8, 12);
	        const vp8Header = 'VP8' === (0, utils_1.toUTF8String)(input, 12, 15);
	        return riffHeader && webpHeader && vp8Header;
	    },
	    calculate(input) {
	        const chunkHeader = (0, utils_1.toUTF8String)(input, 12, 16);
	        input = input.slice(20, 30);
	        // Extended webp stream signature
	        if (chunkHeader === 'VP8X') {
	            const extendedHeader = input[0];
	            const validStart = (extendedHeader & 0xc0) === 0;
	            const validEnd = (extendedHeader & 0x01) === 0;
	            if (validStart && validEnd) {
	                return calculateExtended(input);
	            }
	            else {
	                // TODO: breaking change
	                throw new TypeError('Invalid WebP');
	            }
	        }
	        // Lossless webp stream signature
	        if (chunkHeader === 'VP8 ' && input[0] !== 0x2f) {
	            return calculateLossy(input);
	        }
	        // Lossy webp stream signature
	        const signature = (0, utils_1.toHexString)(input, 3, 6);
	        if (chunkHeader === 'VP8L' && signature !== '9d012a') {
	            return calculateLossless(input);
	        }
	        throw new TypeError('Invalid WebP');
	    },
	};
	return webp;
}

var hasRequiredTypes$1;

function requireTypes$1 () {
	if (hasRequiredTypes$1) return types$1;
	hasRequiredTypes$1 = 1;
	Object.defineProperty(types$1, "__esModule", { value: true });
	types$1.typeHandlers = void 0;
	// load all available handlers explicitly for browserify support
	const bmp_1 = requireBmp();
	const cur_1 = requireCur();
	const dds_1 = requireDds();
	const gif_1 = requireGif();
	const heif_1 = requireHeif();
	const icns_1 = requireIcns();
	const ico_1 = requireIco();
	const j2c_1 = requireJ2c();
	const jp2_1 = requireJp2();
	const jpg_1 = requireJpg();
	const ktx_1 = requireKtx();
	const png_1 = requirePng();
	const pnm_1 = requirePnm();
	const psd_1 = requirePsd();
	const svg_1 = requireSvg();
	const tga_1 = requireTga();
	const tiff_1 = requireTiff();
	const webp_1 = requireWebp();
	types$1.typeHandlers = {
	    bmp: bmp_1.BMP,
	    cur: cur_1.CUR,
	    dds: dds_1.DDS,
	    gif: gif_1.GIF,
	    heif: heif_1.HEIF,
	    icns: icns_1.ICNS,
	    ico: ico_1.ICO,
	    j2c: j2c_1.J2C,
	    jp2: jp2_1.JP2,
	    jpg: jpg_1.JPG,
	    ktx: ktx_1.KTX,
	    png: png_1.PNG,
	    pnm: pnm_1.PNM,
	    psd: psd_1.PSD,
	    svg: svg_1.SVG,
	    tga: tga_1.TGA,
	    tiff: tiff_1.TIFF,
	    webp: webp_1.WEBP,
	};
	return types$1;
}

var detector = {};

var hasRequiredDetector;

function requireDetector () {
	if (hasRequiredDetector) return detector;
	hasRequiredDetector = 1;
	Object.defineProperty(detector, "__esModule", { value: true });
	detector.detector = void 0;
	const index_1 = requireTypes$1();
	const keys = Object.keys(index_1.typeHandlers);
	// This map helps avoid validating for every single image type
	const firstBytes = {
	    0x38: 'psd',
	    0x42: 'bmp',
	    0x44: 'dds',
	    0x47: 'gif',
	    0x49: 'tiff',
	    0x4d: 'tiff',
	    0x52: 'webp',
	    0x69: 'icns',
	    0x89: 'png',
	    0xff: 'jpg',
	};
	function detector$1(input) {
	    const byte = input[0];
	    if (byte in firstBytes) {
	        const type = firstBytes[byte];
	        if (type && index_1.typeHandlers[type].validate(input)) {
	            return type;
	        }
	    }
	    const finder = (key) => index_1.typeHandlers[key].validate(input);
	    return keys.find(finder);
	}
	detector.detector = detector$1;
	return detector;
}

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist.exports;
	hasRequiredDist = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.types = exports.setConcurrency = exports.disableTypes = exports.disableFS = exports.imageSize = void 0;
		const fs = fs__default;
		const path$1 = path;
		const queue_1 = requireQueue();
		const index_1 = requireTypes$1();
		const detector_1 = requireDetector();
		// Maximum input size, with a default of 512 kilobytes.
		// TO-DO: make this adaptive based on the initial signature of the image
		const MaxInputSize = 512 * 1024;
		// This queue is for async `fs` operations, to avoid reaching file-descriptor limits
		const queue = new queue_1.default({ concurrency: 100, autostart: true });
		const globalOptions = {
		    disabledFS: false,
		    disabledTypes: [],
		};
		/**
		 * Return size information based on an Uint8Array
		 *
		 * @param {Uint8Array} input
		 * @param {String} filepath
		 * @returns {Object}
		 */
		function lookup(input, filepath) {
		    // detect the file type.. don't rely on the extension
		    const type = (0, detector_1.detector)(input);
		    if (typeof type !== 'undefined') {
		        if (globalOptions.disabledTypes.indexOf(type) > -1) {
		            throw new TypeError('disabled file type: ' + type);
		        }
		        // find an appropriate handler for this file type
		        if (type in index_1.typeHandlers) {
		            const size = index_1.typeHandlers[type].calculate(input, filepath);
		            if (size !== undefined) {
		                size.type = size.type ?? type;
		                return size;
		            }
		        }
		    }
		    // throw up, if we don't understand the file
		    throw new TypeError('unsupported file type: ' + type + ' (file: ' + filepath + ')');
		}
		/**
		 * Reads a file into an Uint8Array.
		 * @param {String} filepath
		 * @returns {Promise<Uint8Array>}
		 */
		async function readFileAsync(filepath) {
		    const handle = await fs.promises.open(filepath, 'r');
		    try {
		        const { size } = await handle.stat();
		        if (size <= 0) {
		            throw new Error('Empty file');
		        }
		        const inputSize = Math.min(size, MaxInputSize);
		        const input = new Uint8Array(inputSize);
		        await handle.read(input, 0, inputSize, 0);
		        return input;
		    }
		    finally {
		        await handle.close();
		    }
		}
		/**
		 * Synchronously reads a file into an Uint8Array, blocking the nodejs process.
		 *
		 * @param {String} filepath
		 * @returns {Uint8Array}
		 */
		function readFileSync(filepath) {
		    // read from the file, synchronously
		    const descriptor = fs.openSync(filepath, 'r');
		    try {
		        const { size } = fs.fstatSync(descriptor);
		        if (size <= 0) {
		            throw new Error('Empty file');
		        }
		        const inputSize = Math.min(size, MaxInputSize);
		        const input = new Uint8Array(inputSize);
		        fs.readSync(descriptor, input, 0, inputSize, 0);
		        return input;
		    }
		    finally {
		        fs.closeSync(descriptor);
		    }
		}
		// eslint-disable-next-line @typescript-eslint/no-use-before-define
		module.exports = exports = imageSize; // backwards compatibility
		exports.default = imageSize;
		/**
		 * @param {Uint8Array|string} input - Uint8Array or relative/absolute path of the image file
		 * @param {Function=} [callback] - optional function for async detection
		 */
		function imageSize(input, callback) {
		    // Handle Uint8Array input
		    if (input instanceof Uint8Array) {
		        return lookup(input);
		    }
		    // input should be a string at this point
		    if (typeof input !== 'string' || globalOptions.disabledFS) {
		        throw new TypeError('invalid invocation. input should be a Uint8Array');
		    }
		    // resolve the file path
		    const filepath = path$1.resolve(input);
		    if (typeof callback === 'function') {
		        queue.push(() => readFileAsync(filepath)
		            .then((input) => process.nextTick(callback, null, lookup(input, filepath)))
		            .catch(callback));
		    }
		    else {
		        const input = readFileSync(filepath);
		        return lookup(input, filepath);
		    }
		}
		exports.imageSize = imageSize;
		const disableFS = (v) => {
		    globalOptions.disabledFS = v;
		};
		exports.disableFS = disableFS;
		const disableTypes = (types) => {
		    globalOptions.disabledTypes = types;
		};
		exports.disableTypes = disableTypes;
		const setConcurrency = (c) => {
		    queue.concurrency = c;
		};
		exports.setConcurrency = setConcurrency;
		exports.types = Object.keys(index_1.typeHandlers); 
	} (dist, dist.exports));
	return dist.exports;
}

var distExports = requireDist();
const imageSize = /*@__PURE__*/getDefaultExportFromCjs(distExports);

class RequestUtil {
  // 适用于获取服务器下发cookies时获取，仅GET
  static async HttpsGetCookies(url) {
    const client = url.startsWith("https") ? https : http;
    return new Promise((resolve, reject) => {
      const req = client.get(url, (res) => {
        const cookies = {};
        res.on("data", () => {
        });
        res.on("end", () => {
          this.handleRedirect(res, url, cookies).then(resolve).catch(reject);
        });
        if (res.headers["set-cookie"]) {
          this.extractCookies(res.headers["set-cookie"], cookies);
        }
      });
      req.on("error", (error) => {
        reject(error);
      });
    });
  }
  static async handleRedirect(res, url, cookies) {
    if (res.statusCode === 301 || res.statusCode === 302) {
      if (res.headers.location) {
        const redirectUrl = new URL(res.headers.location, url);
        const redirectCookies = await this.HttpsGetCookies(redirectUrl.href);
        return { ...cookies, ...redirectCookies };
      }
    }
    return cookies;
  }
  static extractCookies(setCookieHeaders, cookies) {
    setCookieHeaders.forEach((cookie) => {
      const parts = cookie.split(";")[0].split("=");
      const key = parts[0];
      const value = parts[1];
      if (key && value && key.length > 0 && value.length > 0) {
        cookies[key] = value;
      }
    });
  }
  // 请求和回复都是JSON data传原始内容 自动编码json
  static async HttpGetJson(url, method = "GET", data, headers = {}, isJsonRet = true, isArgJson = true) {
    const option = new URL(url);
    const protocol = url.startsWith("https://") ? https : http;
    const options = {
      hostname: option.hostname,
      port: option.port,
      path: option.pathname + option.search,
      method,
      headers
    };
    return new Promise((resolve, reject) => {
      const req = protocol.request(options, (res) => {
        let responseBody = "";
        res.on("data", (chunk) => {
          responseBody += chunk.toString();
        });
        res.on("end", () => {
          try {
            if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
              if (isJsonRet) {
                const responseJson = JSON.parse(responseBody);
                resolve(responseJson);
              } else {
                resolve(responseBody);
              }
            } else {
              reject(new Error(`Unexpected status code: ${res.statusCode}`));
            }
          } catch (parseError) {
            reject(new Error(parseError.message));
          }
        });
      });
      req.on("error", (error) => {
        reject(error);
      });
      if (method === "POST" || method === "PUT" || method === "PATCH") {
        if (isArgJson) {
          req.write(JSON.stringify(data));
        } else {
          req.write(data);
        }
      }
      req.end();
    });
  }
  // 请求返回都是原始内容
  static async HttpGetText(url, method = "GET", data, headers = {}) {
    return this.HttpGetJson(url, method, data, headers, false, false);
  }
}

class RkeyManager {
  serverUrl = [];
  logger;
  rkeyData = {
    group_rkey: "",
    private_rkey: "",
    expired_time: 0
  };
  constructor(serverUrl, logger) {
    this.logger = logger;
    this.serverUrl = serverUrl;
  }
  async getRkey() {
    if (this.isExpired()) {
      try {
        await this.refreshRkey();
      } catch (e) {
        throw new Error(`获取rkey失败: ${e}`);
      }
    }
    return this.rkeyData;
  }
  isExpired() {
    const now = (/* @__PURE__ */ new Date()).getTime() / 1e3;
    return now > this.rkeyData.expired_time;
  }
  async refreshRkey() {
    for (const url of this.serverUrl) {
      try {
        const temp = await RequestUtil.HttpGetJson(url, "GET");
        this.rkeyData = {
          group_rkey: temp.group_rkey.slice(6),
          private_rkey: temp.private_rkey.slice(6),
          expired_time: temp.expired_time
        };
      } catch (e) {
        this.logger.logError(`[Rkey] Get Rkey ${url} Error `, e);
        if (url === this.serverUrl[this.serverUrl.length - 1]) {
          throw new Error(`获取rkey失败: ${e}`);
        }
      }
    }
  }
}

function checkFileExist(path2, timeout = 3e3) {
  return new Promise((resolve, reject) => {
    const startTime = Date.now();
    function check() {
      if (fs__default.existsSync(path2)) {
        resolve();
      } else if (Date.now() - startTime > timeout) {
        reject(new Error(`文件不存在: ${path2}`));
      } else {
        setTimeout(check, 100);
      }
    }
    check();
  });
}
async function checkFileExistV2(path2, timeout = 3e3) {
  await Promise.race([
    checkFile(path2),
    timeoutPromise(timeout, `文件不存在: ${path2}`)
  ]);
}
function timeoutPromise(timeout, errorMsg) {
  return new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error(errorMsg));
    }, timeout);
  });
}
async function checkFile(path2) {
  try {
    await stat$1(path2);
  } catch (error) {
    if (error.code === "ENOENT") {
      throw new Error(`文件不存在: ${path2}`);
    } else {
      throw error;
    }
  }
}
function calculateFileMD5(filePath) {
  return new Promise((resolve, reject) => {
    const stream = fs__default.createReadStream(filePath);
    const hash = crypto__default.createHash("md5");
    stream.on("data", (data) => {
      hash.update(data);
    });
    stream.on("end", () => {
      const md5 = hash.digest("hex");
      resolve(md5);
    });
    stream.on("error", (err) => {
      reject(err);
    });
  });
}
async function tryDownload(options, useReferer = false) {
  let url;
  let headers = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36"
  };
  if (typeof options === "string") {
    url = options;
    headers["Host"] = new URL(url).hostname;
  } else {
    url = options.url;
    if (options.headers) {
      if (typeof options.headers === "string") {
        headers = JSON.parse(options.headers);
      } else {
        headers = options.headers;
      }
    }
  }
  if (useReferer && !headers["Referer"]) {
    headers["Referer"] = url;
  }
  const fetchRes = await fetch(url, { headers }).catch((err) => {
    if (err.cause) {
      throw err.cause;
    }
    throw err;
  });
  return fetchRes;
}
async function httpDownload(options) {
  const useReferer = typeof options === "string";
  let resp = await tryDownload(options);
  if (resp.status === 403 && useReferer) {
    resp = await tryDownload(options, true);
  }
  if (!resp.ok) throw new Error(`下载文件失败: ${resp.statusText}`);
  const blob = await resp.blob();
  const buffer = await blob.arrayBuffer();
  return Buffer.from(buffer);
}
async function checkUriType(Uri) {
  const LocalFileRet = await solveProblem((uri) => {
    if (fs__default.existsSync(uri)) {
      return { Uri: uri, Type: 1 /* Local */ };
    }
    return void 0;
  }, Uri);
  if (LocalFileRet) return LocalFileRet;
  const OtherFileRet = await solveProblem((uri) => {
    if (uri.startsWith("http:") || uri.startsWith("https:")) {
      return { Uri: uri, Type: 2 /* Remote */ };
    }
    if (uri.startsWith("base64:")) {
      return { Uri: uri, Type: 3 /* Base64 */ };
    }
    if (uri.startsWith("file:")) {
      const filePath = decodeURIComponent(uri.startsWith("file:///") && process.platform === "win32" ? uri.slice(8) : uri.slice(7));
      return { Uri: filePath, Type: 1 /* Local */ };
    }
    if (uri.startsWith("data:")) {
      const data = uri.split(",")[1];
      if (data) return { Uri: data, Type: 3 /* Base64 */ };
    }
  }, Uri);
  if (OtherFileRet) return OtherFileRet;
  return { Uri, Type: 0 /* Unknown */ };
}
async function uriToLocalFile(dir, uri) {
  const { Uri: HandledUri, Type: UriType } = await checkUriType(uri);
  const filename = randomUUID();
  const filePath = path$1.join(dir, filename);
  switch (UriType) {
    case 1 /* Local */: {
      const fileExt = path$1.extname(HandledUri);
      const localFileName = path$1.basename(HandledUri, fileExt) + fileExt;
      const tempFilePath = path$1.join(dir, filename + fileExt);
      fs__default.copyFileSync(HandledUri, tempFilePath);
      return { success: true, errMsg: "", fileName: localFileName, path: tempFilePath };
    }
    case 2 /* Remote */: {
      const buffer = await httpDownload(HandledUri);
      fs__default.writeFileSync(filePath, buffer, { flag: "wx" });
      return { success: true, errMsg: "", fileName: filename, path: filePath };
    }
    case 3 /* Base64 */: {
      const base64 = HandledUri.replace(/^base64:\/\//, "");
      const base64Buffer = Buffer.from(base64, "base64");
      fs__default.writeFileSync(filePath, base64Buffer, { flag: "wx" });
      return { success: true, errMsg: "", fileName: filename, path: filePath };
    }
    default:
      return { success: false, errMsg: `识别URL失败, uri= ${uri}`, fileName: "", path: "" };
  }
}

const defaultVideoThumbB64 = "/9j/4AAQSkZJRgABAQAAAQABAAD//gAXR2VuZXJhdGVkIGJ5IFNuaXBhc3Rl/9sAhAAKBwcIBwYKCAgICwoKCw4YEA4NDQ4dFRYRGCMfJSQiHyIhJis3LyYpNCkhIjBBMTQ5Oz4+PiUuRElDPEg3PT47AQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAF/APADAREAAhEBAxEB/8QBogAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoLEAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+foBAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKCxEAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDiAayNxwagBwNAC5oAM0xBmgBM0ANJoAjY0AQsaBkTGgCM0DEpAFAC0AFMBaACgAoEJTASgQlACUwCgQ4UAOFADhQA4UAOFADxQIkBqDQUGgBwagBQaBC5pgGaAELUAMLUARs1AETGgBhNAxhoASkAUALQIKYxaBBQAUwEoAQ0CEoASmAUAOoEKKAHCgBwoAeKAHigQ7NZmoZpgLmgBd1Ahd1ABupgNLUAMLUAMY0AMJoAYaAENACUCCgAoAWgAoAWgBKYCUAJQISgApgLQAooEOFACigB4oAeKBDxQAVmaiZpgGaAFzQAbqAE3UAIWpgNJoAYTQIaaAEoAQ0CEoASgBaACgBaACmAUAJQAlAgoAKYC0AKKBCigB4FADgKBDwKAHigBuazNRM0DEzTAM0AJmgAzQAhNAhpNACGmA2gQlACUCEoAKACgBaAFpgFACUAJQAUCCmAUALQIcBQA4CgB4FADgKBDhQA4UAMzWZqNzTGJQAZoATNABmgBKAEoEIaYCUCEoASgQlABQAtABQAtMBKACgAoEFABimAYoEKBQA4CgB4FADwKBDgKAFFADhQBCazNhKAEpgFACUAFACUAFAhDTAbQISgAoEJQAUALQAtMAoAKADFABigQYoAMUALimIUCgBwFAh4FADgKAHUALQAtAENZmwlACUwEoAKAEoAKACgQlMBpoEJQAUCCgBcUAFABTAXFAC4oAMUAGKBBigAxQIKYCigQ8UAOFADhQAtAC0ALQBDWZqJQMSgBKYBQAlABQISgBKYCGgQlAC0CCgBcUAFABTAUCkA7FMAxQAYoEJQAUCCmAooEOFADxQA4UAFAC0ALQBDWZqJQAlACUxhQAlABQIKAEoASmISgBcUCCgBaACgBcUAKBQAuKYC0CEoAQ0AJQISmAooEPFADhQA4UALQAtAC0AQ1maiUAFACUAJTAKAEoAKAEoAMUxBigAxQIWgAoAKAFAoAWgBaYBQIQ0ANNACUCCmIUUAOFADxQA4UALQAtABQBFWZqFACUAFACYpgFACUAFACUAFAgxTEFABQAUALQAooAWgAoAKYDTQIaaAEpiCgQ4UAOFAh4oGOFAC0ALSAKYEdZmglABQAUDDFACUwEoASgAoAKBBQIKYBQAUALQAtAC0AJQAhpgNJoENJoATNMQCgQ8UCHigB4oAWgYtABQAUAMrM0CgAoAKADFACUxiUAJQAlAgoAKYgoAKACgYtAC0AFAhDTAQmgBhNAhpNACZpiFBoEPFAEi0CHigB1ABQAUDEoAbWZoFABQAtABTAQ0ANNAxDQAlAhaAEpiCgAoGFAC0AFABmgBCaYhpNADCaBDSaBBmgABpiJFNAEimgB4NADqAFzQAlACE0AJWZoFAC0AFAC0wEIoAaaAG0AJQAUCCgApjCgAoAKADNABmgBpNMQ0mgBpNAhhNAgzQAoNADwaAHqaAJAaBDgaYC5oATNACZoAWszQKACgBaBDqYCGgBpoAYaBiUCCgBKYBQMKACgAoAM0AITQIaTQA0mmA0mgQ3NAhKAHCgBwNADwaAHg0AOBpiFzQAZoATNAD6zNAoAKAFoEOpgBoAaaAGGmAw0AJmgAzQMM0AGaADNABmgBM0AITQIaTQAhNMQw0AJQIKAFFADhQA4GgBwNADs0xC5oAM0CDNAEtZmoUCCgBaAHUwCgBppgRtQAw0ANzQAZoAM0AGaADNABmgBKAEoAQ0ANNMQhoEJQAlMBaQDgaAFBoAcDTAdmgQuaADNAgzQBPWZqFAgoAWgBaYC0CGmmBG1AyM0ANJoATNACZoAXNABmgAzQAUAJQAhoAQ0xDTQISmAUALQAUgHA0AKDTAdmgQuaBBQAtAFiszQKACgBaAFFMAoEIaYEbUDI2oAYaAEoASgAzQAuaACgAoAKAENMQ00AJTEFAhKACgAoAXNACg0AOBoAWgQtAC0AWazNAoAKACgBaYBQIQ0AMNMYw0AMIoAbQAlMAoAKACgAzSAKYhKAENACUxBQIKACgBKACgBaAHCgQ4UALQAUAWqzNAoAKACgApgFACGgQ00xjTQAwigBCKAG4pgJQAlABQAUCCgBKACgBKYgoEFABQISgAoAWgBRQA4UALQAUCLdZmoUAFABQAlMAoASgBDQA00wENACYoATFMBpFADSKAEoEJQAUAFABQAlMQtAgoASgQUAJQAUAKKAHCgBaBBQBbrM1CgAoAKACmAUAJQAlADaYBQAlACYpgIRQA0igBpFAhtABQAUAFMAoEFABQIKAEoASgQUALQAooAWgQUAW81mbC0CCgApgFACUAIaAEpgJQAUAFABQAhFMBpFADSKAGkUCExQAYoAMUAGKADFMQYoAMUCExSATFABQIKYBQAtABQIt5qDYM0ALmgQtIApgIaAENADaACmAlAC0ALQAUwGkUANIoAaRQAmKBBigAxQAYoAMUAGKBBigBMUAJigQmKAExTAKBC0AFAFnNQaig0AKDQAtAgoASgBDQAlMBKACgAFADhQAtMBCKAGkUAIRQAmKADFABigQmKADFACYoAXFABigQmKAExQAmKBCYpgJigAoAnzUGgZoAcDQAuaBC0AJQAhoASmAlABQAtADhQAtMAoATFACEUAJigAxQAYoATFAhMUAFABQAuKADFABigBpWgBCKBCYpgJigB+ag0DNADgaBDgaAFzQITNACUAJTAKACgBRQAopgOoAWgBKAEoAKACgAoASgBpoEJQAooAWgBaBhigBMUCEIoAQigBMUAJSLCgBQaBDgaQC5oEFACUwCgBKACmAtADhQA4UALQAUAJQAUAJQAUAJQAhoENoAWgBRQAooGLQAUAGKAGkUAIRQIZSKEoGKKBDhQAUCCgAoAKBBQAUwFoGKKAHCgBaACgAoASgAoASgBCaAEoEJmgAoAUGgBQaAHZoGFABQAUANoAjpDEoAWgBaAFoEFACUALQAUCCmAUAOFAxRQAtAC0AJQAUAJQAmaBDSaAEzQAmaYBmgBQaAHA0gFzQAuaBhmgAzQAlAEdIYUALQAtAgoAKAEoEFAC0AFMAoAUUDFFAC0ALQAUAJQAhoENNACE0wEoATNABmgBc0ALmgBc0gDNAC5oATNABmgBKRQlACigB1AgoASgQlABTAWgBKACgBaBi0ALQAZoAM0AFACGgQ00wENACUAJQAUCFzQMM0ALmgAzQAZoAM0AGaQC0igoAUUALQIWgBDQISmAUAFACUAFABQAuaBi5oAM0AGaBBmgBKAEpgIaAG0AJQAUCFoAM0DDNAC5oATNABmgAzQBJUlBQAooAWgQtACGmIaaACgAoASgBKACgBc0DCgQUAGaADNABTASgBDQAlACUAFAgoAKBhQAUAFABQAlAE1SUFAxRQIWgQtMBDQIQ0AJQAlAhKBiUAFABmgBc0AGaADNABTAKACgBKAEoASgQlABQAUAFAC0AFACUAFAE1SaBQAUCHCgQtMBKBCUAJQISgBDQA00DEzQAuaADNMBc0AGaADNABQAUAJQAlABQISgAoAKACgBaACgBKAEoAnqTQSgBRQIcKBC0xCUAJQISgBKAENADDQAmaYwzQAuaADNAC0AFABQAUAFAhKACgBKACgAoAWgAoELQAlAxKAJqk0EoAWgQooELTEFADaBCUABoENNMY00ANNAwzQAZoAXNAC0AFAC0CFoASgAoASgBKACgAoAWgQtABQAUANNAyWpNAoAKBCimIWgQUCEoASmIQ0ANNADTQMaaAEoGLmgAzQAtADhQIWgBaACgQhoASgYlACUALQIWgBaACgBKAENAyWpNBKYBQIcKBC0CEoEJTAKBCUANNADDQMQ0ANoGFAC5oAUGgBwNAhRQIWgBaAENACGgBtAwoAKAFzQIXNABmgAoAQ0DJKRoJQAtAhRQSLQIKYCUCCgBDQA00AMNAxpoGNoAM0AGaAFBoAcDQIcKBDqACgBDQAhoAQ0DEoAKADNAC5oEGaBhmgAoAkpGgUCCgQooELQIKYhKACgBKAGmgBpoGMNAxDQAlAwzQIUUAOFAhwoAcKBC0AJQAhoGNNACUAFABQAZoAXNABQAUAS0ixKACgQoNAhaYgoEFACUABoAaaAGmgYw0DENAxtABQAooEOFADhQIcKAFoASgBDQAhoGJQAUAFACUALQIKBi0CJDSLEoATNAhc0CHZpiCgQUAJQIKBjTQAhoGNNAxpoATFABigBQKAHCgBwoAWgAoAKACgBKAEoASgAoASgBaAAUAOoEONIoaTQAZoAUGmIUGgQtAgzQISgAoAQ0DGmgYlAxKACgAxQAtACigBRQAtAxaACgAoATFABigBCKAG0CEoAWgBRTAUUAf//Z";
async function getFileSize(filePath) {
  const stats = await fs__default.promises.stat(filePath);
  return stats.size;
}
function setFfmpegPath() {
  const ffmpegPath = process.env.FFMPEG_PATH;
  if (ffmpegPath) {
    ffmpeg.setFfmpegPath(ffmpegPath);
  }
}
function extractVideoStream(metadata) {
  return metadata.streams.find((s) => s.codec_type === "video");
}
async function probeVideo(filePath) {
  return new Promise((resolve, reject) => {
    ffmpeg(filePath).ffprobe((err, metadata) => {
      if (err) {
        reject(new Error("无法获取视频信息。"));
      } else {
        resolve(metadata);
      }
    });
  });
}
async function getVideoInfo(filePath, logger) {
  try {
    const size = await getFileSize(filePath);
    setFfmpegPath();
    const metadata = await probeVideo(filePath);
    const videoStream = extractVideoStream(metadata);
    if (!videoStream) {
      throw new Error("未找到视频流信息。");
    }
    logger.log(`视频尺寸: ${videoStream.width}x${videoStream.height}`);
    if (!videoStream.width || !metadata.format.format_name || !videoStream.height) {
      throw new Error("获取基础信息失败");
    }
    return {
      width: videoStream.width,
      height: videoStream.height,
      time: +(videoStream.duration ?? 10),
      format: metadata.format.format_name,
      size,
      filePath
    };
  } catch (error) {
    throw new Error("无法获取视频信息。");
  }
}

const ALLOW_SAMPLE_RATE = [8e3, 12e3, 16e3, 24e3, 32e3, 44100, 48e3];
const EXIT_CODES = [0, 255];
const FFMPEG_PATH$1 = process.env.FFMPEG_PATH ?? "ffmpeg";
async function getWorkerPath() {
  return new URL(
    /* @vite-ignore */
    "./audio-worker.mjs",
    import.meta.url
  ).href;
}
const piscina = new Piscina({
  filename: await getWorkerPath()
});
async function guessDuration(pttPath, logger) {
  const pttFileInfo = await fsPromise.stat(pttPath);
  const duration = Math.max(1, Math.floor(pttFileInfo.size / 1024 / 3));
  logger.log("通过文件大小估算语音的时长:", duration);
  return duration;
}
async function convert$1(filePath, pcmPath, logger) {
  return new Promise((resolve, reject) => {
    const cp = spawn(FFMPEG_PATH$1, ["-y", "-i", filePath, "-ar", "24000", "-ac", "1", "-f", "s16le", pcmPath]);
    cp.on("error", (err) => {
      logger.log("FFmpeg处理转换出错: ", err.message);
      reject(err);
    });
    cp.on("exit", async (code, signal) => {
      if (code == null || EXIT_CODES.includes(code)) {
        try {
          const data = await fsPromise.readFile(pcmPath);
          await fsPromise.unlink(pcmPath);
          resolve(data);
        } catch (err) {
          reject(err);
        }
      } else {
        logger.log(`FFmpeg exit: code=${code ?? "unknown"} sig=${signal ?? "unknown"}`);
        reject(new Error("FFmpeg处理转换失败"));
      }
    });
  });
}
async function handleWavFile(file, filePath, pcmPath, logger) {
  const { fmt } = getWavFileInfo(file);
  if (!ALLOW_SAMPLE_RATE.includes(fmt.sampleRate)) {
    return { input: await convert$1(filePath, pcmPath, logger), sampleRate: 24e3 };
  }
  return { input: file, sampleRate: fmt.sampleRate };
}
async function encodeSilk(filePath, TEMP_DIR, logger) {
  try {
    const file = await fsPromise.readFile(filePath);
    const pttPath = path$1.join(TEMP_DIR, randomUUID());
    if (!isSilk(file)) {
      logger.log(`语音文件${filePath}需要转换成silk`);
      const pcmPath = `${pttPath}.pcm`;
      const { input, sampleRate } = isWav(file) ? await handleWavFile(file, filePath, pcmPath, logger) : { input: await convert$1(filePath, pcmPath, logger), sampleRate: 24e3 };
      const silk = await piscina.run({ input, sampleRate });
      await fsPromise.writeFile(pttPath, Buffer.from(silk.data));
      logger.log(`语音文件${filePath}转换成功!`, pttPath, "时长:", silk.duration);
      return {
        converted: true,
        path: pttPath,
        duration: silk.duration / 1e3
      };
    } else {
      let duration = 0;
      try {
        duration = getDuration(file) / 1e3;
      } catch (e) {
        logger.log("获取语音文件时长失败, 使用文件大小推测时长", filePath, e.stack);
        duration = await guessDuration(filePath, logger);
      }
      return {
        converted: false,
        path: filePath,
        duration
      };
    }
  } catch (error) {
    logger.logError("convert silk failed", error.stack);
    return {};
  }
}

async function getFileTypeForSendType(picPath) {
  const fileTypeResult = (await fileTypeFromFile(picPath))?.ext ?? "jpg";
  const picTypeMap = {
    //'webp': PicType.NEWPIC_WEBP,
    "gif": PicType.NEWPIC_GIF
    // 'png': PicType.NEWPIC_APNG,
    // 'jpg': PicType.NEWPIC_JPEG,
    // 'jpeg': PicType.NEWPIC_JPEG,
    // 'bmp': PicType.NEWPIC_BMP,
  };
  return picTypeMap[fileTypeResult] ?? PicType.NEWPIC_JPEG;
}

class NTQQFileApi {
  context;
  core;
  rkeyManager;
  packetRkey;
  constructor(context, core) {
    this.context = context;
    this.core = core;
    this.rkeyManager = new RkeyManager(
      [
        "https://rkey.napneko.icu/rkeys"
      ],
      this.context.logger
    );
  }
  async copyFile(filePath, destPath) {
    await this.core.util.copyFile(filePath, destPath);
  }
  async getFileSize(filePath) {
    return await this.core.util.getFileSize(filePath);
  }
  async getVideoUrl(peer, msgId, elementId) {
    return (await this.context.session.getRichMediaService().getVideoPlayUrlV2(peer, msgId, elementId, 0, {
      downSourceType: 1,
      triggerType: 1
    })).urlResult.domainUrl;
  }
  async uploadFile(filePath, elementType = ElementType.PIC, elementSubType = 0) {
    const fileMd5 = await calculateFileMD5(filePath);
    const extOrEmpty = await fileTypeFromFile(filePath).then((e) => e?.ext ?? "").catch((e) => "");
    const ext = extOrEmpty ? `.${extOrEmpty}` : "";
    let fileName = `${path.basename(filePath)}`;
    if (fileName.indexOf(".") === -1) {
      fileName += ext;
    }
    const mediaPath = this.context.session.getMsgService().getRichMediaFilePathForGuild({
      md5HexStr: fileMd5,
      fileName,
      elementType,
      elementSubType,
      thumbSize: 0,
      needCreate: true,
      downloadType: 1,
      file_uuid: ""
    });
    await this.copyFile(filePath, mediaPath);
    const fileSize = await this.getFileSize(filePath);
    return {
      md5: fileMd5,
      fileName,
      path: mediaPath,
      fileSize,
      ext
    };
  }
  async createValidSendFileElement(context, filePath, fileName = "", folderId = "") {
    const {
      fileName: _fileName,
      path: path2,
      fileSize
    } = await this.core.apis.FileApi.uploadFile(filePath, ElementType.FILE);
    if (fileSize === 0) {
      throw new Error("文件异常，大小为0");
    }
    context.deleteAfterSentFiles.push(path2);
    return {
      elementType: ElementType.FILE,
      elementId: "",
      fileElement: {
        fileName: fileName || _fileName,
        folderId,
        filePath: path2,
        fileSize: fileSize.toString()
      }
    };
  }
  async createValidSendPicElement(context, picPath, summary = "", subType = 0) {
    const { md5, fileName, path: path2, fileSize } = await this.core.apis.FileApi.uploadFile(picPath, ElementType.PIC, subType);
    if (fileSize === 0) {
      throw new Error("文件异常，大小为0");
    }
    const imageSize2 = await this.core.apis.FileApi.getImageSize(picPath);
    context.deleteAfterSentFiles.push(path2);
    return {
      elementType: ElementType.PIC,
      elementId: "",
      picElement: {
        md5HexStr: md5,
        fileSize: fileSize.toString(),
        picWidth: imageSize2.width,
        picHeight: imageSize2.height,
        fileName,
        sourcePath: path2,
        original: true,
        picType: await getFileTypeForSendType(picPath),
        picSubType: subType,
        fileUuid: "",
        fileSubId: "",
        thumbFileSize: 0,
        summary
      }
    };
  }
  async createValidSendVideoElement(context, filePath, fileName = "", diyThumbPath = "") {
    let videoInfo = {
      width: 1920,
      height: 1080,
      time: 15,
      format: "mp4",
      size: 0,
      filePath
    };
    try {
      videoInfo = await getVideoInfo(filePath, this.context.logger);
    } catch (e) {
      this.context.logger.logError("获取视频信息失败，将使用默认值", e);
    }
    let fileExt = "mp4";
    try {
      const tempExt = (await fileTypeFromFile(filePath))?.ext;
      if (tempExt) fileExt = tempExt;
    } catch (e) {
      this.context.logger.logError("获取文件类型失败", e);
    }
    const newFilePath = filePath + "." + fileExt;
    fs__default.copyFileSync(filePath, newFilePath);
    context.deleteAfterSentFiles.push(newFilePath);
    filePath = newFilePath;
    const { fileName: _fileName, path: path2, fileSize, md5 } = await this.core.apis.FileApi.uploadFile(filePath, ElementType.VIDEO);
    if (fileSize === 0) {
      throw new Error("文件异常，大小为0");
    }
    videoInfo.size = fileSize;
    let thumb = path2.replace(`${path$1.sep}Ori${path$1.sep}`, `${path$1.sep}Thumb${path$1.sep}`);
    thumb = path$1.dirname(thumb);
    const thumbPath = /* @__PURE__ */ new Map();
    const _thumbPath = await new Promise((resolve, reject) => {
      const thumbFileName = `${md5}_0.png`;
      const thumbPath2 = path$1.join(thumb, thumbFileName);
      ffmpeg(filePath).on("error", (err) => {
        try {
          this.context.logger.logDebug("获取视频封面失败，使用默认封面", err);
          if (diyThumbPath) {
            fsPromise.copyFile(diyThumbPath, thumbPath2).then(() => {
              resolve(thumbPath2);
            }).catch(reject);
          } else {
            fs__default.writeFileSync(thumbPath2, Buffer.from(defaultVideoThumbB64, "base64"));
            resolve(thumbPath2);
          }
        } catch (error) {
          this.context.logger.logError("获取视频封面失败，使用默认封面失败", error);
        }
      }).screenshots({
        timestamps: [0],
        filename: thumbFileName,
        folder: thumb,
        size: videoInfo.width + "x" + videoInfo.height
      }).on("end", () => {
        resolve(thumbPath2);
      });
    });
    const thumbSize = _thumbPath ? (await fsPromise.stat(_thumbPath)).size : 0;
    thumbPath.set(0, _thumbPath);
    const thumbMd5 = _thumbPath ? await calculateFileMD5(_thumbPath) : "";
    context.deleteAfterSentFiles.push(path2);
    const uploadName = (fileName || _fileName).toLocaleLowerCase().endsWith("." + fileExt.toLocaleLowerCase()) ? fileName || _fileName : (fileName || _fileName) + "." + fileExt;
    return {
      elementType: ElementType.VIDEO,
      elementId: "",
      videoElement: {
        fileName: uploadName,
        filePath: path2,
        videoMd5: md5,
        thumbMd5,
        fileTime: videoInfo.time,
        thumbPath,
        thumbSize,
        thumbWidth: videoInfo.width,
        thumbHeight: videoInfo.height,
        fileSize: "" + fileSize
      }
    };
  }
  async createValidSendPttElement(pttPath) {
    const { converted, path: silkPath, duration } = await encodeSilk(pttPath, this.core.NapCatTempPath, this.core.context.logger);
    if (!silkPath) {
      throw new Error("语音转换失败, 请检查语音文件是否正常");
    }
    const { md5, fileName, path: path2, fileSize } = await this.core.apis.FileApi.uploadFile(silkPath, ElementType.PTT);
    if (fileSize === 0) {
      throw new Error("文件异常，大小为0");
    }
    if (converted) {
      fsPromise.unlink(silkPath).then().catch(
        (e) => this.context.logger.logError("删除临时文件失败", e)
      );
    }
    return {
      elementType: ElementType.PTT,
      elementId: "",
      pttElement: {
        fileName,
        filePath: path2,
        md5HexStr: md5,
        fileSize: fileSize.toString(),
        duration: duration ?? 1,
        formatType: 1,
        voiceType: 1,
        voiceChangeType: 0,
        canConvert2Text: true,
        waveAmplitudes: [
          0,
          18,
          9,
          23,
          16,
          17,
          16,
          15,
          44,
          17,
          24,
          20,
          14,
          15,
          17
        ],
        fileSubId: "",
        playState: 1,
        autoConvertText: 0
      }
    };
  }
  async downloadFileForModelId(peer, modelId, unknown, timeout = 1e3 * 60 * 2) {
    const [, fileTransNotifyInfo] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelRichMediaService/downloadFileForModelId",
      "NodeIKernelMsgListener/onRichMediaDownloadComplete",
      [peer, [modelId], unknown],
      () => true,
      (arg) => arg?.commonFileInfo?.fileModelId === modelId,
      1,
      timeout
    );
    return fileTransNotifyInfo.filePath;
  }
  async downloadRawMsgMedia(msg) {
    const res = await Promise.all(
      msg.map(
        (m) => Promise.all(
          m.elements.filter(
            (element) => element.elementType === ElementType.PIC || element.elementType === ElementType.VIDEO || element.elementType === ElementType.PTT || element.elementType === ElementType.FILE
          ).map(
            (element) => this.downloadMedia(m.msgId, m.chatType, m.peerUid, element.elementId, "", "", 1e3 * 60 * 2, true)
          )
        )
      )
    );
    msg.forEach((m, msgIndex) => {
      const elementResults = res[msgIndex];
      let elementIndex = 0;
      m.elements.forEach((element) => {
        if (element.elementType === ElementType.PIC || element.elementType === ElementType.VIDEO || element.elementType === ElementType.PTT || element.elementType === ElementType.FILE) {
          switch (element.elementType) {
            case ElementType.PIC:
              element.picElement.sourcePath = elementResults[elementIndex];
              break;
            case ElementType.VIDEO:
              element.videoElement.filePath = elementResults[elementIndex];
              break;
            case ElementType.PTT:
              element.pttElement.filePath = elementResults[elementIndex];
              break;
            case ElementType.FILE:
              element.fileElement.filePath = elementResults[elementIndex];
              break;
          }
          elementIndex++;
        }
      });
    });
  }
  async downloadMedia(msgId, chatType, peerUid, elementId, thumbPath, sourcePath, timeout = 1e3 * 60 * 2, force = false) {
    if (sourcePath && fs__default.existsSync(sourcePath)) {
      if (force) {
        try {
          await fsPromise.unlink(sourcePath);
        } catch (e) {
        }
      } else {
        return sourcePath;
      }
    }
    const [, completeRetData] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelMsgService/downloadRichMedia",
      "NodeIKernelMsgListener/onRichMediaDownloadComplete",
      [{
        fileModelId: "0",
        downloadSourceType: 0,
        triggerType: 1,
        msgId,
        chatType,
        peerUid,
        elementId,
        thumbSize: 0,
        downloadType: 1,
        filePath: thumbPath
      }],
      () => true,
      (arg) => arg.msgElementId === elementId && arg.msgId === msgId,
      1,
      timeout
    );
    return completeRetData.filePath;
  }
  async getImageSize(filePath) {
    return new Promise((resolve, reject) => {
      imageSize(filePath, (err, dimensions) => {
        if (err) {
          reject(new Error(err.message));
        } else if (!dimensions) {
          reject(new Error("获取图片尺寸失败"));
        } else {
          resolve(dimensions);
        }
      });
    });
  }
  async searchForFile(keys) {
    const randomResultId = 1e5 + Math.floor(Math.random() * 1e4);
    let searchId = 0;
    const [, searchResult] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelFileAssistantService/searchFile",
      "NodeIKernelFileAssistantListener/onFileSearch",
      [
        keys,
        { resultType: 2, pageLimit: 1 },
        randomResultId
      ],
      (ret) => {
        searchId = ret;
        return true;
      },
      (result) => result.searchId === searchId && result.resultId === randomResultId
    );
    return searchResult.resultItems[0];
  }
  async downloadFileById(fileId, fileSize = 1024576, estimatedTime = fileSize * 1e3 / 1024576 + 5e3) {
    const [, fileData] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelFileAssistantService/downloadFile",
      "NodeIKernelFileAssistantListener/onFileStatusChanged",
      [[fileId]],
      (ret) => ret.result === 0,
      (status) => status.fileStatus === 2 && status.fileProgress === "0",
      1,
      estimatedTime
      // estimate 1MB/s
    );
    return fileData.filePath;
  }
  async getImageUrl(element) {
    if (!element) {
      return "";
    }
    const url = element.originImageUrl ?? "";
    const md5HexStr = element.md5HexStr;
    const fileMd5 = element.md5HexStr;
    const parsedUrl = new URL(IMAGE_HTTP_HOST + url);
    const imageAppid = parsedUrl.searchParams.get("appid");
    const isNTV2 = imageAppid && ["1406", "1407"].includes(imageAppid);
    const imageFileId = parsedUrl.searchParams.get("fileid");
    if (url && isNTV2 && imageFileId) {
      const rkeyData = await this.getRkeyData();
      return this.getImageUrlFromParsedUrl(imageFileId, imageAppid, rkeyData);
    }
    return this.getImageUrlFromMd5(fileMd5, md5HexStr);
  }
  async getRkeyData() {
    const rkeyData = {
      private_rkey: "CAQSKAB6JWENi5LM_xp9vumLbuThJSaYf-yzMrbZsuq7Uz2qEc3Rbib9LP4",
      group_rkey: "CAQSKAB6JWENi5LM_xp9vumLbuThJSaYf-yzMrbZsuq7Uz2qffcqm614gds",
      online_rkey: false
    };
    try {
      if (this.core.apis.PacketApi.available) {
        const rkey_expired_private = !this.packetRkey || this.packetRkey[0].time + Number(this.packetRkey[0].ttl) < Date.now() / 1e3;
        const rkey_expired_group = !this.packetRkey || this.packetRkey[0].time + Number(this.packetRkey[0].ttl) < Date.now() / 1e3;
        if (rkey_expired_private || rkey_expired_group) {
          this.packetRkey = await this.core.apis.PacketApi.pkt.operation.FetchRkey();
        }
        if (this.packetRkey && this.packetRkey.length > 0) {
          rkeyData.group_rkey = this.packetRkey[1].rkey.slice(6);
          rkeyData.private_rkey = this.packetRkey[0].rkey.slice(6);
          rkeyData.online_rkey = true;
        }
      }
    } catch (error) {
      this.context.logger.logError("获取rkey失败", error.message);
    }
    if (!rkeyData.online_rkey) {
      try {
        const tempRkeyData = await this.rkeyManager.getRkey();
        rkeyData.group_rkey = tempRkeyData.group_rkey;
        rkeyData.private_rkey = tempRkeyData.private_rkey;
        rkeyData.online_rkey = tempRkeyData.expired_time > Date.now() / 1e3;
      } catch (e) {
        this.context.logger.logError("获取rkey失败 Fallback Old Mode", e);
      }
    }
    return rkeyData;
  }
  getImageUrlFromParsedUrl(imageFileId, appid, rkeyData) {
    const rkey = appid === "1406" ? rkeyData.private_rkey : rkeyData.group_rkey;
    if (rkeyData.online_rkey) {
      return IMAGE_HTTP_HOST_NT + `/download?appid=${appid}&fileid=${imageFileId}&rkey=${rkey}`;
    }
    return IMAGE_HTTP_HOST + `/download?appid=${appid}&fileid=${imageFileId}&rkey=${rkey}`;
  }
  getImageUrlFromMd5(fileMd5, md5HexStr) {
    if (fileMd5 || md5HexStr) {
      return `${IMAGE_HTTP_HOST}/gchatpic_new/0/0-0-${(fileMd5 ?? md5HexStr ?? "").toUpperCase()}/0`;
    }
    this.context.logger.logDebug("图片url获取失败", { fileMd5, md5HexStr });
    return "";
  }
}

class LimitedHashTable {
  keyToValue = /* @__PURE__ */ new Map();
  valueToKey = /* @__PURE__ */ new Map();
  maxSize;
  constructor(maxSize) {
    this.maxSize = maxSize;
  }
  resize(count) {
    this.maxSize = count;
  }
  set(key, value) {
    this.keyToValue.set(key, value);
    this.valueToKey.set(value, key);
    while (this.keyToValue.size !== this.valueToKey.size) {
      this.keyToValue.clear();
      this.valueToKey.clear();
    }
    while (this.keyToValue.size > this.maxSize || this.valueToKey.size > this.maxSize) {
      const oldestKey = this.keyToValue.keys().next().value;
      if (oldestKey !== void 0) {
        this.valueToKey.delete(this.keyToValue.get(oldestKey));
        this.keyToValue.delete(oldestKey);
      }
    }
  }
  getValue(key) {
    return this.keyToValue.get(key);
  }
  getKey(value) {
    return this.valueToKey.get(value);
  }
  deleteByValue(value) {
    const key = this.valueToKey.get(value);
    if (key !== void 0) {
      this.keyToValue.delete(key);
      this.valueToKey.delete(value);
    }
  }
  deleteByKey(key) {
    const value = this.keyToValue.get(key);
    if (value !== void 0) {
      this.keyToValue.delete(key);
      this.valueToKey.delete(value);
    }
  }
  getKeyList() {
    return Array.from(this.keyToValue.keys());
  }
  //获取最近刚写入的几个值
  getHeads(size) {
    const keyList = this.getKeyList();
    if (keyList.length === 0) {
      return void 0;
    }
    const result = [];
    const listSize = Math.min(size, keyList.length);
    for (let i = 0; i < listSize; i++) {
      const key = keyList[listSize - i];
      result.push({ key, value: this.keyToValue.get(key) });
    }
    return result;
  }
}
class MessageUniqueWrapper {
  msgDataMap;
  msgIdMap;
  constructor(maxMap = 1e3) {
    this.msgIdMap = new LimitedHashTable(maxMap);
    this.msgDataMap = new LimitedHashTable(maxMap);
  }
  getRecentMsgIds(Peer2, size) {
    const heads = this.msgIdMap.getHeads(size);
    if (!heads) {
      return [];
    }
    const data = heads.map((t) => MessageUnique.getMsgIdAndPeerByShortId(t.value));
    const ret = data.filter((t) => t?.Peer.chatType === Peer2.chatType && t?.Peer.peerUid === Peer2.peerUid);
    return ret.map((t) => t?.MsgId).filter((t) => t !== void 0);
  }
  createUniqueMsgId(peer, msgId) {
    const key = `${msgId}|${peer.chatType}|${peer.peerUid}`;
    const hash = crypto__default.createHash("md5").update(key).digest();
    hash[0] &= 127;
    const shortId = hash.readInt32BE(0);
    this.msgIdMap.set(msgId, shortId);
    this.msgDataMap.set(key, shortId);
    return shortId;
  }
  getMsgIdAndPeerByShortId(shortId) {
    const data = this.msgDataMap.getKey(shortId);
    if (data) {
      const [msgId, chatTypeStr, peerUid] = data.split("|");
      const peer = {
        chatType: parseInt(chatTypeStr),
        peerUid,
        guildId: ""
      };
      return { MsgId: msgId, Peer: peer };
    }
    return void 0;
  }
  getShortIdByMsgId(msgId) {
    return this.msgIdMap.getValue(msgId);
  }
  getPeerByMsgId(msgId) {
    const shortId = this.msgIdMap.getValue(msgId);
    if (!shortId) return void 0;
    return this.getMsgIdAndPeerByShortId(shortId);
  }
  resize(maxSize) {
    this.msgIdMap.resize(maxSize);
    this.msgDataMap.resize(maxSize);
  }
}
const MessageUnique = new MessageUniqueWrapper();

class NTQQFriendApi {
  context;
  core;
  constructor(context, core) {
    this.context = context;
    this.core = core;
  }
  async setBuddyRemark(uid, remark) {
    return this.context.session.getBuddyService().setBuddyRemark({ uid, remark });
  }
  async getBuddyV2SimpleInfoMap(refresh = false) {
    const buddyService = this.context.session.getBuddyService();
    const buddyListV2 = await buddyService.getBuddyListV2("0", BuddyListReqType.KNOMAL);
    const uids = buddyListV2.data.flatMap((item) => item.buddyUids);
    return await this.core.eventWrapper.callNoListenerEvent(
      "NodeIKernelProfileService/getCoreAndBaseInfo",
      "nodeStore",
      uids
    );
  }
  async getBuddy(refresh = false) {
    return Array.from((await this.getBuddyV2SimpleInfoMap(refresh)).values());
  }
  async getBuddyIdMap(refresh = false) {
    const retMap = new LimitedHashTable(5e3);
    const data = await this.getBuddyV2SimpleInfoMap(refresh);
    data.forEach((value) => retMap.set(value.uin, value.uid));
    return retMap;
  }
  async delBuudy(uid, tempBlock = false, tempBothDel = false) {
    return this.context.session.getBuddyService().delBuddy({
      friendUid: uid,
      tempBlock,
      tempBothDel
    });
  }
  async getBuddyV2ExWithCate() {
    const buddyService = this.context.session.getBuddyService();
    const buddyListV2 = (await buddyService.getBuddyListV2("0", BuddyListReqType.KNOMAL)).data;
    const uids = buddyListV2.flatMap((item) => {
      return item.buddyUids;
    });
    const data = await this.core.eventWrapper.callNoListenerEvent(
      "NodeIKernelProfileService/getCoreAndBaseInfo",
      "nodeStore",
      uids
    );
    return buddyListV2.map((category) => ({
      categoryId: category.categoryId,
      categorySortId: category.categorySortId,
      categoryName: category.categroyName,
      categoryMbCount: category.categroyMbCount,
      onlineCount: category.onlineCount,
      buddyList: category.buddyUids.map((uid) => data.get(uid)).filter((value) => !!value)
    }));
  }
  async isBuddy(uid) {
    return this.context.session.getBuddyService().isBuddy(uid);
  }
  async clearBuddyReqUnreadCnt() {
    return this.context.session.getBuddyService().clearBuddyReqUnreadCnt();
  }
  async getBuddyReq() {
    const [, ret] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelBuddyService/getBuddyReq",
      "NodeIKernelBuddyListener/onBuddyReqChange",
      []
    );
    return ret;
  }
  async handleFriendRequest(notify, accept) {
    this.context.session.getBuddyService()?.approvalFriendRequest({
      friendUid: notify.friendUid,
      reqTime: notify.reqTime,
      accept
    });
  }
}

class NTQQGroupApi {
  context;
  core;
  groupMemberCache = /* @__PURE__ */ new Map();
  essenceLRU = new LimitedHashTable(1e3);
  constructor(context, core) {
    this.context = context;
    this.core = core;
  }
  async fetchGroupDetail(groupCode) {
    let [, detailInfo] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelGroupService/getGroupDetailInfo",
      "NodeIKernelGroupListener/onGroupDetailInfoChange",
      [groupCode, GroupInfoSource.KDATACARD],
      (ret) => ret.result === 0,
      (detailInfo2) => detailInfo2.groupCode === groupCode,
      1,
      5e3
    );
    return detailInfo;
  }
  async initApi() {
    this.initCache().then().catch((e) => this.context.logger.logError(e));
  }
  async initCache() {
    for (const group of await this.getGroups(true)) {
      this.refreshGroupMemberCache(group.groupCode).then().catch();
    }
  }
  async fetchGroupEssenceList(groupCode) {
    const pskey = (await this.core.apis.UserApi.getPSkey(["qun.qq.com"])).domainPskeyMap.get("qun.qq.com");
    return this.context.session.getGroupService().fetchGroupEssenceList({
      groupCode,
      pageStart: 0,
      pageLimit: 300
    }, pskey);
  }
  async getGroupShutUpMemberList(groupCode) {
    const data = this.core.eventWrapper.registerListen("NodeIKernelGroupListener/onShutUpMemberListChanged", (group_id) => group_id === groupCode, 1, 1e3);
    this.context.session.getGroupService().getGroupShutUpMemberList(groupCode);
    return (await data)[1];
  }
  async clearGroupNotifiesUnreadCount(doubt) {
    return this.context.session.getGroupService().clearGroupNotifiesUnreadCount(doubt);
  }
  async setGroupAvatar(groupCode, filePath) {
    return this.context.session.getGroupService().setHeader(groupCode, filePath);
  }
  async getGroups(forced = false) {
    const [, , groupList] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelGroupService/getGroupList",
      "NodeIKernelGroupListener/onGroupListUpdate",
      [forced]
    );
    return groupList;
  }
  async getGroupExtFE0Info(groupCodes, forced = true) {
    return this.context.session.getGroupService().getGroupExt0xEF0Info(
      groupCodes,
      [],
      {
        bindGuildId: 1,
        blacklistExpireTime: 1,
        companyId: 1,
        essentialMsgPrivilege: 1,
        essentialMsgSwitch: 1,
        fullGroupExpansionSeq: 1,
        fullGroupExpansionSwitch: 1,
        gangUpId: 1,
        groupAioBindGuildId: 1,
        groupBindGuildIds: 1,
        groupBindGuildSwitch: 1,
        groupExcludeGuildIds: 1,
        groupExtFlameData: 1,
        groupFlagPro1: 1,
        groupInfoExtSeq: 1,
        groupOwnerId: 1,
        groupSquareSwitch: 1,
        hasGroupCustomPortrait: 1,
        inviteRobotMemberExamine: 1,
        inviteRobotMemberSwitch: 1,
        inviteRobotSwitch: 1,
        isLimitGroupRtc: 1,
        lightCharNum: 1,
        luckyWord: 1,
        luckyWordId: 1,
        msgEventSeq: 1,
        qqMusicMedalSwitch: 1,
        reserve: 1,
        showPlayTogetherSwitch: 1,
        starId: 1,
        todoSeq: 1,
        viewedMsgDisappearTime: 1
      },
      forced
    );
  }
  async getGroupMemberAll(groupCode, forced = false) {
    return this.context.session.getGroupService().getAllMemberList(groupCode, forced);
  }
  async refreshGroupMemberCache(groupCode) {
    try {
      const members = await this.getGroupMemberAll(groupCode, true);
      this.groupMemberCache.set(groupCode, members.result.infos);
    } catch (e) {
      this.context.logger.logError(`刷新群成员缓存失败, 群号: ${groupCode}, 错误: ${e}`);
    }
    return this.groupMemberCache;
  }
  async getGroupMember(groupCode, memberUinOrUid) {
    const groupCodeStr = groupCode.toString();
    const memberUinOrUidStr = memberUinOrUid.toString();
    let members = this.groupMemberCache.get(groupCodeStr);
    if (!members) {
      members = (await this.refreshGroupMemberCache(groupCodeStr)).get(groupCodeStr);
    }
    const getMember = () => {
      if (isNumeric(memberUinOrUidStr)) {
        return Array.from(members.values()).find((member2) => member2.uin === memberUinOrUidStr);
      } else {
        return members.get(memberUinOrUidStr);
      }
    };
    let member = getMember();
    if (!member) {
      members = (await this.refreshGroupMemberCache(groupCodeStr)).get(groupCodeStr);
      member = getMember();
    }
    return member;
  }
  async getGroupRecommendContactArkJson(groupCode) {
    return this.context.session.getGroupService().getGroupRecommendContactArkJson(groupCode);
  }
  async creatGroupFileFolder(groupCode, folderName) {
    return this.context.session.getRichMediaService().createGroupFolder(groupCode, folderName);
  }
  async delGroupFile(groupCode, files) {
    return this.context.session.getRichMediaService().deleteGroupFile(groupCode, [102], files);
  }
  async delGroupFileFolder(groupCode, folderId) {
    return this.context.session.getRichMediaService().deleteGroupFolder(groupCode, folderId);
  }
  async addGroupEssence(groupCode, msgId) {
    const MsgData = await this.context.session.getMsgService().getMsgsIncludeSelf({
      chatType: 2,
      guildId: "",
      peerUid: groupCode
    }, msgId, 1, false);
    const param = {
      groupCode,
      msgRandom: parseInt(MsgData.msgList[0].msgRandom),
      msgSeq: parseInt(MsgData.msgList[0].msgSeq)
    };
    return this.context.session.getGroupService().addGroupEssence(param);
  }
  async kickMemberV2Inner(param) {
    return this.context.session.getGroupService().kickMemberV2(param);
  }
  async deleteGroupBulletin(groupCode, noticeId) {
    const psKey = (await this.core.apis.UserApi.getPSkey(["qun.qq.com"])).domainPskeyMap.get("qun.qq.com");
    return this.context.session.getGroupService().deleteGroupBulletin(groupCode, psKey, noticeId);
  }
  async quitGroupV2(GroupCode, needDeleteLocalMsg) {
    const param = {
      groupCode: GroupCode,
      needDeleteLocalMsg
    };
    return this.context.session.getGroupService().quitGroupV2(param);
  }
  async removeGroupEssenceBySeq(groupCode, msgRandom, msgSeq) {
    const param = {
      groupCode,
      msgRandom: parseInt(msgRandom),
      msgSeq: parseInt(msgSeq)
    };
    return this.context.session.getGroupService().removeGroupEssence(param);
  }
  async removeGroupEssence(groupCode, msgId) {
    const MsgData = await this.context.session.getMsgService().getMsgsIncludeSelf({
      chatType: 2,
      guildId: "",
      peerUid: groupCode
    }, msgId, 1, false);
    const param = {
      groupCode,
      msgRandom: parseInt(MsgData.msgList[0].msgRandom),
      msgSeq: parseInt(MsgData.msgList[0].msgSeq)
    };
    return this.context.session.getGroupService().removeGroupEssence(param);
  }
  async getSingleScreenNotifies(doubt, count) {
    const [, , , notifies] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelGroupService/getSingleScreenNotifies",
      "NodeIKernelGroupListener/onGroupSingleScreenNotifies",
      [
        doubt,
        "",
        count
      ]
    );
    return notifies;
  }
  async searchGroup(groupCode) {
    const [, ret] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelSearchService/searchGroup",
      "NodeIKernelSearchListener/onSearchGroupResult",
      [{
        keyWords: groupCode,
        groupNum: 25,
        exactSearch: false,
        penetrate: ""
      }],
      (ret2) => ret2.result === 0,
      (params) => !!params.groupInfos.find((g) => g.groupCode === groupCode),
      1,
      5e3
    );
    return ret.groupInfos.find((g) => g.groupCode === groupCode);
  }
  async getGroupMemberEx(groupCode, uid, forced = false, retry = 2) {
    const data = await solveAsyncProblem((eventWrapper, GroupCode, uid2, forced2 = false) => {
      return eventWrapper.callNormalEventV2(
        "NodeIKernelGroupService/getMemberInfo",
        "NodeIKernelGroupListener/onMemberInfoChange",
        [groupCode, [uid2], forced2],
        (ret) => ret.result === 0,
        (params, _, members) => params === GroupCode && members.size > 0 && members.has(uid2),
        1,
        forced2 ? 2500 : 250
      );
    }, this.core.eventWrapper, groupCode, uid, forced);
    if (data && data[3] instanceof Map && data[3].has(uid)) {
      return data[3].get(uid);
    }
    if (retry > 0) {
      const trydata = await this.getGroupMemberEx(groupCode, uid, true, retry - 1);
      if (trydata) return trydata;
    }
    return void 0;
  }
  async getGroupFileCount(groupCodes) {
    return this.context.session.getRichMediaService().batchGetGroupFileCount(groupCodes);
  }
  async getArkJsonGroupShare(groupCode) {
    const ret = await this.core.eventWrapper.callNoListenerEvent(
      "NodeIKernelGroupService/getGroupRecommendContactArkJson",
      groupCode
    );
    return ret.arkJson;
  }
  async uploadGroupBulletinPic(groupCode, imageurl) {
    const _Pskey = (await this.core.apis.UserApi.getPSkey(["qun.qq.com"])).domainPskeyMap.get("qun.qq.com");
    return this.context.session.getGroupService().uploadGroupBulletinPic(groupCode, _Pskey, imageurl);
  }
  async handleGroupRequest(notify, operateType, reason) {
    return this.context.session.getGroupService().operateSysNotify(
      false,
      {
        operateType,
        targetMsg: {
          seq: notify.seq,
          // 通知序列号
          type: notify.type,
          groupCode: notify.group.groupCode,
          postscript: reason ?? " "
          // 仅传空值可能导致处理失败，故默认给个空格
        }
      }
    );
  }
  async quitGroup(groupCode) {
    return this.context.session.getGroupService().quitGroup(groupCode);
  }
  async kickMember(groupCode, kickUids, refuseForever = false, kickReason = "") {
    return this.context.session.getGroupService().kickMember(groupCode, kickUids, refuseForever, kickReason);
  }
  async banMember(groupCode, memList) {
    return this.context.session.getGroupService().setMemberShutUp(groupCode, memList);
  }
  async banGroup(groupCode, shutUp) {
    return this.context.session.getGroupService().setGroupShutUp(groupCode, shutUp);
  }
  async setMemberCard(groupCode, memberUid, cardName) {
    return this.context.session.getGroupService().modifyMemberCardName(groupCode, memberUid, cardName);
  }
  async setMemberRole(groupCode, memberUid, role) {
    return this.context.session.getGroupService().modifyMemberRole(groupCode, memberUid, role);
  }
  async setGroupName(groupCode, groupName) {
    return this.context.session.getGroupService().modifyGroupName(groupCode, groupName, false);
  }
  async publishGroupBulletin(groupCode, content, picInfo = void 0, pinned = 0, confirmRequired = 0) {
    const psKey = (await this.core.apis.UserApi.getPSkey(["qun.qq.com"])).domainPskeyMap.get("qun.qq.com");
    const data = {
      text: encodeURI(content),
      picInfo,
      oldFeedsId: "",
      pinned,
      confirmRequired
    };
    return this.context.session.getGroupService().publishGroupBulletin(groupCode, psKey, data);
  }
  async getGroupRemainAtTimes(groupCode) {
    return this.context.session.getGroupService().getGroupRemainAtTimes(groupCode);
  }
  async getMemberExtInfo(groupCode, uin) {
    return this.context.session.getGroupService().getMemberExtInfo(
      {
        groupCode,
        sourceType: MemberExtSourceType.TITLETYPE,
        beginUin: "0",
        dataTime: "0",
        uinList: [uin],
        uinNum: "",
        seq: "",
        groupType: "",
        richCardNameVer: "",
        memberExtFilter: {
          memberLevelInfoUin: 1,
          memberLevelInfoPoint: 1,
          memberLevelInfoActiveDay: 1,
          memberLevelInfoLevel: 1,
          memberLevelInfoName: 1,
          levelName: 1,
          dataTime: 1,
          userShowFlag: 1,
          sysShowFlag: 1,
          timeToUpdate: 1,
          nickName: 1,
          specialTitle: 1,
          levelNameNew: 1,
          userShowFlagNew: 1,
          msgNeedField: 1,
          cmdUinFlagExt3Grocery: 1,
          memberIcon: 1,
          memberInfoSeq: 1
        }
      }
    );
  }
}

class NTQQMsgApi {
  context;
  core;
  constructor(context, core) {
    this.context = context;
    this.core = core;
  }
  getMsgByClientSeqAndTime(peer, replyMsgClientSeq, replyMsgTime) {
    return this.context.session.getMsgService().getMsgByClientSeqAndTime(peer, replyMsgClientSeq, replyMsgTime);
  }
  async getAioFirstViewLatestMsgs(peer, MsgCount) {
    return this.context.session.getMsgService().getAioFirstViewLatestMsgs(peer, MsgCount);
  }
  async sendShowInputStatusReq(peer, eventType) {
    return this.context.session.getMsgService().sendShowInputStatusReq(peer.chatType, eventType, peer.peerUid);
  }
  async getSourceOfReplyMsgV2(peer, clientSeq, time) {
    return this.context.session.getMsgService().getSourceOfReplyMsgV2(peer, clientSeq, time);
  }
  async getMsgEmojiLikesList(peer, msgSeq, emojiId, emojiType, count = 20) {
    return this.context.session.getMsgService().getMsgEmojiLikesList(peer, msgSeq, emojiId, emojiType, "", false, count);
  }
  async setEmojiLike(peer, msgSeq, emojiId, set = true) {
    emojiId = emojiId.toString();
    return this.context.session.getMsgService().setMsgEmojiLikes(peer, msgSeq, emojiId, emojiId.length > 3 ? "2" : "1", set);
  }
  async getMultiMsg(peer, rootMsgId, parentMsgId) {
    return this.context.session.getMsgService().getMultiMsg(peer, rootMsgId, parentMsgId);
  }
  async ForwardMsg(peer, msgIds) {
    return this.context.session.getMsgService().forwardMsg(msgIds, peer, [peer], /* @__PURE__ */ new Map());
  }
  async getMsgsByMsgId(peer, msgIds) {
    if (!peer) throw new Error("peer is not allowed");
    if (!msgIds) throw new Error("msgIds is not allowed");
    return await this.context.session.getMsgService().getMsgsByMsgId(peer, msgIds);
  }
  async getSingleMsg(peer, seq) {
    return await this.context.session.getMsgService().getSingleMsg(peer, seq);
  }
  async fetchFavEmojiList(num) {
    return this.context.session.getMsgService().fetchFavEmojiList("", num, true, true);
  }
  async queryMsgsWithFilterExWithSeq(peer, msgSeq) {
    return await this.context.session.getMsgService().queryMsgsWithFilterEx("0", "0", msgSeq, {
      chatInfo: peer,
      filterMsgType: [],
      filterSendersUid: [],
      filterMsgToTime: "0",
      filterMsgFromTime: "0",
      isReverseOrder: false,
      isIncludeCurrent: true,
      pageLimit: 1
    });
  }
  async queryMsgsWithFilterExWithSeqV2(peer, msgSeq, MsgTime, SendersUid) {
    return await this.context.session.getMsgService().queryMsgsWithFilterEx("0", "0", msgSeq, {
      chatInfo: peer,
      filterMsgType: [],
      filterSendersUid: SendersUid,
      filterMsgToTime: MsgTime,
      filterMsgFromTime: MsgTime,
      isReverseOrder: false,
      isIncludeCurrent: true,
      pageLimit: 1
    });
  }
  async queryMsgsWithFilterExWithSeqV3(peer, msgSeq, SendersUid) {
    return await this.context.session.getMsgService().queryMsgsWithFilterEx("0", "0", msgSeq, {
      chatInfo: peer,
      filterMsgType: [],
      filterSendersUid: SendersUid,
      filterMsgToTime: "0",
      filterMsgFromTime: "0",
      isReverseOrder: false,
      isIncludeCurrent: true,
      pageLimit: 1
    });
  }
  async queryFirstMsgBySeq(peer, msgSeq) {
    return await this.context.session.getMsgService().queryMsgsWithFilterEx("0", "0", msgSeq, {
      chatInfo: peer,
      filterMsgType: [],
      filterSendersUid: [],
      filterMsgToTime: "0",
      filterMsgFromTime: "0",
      isReverseOrder: true,
      isIncludeCurrent: true,
      pageLimit: 1
    });
  }
  // 客户端还在用别慌
  async getMsgsBySeqAndCount(peer, seq, count, desc, isReverseOrder) {
    return await this.context.session.getMsgService().getMsgsBySeqAndCount(peer, seq, count, desc, isReverseOrder);
  }
  async getMsgExBySeq(peer, msgSeq) {
    const DateNow = Math.floor(Date.now() / 1e3);
    const filterMsgFromTime = (DateNow - 300).toString();
    const filterMsgToTime = DateNow.toString();
    return await this.context.session.getMsgService().queryMsgsWithFilterEx("0", "0", msgSeq, {
      chatInfo: peer,
      //此处为Peer 为关键查询参数 没有啥也没有 by mlik iowa
      filterMsgType: [],
      filterSendersUid: [],
      filterMsgToTime,
      filterMsgFromTime,
      isReverseOrder: false,
      isIncludeCurrent: true,
      pageLimit: 100
    });
  }
  async setMsgRead(peer) {
    return this.context.session.getMsgService().setMsgRead(peer);
  }
  async getGroupFileList(GroupCode, params) {
    const item = [];
    let index = params.startIndex;
    while (true) {
      params.startIndex = index;
      const [, groupFileListResult] = await this.core.eventWrapper.callNormalEventV2(
        "NodeIKernelRichMediaService/getGroupFileList",
        "NodeIKernelMsgListener/onGroupFileInfoUpdate",
        [
          GroupCode,
          params
        ],
        () => true,
        () => true,
        // 应当通过 groupFileListResult 判断
        1,
        5e3
      );
      if (!groupFileListResult?.item?.length) break;
      item.push(...groupFileListResult.item);
      if (groupFileListResult.isEnd) break;
      if (item.length === params.fileCount) break;
      index = groupFileListResult.nextIndex;
    }
    return item;
  }
  async getMsgHistory(peer, msgId, count, isReverseOrder = false) {
    return this.context.session.getMsgService().getMsgsIncludeSelf(peer, msgId, count, isReverseOrder);
  }
  async recallMsg(peer, msgId) {
    await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelMsgService/recallMsg",
      "NodeIKernelMsgListener/onMsgInfoListUpdate",
      [peer, [msgId]],
      () => true,
      (updatedList) => updatedList.find((m) => m.msgId === msgId && m.recallTime !== "0") !== void 0,
      1,
      1e3
    );
  }
  async PrepareTempChat(toUserUid, GroupCode, nickname) {
    return this.context.session.getMsgService().prepareTempChat({
      chatType: ChatType.KCHATTYPETEMPC2CFROMGROUP,
      peerUid: toUserUid,
      peerNickname: nickname,
      fromGroupCode: GroupCode,
      sig: "",
      selfPhone: "",
      selfUid: this.core.selfInfo.uid,
      gameSession: {
        nickname: "",
        gameAppId: "",
        selfTinyId: "",
        peerRoleId: "",
        peerOpenId: ""
      }
    });
  }
  async getTempChatInfo(chatType, peerUid) {
    return this.context.session.getMsgService().getTempChatInfo(chatType, peerUid);
  }
  async sendMsg(peer, msgElements, waitComplete = true, timeout = 1e4) {
    if (peer.chatType === ChatType.KCHATTYPETEMPC2CFROMGROUP && peer.guildId && peer.guildId !== "") {
      const member = await this.core.apis.GroupApi.getGroupMember(peer.guildId, peer.peerUid);
      if (member) {
        await this.PrepareTempChat(peer.peerUid, peer.guildId, member.nick);
      }
    }
    const msgId = await this.generateMsgUniqueId(peer.chatType);
    peer.guildId = msgId;
    const [, msgList] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelMsgService/sendMsg",
      "NodeIKernelMsgListener/onMsgInfoListUpdate",
      [
        "0",
        peer,
        msgElements,
        /* @__PURE__ */ new Map()
      ],
      (ret) => ret.result === 0,
      (msgRecords) => {
        for (const msgRecord of msgRecords) {
          if (msgRecord.guildId === msgId && msgRecord.sendStatus === SendStatusType.KSEND_STATUS_SUCCESS) {
            return true;
          }
        }
        return false;
      },
      1,
      timeout
    );
    return msgList.find((msgRecord) => msgRecord.guildId === msgId);
  }
  async generateMsgUniqueId(chatType) {
    return this.context.session.getMsgService().generateMsgUniqueId(chatType, this.context.session.getMSFService().getServerTime());
  }
  async forwardMsg(srcPeer, destPeer, msgIds) {
    return this.context.session.getMsgService().forwardMsg(msgIds, srcPeer, [destPeer], /* @__PURE__ */ new Map());
  }
  async multiForwardMsg(srcPeer, destPeer, msgIds) {
    const msgInfos = msgIds.map((id) => {
      return { msgId: id, senderShowName: this.core.selfInfo.nick };
    });
    const [, msgList] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelMsgService/multiForwardMsgWithComment",
      "NodeIKernelMsgListener/onMsgInfoListUpdate",
      [
        msgInfos,
        srcPeer,
        destPeer,
        [],
        /* @__PURE__ */ new Map()
      ],
      () => true,
      (msgRecords) => msgRecords.some(
        (msgRecord) => msgRecord.peerUid === destPeer.peerUid && msgRecord.senderUid === this.core.selfInfo.uid
      )
    );
    for (const msg of msgList) {
      const arkElement = msg.elements.find((ele) => ele.arkElement);
      if (!arkElement) {
        continue;
      }
      const forwardData = JSON.parse(arkElement.arkElement?.bytesData ?? "");
      if (forwardData.app != "com.tencent.multimsg") {
        continue;
      }
      if (msg.peerUid == destPeer.peerUid && msg.senderUid == this.core.selfInfo.uid) {
        return msg;
      }
    }
    throw new Error("转发消息超时");
  }
  async markAllMsgAsRead() {
    return this.context.session.getMsgService().setAllC2CAndGroupMsgRead();
  }
}

class NTQQUserApi {
  context;
  core;
  constructor(context, core) {
    this.context = context;
    this.core = core;
  }
  async getCoreAndBaseInfo(uids) {
    return await this.core.eventWrapper.callNoListenerEvent(
      "NodeIKernelProfileService/getCoreAndBaseInfo",
      "nodeStore",
      uids
    );
  }
  // 默认获取自己的 type = 2 获取别人 type = 1
  async getProfileLike(uid, start, count, type = 2) {
    return this.context.session.getProfileLikeService().getBuddyProfileLike({
      friendUids: [uid],
      basic: 1,
      vote: 1,
      favorite: 0,
      userProfile: 1,
      type,
      start,
      limit: count
    });
  }
  async setLongNick(longNick) {
    return this.context.session.getProfileService().setLongNick(longNick);
  }
  async setSelfOnlineStatus(status, extStatus, batteryStatus) {
    return this.context.session.getMsgService().setStatus({
      status,
      extStatus,
      batteryStatus
    });
  }
  async getBuddyRecommendContactArkJson(uin, sencenID = "") {
    return this.context.session.getBuddyService().getBuddyRecommendContactArkJson(uin, sencenID);
  }
  async like(uid, count = 1) {
    return this.context.session.getProfileLikeService().setBuddyProfileLike({
      friendUid: uid,
      sourceId: 71,
      doLikeCount: count,
      doLikeTollCount: 0
    });
  }
  async setQQAvatar(filePath) {
    const ret = await this.context.session.getProfileService().setHeader(filePath);
    return { result: ret?.result, errMsg: ret?.errMsg };
  }
  async setGroupAvatar(gc, filePath) {
    return this.context.session.getGroupService().setHeader(gc, filePath);
  }
  async fetchUserDetailInfo(uid, mode = UserDetailSource.KDB) {
    const [_retData, profile] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelProfileService/fetchUserDetailInfo",
      "NodeIKernelProfileListener/onUserDetailInfoChanged",
      [
        "BuddyProfileStore",
        [uid],
        mode,
        [ProfileBizType.KALL]
      ],
      () => true,
      (profile2) => profile2.uid === uid
    );
    const RetUser = {
      ...profile.simpleInfo.status,
      ...profile.simpleInfo.vasInfo,
      ...profile.commonExt,
      ...profile.simpleInfo.baseInfo,
      qqLevel: profile.commonExt?.qqLevel,
      age: profile.simpleInfo.baseInfo.age,
      pendantId: "",
      ...profile.simpleInfo.coreInfo
    };
    return RetUser;
  }
  async getUserDetailInfo(uid) {
    let retUser = await solveAsyncProblem(async (uid2) => this.fetchUserDetailInfo(uid2, UserDetailSource.KDB), uid);
    if (retUser && retUser.uin !== "0") {
      return retUser;
    }
    this.context.logger.logDebug("[NapCat] [Mark] getUserDetailInfo Mode1 Failed.");
    retUser = await this.fetchUserDetailInfo(uid, UserDetailSource.KSERVER);
    if (retUser && retUser.uin === "0") {
      retUser.uin = await this.core.apis.UserApi.getUidByUinV2(uid) ?? "0";
    }
    return retUser;
  }
  async modifySelfProfile(param) {
    return this.context.session.getProfileService().modifyDesktopMiniProfile(param);
  }
  async getCookies(domain) {
    const ClientKeyData = await this.forceFetchClientKey();
    const requestUrl = "https://ssl.ptlogin2.qq.com/jump?ptlang=1033&clientuin=" + this.core.selfInfo.uin + "&clientkey=" + ClientKeyData.clientKey + "&u1=https%3A%2F%2F" + domain + "%2F" + this.core.selfInfo.uin + "%2Finfocenter&keyindex=19%27";
    const data = await RequestUtil.HttpsGetCookies(requestUrl);
    if (!data.p_skey || data.p_skey.length == 0) {
      try {
        const pskey = (await this.getPSkey([domain])).domainPskeyMap.get(domain);
        if (pskey) data.p_skey = pskey;
      } catch {
        return data;
      }
    }
    return data;
  }
  async getPSkey(domainList) {
    return await this.context.session.getTipOffService().getPskey(domainList, true);
  }
  async getRobotUinRange() {
    const robotUinRanges = await this.context.session.getRobotService().getRobotUinRange({
      justFetchMsgConfig: "1",
      type: 1,
      version: 0,
      aioKeywordVersion: 0
    });
    return robotUinRanges?.response?.robotUinRanges;
  }
  //需要异常处理
  async getQzoneCookies() {
    const ClientKeyData = await this.forceFetchClientKey();
    const requestUrl = "https://ssl.ptlogin2.qq.com/jump?ptlang=1033&clientuin=" + this.core.selfInfo.uin + "&clientkey=" + ClientKeyData.clientKey + "&u1=https%3A%2F%2Fuser.qzone.qq.com%2F" + this.core.selfInfo.uin + "%2Finfocenter&keyindex=19%27";
    return await RequestUtil.HttpsGetCookies(requestUrl);
  }
  //需要异常处理
  async getSKey() {
    const ClientKeyData = await this.forceFetchClientKey();
    if (ClientKeyData.result !== 0) {
      throw new Error("getClientKey Error");
    }
    const clientKey = ClientKeyData.clientKey;
    const requestUrl = "https://ssl.ptlogin2.qq.com/jump?ptlang=1033&clientuin=" + this.core.selfInfo.uin + "&clientkey=" + clientKey + "&u1=https%3A%2F%2Fh5.qzone.qq.com%2Fqqnt%2Fqzoneinpcqq%2Ffriend%3Frefresh%3D0%26clientuin%3D0%26darkMode%3D0&keyindex=19%27";
    const cookies = await RequestUtil.HttpsGetCookies(requestUrl);
    const skey = cookies["skey"];
    if (!skey) {
      throw new Error("SKey is Empty");
    }
    return skey;
  }
  async getUidByUinV2(Uin) {
    if (!Uin) {
      return "";
    }
    const services = [
      () => this.context.session.getUixConvertService().getUid([Uin]).then((data) => data.uidInfo.get(Uin)).catch(() => void 0),
      () => promisify(this.context.session.getProfileService().getUidByUin)("FriendsServiceImpl", [Uin]).then((data) => data.get(Uin)).catch(() => void 0),
      () => this.context.session.getGroupService().getUidByUins([Uin]).then((data) => data.uids.get(Uin)).catch(() => void 0),
      () => this.getUserDetailInfoByUin(Uin).then((data) => data.detail.uid).catch(() => void 0)
    ];
    let uid = void 0;
    for (const service of services) {
      uid = await service();
      if (uid && uid.indexOf("*") == -1 && uid !== "") {
        break;
      }
    }
    return uid ?? "";
  }
  async getUinByUidV2(Uid) {
    if (!Uid) {
      return "0";
    }
    const services = [
      () => this.context.session.getUixConvertService().getUin([Uid]).then((data) => data.uinInfo.get(Uid)).catch(() => void 0),
      () => this.context.session.getGroupService().getUinByUids([Uid]).then((data) => data.uins.get(Uid)).catch(() => void 0),
      () => promisify(this.context.session.getProfileService().getUinByUid)("FriendsServiceImpl", [Uid]).then((data) => data.get(Uid)).catch(() => void 0),
      () => this.core.apis.FriendApi.getBuddyIdMap(true).then((data) => data.getKey(Uid)).catch(() => void 0),
      () => this.getUserDetailInfo(Uid).then((data) => data.uin).catch(() => void 0)
    ];
    let uin = void 0;
    for (const service of services) {
      uin = await service();
      if (uin && uin !== "0" && uin !== "") {
        break;
      }
    }
    return uin ?? "0";
  }
  async getRecentContactListSnapShot(count) {
    return await this.context.session.getRecentContactService().getRecentContactListSnapShot(count);
  }
  async getRecentContactListSyncLimit(count) {
    return await this.context.session.getRecentContactService().getRecentContactListSyncLimit(count);
  }
  async getRecentContactListSync() {
    return await this.context.session.getRecentContactService().getRecentContactListSync();
  }
  async getRecentContactList() {
    return await this.context.session.getRecentContactService().getRecentContactList();
  }
  async getUserDetailInfoByUin(Uin) {
    return await this.core.eventWrapper.callNoListenerEvent(
      "NodeIKernelProfileService/getUserDetailInfoByUin",
      Uin
    );
  }
  async forceFetchClientKey() {
    return await this.context.session.getTicketService().forceFetchClientKey("");
  }
}

class NTQQWebApi {
  context;
  core;
  constructor(context, core) {
    this.context = context;
    this.core = core;
  }
  async shareDigest(groupCode, msgSeq, msgRandom, targetGroupCode) {
    const cookieObject = await this.core.apis.UserApi.getCookies("qun.qq.com");
    const url = `https://qun.qq.com/cgi-bin/group_digest/share_digest?${new URLSearchParams({
      bkn: this.getBknFromCookie(cookieObject),
      group_code: groupCode,
      msg_seq: msgSeq,
      msg_random: msgRandom,
      target_group_code: targetGroupCode
    }).toString()}`;
    try {
      return RequestUtil.HttpGetText(url, "GET", "", { "Cookie": this.cookieToString(cookieObject) });
    } catch (e) {
      return void 0;
    }
  }
  async getGroupEssenceMsgAll(GroupCode) {
    const ret = [];
    for (let i = 0; i < 20; i++) {
      const data = await this.getGroupEssenceMsg(GroupCode, i, 50);
      if (!data) break;
      ret.push(data);
      if (data.data.is_end) break;
    }
    return ret;
  }
  async getGroupEssenceMsg(GroupCode, page_start = 0, page_limit = 50) {
    const cookieObject = await this.core.apis.UserApi.getCookies("qun.qq.com");
    const url = `https://qun.qq.com/cgi-bin/group_digest/digest_list?${new URLSearchParams({
      bkn: this.getBknFromCookie(cookieObject),
      page_start: page_start.toString(),
      page_limit: page_limit.toString(),
      group_code: GroupCode
    }).toString()}`;
    try {
      const ret = await RequestUtil.HttpGetJson(
        url,
        "GET",
        "",
        { "Cookie": this.cookieToString(cookieObject) }
      );
      return ret.retcode === 0 ? ret : void 0;
    } catch {
      return void 0;
    }
  }
  async getGroupMembers(GroupCode, cached = true) {
    const memberData = new Array();
    const cookieObject = await this.core.apis.UserApi.getCookies("qun.qq.com");
    const retList = [];
    const fastRet = await RequestUtil.HttpGetJson(
      `https://qun.qq.com/cgi-bin/qun_mgr/search_group_members?${new URLSearchParams({
        st: "0",
        end: "40",
        sort: "1",
        gc: GroupCode,
        bkn: this.getBknFromCookie(cookieObject)
      }).toString()}`,
      "POST",
      "",
      { "Cookie": this.cookieToString(cookieObject) }
    );
    if (!fastRet?.count || fastRet?.errcode !== 0 || !fastRet?.mems) {
      return [];
    } else {
      for (const key in fastRet.mems) {
        memberData.push(fastRet.mems[key]);
      }
    }
    const PageNum = Math.ceil(fastRet.count / 40);
    for (let i = 2; i <= PageNum; i++) {
      const ret = RequestUtil.HttpGetJson(
        `https://qun.qq.com/cgi-bin/qun_mgr/search_group_members?${new URLSearchParams({
          st: ((i - 1) * 40).toString(),
          end: (i * 40).toString(),
          sort: "1",
          gc: GroupCode,
          bkn: this.getBknFromCookie(cookieObject)
        }).toString()}`,
        "POST",
        "",
        { "Cookie": this.cookieToString(cookieObject) }
      );
      retList.push(ret);
    }
    for (let i = 1; i <= PageNum; i++) {
      const ret = await retList[i];
      if (!ret?.count || ret?.errcode !== 0 || !ret?.mems) {
        continue;
      }
      for (const key in ret.mems) {
        memberData.push(ret.mems[key]);
      }
    }
    return memberData;
  }
  // public  async addGroupDigest(groupCode: string, msgSeq: string) {
  //   const url = `https://qun.qq.com/cgi-bin/group_digest/cancel_digest?random=665&X-CROSS-ORIGIN=fetch&group_code=${groupCode}&msg_seq=${msgSeq}&msg_random=444021292`;
  //   const res = await this.request(url);
  //   return await res.json();
  // }
  // public async getGroupDigest(groupCode: string) {
  //   const url = `https://qun.qq.com/cgi-bin/group_digest/digest_list?random=665&X-CROSS-ORIGIN=fetch&group_code=${groupCode}&page_start=0&page_limit=20`;
  //   const res = await this.request(url);
  //   return await res.json();
  // }
  async setGroupNotice(GroupCode, Content, pinned = 0, type = 1, is_show_edit_card = 1, tip_window_type = 1, confirm_required = 1, picId = "", imgWidth = 540, imgHeight = 300) {
    const cookieObject = await this.core.apis.UserApi.getCookies("qun.qq.com");
    try {
      const settings = JSON.stringify({
        is_show_edit_card,
        tip_window_type,
        confirm_required
      });
      const externalParam = {
        pic: picId,
        imgWidth: imgWidth.toString(),
        imgHeight: imgHeight.toString()
      };
      const ret = await RequestUtil.HttpGetJson(
        `https://web.qun.qq.com/cgi-bin/announce/add_qun_notice?${new URLSearchParams({
          bkn: this.getBknFromCookie(cookieObject),
          qid: GroupCode,
          text: Content,
          pinned: pinned.toString(),
          type: type.toString(),
          settings,
          ...picId === "" ? {} : externalParam
        }).toString()}`,
        "POST",
        "",
        { "Cookie": this.cookieToString(cookieObject) }
      );
      return ret;
    } catch (e) {
      return void 0;
    }
  }
  async getGroupNotice(GroupCode) {
    const cookieObject = await this.core.apis.UserApi.getCookies("qun.qq.com");
    try {
      const ret = await RequestUtil.HttpGetJson(
        `https://web.qun.qq.com/cgi-bin/announce/get_t_list?${new URLSearchParams({
          bkn: this.getBknFromCookie(cookieObject),
          qid: GroupCode,
          ft: "23",
          ni: "1",
          n: "1",
          i: "1",
          log_read: "1",
          platform: "1",
          s: "-1"
        }).toString()}&n=20`,
        "GET",
        "",
        { "Cookie": this.cookieToString(cookieObject) }
      );
      return ret?.ec === 0 ? ret : void 0;
    } catch (e) {
      return void 0;
    }
  }
  async getDataInternal(cookieObject, groupCode, type) {
    let resJson;
    try {
      const res = await RequestUtil.HttpGetText(
        `https://qun.qq.com/interactive/honorlist?${new URLSearchParams({
          gc: groupCode,
          type: type.toString()
        }).toString()}`,
        "GET",
        "",
        { "Cookie": this.cookieToString(cookieObject) }
      );
      const match = /window\.__INITIAL_STATE__=(.*?);/.exec(res);
      if (match) {
        resJson = JSON.parse(match[1].trim());
      }
      return type === 1 ? resJson?.talkativeList : resJson?.actorList;
    } catch (e) {
      this.context.logger.logDebug("获取当前群荣耀失败", e);
      return void 0;
    }
  }
  async getHonorList(cookieObject, groupCode, type) {
    const data = await this.getDataInternal(cookieObject, groupCode, type);
    if (!data) {
      this.context.logger.logError(`获取类型 ${type} 的荣誉信息失败`);
      return [];
    }
    return data.map((item) => ({
      user_id: item?.uin,
      nickname: item?.name,
      avatar: item?.avatar,
      description: item?.desc
    }));
  }
  async getGroupHonorInfo(groupCode, getType) {
    const cookieObject = await this.core.apis.UserApi.getCookies("qun.qq.com");
    const HonorInfo = { group_id: groupCode };
    if (getType === WebHonorType.TALKATIVE || getType === WebHonorType.ALL) {
      const talkativeList = await this.getHonorList(cookieObject, groupCode, 1);
      if (talkativeList.length > 0) {
        HonorInfo.current_talkative = talkativeList[0];
        HonorInfo.talkative_list = talkativeList;
      }
    }
    if (getType === WebHonorType.PERFORMER || getType === WebHonorType.ALL) {
      HonorInfo.performer_list = await this.getHonorList(cookieObject, groupCode, 2);
    }
    if (getType === WebHonorType.LEGEND || getType === WebHonorType.ALL) {
      HonorInfo.legend_list = await this.getHonorList(cookieObject, groupCode, 3);
    }
    if (getType === WebHonorType.EMOTION || getType === WebHonorType.ALL) {
      HonorInfo.emotion_list = await this.getHonorList(cookieObject, groupCode, 6);
    }
    if (getType === WebHonorType.EMOTION || getType === WebHonorType.ALL) {
      HonorInfo.strong_newbie_list = [];
    }
    return HonorInfo;
  }
  cookieToString(cookieObject) {
    return Object.entries(cookieObject).map(([key, value]) => `${key}=${value}`).join("; ");
  }
  getBknFromCookie(cookieObject) {
    const sKey = cookieObject.skey;
    let hash = 5381;
    for (let i = 0; i < sKey.length; i++) {
      const code = sKey.charCodeAt(i);
      hash = hash + (hash << 5) + code;
    }
    return (hash & 2147483647).toString();
  }
  getBknFromSKey(sKey) {
    let hash = 5381;
    for (let i = 0; i < sKey.length; i++) {
      const code = sKey.charCodeAt(i);
      hash = hash + (hash << 5) + code;
    }
    return (hash & 2147483647).toString();
  }
  async createQunAlbumSession(gc, sAlbumID, sAlbumName, path, skey, pskey, uin) {
    const img = readFileSync(path);
    const img_md5 = createHash("md5").update(img).digest("hex");
    const img_size = img.length;
    const img_name = basename(path);
    const time = Math.floor(Date.now() / 1e3);
    const GTK = this.getBknFromSKey(pskey);
    const cookie = `p_uin=${uin}; p_skey=${pskey}; skey=${skey}; uin=${uin}`;
    const body = {
      control_req: [{
        uin,
        token: {
          type: 4,
          data: pskey,
          appid: 5
        },
        appid: "qun",
        checksum: img_md5,
        check_type: 0,
        file_len: img_size,
        env: {
          refer: "qzone",
          deviceInfo: "h5"
        },
        model: 0,
        biz_req: {
          sPicTitle: img_name,
          sPicDesc: "",
          sAlbumName,
          sAlbumID,
          iAlbumTypeID: 0,
          iBitmap: 0,
          iUploadType: 0,
          iUpPicType: 0,
          iBatchID: time,
          sPicPath: "",
          iPicWidth: 0,
          iPicHight: 0,
          iWaterType: 0,
          iDistinctUse: 0,
          iNeedFeeds: 1,
          iUploadTime: time,
          mapExt: {
            appid: "qun",
            userid: gc
          }
        },
        session: "",
        asy_upload: 0,
        cmd: "FileUpload"
      }]
    };
    const api = `https://h5.qzone.qq.com/webapp/json/sliceUpload/FileBatchControl/${img_md5}?g_tk=${GTK}`;
    const post = await RequestUtil.HttpGetJson(api, "POST", body, {
      "Cookie": cookie,
      "Content-Type": "application/json"
    });
    return post;
  }
}

class NTQQSystemApi {
  context;
  core;
  constructor(context, core) {
    this.context = context;
    this.core = core;
  }
  async hasOtherRunningQQProcess() {
    return this.core.util.hasOtherRunningQQProcess();
  }
  async ocrImage(filePath) {
    return this.context.session.getNodeMiscService().wantWinScreenOCR(filePath);
  }
  async translateEnWordToZn(words) {
    return this.context.session.getRichMediaService().translateEnWordToZn(words);
  }
  async getOnlineDev() {
    this.context.session.getMsgService().getOnLineDev();
  }
  async getArkJsonCollection(cid) {
    return await this.core.eventWrapper.callNoListenerEvent("NodeIKernelCollectionService/collectionArkShare", "1717662698058");
  }
  async bootMiniApp(appFile, params) {
    await this.context.session.getNodeMiscService().setMiniAppVersion("2.16.4");
    return this.context.session.getNodeMiscService().startNewMiniApp(appFile, params);
  }
}

class NTQQCollectionApi {
  context;
  core;
  constructor(context, core) {
    this.context = context;
    this.core = core;
  }
  async createCollection(authorUin, authorUid, authorName, brief, rawData) {
    return this.context.session.getCollectionService().createNewCollectionItem({
      commInfo: {
        bid: 1,
        category: 2,
        author: {
          type: 1,
          numId: authorUin,
          strId: authorName,
          groupId: "0",
          groupName: "",
          uid: authorUid
        },
        customGroupId: "0",
        createTime: Date.now().toString(),
        sequence: Date.now().toString()
      },
      richMediaSummary: {
        originalUri: "",
        publisher: "",
        richMediaVersion: 0,
        subTitle: "",
        title: "",
        brief,
        picList: [],
        contentType: 1
      },
      richMediaContent: {
        rawData,
        bizDataList: [],
        picList: [],
        fileList: []
      },
      need_share_url: false
    });
  }
  async getAllCollection(category = 0, count = 50) {
    return this.context.session.getCollectionService().getCollectionItemList({
      category,
      groupId: -1,
      forceSync: true,
      forceFromDb: false,
      timeStamp: "0",
      count,
      searchDown: true
    });
  }
}

var PlatformType = /* @__PURE__ */ ((PlatformType2) => {
  PlatformType2[PlatformType2["KUNKNOWN"] = 0] = "KUNKNOWN";
  PlatformType2[PlatformType2["KANDROID"] = 1] = "KANDROID";
  PlatformType2[PlatformType2["KIOS"] = 2] = "KIOS";
  PlatformType2[PlatformType2["KWINDOWS"] = 3] = "KWINDOWS";
  PlatformType2[PlatformType2["KMAC"] = 4] = "KMAC";
  PlatformType2[PlatformType2["KLINUX"] = 5] = "KLINUX";
  return PlatformType2;
})(PlatformType || {});
var VendorType = /* @__PURE__ */ ((VendorType2) => {
  VendorType2[VendorType2["KNOSETONIOS"] = 0] = "KNOSETONIOS";
  VendorType2[VendorType2["KSUPPORTGOOGLEPUSH"] = 99] = "KSUPPORTGOOGLEPUSH";
  VendorType2[VendorType2["KSUPPORTHMS"] = 3] = "KSUPPORTHMS";
  VendorType2[VendorType2["KSUPPORTOPPOPUSH"] = 4] = "KSUPPORTOPPOPUSH";
  VendorType2[VendorType2["KSUPPORTTPNS"] = 2] = "KSUPPORTTPNS";
  VendorType2[VendorType2["KSUPPORTVIVOPUSH"] = 5] = "KSUPPORTVIVOPUSH";
  VendorType2[VendorType2["KUNSUPPORTANDROIDPUSH"] = 1] = "KUNSUPPORTANDROIDPUSH";
  return VendorType2;
})(VendorType || {});

let osName;
try {
  osName = os$1.hostname();
} catch (e) {
  osName = "NapCat";
}
const homeDir = os$1.homedir();
const systemPlatform = os$1.platform();
os$1.arch();
const systemVersion = os$1.release();
const hostname = osName;
path$1.join(homeDir, "Downloads");
const systemName = os$1.type();

class NTEventWrapper {
  WrapperSession;
  //WrapperSession
  listenerManager = /* @__PURE__ */ new Map();
  //ListenerName-Unique -> Listener实例
  EventTask = /* @__PURE__ */ new Map();
  //tasks ListenerMainName -> ListenerSubName-> uuid -> {timeout,createtime,func}
  constructor(wrapperSession) {
    this.WrapperSession = wrapperSession;
  }
  createProxyDispatch(ListenerMainName) {
    const dispatcherListenerFunc = this.dispatcherListener.bind(this);
    return new Proxy(
      {},
      {
        get(target, prop, receiver) {
          if (typeof target[prop] === "undefined") {
            return (...args) => {
              dispatcherListenerFunc(ListenerMainName, prop, ...args).then();
            };
          }
          return Reflect.get(target, prop, receiver);
        }
      }
    );
  }
  createEventFunction(eventName) {
    const eventNameArr = eventName.split("/");
    if (eventNameArr.length > 1) {
      const serviceName = "get" + eventNameArr[0].replace("NodeIKernel", "");
      const eventName2 = eventNameArr[1];
      const services = this.WrapperSession[serviceName]();
      let event = services[eventName2];
      event = event.bind(services);
      if (event) {
        return event;
      }
      return void 0;
    }
  }
  createListenerFunction(listenerMainName, uniqueCode = "") {
    const existListener = this.listenerManager.get(listenerMainName + uniqueCode);
    if (!existListener) {
      const Listener = this.createProxyDispatch(listenerMainName);
      const ServiceSubName = /^NodeIKernel(.*?)Listener$/.exec(listenerMainName)[1];
      const Service = `NodeIKernel${ServiceSubName}Service/addKernel${ServiceSubName}Listener`;
      this.createEventFunction(Service)(Listener);
      this.listenerManager.set(listenerMainName + uniqueCode, Listener);
      return Listener;
    }
    return existListener;
  }
  //统一回调清理事件
  async dispatcherListener(ListenerMainName, ListenerSubName, ...args) {
    this.EventTask.get(ListenerMainName)?.get(ListenerSubName)?.forEach((task, uuid) => {
      if (task.createtime + task.timeout < Date.now()) {
        this.EventTask.get(ListenerMainName)?.get(ListenerSubName)?.delete(uuid);
        return;
      }
      if (task?.checker?.(...args)) {
        task.func(...args);
      }
    });
  }
  async callNoListenerEvent(serviceAndMethod, ...args) {
    return this.createEventFunction(serviceAndMethod)(...args);
  }
  async registerListen(listenerAndMethod, checker, waitTimes = 1, timeout = 5e3) {
    return new Promise((resolve, reject) => {
      const ListenerNameList = listenerAndMethod.split("/");
      const ListenerMainName = ListenerNameList[0];
      const ListenerSubName = ListenerNameList[1];
      const id = randomUUID();
      let complete = 0;
      let retData = void 0;
      function sendDataCallback() {
        if (complete == 0) {
          reject(new Error(" ListenerName:" + listenerAndMethod + " timeout"));
        } else {
          resolve(retData);
        }
      }
      const timeoutRef = setTimeout(sendDataCallback, timeout);
      const eventCallback = {
        timeout,
        createtime: Date.now(),
        checker,
        func: (...args) => {
          complete++;
          retData = args;
          if (complete >= waitTimes) {
            clearTimeout(timeoutRef);
            sendDataCallback();
          }
        }
      };
      if (!this.EventTask.get(ListenerMainName)) {
        this.EventTask.set(ListenerMainName, /* @__PURE__ */ new Map());
      }
      if (!this.EventTask.get(ListenerMainName)?.get(ListenerSubName)) {
        this.EventTask.get(ListenerMainName)?.set(ListenerSubName, /* @__PURE__ */ new Map());
      }
      this.EventTask.get(ListenerMainName)?.get(ListenerSubName)?.set(id, eventCallback);
      this.createListenerFunction(ListenerMainName);
    });
  }
  async callNormalEventV2(serviceAndMethod, listenerAndMethod, args, checkerEvent = () => true, checkerListener = () => true, callbackTimesToWait = 1, timeout = 5e3) {
    const id = randomUUID();
    let complete = 0;
    let retData = void 0;
    let retEvent = {};
    function sendDataCallback(resolve, reject) {
      if (complete == 0) {
        reject(
          new Error(
            "Timeout: NTEvent serviceAndMethod:" + serviceAndMethod + " ListenerName:" + listenerAndMethod + " EventRet:\n" + JSON.stringify(retEvent, null, 4) + "\n"
          )
        );
      } else {
        resolve([retEvent, ...retData]);
      }
    }
    const ListenerNameList = listenerAndMethod.split("/");
    const ListenerMainName = ListenerNameList[0];
    const ListenerSubName = ListenerNameList[1];
    return new Promise(
      (resolve, reject) => {
        const timeoutRef = setTimeout(() => sendDataCallback(resolve, reject), timeout);
        const eventCallback = {
          timeout,
          createtime: Date.now(),
          checker: checkerListener,
          func: (...args2) => {
            complete++;
            retData = args2;
            if (complete >= callbackTimesToWait) {
              clearTimeout(timeoutRef);
              sendDataCallback(resolve, reject);
            }
          }
        };
        if (!this.EventTask.get(ListenerMainName)) {
          this.EventTask.set(ListenerMainName, /* @__PURE__ */ new Map());
        }
        if (!this.EventTask.get(ListenerMainName)?.get(ListenerSubName)) {
          this.EventTask.get(ListenerMainName)?.set(ListenerSubName, /* @__PURE__ */ new Map());
        }
        this.EventTask.get(ListenerMainName)?.get(ListenerSubName)?.set(id, eventCallback);
        this.createListenerFunction(ListenerMainName);
        const eventResult = this.createEventFunction(serviceAndMethod)(...args);
        const eventRetHandle = (eventData) => {
          retEvent = eventData;
          if (!checkerEvent(retEvent) && timeoutRef.hasRef()) {
            clearTimeout(timeoutRef);
            reject(
              new Error(
                "EventChecker Failed: NTEvent serviceAndMethod:" + serviceAndMethod + " ListenerName:" + listenerAndMethod + " EventRet:\n" + JSON.stringify(retEvent, null, 4) + "\n"
              )
            );
          }
        };
        if (eventResult instanceof Promise) {
          eventResult.then((eventResult2) => {
            eventRetHandle(eventResult2);
          }).catch(reject);
        } else {
          eventRetHandle(eventResult);
        }
      }
    );
  }
}

class ConfigBase {
  name;
  core;
  configPath;
  configData = {};
  constructor(name, core, configPath, copy_default = true) {
    this.name = name;
    this.core = core;
    this.configPath = configPath;
    fs$1.mkdirSync(this.configPath, { recursive: true });
    this.read(copy_default);
  }
  getKeys() {
    return null;
  }
  getConfigPath(pathName) {
    if (!pathName) {
      const filename = `${this.name}.json`;
      const mainPath = this.core.context.pathWrapper.binaryPath;
      return path$1.join(mainPath, "config", filename);
    } else {
      const filename = `${this.name}_${pathName}.json`;
      return path$1.join(this.configPath, filename);
    }
  }
  read(copy_default = true) {
    const configPath = this.getConfigPath(this.core.selfInfo.uin);
    if (!fs$1.existsSync(configPath) && copy_default) {
      try {
        fs$1.writeFileSync(configPath, fs$1.readFileSync(this.getConfigPath(void 0), "utf-8"));
        this.core.context.logger.log(`[Core] [Config] 配置文件创建成功!
`);
      } catch (e) {
        this.core.context.logger.logError(`[Core] [Config] 创建配置文件时发生错误:`, e.message);
      }
    } else if (!fs$1.existsSync(configPath) && !copy_default) {
      fs$1.writeFileSync(configPath, "{}");
    }
    try {
      this.configData = JSON.parse(fs$1.readFileSync(configPath, "utf-8"));
      this.core.context.logger.logDebug(`[Core] [Config] 配置文件${configPath}加载`, this.configData);
      return this.configData;
    } catch (e) {
      if (e instanceof SyntaxError) {
        this.core.context.logger.logError(`[Core] [Config] 配置文件格式错误，请检查配置文件:`, e.message);
      } else {
        this.core.context.logger.logError(`[Core] [Config] 读取配置文件时发生错误:`, e.message);
      }
      return {};
    }
  }
  save(newConfigData = this.configData) {
    const selfInfo = this.core.selfInfo;
    this.configData = newConfigData;
    const configPath = this.getConfigPath(selfInfo.uin);
    try {
      fs$1.writeFileSync(configPath, JSON.stringify(newConfigData, this.getKeys(), 2));
    } catch (e) {
      this.core.context.logger.logError(`保存配置文件 ${configPath} 时发生错误:`, e.message);
    }
  }
}

class NapCatConfigLoader extends ConfigBase {
  constructor(core, configPath) {
    super("napcat", core, configPath);
  }
}

class NodeIKernelSessionListener {
  onNTSessionCreate(args) {
  }
  onGProSessionCreate(args) {
  }
  onSessionInitComplete(args) {
  }
  onOpentelemetryInit(args) {
  }
  onUserOnlineResult(args) {
  }
  onGetSelfTinyId(args) {
  }
}

class NodeIKernelLoginListener {
  onLoginConnected(...args) {
  }
  onLoginDisConnected(...args) {
  }
  onLoginConnecting(...args) {
  }
  onQRCodeGetPicture(arg) {
  }
  onQRCodeLoginPollingStarted(...args) {
  }
  onQRCodeSessionUserScaned(...args) {
  }
  onQRCodeLoginSucceed(arg) {
  }
  onQRCodeSessionFailed(...args) {
  }
  onLoginFailed(...args) {
  }
  onLogoutSucceed(...args) {
  }
  onLogoutFailed(...args) {
  }
  onUserLoggedIn(...args) {
  }
  onQRCodeSessionQuickLoginFailed(...args) {
  }
  onPasswordLoginFailed(...args) {
  }
  OnConfirmUnusualDeviceFailed(...args) {
  }
  onQQLoginNumLimited(...args) {
  }
  onLoginState(...args) {
  }
}

class NodeIKernelMsgListener {
  onAddSendMsg(msgRecord) {
  }
  onBroadcastHelperDownloadComplete(broadcastHelperTransNotifyInfo) {
  }
  onBroadcastHelperProgressUpdate(broadcastHelperTransNotifyInfo) {
  }
  onChannelFreqLimitInfoUpdate(contact, z, freqLimitInfo) {
  }
  onContactUnreadCntUpdate(hashMap) {
  }
  onCustomWithdrawConfigUpdate(customWithdrawConfig) {
  }
  onDraftUpdate(contact, arrayList, j2) {
  }
  onEmojiDownloadComplete(emojiNotifyInfo) {
  }
  onEmojiResourceUpdate(emojiResourceInfo) {
  }
  onFeedEventUpdate(firstViewDirectMsgNotifyInfo) {
  }
  onFileMsgCome(arrayList) {
  }
  onFirstViewDirectMsgUpdate(firstViewDirectMsgNotifyInfo) {
  }
  onFirstViewGroupGuildMapping(arrayList) {
  }
  onGrabPasswordRedBag(i2, str, i3, recvdOrder, msgRecord) {
  }
  onGroupFileInfoAdd(groupItem) {
  }
  onGroupFileInfoUpdate(groupFileListResult) {
  }
  onGroupGuildUpdate(groupGuildNotifyInfo) {
  }
  onGroupTransferInfoAdd(groupItem) {
  }
  onGroupTransferInfoUpdate(groupFileListResult) {
  }
  onGuildInteractiveUpdate(guildInteractiveNotificationItem) {
  }
  onGuildMsgAbFlagChanged(guildMsgAbFlag) {
  }
  onGuildNotificationAbstractUpdate(guildNotificationAbstractInfo) {
  }
  onHitCsRelatedEmojiResult(downloadRelateEmojiResultInfo) {
  }
  onHitEmojiKeywordResult(hitRelatedEmojiWordsResult) {
  }
  onHitRelatedEmojiResult(relatedWordEmojiInfo) {
  }
  onImportOldDbProgressUpdate(importOldDbMsgNotifyInfo) {
  }
  onInputStatusPush(inputStatusInfo) {
  }
  onKickedOffLine(kickedInfo) {
  }
  onLineDev(arrayList) {
  }
  onLogLevelChanged(j2) {
  }
  onMsgAbstractUpdate(arrayList) {
  }
  onMsgBoxChanged(arrayList) {
  }
  onMsgDelete(contact, arrayList) {
  }
  onMsgEventListUpdate(hashMap) {
  }
  onMsgInfoListAdd(arrayList) {
  }
  onMsgInfoListUpdate(msgList) {
  }
  onMsgQRCodeStatusChanged(i2) {
  }
  onMsgRecall(chatType, uid, msgSeq) {
  }
  onMsgSecurityNotify(msgRecord) {
  }
  onMsgSettingUpdate(msgSetting) {
  }
  onNtFirstViewMsgSyncEnd() {
  }
  onNtMsgSyncEnd() {
  }
  onNtMsgSyncStart() {
  }
  onReadFeedEventUpdate(firstViewDirectMsgNotifyInfo) {
  }
  onRecvGroupGuildFlag(i2) {
  }
  onRecvMsg(arrayList) {
  }
  onRecvMsgSvrRspTransInfo(j2, contact, i2, i3, str, bArr) {
  }
  onRecvOnlineFileMsg(arrayList) {
  }
  onRecvS2CMsg(arrayList) {
  }
  onRecvSysMsg(arrayList) {
  }
  onRecvUDCFlag(i2) {
  }
  onRichMediaDownloadComplete(fileTransNotifyInfo) {
  }
  onRichMediaProgerssUpdate(fileTransNotifyInfo) {
  }
  onRichMediaUploadComplete(fileTransNotifyInfo) {
  }
  onSearchGroupFileInfoUpdate(searchGroupFileResult) {
  }
  onSendMsgError(j2, contact, i2, str) {
  }
  onSysMsgNotification(i2, j2, j3, arrayList) {
  }
  onTempChatInfoUpdate(tempChatInfo) {
  }
  onUnreadCntAfterFirstView(hashMap) {
  }
  onUnreadCntUpdate(hashMap) {
  }
  onUserChannelTabStatusChanged(z) {
  }
  onUserOnlineStatusChanged(z) {
  }
  onUserTabStatusChanged(arrayList) {
  }
  onlineStatusBigIconDownloadPush(i2, j2, str) {
  }
  onlineStatusSmallIconDownloadPush(i2, j2, str) {
  }
  // 第一次发现于Linux
  onUserSecQualityChanged(...args) {
  }
  onMsgWithRichLinkInfoUpdate(...args) {
  }
  onRedTouchChanged(...args) {
  }
  // 第一次发现于Win 9.9.9-23159
  onBroadcastHelperProgerssUpdate(...args) {
  }
}

class NodeIKernelGroupListener {
  onGroupListInited(listEmpty) {
  }
  // 发现于Win 9.9.9 23159
  onGroupMemberLevelInfoChange(...args) {
  }
  onGetGroupBulletinListResult(...args) {
  }
  onGroupAllInfoChange(...args) {
  }
  onGroupBulletinChange(...args) {
  }
  onGroupBulletinRemindNotify(...args) {
  }
  onGroupArkInviteStateResult(...args) {
  }
  onGroupBulletinRichMediaDownloadComplete(...args) {
  }
  onGroupConfMemberChange(...args) {
  }
  onGroupDetailInfoChange(detailInfo) {
  }
  onGroupExtListUpdate(...args) {
  }
  onGroupFirstBulletinNotify(...args) {
  }
  onGroupListUpdate(updateType, groupList) {
  }
  onGroupNotifiesUpdated(dboubt, notifies) {
  }
  onGroupBulletinRichMediaProgressUpdate(...args) {
  }
  onGroupNotifiesUnreadCountUpdated(...args) {
  }
  onGroupSingleScreenNotifies(doubt, seq, notifies) {
  }
  onGroupsMsgMaskResult(...args) {
  }
  onGroupStatisticInfoChange(...args) {
  }
  onJoinGroupNotify(...args) {
  }
  onJoinGroupNoVerifyFlag(...args) {
  }
  onMemberInfoChange(groupCode, dateSource, members) {
  }
  onMemberListChange(arg) {
  }
  onSearchMemberChange(...args) {
  }
  onShutUpMemberListChanged(groupCode, members) {
  }
}

class NodeIKernelBuddyListener {
  onBuddyListChangedV2(arg) {
  }
  onAddBuddyNeedVerify(arg) {
  }
  onAddMeSettingChanged(arg) {
  }
  onAvatarUrlUpdated(arg) {
  }
  onBlockChanged(arg) {
  }
  onBuddyDetailInfoChange(arg) {
  }
  onBuddyInfoChange(arg) {
  }
  onBuddyListChange(arg) {
  }
  onBuddyRemarkUpdated(arg) {
  }
  onBuddyReqChange(arg) {
  }
  onBuddyReqUnreadCntChange(arg) {
  }
  onCheckBuddySettingResult(arg) {
  }
  onDelBatchBuddyInfos(arg) {
  }
  onDoubtBuddyReqChange(arg) {
  }
  onDoubtBuddyReqUnreadNumChange(arg) {
  }
  onNickUpdated(arg) {
  }
  onSmartInfos(arg) {
  }
  onSpacePermissionInfos(arg) {
  }
}

class NodeIKernelProfileListener {
  onUserDetailInfoChanged(arg) {
  }
  onProfileSimpleChanged(...args) {
  }
  onProfileDetailInfoChanged(profile) {
  }
  onStatusUpdate(...args) {
  }
  onSelfStatusChanged(...args) {
  }
  onStrangerRemarkChanged(...args) {
  }
  onMemberListChange(...args) {
  }
  onMemberInfoChange(...args) {
  }
  onGroupListUpdate(...args) {
  }
  onGroupAllInfoChange(...args) {
  }
  onGroupDetailInfoChange(...args) {
  }
  onGroupConfMemberChange(...args) {
  }
  onGroupExtListUpdate(...args) {
  }
  onGroupNotifiesUpdated(...args) {
  }
  onGroupNotifiesUnreadCountUpdated(...args) {
  }
  onGroupMemberLevelInfoChange(...args) {
  }
  onGroupBulletinChange(...args) {
  }
}

function proxyHandlerOf(logger) {
  return {
    get(target, prop, receiver) {
      if (typeof target[prop] === "undefined") {
        return (..._args) => {
          logger.logDebug(`${target.constructor.name} has no method ${prop}`);
        };
      }
      return Reflect.get(target, prop, receiver);
    }
  };
}
function proxiedListenerOf(listener, logger) {
  return new Proxy(listener, proxyHandlerOf(logger));
}

const offset = {
  "3.2.12-28418-x64": {"recv":"A0723E0","send":"A06EAE0"},
  "9.9.15-28418-x64": {"recv":"37A9004","send":"37A4BD0"},
  "6.9.56-28418-x64": {"send":"4471360","recv":"4473BCC"},
  "6.9.56-28418-arm64": {"send":"3FBDBF8","recv":"3FC0410"},
  "9.9.15-28498-x64": {"recv":"37A9004","send":"37A4BD0"},
  "9.9.16-28788-x64": {"send":"38076D0","recv":"380BB04"},
  "3.2.13-28788-x64": {"send":"A0CEC20","recv":"A0D2520"},
  "3.2.13-28788-arm64": {"send":"6E91018","recv":"6E94850"},
  "9.9.16-28971-x64": {"send":"38079F0","recv":"380BE24"},
  "3.2.13-28971-x64": {"send":"A0CEF60","recv":"A0D2860"},
  "3.2.12-28971-arm64": {"send":"6E91318","recv":"6E94B50"},
  "6.9.58-28971-x64": {"send":"449ACA0","recv":"449D50C"},
  "6.9.58-28971-arm64": {"send":"3FE0DB0","recv":"3FE35C8"},
  "9.9.16-29271-x64": {"send":"3833510","recv":"3837944"},
  "3.2.13-29271-x64": {"send":"A11E680","recv":"A121F80"},
  "3.2.13-29271-arm64": {"send":"6ECA098","recv":"6ECD8D0"},
  "9.9.16-29456-x64": {"send":"3835CD0","recv":"383A104"},
  "3.2.13-29456-x64": {"send":"A11E820","recv":"A122120"},
  "3.2.13-29456-arm64": {"send":"6ECA130","recv":"6ECD968"},
  "6.9.59-29456-x64": {"send":"44C57A0","recv":"44C800C"},
  "6.9.59-29456-arm64": {"send":"4005FE8","recv":"4008800"},
  "9.9.16-29927-x64": {"send":"3869C50","recv":"386E084"},
  "3.2.13-29927-x64": {"send":"A1913A0","recv":"A194CA0"},
  "3.2.13-29927-arm64": {"send":"6F1C7E0","recv":"6F20018"},
  "6.9.61-29927-x64": {"send":"44FCC60","recv":"44FF4CC"},
  "6.9.61-29927-arm64": {"send":"4038740","recv":"403AF58"},
  "9.9.17-30366-x64": {"send":"39AB0B0","recv":"39AF4E4"},
  "3.2.15-30366-x64": {"send":"A402380","recv":"A405C80"},
  "3.2.15-30366-arm64": {"send":"70C3FA8","recv":"70C77E0"},
  "6.9.62-30366-x64": {"send":"4669760","recv":"466BFCC"},
  "6.9.62-30366-arm64": {"send":"4189770","recv":"418BF88"},
};

/**
 * Get the type of a JSON value.
 * Distinguishes between array, null and object.
 */
function typeofJsonValue(value) {
    let t = typeof value;
    if (t == "object") {
        if (Array.isArray(value))
            return "array";
        if (value === null)
            return "null";
    }
    return t;
}
/**
 * Is this a JSON object (instead of an array or null)?
 */
function isJsonObject(value) {
    return value !== null && typeof value == "object" && !Array.isArray(value);
}

// lookup table from base64 character to byte
let encTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
// lookup table from base64 character *code* to byte because lookup by number is fast
let decTable = [];
for (let i = 0; i < encTable.length; i++)
    decTable[encTable[i].charCodeAt(0)] = i;
// support base64url variants
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
/**
 * Decodes a base64 string to a byte array.
 *
 * - ignores white-space, including line breaks and tabs
 * - allows inner padding (can decode concatenated base64 strings)
 * - does not require padding
 * - understands base64url encoding:
 *   "-" instead of "+",
 *   "_" instead of "/",
 *   no padding
 */
function base64decode(base64Str) {
    // estimate byte size, not accounting for inner padding and whitespace
    let es = base64Str.length * 3 / 4;
    // if (es % 3 !== 0)
    // throw new Error('invalid base64 string');
    if (base64Str[base64Str.length - 2] == '=')
        es -= 2;
    else if (base64Str[base64Str.length - 1] == '=')
        es -= 1;
    let bytes = new Uint8Array(es), bytePos = 0, // position in byte array
    groupPos = 0, // position in base64 group
    b, // current byte
    p = 0 // previous byte
    ;
    for (let i = 0; i < base64Str.length; i++) {
        b = decTable[base64Str.charCodeAt(i)];
        if (b === undefined) {
            // noinspection FallThroughInSwitchStatementJS
            switch (base64Str[i]) {
                case '=':
                    groupPos = 0; // reset state when padding found
                case '\n':
                case '\r':
                case '\t':
                case ' ':
                    continue; // skip white-space, and padding
                default:
                    throw Error(`invalid base64 string.`);
            }
        }
        switch (groupPos) {
            case 0:
                p = b;
                groupPos = 1;
                break;
            case 1:
                bytes[bytePos++] = p << 2 | (b & 48) >> 4;
                p = b;
                groupPos = 2;
                break;
            case 2:
                bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
                p = b;
                groupPos = 3;
                break;
            case 3:
                bytes[bytePos++] = (p & 3) << 6 | b;
                groupPos = 0;
                break;
        }
    }
    if (groupPos == 1)
        throw Error(`invalid base64 string.`);
    return bytes.subarray(0, bytePos);
}
/**
 * Encodes a byte array to a base64 string.
 * Adds padding at the end.
 * Does not insert newlines.
 */
function base64encode(bytes) {
    let base64 = '', groupPos = 0, // position in base64 group
    b, // current byte
    p = 0; // carry over from previous byte
    for (let i = 0; i < bytes.length; i++) {
        b = bytes[i];
        switch (groupPos) {
            case 0:
                base64 += encTable[b >> 2];
                p = (b & 3) << 4;
                groupPos = 1;
                break;
            case 1:
                base64 += encTable[p | b >> 4];
                p = (b & 15) << 2;
                groupPos = 2;
                break;
            case 2:
                base64 += encTable[p | b >> 6];
                base64 += encTable[b & 63];
                groupPos = 0;
                break;
        }
    }
    // padding required?
    if (groupPos) {
        base64 += encTable[p];
        base64 += '=';
        if (groupPos == 1)
            base64 += '=';
    }
    return base64;
}

/**
 * This handler implements the default behaviour for unknown fields.
 * When reading data, unknown fields are stored on the message, in a
 * symbol property.
 * When writing data, the symbol property is queried and unknown fields
 * are serialized into the output again.
 */
var UnknownFieldHandler;
(function (UnknownFieldHandler) {
    /**
     * The symbol used to store unknown fields for a message.
     * The property must conform to `UnknownFieldContainer`.
     */
    UnknownFieldHandler.symbol = Symbol.for("protobuf-ts/unknown");
    /**
     * Store an unknown field during binary read directly on the message.
     * This method is compatible with `BinaryReadOptions.readUnknownField`.
     */
    UnknownFieldHandler.onRead = (typeName, message, fieldNo, wireType, data) => {
        let container = is(message) ? message[UnknownFieldHandler.symbol] : message[UnknownFieldHandler.symbol] = [];
        container.push({ no: fieldNo, wireType, data });
    };
    /**
     * Write unknown fields stored for the message to the writer.
     * This method is compatible with `BinaryWriteOptions.writeUnknownFields`.
     */
    UnknownFieldHandler.onWrite = (typeName, message, writer) => {
        for (let { no, wireType, data } of UnknownFieldHandler.list(message))
            writer.tag(no, wireType).raw(data);
    };
    /**
     * List unknown fields stored for the message.
     * Note that there may be multiples fields with the same number.
     */
    UnknownFieldHandler.list = (message, fieldNo) => {
        if (is(message)) {
            let all = message[UnknownFieldHandler.symbol];
            return fieldNo ? all.filter(uf => uf.no == fieldNo) : all;
        }
        return [];
    };
    /**
     * Returns the last unknown field by field number.
     */
    UnknownFieldHandler.last = (message, fieldNo) => UnknownFieldHandler.list(message, fieldNo).slice(-1)[0];
    const is = (message) => message && Array.isArray(message[UnknownFieldHandler.symbol]);
})(UnknownFieldHandler || (UnknownFieldHandler = {}));
/**
 * Protobuf binary format wire types.
 *
 * A wire type provides just enough information to find the length of the
 * following value.
 *
 * See https://developers.google.com/protocol-buffers/docs/encoding#structure
 */
var WireType;
(function (WireType) {
    /**
     * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum
     */
    WireType[WireType["Varint"] = 0] = "Varint";
    /**
     * Used for fixed64, sfixed64, double.
     * Always 8 bytes with little-endian byte order.
     */
    WireType[WireType["Bit64"] = 1] = "Bit64";
    /**
     * Used for string, bytes, embedded messages, packed repeated fields
     *
     * Only repeated numeric types (types which use the varint, 32-bit,
     * or 64-bit wire types) can be packed. In proto3, such fields are
     * packed by default.
     */
    WireType[WireType["LengthDelimited"] = 2] = "LengthDelimited";
    /**
     * Used for groups
     * @deprecated
     */
    WireType[WireType["StartGroup"] = 3] = "StartGroup";
    /**
     * Used for groups
     * @deprecated
     */
    WireType[WireType["EndGroup"] = 4] = "EndGroup";
    /**
     * Used for fixed32, sfixed32, float.
     * Always 4 bytes with little-endian byte order.
     */
    WireType[WireType["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));

// Copyright 2008 Google Inc.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Code generated by the Protocol Buffer compiler is owned by the owner
// of the input file used when generating it.  This code is not
// standalone and requires a support library to be linked with it.  This
// support library is itself covered by the above license.
/**
 * Read a 64 bit varint as two JS numbers.
 *
 * Returns tuple:
 * [0]: low bits
 * [0]: high bits
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175
 */
function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0; shift < 28; shift += 7) {
        let b = this.buf[this.pos++];
        lowBits |= (b & 0x7F) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [lowBits, highBits];
        }
    }
    let middleByte = this.buf[this.pos++];
    // last four bits of the first 32 bit number
    lowBits |= (middleByte & 0x0F) << 28;
    // 3 upper bits are part of the next 32 bit number
    highBits = (middleByte & 0x70) >> 4;
    if ((middleByte & 0x80) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
    }
    for (let shift = 3; shift <= 31; shift += 7) {
        let b = this.buf[this.pos++];
        highBits |= (b & 0x7F) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [lowBits, highBits];
        }
    }
    throw new Error('invalid varint');
}
/**
 * Write a 64 bit varint, given as two JS numbers, to the given bytes array.
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344
 */
function varint64write(lo, hi, bytes) {
    for (let i = 0; i < 28; i = i + 7) {
        const shift = lo >>> i;
        const hasNext = !((shift >>> 7) == 0 && hi == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;
        bytes.push(byte);
        if (!hasNext) {
            return;
        }
    }
    const splitBits = ((lo >>> 28) & 0x0F) | ((hi & 0x07) << 4);
    const hasMoreBits = !((hi >> 3) == 0);
    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xFF);
    if (!hasMoreBits) {
        return;
    }
    for (let i = 3; i < 31; i = i + 7) {
        const shift = hi >>> i;
        const hasNext = !((shift >>> 7) == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;
        bytes.push(byte);
        if (!hasNext) {
            return;
        }
    }
    bytes.push((hi >>> 31) & 0x01);
}
// constants for binary math
const TWO_PWR_32_DBL$1 = (1 << 16) * (1 << 16);
/**
 * Parse decimal string of 64 bit integer value as two JS numbers.
 *
 * Returns tuple:
 * [0]: minus sign?
 * [1]: low bits
 * [2]: high bits
 *
 * Copyright 2008 Google Inc.
 */
function int64fromString(dec) {
    // Check for minus sign.
    let minus = dec[0] == '-';
    if (minus)
        dec = dec.slice(1);
    // Work 6 decimal digits at a time, acting like we're converting base 1e6
    // digits to binary. This is safe to do with floating point math because
    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
        // Note: Number('') is 0.
        const digit1e6 = Number(dec.slice(begin, end));
        highBits *= base;
        lowBits = lowBits * base + digit1e6;
        // Carry bits from lowBits to highBits
        if (lowBits >= TWO_PWR_32_DBL$1) {
            highBits = highBits + ((lowBits / TWO_PWR_32_DBL$1) | 0);
            lowBits = lowBits % TWO_PWR_32_DBL$1;
        }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return [minus, lowBits, highBits];
}
/**
 * Format 64 bit integer value (as two JS numbers) to decimal string.
 *
 * Copyright 2008 Google Inc.
 */
function int64toString(bitsLow, bitsHigh) {
    // Skip the expensive conversion if the number is small enough to use the
    // built-in conversions.
    if ((bitsHigh >>> 0) <= 0x1FFFFF) {
        return '' + (TWO_PWR_32_DBL$1 * bitsHigh + (bitsLow >>> 0));
    }
    // What this code is doing is essentially converting the input number from
    // base-2 to base-1e7, which allows us to represent the 64-bit range with
    // only 3 (very large) digits. Those digits are then trivial to convert to
    // a base-10 string.
    // The magic numbers used here are -
    // 2^24 = 16777216 = (1,6777216) in base-1e7.
    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.
    // Split 32:32 representation into 16:24:24 representation so our
    // intermediate digits don't overflow.
    let low = bitsLow & 0xFFFFFF;
    let mid = (((bitsLow >>> 24) | (bitsHigh << 8)) >>> 0) & 0xFFFFFF;
    let high = (bitsHigh >> 16) & 0xFFFF;
    // Assemble our three base-1e7 digits, ignoring carries. The maximum
    // value in a digit at this step is representable as a 48-bit integer, which
    // can be stored in a 64-bit floating point number.
    let digitA = low + (mid * 6777216) + (high * 6710656);
    let digitB = mid + (high * 8147497);
    let digitC = (high * 2);
    // Apply carries from A to B and from B to C.
    let base = 10000000;
    if (digitA >= base) {
        digitB += Math.floor(digitA / base);
        digitA %= base;
    }
    if (digitB >= base) {
        digitC += Math.floor(digitB / base);
        digitB %= base;
    }
    // Convert base-1e7 digits to base-10, with optional leading zeroes.
    function decimalFrom1e7(digit1e7, needLeadingZeros) {
        let partial = digit1e7 ? String(digit1e7) : '';
        if (needLeadingZeros) {
            return '0000000'.slice(partial.length) + partial;
        }
        return partial;
    }
    return decimalFrom1e7(digitC, /*needLeadingZeros=*/ 0) +
        decimalFrom1e7(digitB, /*needLeadingZeros=*/ digitC) +
        // If the final 1e7 digit didn't need leading zeros, we would have
        // returned via the trivial code path at the top.
        decimalFrom1e7(digitA, /*needLeadingZeros=*/ 1);
}
/**
 * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144
 */
function varint32write(value, bytes) {
    if (value >= 0) {
        // write value as varint 32
        while (value > 0x7f) {
            bytes.push((value & 0x7f) | 0x80);
            value = value >>> 7;
        }
        bytes.push(value);
    }
    else {
        for (let i = 0; i < 9; i++) {
            bytes.push(value & 127 | 128);
            value = value >> 7;
        }
        bytes.push(1);
    }
}
/**
 * Read an unsigned 32 bit varint.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220
 */
function varint32read() {
    let b = this.buf[this.pos++];
    let result = b & 0x7F;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 7;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 14;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 21;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    // Extract only last 4 bits
    b = this.buf[this.pos++];
    result |= (b & 0x0F) << 28;
    for (let readBytes = 5; ((b & 0x80) !== 0) && readBytes < 10; readBytes++)
        b = this.buf[this.pos++];
    if ((b & 0x80) != 0)
        throw new Error('invalid varint');
    this.assertBounds();
    // Result can have 32 bits, convert it to unsigned
    return result >>> 0;
}

let BI;
function detectBi() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok = globalThis.BigInt !== undefined
        && typeof dv.getBigInt64 === "function"
        && typeof dv.getBigUint64 === "function"
        && typeof dv.setBigInt64 === "function"
        && typeof dv.setBigUint64 === "function";
    BI = ok ? {
        MIN: BigInt("-9223372036854775808"),
        MAX: BigInt("9223372036854775807"),
        UMIN: BigInt("0"),
        UMAX: BigInt("18446744073709551615"),
        C: BigInt,
        V: dv,
    } : undefined;
}
detectBi();
function assertBi(bi) {
    if (!bi)
        throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
// used to validate from(string) input (when bigint is unavailable)
const RE_DECIMAL_STR = /^-?[0-9]+$/;
// constants for binary math
const TWO_PWR_32_DBL = 0x100000000;
const HALF_2_PWR_32 = 0x080000000;
// base class for PbLong and PbULong provides shared code
class SharedPbLong {
    /**
     * Create a new instance with the given bits.
     */
    constructor(lo, hi) {
        this.lo = lo | 0;
        this.hi = hi | 0;
    }
    /**
     * Is this instance equal to 0?
     */
    isZero() {
        return this.lo == 0 && this.hi == 0;
    }
    /**
     * Convert to a native number.
     */
    toNumber() {
        let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);
        if (!Number.isSafeInteger(result))
            throw new Error("cannot convert to safe number");
        return result;
    }
}
/**
 * 64-bit unsigned integer as two 32-bit values.
 * Converts between `string`, `number` and `bigint` representations.
 */
class PbULong extends SharedPbLong {
    /**
     * Create instance from a `string`, `number` or `bigint`.
     */
    static from(value) {
        if (BI)
            // noinspection FallThroughInSwitchStatementJS
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    if (value == "")
                        throw new Error('string is no integer');
                    value = BI.C(value);
                case "number":
                    if (value === 0)
                        return this.ZERO;
                    value = BI.C(value);
                case "bigint":
                    if (!value)
                        return this.ZERO;
                    if (value < BI.UMIN)
                        throw new Error('signed value for ulong');
                    if (value > BI.UMAX)
                        throw new Error('ulong too large');
                    BI.V.setBigUint64(0, value, true);
                    return new PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
            }
        else
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    value = value.trim();
                    if (!RE_DECIMAL_STR.test(value))
                        throw new Error('string is no integer');
                    let [minus, lo, hi] = int64fromString(value);
                    if (minus)
                        throw new Error('signed value for ulong');
                    return new PbULong(lo, hi);
                case "number":
                    if (value == 0)
                        return this.ZERO;
                    if (!Number.isSafeInteger(value))
                        throw new Error('number is no integer');
                    if (value < 0)
                        throw new Error('signed value for ulong');
                    return new PbULong(value, value / TWO_PWR_32_DBL);
            }
        throw new Error('unknown value ' + typeof value);
    }
    /**
     * Convert to decimal string.
     */
    toString() {
        return BI ? this.toBigInt().toString() : int64toString(this.lo, this.hi);
    }
    /**
     * Convert to native bigint.
     */
    toBigInt() {
        assertBi(BI);
        BI.V.setInt32(0, this.lo, true);
        BI.V.setInt32(4, this.hi, true);
        return BI.V.getBigUint64(0, true);
    }
}
/**
 * ulong 0 singleton.
 */
PbULong.ZERO = new PbULong(0, 0);
/**
 * 64-bit signed integer as two 32-bit values.
 * Converts between `string`, `number` and `bigint` representations.
 */
class PbLong extends SharedPbLong {
    /**
     * Create instance from a `string`, `number` or `bigint`.
     */
    static from(value) {
        if (BI)
            // noinspection FallThroughInSwitchStatementJS
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    if (value == "")
                        throw new Error('string is no integer');
                    value = BI.C(value);
                case "number":
                    if (value === 0)
                        return this.ZERO;
                    value = BI.C(value);
                case "bigint":
                    if (!value)
                        return this.ZERO;
                    if (value < BI.MIN)
                        throw new Error('signed long too small');
                    if (value > BI.MAX)
                        throw new Error('signed long too large');
                    BI.V.setBigInt64(0, value, true);
                    return new PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
            }
        else
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    value = value.trim();
                    if (!RE_DECIMAL_STR.test(value))
                        throw new Error('string is no integer');
                    let [minus, lo, hi] = int64fromString(value);
                    if (minus) {
                        if (hi > HALF_2_PWR_32 || (hi == HALF_2_PWR_32 && lo != 0))
                            throw new Error('signed long too small');
                    }
                    else if (hi >= HALF_2_PWR_32)
                        throw new Error('signed long too large');
                    let pbl = new PbLong(lo, hi);
                    return minus ? pbl.negate() : pbl;
                case "number":
                    if (value == 0)
                        return this.ZERO;
                    if (!Number.isSafeInteger(value))
                        throw new Error('number is no integer');
                    return value > 0
                        ? new PbLong(value, value / TWO_PWR_32_DBL)
                        : new PbLong(-value, -value / TWO_PWR_32_DBL).negate();
            }
        throw new Error('unknown value ' + typeof value);
    }
    /**
     * Do we have a minus sign?
     */
    isNegative() {
        return (this.hi & HALF_2_PWR_32) !== 0;
    }
    /**
     * Negate two's complement.
     * Invert all the bits and add one to the result.
     */
    negate() {
        let hi = ~this.hi, lo = this.lo;
        if (lo)
            lo = ~lo + 1;
        else
            hi += 1;
        return new PbLong(lo, hi);
    }
    /**
     * Convert to decimal string.
     */
    toString() {
        if (BI)
            return this.toBigInt().toString();
        if (this.isNegative()) {
            let n = this.negate();
            return '-' + int64toString(n.lo, n.hi);
        }
        return int64toString(this.lo, this.hi);
    }
    /**
     * Convert to native bigint.
     */
    toBigInt() {
        assertBi(BI);
        BI.V.setInt32(0, this.lo, true);
        BI.V.setInt32(4, this.hi, true);
        return BI.V.getBigInt64(0, true);
    }
}
/**
 * long 0 singleton.
 */
PbLong.ZERO = new PbLong(0, 0);

const defaultsRead$1 = {
    readUnknownField: true,
    readerFactory: bytes => new BinaryReader(bytes),
};
/**
 * Make options for reading binary data form partial options.
 */
function binaryReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead$1), options) : defaultsRead$1;
}
class BinaryReader {
    constructor(buf, textDecoder) {
        this.varint64 = varint64read; // dirty cast for `this`
        /**
         * Read a `uint32` field, an unsigned 32 bit varint.
         */
        this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`
        this.buf = buf;
        this.len = buf.length;
        this.pos = 0;
        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
            fatal: true,
            ignoreBOM: true,
        });
    }
    /**
     * Reads a tag - field number and wire type.
     */
    tag() {
        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
        if (fieldNo <= 0 || wireType < 0 || wireType > 5)
            throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
        return [fieldNo, wireType];
    }
    /**
     * Skip one element on the wire and return the skipped data.
     * Supports WireType.StartGroup since v2.0.0-alpha.23.
     */
    skip(wireType) {
        let start = this.pos;
        // noinspection FallThroughInSwitchStatementJS
        switch (wireType) {
            case WireType.Varint:
                while (this.buf[this.pos++] & 0x80) {
                    // ignore
                }
                break;
            case WireType.Bit64:
                this.pos += 4;
            case WireType.Bit32:
                this.pos += 4;
                break;
            case WireType.LengthDelimited:
                let len = this.uint32();
                this.pos += len;
                break;
            case WireType.StartGroup:
                // From descriptor.proto: Group type is deprecated, not supported in proto3.
                // But we must still be able to parse and treat as unknown.
                let t;
                while ((t = this.tag()[1]) !== WireType.EndGroup) {
                    this.skip(t);
                }
                break;
            default:
                throw new Error("cant skip wire type " + wireType);
        }
        this.assertBounds();
        return this.buf.subarray(start, this.pos);
    }
    /**
     * Throws error if position in byte array is out of range.
     */
    assertBounds() {
        if (this.pos > this.len)
            throw new RangeError("premature EOF");
    }
    /**
     * Read a `int32` field, a signed 32 bit varint.
     */
    int32() {
        return this.uint32() | 0;
    }
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */
    sint32() {
        let zze = this.uint32();
        // decode zigzag
        return (zze >>> 1) ^ -(zze & 1);
    }
    /**
     * Read a `int64` field, a signed 64-bit varint.
     */
    int64() {
        return new PbLong(...this.varint64());
    }
    /**
     * Read a `uint64` field, an unsigned 64-bit varint.
     */
    uint64() {
        return new PbULong(...this.varint64());
    }
    /**
     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64() {
        let [lo, hi] = this.varint64();
        // decode zig zag
        let s = -(lo & 1);
        lo = ((lo >>> 1 | (hi & 1) << 31) ^ s);
        hi = (hi >>> 1 ^ s);
        return new PbLong(lo, hi);
    }
    /**
     * Read a `bool` field, a variant.
     */
    bool() {
        let [lo, hi] = this.varint64();
        return lo !== 0 || hi !== 0;
    }
    /**
     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
     */
    fixed32() {
        return this.view.getUint32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
     */
    sfixed32() {
        return this.view.getInt32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
     */
    fixed64() {
        return new PbULong(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
     */
    sfixed64() {
        return new PbLong(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `float` field, 32-bit floating point number.
     */
    float() {
        return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `double` field, a 64-bit floating point number.
     */
    double() {
        return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    /**
     * Read a `bytes` field, length-delimited arbitrary data.
     */
    bytes() {
        let len = this.uint32();
        let start = this.pos;
        this.pos += len;
        this.assertBounds();
        return this.buf.subarray(start, start + len);
    }
    /**
     * Read a `string` field, length-delimited data converted to UTF-8 text.
     */
    string() {
        return this.textDecoder.decode(this.bytes());
    }
}

/**
 * assert that condition is true or throw error (with message)
 */
function assert(condition, msg) {
    if (!condition) {
        throw new Error(msg);
    }
}
const FLOAT32_MAX = 3.4028234663852886e+38, FLOAT32_MIN = -3.4028234663852886e+38, UINT32_MAX = 0xFFFFFFFF, INT32_MAX = 0X7FFFFFFF, INT32_MIN = -0X80000000;
function assertInt32(arg) {
    if (typeof arg !== "number")
        throw new Error('invalid int 32: ' + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
        throw new Error('invalid int 32: ' + arg);
}
function assertUInt32(arg) {
    if (typeof arg !== "number")
        throw new Error('invalid uint 32: ' + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
        throw new Error('invalid uint 32: ' + arg);
}
function assertFloat32(arg) {
    if (typeof arg !== "number")
        throw new Error('invalid float 32: ' + typeof arg);
    if (!Number.isFinite(arg))
        return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
        throw new Error('invalid float 32: ' + arg);
}

const defaultsWrite$1 = {
    writeUnknownFields: true,
    writerFactory: () => new BinaryWriter(),
};
/**
 * Make options for writing binary data form partial options.
 */
function binaryWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite$1), options) : defaultsWrite$1;
}
class BinaryWriter {
    constructor(textEncoder) {
        /**
         * Previous fork states.
         */
        this.stack = [];
        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
        this.chunks = [];
        this.buf = [];
    }
    /**
     * Return all bytes written and reset this writer.
     */
    finish() {
        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer
        let len = 0;
        for (let i = 0; i < this.chunks.length; i++)
            len += this.chunks[i].length;
        let bytes = new Uint8Array(len);
        let offset = 0;
        for (let i = 0; i < this.chunks.length; i++) {
            bytes.set(this.chunks[i], offset);
            offset += this.chunks[i].length;
        }
        this.chunks = [];
        return bytes;
    }
    /**
     * Start a new fork for length-delimited data like a message
     * or a packed repeated field.
     *
     * Must be joined later with `join()`.
     */
    fork() {
        this.stack.push({ chunks: this.chunks, buf: this.buf });
        this.chunks = [];
        this.buf = [];
        return this;
    }
    /**
     * Join the last fork. Write its length and bytes, then
     * return to the previous state.
     */
    join() {
        // get chunk of fork
        let chunk = this.finish();
        // restore previous state
        let prev = this.stack.pop();
        if (!prev)
            throw new Error('invalid state, fork stack empty');
        this.chunks = prev.chunks;
        this.buf = prev.buf;
        // write length of chunk as varint
        this.uint32(chunk.byteLength);
        return this.raw(chunk);
    }
    /**
     * Writes a tag (field number and wire type).
     *
     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
     *
     * Generated code should compute the tag ahead of time and call `uint32()`.
     */
    tag(fieldNo, type) {
        return this.uint32((fieldNo << 3 | type) >>> 0);
    }
    /**
     * Write a chunk of raw bytes.
     */
    raw(chunk) {
        if (this.buf.length) {
            this.chunks.push(new Uint8Array(this.buf));
            this.buf = [];
        }
        this.chunks.push(chunk);
        return this;
    }
    /**
     * Write a `uint32` value, an unsigned 32 bit varint.
     */
    uint32(value) {
        assertUInt32(value);
        // write value as varint 32, inlined for speed
        while (value > 0x7f) {
            this.buf.push((value & 0x7f) | 0x80);
            value = value >>> 7;
        }
        this.buf.push(value);
        return this;
    }
    /**
     * Write a `int32` value, a signed 32 bit varint.
     */
    int32(value) {
        assertInt32(value);
        varint32write(value, this.buf);
        return this;
    }
    /**
     * Write a `bool` value, a variant.
     */
    bool(value) {
        this.buf.push(value ? 1 : 0);
        return this;
    }
    /**
     * Write a `bytes` value, length-delimited arbitrary data.
     */
    bytes(value) {
        this.uint32(value.byteLength); // write length of chunk as varint
        return this.raw(value);
    }
    /**
     * Write a `string` value, length-delimited data converted to UTF-8 text.
     */
    string(value) {
        let chunk = this.textEncoder.encode(value);
        this.uint32(chunk.byteLength); // write length of chunk as varint
        return this.raw(chunk);
    }
    /**
     * Write a `float` value, 32-bit floating point number.
     */
    float(value) {
        assertFloat32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setFloat32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `double` value, a 64-bit floating point number.
     */
    double(value) {
        let chunk = new Uint8Array(8);
        new DataView(chunk.buffer).setFloat64(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
     */
    fixed32(value) {
        assertUInt32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setUint32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
     */
    sfixed32(value) {
        assertInt32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setInt32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
     */
    sint32(value) {
        assertInt32(value);
        // zigzag encode
        value = ((value << 1) ^ (value >> 31)) >>> 0;
        varint32write(value, this.buf);
        return this;
    }
    /**
     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
     */
    sfixed64(value) {
        let chunk = new Uint8Array(8);
        let view = new DataView(chunk.buffer);
        let long = PbLong.from(value);
        view.setInt32(0, long.lo, true);
        view.setInt32(4, long.hi, true);
        return this.raw(chunk);
    }
    /**
     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
     */
    fixed64(value) {
        let chunk = new Uint8Array(8);
        let view = new DataView(chunk.buffer);
        let long = PbULong.from(value);
        view.setInt32(0, long.lo, true);
        view.setInt32(4, long.hi, true);
        return this.raw(chunk);
    }
    /**
     * Write a `int64` value, a signed 64-bit varint.
     */
    int64(value) {
        let long = PbLong.from(value);
        varint64write(long.lo, long.hi, this.buf);
        return this;
    }
    /**
     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64(value) {
        let long = PbLong.from(value), 
        // zigzag encode
        sign = long.hi >> 31, lo = (long.lo << 1) ^ sign, hi = ((long.hi << 1) | (long.lo >>> 31)) ^ sign;
        varint64write(lo, hi, this.buf);
        return this;
    }
    /**
     * Write a `uint64` value, an unsigned 64-bit varint.
     */
    uint64(value) {
        let long = PbULong.from(value);
        varint64write(long.lo, long.hi, this.buf);
        return this;
    }
}

const defaultsWrite = {
    emitDefaultValues: false,
    enumAsInteger: false,
    useProtoFieldName: false,
    prettySpaces: 0,
}, defaultsRead = {
    ignoreUnknownFields: false,
};
/**
 * Make options for reading JSON data from partial options.
 */
function jsonReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
/**
 * Make options for writing JSON data from partial options.
 */
function jsonWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}

/**
 * The symbol used as a key on message objects to store the message type.
 *
 * Note that this is an experimental feature - it is here to stay, but
 * implementation details may change without notice.
 */
const MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");

/**
 * Converts snake_case to lowerCamelCase.
 *
 * Should behave like protoc:
 * https://github.com/protocolbuffers/protobuf/blob/e8ae137c96444ea313485ed1118c5e43b2099cf1/src/google/protobuf/compiler/java/java_helpers.cc#L118
 */
function lowerCamelCase(snakeCase) {
    let capNext = false;
    const sb = [];
    for (let i = 0; i < snakeCase.length; i++) {
        let next = snakeCase.charAt(i);
        if (next == '_') {
            capNext = true;
        }
        else if (/\d/.test(next)) {
            sb.push(next);
            capNext = true;
        }
        else if (capNext) {
            sb.push(next.toUpperCase());
            capNext = false;
        }
        else if (i == 0) {
            sb.push(next.toLowerCase());
        }
        else {
            sb.push(next);
        }
    }
    return sb.join('');
}

/**
 * Scalar value types. This is a subset of field types declared by protobuf
 * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE
 * are omitted, but the numerical values are identical.
 */
var ScalarType;
(function (ScalarType) {
    // 0 is reserved for errors.
    // Order is weird for historical reasons.
    ScalarType[ScalarType["DOUBLE"] = 1] = "DOUBLE";
    ScalarType[ScalarType["FLOAT"] = 2] = "FLOAT";
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
    // negative values are likely.
    ScalarType[ScalarType["INT64"] = 3] = "INT64";
    ScalarType[ScalarType["UINT64"] = 4] = "UINT64";
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
    // negative values are likely.
    ScalarType[ScalarType["INT32"] = 5] = "INT32";
    ScalarType[ScalarType["FIXED64"] = 6] = "FIXED64";
    ScalarType[ScalarType["FIXED32"] = 7] = "FIXED32";
    ScalarType[ScalarType["BOOL"] = 8] = "BOOL";
    ScalarType[ScalarType["STRING"] = 9] = "STRING";
    // Tag-delimited aggregate.
    // Group type is deprecated and not supported in proto3. However, Proto3
    // implementations should still be able to parse the group wire format and
    // treat group fields as unknown fields.
    // TYPE_GROUP = 10,
    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.
    // New in version 2.
    ScalarType[ScalarType["BYTES"] = 12] = "BYTES";
    ScalarType[ScalarType["UINT32"] = 13] = "UINT32";
    // TYPE_ENUM = 14,
    ScalarType[ScalarType["SFIXED32"] = 15] = "SFIXED32";
    ScalarType[ScalarType["SFIXED64"] = 16] = "SFIXED64";
    ScalarType[ScalarType["SINT32"] = 17] = "SINT32";
    ScalarType[ScalarType["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
/**
 * JavaScript representation of 64 bit integral types. Equivalent to the
 * field option "jstype".
 *
 * By default, protobuf-ts represents 64 bit types as `bigint`.
 *
 * You can change the default behaviour by enabling the plugin parameter
 * `long_type_string`, which will represent 64 bit types as `string`.
 *
 * Alternatively, you can change the behaviour for individual fields
 * with the field option "jstype":
 *
 * ```protobuf
 * uint64 my_field = 1 [jstype = JS_STRING];
 * uint64 other_field = 2 [jstype = JS_NUMBER];
 * ```
 */
var LongType;
(function (LongType) {
    /**
     * Use JavaScript `bigint`.
     *
     * Field option `[jstype = JS_NORMAL]`.
     */
    LongType[LongType["BIGINT"] = 0] = "BIGINT";
    /**
     * Use JavaScript `string`.
     *
     * Field option `[jstype = JS_STRING]`.
     */
    LongType[LongType["STRING"] = 1] = "STRING";
    /**
     * Use JavaScript `number`.
     *
     * Large values will loose precision.
     *
     * Field option `[jstype = JS_NUMBER]`.
     */
    LongType[LongType["NUMBER"] = 2] = "NUMBER";
})(LongType || (LongType = {}));
/**
 * Protobuf 2.1.0 introduced packed repeated fields.
 * Setting the field option `[packed = true]` enables packing.
 *
 * In proto3, all repeated fields are packed by default.
 * Setting the field option `[packed = false]` disables packing.
 *
 * Packed repeated fields are encoded with a single tag,
 * then a length-delimiter, then the element values.
 *
 * Unpacked repeated fields are encoded with a tag and
 * value for each element.
 *
 * `bytes` and `string` cannot be packed.
 */
var RepeatType;
(function (RepeatType) {
    /**
     * The field is not repeated.
     */
    RepeatType[RepeatType["NO"] = 0] = "NO";
    /**
     * The field is repeated and should be packed.
     * Invalid for `bytes` and `string`, they cannot be packed.
     */
    RepeatType[RepeatType["PACKED"] = 1] = "PACKED";
    /**
     * The field is repeated but should not be packed.
     * The only valid repeat type for repeated `bytes` and `string`.
     */
    RepeatType[RepeatType["UNPACKED"] = 2] = "UNPACKED";
})(RepeatType || (RepeatType = {}));
/**
 * Turns PartialFieldInfo into FieldInfo.
 */
function normalizeFieldInfo(field) {
    var _a, _b, _c, _d;
    field.localName = (_a = field.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(field.name);
    field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : lowerCamelCase(field.name);
    field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO;
    field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : (field.repeat ? false : field.oneof ? false : field.kind == "message");
    return field;
}

/**
 * Is the given value a valid oneof group?
 *
 * We represent protobuf `oneof` as algebraic data types (ADT) in generated
 * code. But when working with messages of unknown type, the ADT does not
 * help us.
 *
 * This type guard checks if the given object adheres to the ADT rules, which
 * are as follows:
 *
 * 1) Must be an object.
 *
 * 2) Must have a "oneofKind" discriminator property.
 *
 * 3) If "oneofKind" is `undefined`, no member field is selected. The object
 * must not have any other properties.
 *
 * 4) If "oneofKind" is a `string`, the member field with this name is
 * selected.
 *
 * 5) If a member field is selected, the object must have a second property
 * with this name. The property must not be `undefined`.
 *
 * 6) No extra properties are allowed. The object has either one property
 * (no selection) or two properties (selection).
 *
 */
function isOneofGroup(any) {
    if (typeof any != 'object' || any === null || !any.hasOwnProperty('oneofKind')) {
        return false;
    }
    switch (typeof any.oneofKind) {
        case "string":
            if (any[any.oneofKind] === undefined)
                return false;
            return Object.keys(any).length == 2;
        case "undefined":
            return Object.keys(any).length == 1;
        default:
            return false;
    }
}

// noinspection JSMethodCanBeStatic
class ReflectionTypeCheck {
    constructor(info) {
        var _a;
        this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
    }
    prepare() {
        if (this.data)
            return;
        const req = [], known = [], oneofs = [];
        for (let field of this.fields) {
            if (field.oneof) {
                if (!oneofs.includes(field.oneof)) {
                    oneofs.push(field.oneof);
                    req.push(field.oneof);
                    known.push(field.oneof);
                }
            }
            else {
                known.push(field.localName);
                switch (field.kind) {
                    case "scalar":
                    case "enum":
                        if (!field.opt || field.repeat)
                            req.push(field.localName);
                        break;
                    case "message":
                        if (field.repeat)
                            req.push(field.localName);
                        break;
                    case "map":
                        req.push(field.localName);
                        break;
                }
            }
        }
        this.data = { req, known, oneofs: Object.values(oneofs) };
    }
    /**
     * Is the argument a valid message as specified by the
     * reflection information?
     *
     * Checks all field types recursively. The `depth`
     * specifies how deep into the structure the check will be.
     *
     * With a depth of 0, only the presence of fields
     * is checked.
     *
     * With a depth of 1 or more, the field types are checked.
     *
     * With a depth of 2 or more, the members of map, repeated
     * and message fields are checked.
     *
     * Message fields will be checked recursively with depth - 1.
     *
     * The number of map entries / repeated values being checked
     * is < depth.
     */
    is(message, depth, allowExcessProperties = false) {
        if (depth < 0)
            return true;
        if (message === null || message === undefined || typeof message != 'object')
            return false;
        this.prepare();
        let keys = Object.keys(message), data = this.data;
        // if a required field is missing in arg, this cannot be a T
        if (keys.length < data.req.length || data.req.some(n => !keys.includes(n)))
            return false;
        if (!allowExcessProperties) {
            // if the arg contains a key we dont know, this is not a literal T
            if (keys.some(k => !data.known.includes(k)))
                return false;
        }
        // "With a depth of 0, only the presence and absence of fields is checked."
        // "With a depth of 1 or more, the field types are checked."
        if (depth < 1) {
            return true;
        }
        // check oneof group
        for (const name of data.oneofs) {
            const group = message[name];
            if (!isOneofGroup(group))
                return false;
            if (group.oneofKind === undefined)
                continue;
            const field = this.fields.find(f => f.localName === group.oneofKind);
            if (!field)
                return false; // we found no field, but have a kind, something is wrong
            if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
                return false;
        }
        // check types
        for (const field of this.fields) {
            if (field.oneof !== undefined)
                continue;
            if (!this.field(message[field.localName], field, allowExcessProperties, depth))
                return false;
        }
        return true;
    }
    field(arg, field, allowExcessProperties, depth) {
        let repeated = field.repeat;
        switch (field.kind) {
            case "scalar":
                if (arg === undefined)
                    return field.opt;
                if (repeated)
                    return this.scalars(arg, field.T, depth, field.L);
                return this.scalar(arg, field.T, field.L);
            case "enum":
                if (arg === undefined)
                    return field.opt;
                if (repeated)
                    return this.scalars(arg, ScalarType.INT32, depth);
                return this.scalar(arg, ScalarType.INT32);
            case "message":
                if (arg === undefined)
                    return true;
                if (repeated)
                    return this.messages(arg, field.T(), allowExcessProperties, depth);
                return this.message(arg, field.T(), allowExcessProperties, depth);
            case "map":
                if (typeof arg != 'object' || arg === null)
                    return false;
                if (depth < 2)
                    return true;
                if (!this.mapKeys(arg, field.K, depth))
                    return false;
                switch (field.V.kind) {
                    case "scalar":
                        return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
                    case "enum":
                        return this.scalars(Object.values(arg), ScalarType.INT32, depth);
                    case "message":
                        return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
                }
                break;
        }
        return true;
    }
    message(arg, type, allowExcessProperties, depth) {
        if (allowExcessProperties) {
            return type.isAssignable(arg, depth);
        }
        return type.is(arg, depth);
    }
    messages(arg, type, allowExcessProperties, depth) {
        if (!Array.isArray(arg))
            return false;
        if (depth < 2)
            return true;
        if (allowExcessProperties) {
            for (let i = 0; i < arg.length && i < depth; i++)
                if (!type.isAssignable(arg[i], depth - 1))
                    return false;
        }
        else {
            for (let i = 0; i < arg.length && i < depth; i++)
                if (!type.is(arg[i], depth - 1))
                    return false;
        }
        return true;
    }
    scalar(arg, type, longType) {
        let argType = typeof arg;
        switch (type) {
            case ScalarType.UINT64:
            case ScalarType.FIXED64:
            case ScalarType.INT64:
            case ScalarType.SFIXED64:
            case ScalarType.SINT64:
                switch (longType) {
                    case LongType.BIGINT:
                        return argType == "bigint";
                    case LongType.NUMBER:
                        return argType == "number" && !isNaN(arg);
                    default:
                        return argType == "string";
                }
            case ScalarType.BOOL:
                return argType == 'boolean';
            case ScalarType.STRING:
                return argType == 'string';
            case ScalarType.BYTES:
                return arg instanceof Uint8Array;
            case ScalarType.DOUBLE:
            case ScalarType.FLOAT:
                return argType == 'number' && !isNaN(arg);
            default:
                // case ScalarType.UINT32:
                // case ScalarType.FIXED32:
                // case ScalarType.INT32:
                // case ScalarType.SINT32:
                // case ScalarType.SFIXED32:
                return argType == 'number' && Number.isInteger(arg);
        }
    }
    scalars(arg, type, depth, longType) {
        if (!Array.isArray(arg))
            return false;
        if (depth < 2)
            return true;
        if (Array.isArray(arg))
            for (let i = 0; i < arg.length && i < depth; i++)
                if (!this.scalar(arg[i], type, longType))
                    return false;
        return true;
    }
    mapKeys(map, type, depth) {
        let keys = Object.keys(map);
        switch (type) {
            case ScalarType.INT32:
            case ScalarType.FIXED32:
            case ScalarType.SFIXED32:
            case ScalarType.SINT32:
            case ScalarType.UINT32:
                return this.scalars(keys.slice(0, depth).map(k => parseInt(k)), type, depth);
            case ScalarType.BOOL:
                return this.scalars(keys.slice(0, depth).map(k => k == 'true' ? true : k == 'false' ? false : k), type, depth);
            default:
                return this.scalars(keys, type, depth, LongType.STRING);
        }
    }
}

/**
 * Utility method to convert a PbLong or PbUlong to a JavaScript
 * representation during runtime.
 *
 * Works with generated field information, `undefined` is equivalent
 * to `STRING`.
 */
function reflectionLongConvert(long, type) {
    switch (type) {
        case LongType.BIGINT:
            return long.toBigInt();
        case LongType.NUMBER:
            return long.toNumber();
        default:
            // case undefined:
            // case LongType.STRING:
            return long.toString();
    }
}

/**
 * Reads proto3 messages in canonical JSON format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/proto3#json
 */
class ReflectionJsonReader {
    constructor(info) {
        this.info = info;
    }
    prepare() {
        var _a;
        if (this.fMap === undefined) {
            this.fMap = {};
            const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
            for (const field of fieldsInput) {
                this.fMap[field.name] = field;
                this.fMap[field.jsonName] = field;
                this.fMap[field.localName] = field;
            }
        }
    }
    // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
    assert(condition, fieldName, jsonValue) {
        if (!condition) {
            let what = typeofJsonValue(jsonValue);
            if (what == "number" || what == "boolean")
                what = jsonValue.toString();
            throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
        }
    }
    /**
     * Reads a message from canonical JSON format into the target message.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    read(input, message, options) {
        this.prepare();
        const oneofsHandled = [];
        for (const [jsonKey, jsonValue] of Object.entries(input)) {
            const field = this.fMap[jsonKey];
            if (!field) {
                if (!options.ignoreUnknownFields)
                    throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
                continue;
            }
            const localName = field.localName;
            // handle oneof ADT
            let target; // this will be the target for the field value, whether it is member of a oneof or not
            if (field.oneof) {
                if (jsonValue === null && (field.kind !== 'enum' || field.T()[0] !== 'google.protobuf.NullValue')) {
                    continue;
                }
                // since json objects are unordered by specification, it is not possible to take the last of multiple oneofs
                if (oneofsHandled.includes(field.oneof))
                    throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
                oneofsHandled.push(field.oneof);
                target = message[field.oneof] = {
                    oneofKind: localName
                };
            }
            else {
                target = message;
            }
            // we have handled oneof above. we just have read the value into `target`.
            if (field.kind == 'map') {
                if (jsonValue === null) {
                    continue;
                }
                // check input
                this.assert(isJsonObject(jsonValue), field.name, jsonValue);
                // our target to put map entries into
                const fieldObj = target[localName];
                // read entries
                for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
                    this.assert(jsonObjValue !== null, field.name + " map value", null);
                    // read value
                    let val;
                    switch (field.V.kind) {
                        case "message":
                            val = field.V.T().internalJsonRead(jsonObjValue, options);
                            break;
                        case "enum":
                            val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
                            if (val === false)
                                continue;
                            break;
                        case "scalar":
                            val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
                            break;
                    }
                    this.assert(val !== undefined, field.name + " map value", jsonObjValue);
                    // read key
                    let key = jsonObjKey;
                    if (field.K == ScalarType.BOOL)
                        key = key == "true" ? true : key == "false" ? false : key;
                    key = this.scalar(key, field.K, LongType.STRING, field.name).toString();
                    fieldObj[key] = val;
                }
            }
            else if (field.repeat) {
                if (jsonValue === null)
                    continue;
                // check input
                this.assert(Array.isArray(jsonValue), field.name, jsonValue);
                // our target to put array entries into
                const fieldArr = target[localName];
                // read array entries
                for (const jsonItem of jsonValue) {
                    this.assert(jsonItem !== null, field.name, null);
                    let val;
                    switch (field.kind) {
                        case "message":
                            val = field.T().internalJsonRead(jsonItem, options);
                            break;
                        case "enum":
                            val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
                            if (val === false)
                                continue;
                            break;
                        case "scalar":
                            val = this.scalar(jsonItem, field.T, field.L, field.name);
                            break;
                    }
                    this.assert(val !== undefined, field.name, jsonValue);
                    fieldArr.push(val);
                }
            }
            else {
                switch (field.kind) {
                    case "message":
                        if (jsonValue === null && field.T().typeName != 'google.protobuf.Value') {
                            this.assert(field.oneof === undefined, field.name + " (oneof member)", null);
                            continue;
                        }
                        target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
                        break;
                    case "enum":
                        let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
                        if (val === false)
                            continue;
                        target[localName] = val;
                        break;
                    case "scalar":
                        target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
                        break;
                }
            }
        }
    }
    /**
     * Returns `false` for unrecognized string representations.
     *
     * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
     */
    enum(type, json, fieldName, ignoreUnknownFields) {
        if (type[0] == 'google.protobuf.NullValue')
            assert(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
        if (json === null)
            // we require 0 to be default value for all enums
            return 0;
        switch (typeof json) {
            case "number":
                assert(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
                return json;
            case "string":
                let localEnumName = json;
                if (type[2] && json.substring(0, type[2].length) === type[2])
                    // lookup without the shared prefix
                    localEnumName = json.substring(type[2].length);
                let enumNumber = type[1][localEnumName];
                if (typeof enumNumber === 'undefined' && ignoreUnknownFields) {
                    return false;
                }
                assert(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
                return enumNumber;
        }
        assert(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
    }
    scalar(json, type, longType, fieldName) {
        let e;
        try {
            switch (type) {
                // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
                // Either numbers or strings are accepted. Exponent notation is also accepted.
                case ScalarType.DOUBLE:
                case ScalarType.FLOAT:
                    if (json === null)
                        return .0;
                    if (json === "NaN")
                        return Number.NaN;
                    if (json === "Infinity")
                        return Number.POSITIVE_INFINITY;
                    if (json === "-Infinity")
                        return Number.NEGATIVE_INFINITY;
                    if (json === "") {
                        e = "empty string";
                        break;
                    }
                    if (typeof json == "string" && json.trim().length !== json.length) {
                        e = "extra whitespace";
                        break;
                    }
                    if (typeof json != "string" && typeof json != "number") {
                        break;
                    }
                    let float = Number(json);
                    if (Number.isNaN(float)) {
                        e = "not a number";
                        break;
                    }
                    if (!Number.isFinite(float)) {
                        // infinity and -infinity are handled by string representation above, so this is an error
                        e = "too large or small";
                        break;
                    }
                    if (type == ScalarType.FLOAT)
                        assertFloat32(float);
                    return float;
                // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
                case ScalarType.INT32:
                case ScalarType.FIXED32:
                case ScalarType.SFIXED32:
                case ScalarType.SINT32:
                case ScalarType.UINT32:
                    if (json === null)
                        return 0;
                    let int32;
                    if (typeof json == "number")
                        int32 = json;
                    else if (json === "")
                        e = "empty string";
                    else if (typeof json == "string") {
                        if (json.trim().length !== json.length)
                            e = "extra whitespace";
                        else
                            int32 = Number(json);
                    }
                    if (int32 === undefined)
                        break;
                    if (type == ScalarType.UINT32)
                        assertUInt32(int32);
                    else
                        assertInt32(int32);
                    return int32;
                // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
                case ScalarType.INT64:
                case ScalarType.SFIXED64:
                case ScalarType.SINT64:
                    if (json === null)
                        return reflectionLongConvert(PbLong.ZERO, longType);
                    if (typeof json != "number" && typeof json != "string")
                        break;
                    return reflectionLongConvert(PbLong.from(json), longType);
                case ScalarType.FIXED64:
                case ScalarType.UINT64:
                    if (json === null)
                        return reflectionLongConvert(PbULong.ZERO, longType);
                    if (typeof json != "number" && typeof json != "string")
                        break;
                    return reflectionLongConvert(PbULong.from(json), longType);
                // bool:
                case ScalarType.BOOL:
                    if (json === null)
                        return false;
                    if (typeof json !== "boolean")
                        break;
                    return json;
                // string:
                case ScalarType.STRING:
                    if (json === null)
                        return "";
                    if (typeof json !== "string") {
                        e = "extra whitespace";
                        break;
                    }
                    try {
                        encodeURIComponent(json);
                    }
                    catch (e) {
                        e = "invalid UTF8";
                        break;
                    }
                    return json;
                // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
                // Either standard or URL-safe base64 encoding with/without paddings are accepted.
                case ScalarType.BYTES:
                    if (json === null || json === "")
                        return new Uint8Array(0);
                    if (typeof json !== 'string')
                        break;
                    return base64decode(json);
            }
        }
        catch (error) {
            e = error.message;
        }
        this.assert(false, fieldName + (e ? " - " + e : ""), json);
    }
}

/**
 * Writes proto3 messages in canonical JSON format using reflection
 * information.
 *
 * https://developers.google.com/protocol-buffers/docs/proto3#json
 */
class ReflectionJsonWriter {
    constructor(info) {
        var _a;
        this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
    }
    /**
     * Converts the message to a JSON object, based on the field descriptors.
     */
    write(message, options) {
        const json = {}, source = message;
        for (const field of this.fields) {
            // field is not part of a oneof, simply write as is
            if (!field.oneof) {
                let jsonValue = this.field(field, source[field.localName], options);
                if (jsonValue !== undefined)
                    json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
                continue;
            }
            // field is part of a oneof
            const group = source[field.oneof];
            if (group.oneofKind !== field.localName)
                continue; // not selected, skip
            const opt = field.kind == 'scalar' || field.kind == 'enum'
                ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
            let jsonValue = this.field(field, group[field.localName], opt);
            assert(jsonValue !== undefined);
            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
        }
        return json;
    }
    field(field, value, options) {
        let jsonValue = undefined;
        if (field.kind == 'map') {
            assert(typeof value == "object" && value !== null);
            const jsonObj = {};
            switch (field.V.kind) {
                case "scalar":
                    for (const [entryKey, entryValue] of Object.entries(value)) {
                        const val = this.scalar(field.V.T, entryValue, field.name, false, true);
                        assert(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
                case "message":
                    const messageType = field.V.T();
                    for (const [entryKey, entryValue] of Object.entries(value)) {
                        const val = this.message(messageType, entryValue, field.name, options);
                        assert(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
                case "enum":
                    const enumInfo = field.V.T();
                    for (const [entryKey, entryValue] of Object.entries(value)) {
                        assert(entryValue === undefined || typeof entryValue == 'number');
                        const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
                        assert(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
            }
            if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
                jsonValue = jsonObj;
        }
        else if (field.repeat) {
            assert(Array.isArray(value));
            const jsonArr = [];
            switch (field.kind) {
                case "scalar":
                    for (let i = 0; i < value.length; i++) {
                        const val = this.scalar(field.T, value[i], field.name, field.opt, true);
                        assert(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
                case "enum":
                    const enumInfo = field.T();
                    for (let i = 0; i < value.length; i++) {
                        assert(value[i] === undefined || typeof value[i] == 'number');
                        const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options.enumAsInteger);
                        assert(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
                case "message":
                    const messageType = field.T();
                    for (let i = 0; i < value.length; i++) {
                        const val = this.message(messageType, value[i], field.name, options);
                        assert(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
            }
            // add converted array to json output
            if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
                jsonValue = jsonArr;
        }
        else {
            switch (field.kind) {
                case "scalar":
                    jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
                    break;
                case "enum":
                    jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
                    break;
                case "message":
                    jsonValue = this.message(field.T(), value, field.name, options);
                    break;
            }
        }
        return jsonValue;
    }
    /**
     * Returns `null` as the default for google.protobuf.NullValue.
     */
    enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
        if (type[0] == 'google.protobuf.NullValue')
            return !emitDefaultValues && !optional ? undefined : null;
        if (value === undefined) {
            assert(optional);
            return undefined;
        }
        if (value === 0 && !emitDefaultValues && !optional)
            // we require 0 to be default value for all enums
            return undefined;
        assert(typeof value == 'number');
        assert(Number.isInteger(value));
        if (enumAsInteger || !type[1].hasOwnProperty(value))
            // if we don't now the enum value, just return the number
            return value;
        if (type[2])
            // restore the dropped prefix
            return type[2] + type[1][value];
        return type[1][value];
    }
    message(type, value, fieldName, options) {
        if (value === undefined)
            return options.emitDefaultValues ? null : undefined;
        return type.internalJsonWrite(value, options);
    }
    scalar(type, value, fieldName, optional, emitDefaultValues) {
        if (value === undefined) {
            assert(optional);
            return undefined;
        }
        const ed = emitDefaultValues || optional;
        // noinspection FallThroughInSwitchStatementJS
        switch (type) {
            // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
            case ScalarType.INT32:
            case ScalarType.SFIXED32:
            case ScalarType.SINT32:
                if (value === 0)
                    return ed ? 0 : undefined;
                assertInt32(value);
                return value;
            case ScalarType.FIXED32:
            case ScalarType.UINT32:
                if (value === 0)
                    return ed ? 0 : undefined;
                assertUInt32(value);
                return value;
            // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
            // Either numbers or strings are accepted. Exponent notation is also accepted.
            case ScalarType.FLOAT:
                assertFloat32(value);
            case ScalarType.DOUBLE:
                if (value === 0)
                    return ed ? 0 : undefined;
                assert(typeof value == 'number');
                if (Number.isNaN(value))
                    return 'NaN';
                if (value === Number.POSITIVE_INFINITY)
                    return 'Infinity';
                if (value === Number.NEGATIVE_INFINITY)
                    return '-Infinity';
                return value;
            // string:
            case ScalarType.STRING:
                if (value === "")
                    return ed ? '' : undefined;
                assert(typeof value == 'string');
                return value;
            // bool:
            case ScalarType.BOOL:
                if (value === false)
                    return ed ? false : undefined;
                assert(typeof value == 'boolean');
                return value;
            // JSON value will be a decimal string. Either numbers or strings are accepted.
            case ScalarType.UINT64:
            case ScalarType.FIXED64:
                assert(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');
                let ulong = PbULong.from(value);
                if (ulong.isZero() && !ed)
                    return undefined;
                return ulong.toString();
            // JSON value will be a decimal string. Either numbers or strings are accepted.
            case ScalarType.INT64:
            case ScalarType.SFIXED64:
            case ScalarType.SINT64:
                assert(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');
                let long = PbLong.from(value);
                if (long.isZero() && !ed)
                    return undefined;
                return long.toString();
            // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
            // Either standard or URL-safe base64 encoding with/without paddings are accepted.
            case ScalarType.BYTES:
                assert(value instanceof Uint8Array);
                if (!value.byteLength)
                    return ed ? "" : undefined;
                return base64encode(value);
        }
    }
}

/**
 * Creates the default value for a scalar type.
 */
function reflectionScalarDefault(type, longType = LongType.STRING) {
    switch (type) {
        case ScalarType.BOOL:
            return false;
        case ScalarType.UINT64:
        case ScalarType.FIXED64:
            return reflectionLongConvert(PbULong.ZERO, longType);
        case ScalarType.INT64:
        case ScalarType.SFIXED64:
        case ScalarType.SINT64:
            return reflectionLongConvert(PbLong.ZERO, longType);
        case ScalarType.DOUBLE:
        case ScalarType.FLOAT:
            return 0.0;
        case ScalarType.BYTES:
            return new Uint8Array(0);
        case ScalarType.STRING:
            return "";
        default:
            // case ScalarType.INT32:
            // case ScalarType.UINT32:
            // case ScalarType.SINT32:
            // case ScalarType.FIXED32:
            // case ScalarType.SFIXED32:
            return 0;
    }
}

/**
 * Reads proto3 messages in binary format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/encoding
 */
class ReflectionBinaryReader {
    constructor(info) {
        this.info = info;
    }
    prepare() {
        var _a;
        if (!this.fieldNoToField) {
            const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
            this.fieldNoToField = new Map(fieldsInput.map(field => [field.no, field]));
        }
    }
    /**
     * Reads a message from binary format into the target message.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    read(reader, message, options, length) {
        this.prepare();
        const end = length === undefined ? reader.len : reader.pos + length;
        while (reader.pos < end) {
            // read the tag and find the field
            const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
            if (!field) {
                let u = options.readUnknownField;
                if (u == "throw")
                    throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
                let d = reader.skip(wireType);
                if (u !== false)
                    (u === true ? UnknownFieldHandler.onRead : u)(this.info.typeName, message, fieldNo, wireType, d);
                continue;
            }
            // target object for the field we are reading
            let target = message, repeated = field.repeat, localName = field.localName;
            // if field is member of oneof ADT, use ADT as target
            if (field.oneof) {
                target = target[field.oneof];
                // if other oneof member selected, set new ADT
                if (target.oneofKind !== localName)
                    target = message[field.oneof] = {
                        oneofKind: localName
                    };
            }
            // we have handled oneof above, we just have read the value into `target[localName]`
            switch (field.kind) {
                case "scalar":
                case "enum":
                    let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
                    let L = field.kind == "scalar" ? field.L : undefined;
                    if (repeated) {
                        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                        if (wireType == WireType.LengthDelimited && T != ScalarType.STRING && T != ScalarType.BYTES) {
                            let e = reader.uint32() + reader.pos;
                            while (reader.pos < e)
                                arr.push(this.scalar(reader, T, L));
                        }
                        else
                            arr.push(this.scalar(reader, T, L));
                    }
                    else
                        target[localName] = this.scalar(reader, T, L);
                    break;
                case "message":
                    if (repeated) {
                        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                        let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
                        arr.push(msg);
                    }
                    else
                        target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
                    break;
                case "map":
                    let [mapKey, mapVal] = this.mapEntry(field, reader, options);
                    // safe to assume presence of map object, oneof cannot contain repeated values
                    target[localName][mapKey] = mapVal;
                    break;
            }
        }
    }
    /**
     * Read a map field, expecting key field = 1, value field = 2
     */
    mapEntry(field, reader, options) {
        let length = reader.uint32();
        let end = reader.pos + length;
        let key = undefined; // javascript only allows number or string for object properties
        let val = undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    if (field.K == ScalarType.BOOL)
                        key = reader.bool().toString();
                    else
                        // long types are read as string, number types are okay as number
                        key = this.scalar(reader, field.K, LongType.STRING);
                    break;
                case 2:
                    switch (field.V.kind) {
                        case "scalar":
                            val = this.scalar(reader, field.V.T, field.V.L);
                            break;
                        case "enum":
                            val = reader.int32();
                            break;
                        case "message":
                            val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
                            break;
                    }
                    break;
                default:
                    throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
            }
        }
        if (key === undefined) {
            let keyRaw = reflectionScalarDefault(field.K);
            key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;
        }
        if (val === undefined)
            switch (field.V.kind) {
                case "scalar":
                    val = reflectionScalarDefault(field.V.T, field.V.L);
                    break;
                case "enum":
                    val = 0;
                    break;
                case "message":
                    val = field.V.T().create();
                    break;
            }
        return [key, val];
    }
    scalar(reader, type, longType) {
        switch (type) {
            case ScalarType.INT32:
                return reader.int32();
            case ScalarType.STRING:
                return reader.string();
            case ScalarType.BOOL:
                return reader.bool();
            case ScalarType.DOUBLE:
                return reader.double();
            case ScalarType.FLOAT:
                return reader.float();
            case ScalarType.INT64:
                return reflectionLongConvert(reader.int64(), longType);
            case ScalarType.UINT64:
                return reflectionLongConvert(reader.uint64(), longType);
            case ScalarType.FIXED64:
                return reflectionLongConvert(reader.fixed64(), longType);
            case ScalarType.FIXED32:
                return reader.fixed32();
            case ScalarType.BYTES:
                return reader.bytes();
            case ScalarType.UINT32:
                return reader.uint32();
            case ScalarType.SFIXED32:
                return reader.sfixed32();
            case ScalarType.SFIXED64:
                return reflectionLongConvert(reader.sfixed64(), longType);
            case ScalarType.SINT32:
                return reader.sint32();
            case ScalarType.SINT64:
                return reflectionLongConvert(reader.sint64(), longType);
        }
    }
}

/**
 * Writes proto3 messages in binary format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/encoding
 */
class ReflectionBinaryWriter {
    constructor(info) {
        this.info = info;
    }
    prepare() {
        if (!this.fields) {
            const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
            this.fields = fieldsInput.sort((a, b) => a.no - b.no);
        }
    }
    /**
     * Writes the message to binary format.
     */
    write(message, writer, options) {
        this.prepare();
        for (const field of this.fields) {
            let value, // this will be our field value, whether it is member of a oneof or not
            emitDefault, // whether we emit the default value (only true for oneof members)
            repeated = field.repeat, localName = field.localName;
            // handle oneof ADT
            if (field.oneof) {
                const group = message[field.oneof];
                if (group.oneofKind !== localName)
                    continue; // if field is not selected, skip
                value = group[localName];
                emitDefault = true;
            }
            else {
                value = message[localName];
                emitDefault = false;
            }
            // we have handled oneof above. we just have to honor `emitDefault`.
            switch (field.kind) {
                case "scalar":
                case "enum":
                    let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
                    if (repeated) {
                        assert(Array.isArray(value));
                        if (repeated == RepeatType.PACKED)
                            this.packed(writer, T, field.no, value);
                        else
                            for (const item of value)
                                this.scalar(writer, T, field.no, item, true);
                    }
                    else if (value === undefined)
                        assert(field.opt);
                    else
                        this.scalar(writer, T, field.no, value, emitDefault || field.opt);
                    break;
                case "message":
                    if (repeated) {
                        assert(Array.isArray(value));
                        for (const item of value)
                            this.message(writer, options, field.T(), field.no, item);
                    }
                    else {
                        this.message(writer, options, field.T(), field.no, value);
                    }
                    break;
                case "map":
                    assert(typeof value == 'object' && value !== null);
                    for (const [key, val] of Object.entries(value))
                        this.mapEntry(writer, options, field, key, val);
                    break;
            }
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.info.typeName, message, writer);
    }
    mapEntry(writer, options, field, key, value) {
        writer.tag(field.no, WireType.LengthDelimited);
        writer.fork();
        // javascript only allows number or string for object properties
        // we convert from our representation to the protobuf type
        let keyValue = key;
        switch (field.K) {
            case ScalarType.INT32:
            case ScalarType.FIXED32:
            case ScalarType.UINT32:
            case ScalarType.SFIXED32:
            case ScalarType.SINT32:
                keyValue = Number.parseInt(key);
                break;
            case ScalarType.BOOL:
                assert(key == 'true' || key == 'false');
                keyValue = key == 'true';
                break;
        }
        // write key, expecting key field number = 1
        this.scalar(writer, field.K, 1, keyValue, true);
        // write value, expecting value field number = 2
        switch (field.V.kind) {
            case 'scalar':
                this.scalar(writer, field.V.T, 2, value, true);
                break;
            case 'enum':
                this.scalar(writer, ScalarType.INT32, 2, value, true);
                break;
            case 'message':
                this.message(writer, options, field.V.T(), 2, value);
                break;
        }
        writer.join();
    }
    message(writer, options, handler, fieldNo, value) {
        if (value === undefined)
            return;
        handler.internalBinaryWrite(value, writer.tag(fieldNo, WireType.LengthDelimited).fork(), options);
        writer.join();
    }
    /**
     * Write a single scalar value.
     */
    scalar(writer, type, fieldNo, value, emitDefault) {
        let [wireType, method, isDefault] = this.scalarInfo(type, value);
        if (!isDefault || emitDefault) {
            writer.tag(fieldNo, wireType);
            writer[method](value);
        }
    }
    /**
     * Write an array of scalar values in packed format.
     */
    packed(writer, type, fieldNo, value) {
        if (!value.length)
            return;
        assert(type !== ScalarType.BYTES && type !== ScalarType.STRING);
        // write tag
        writer.tag(fieldNo, WireType.LengthDelimited);
        // begin length-delimited
        writer.fork();
        // write values without tags
        let [, method,] = this.scalarInfo(type);
        for (let i = 0; i < value.length; i++)
            writer[method](value[i]);
        // end length delimited
        writer.join();
    }
    /**
     * Get information for writing a scalar value.
     *
     * Returns tuple:
     * [0]: appropriate WireType
     * [1]: name of the appropriate method of IBinaryWriter
     * [2]: whether the given value is a default value
     *
     * If argument `value` is omitted, [2] is always false.
     */
    scalarInfo(type, value) {
        let t = WireType.Varint;
        let m;
        let i = value === undefined;
        let d = value === 0;
        switch (type) {
            case ScalarType.INT32:
                m = "int32";
                break;
            case ScalarType.STRING:
                d = i || !value.length;
                t = WireType.LengthDelimited;
                m = "string";
                break;
            case ScalarType.BOOL:
                d = value === false;
                m = "bool";
                break;
            case ScalarType.UINT32:
                m = "uint32";
                break;
            case ScalarType.DOUBLE:
                t = WireType.Bit64;
                m = "double";
                break;
            case ScalarType.FLOAT:
                t = WireType.Bit32;
                m = "float";
                break;
            case ScalarType.INT64:
                d = i || PbLong.from(value).isZero();
                m = "int64";
                break;
            case ScalarType.UINT64:
                d = i || PbULong.from(value).isZero();
                m = "uint64";
                break;
            case ScalarType.FIXED64:
                d = i || PbULong.from(value).isZero();
                t = WireType.Bit64;
                m = "fixed64";
                break;
            case ScalarType.BYTES:
                d = i || !value.byteLength;
                t = WireType.LengthDelimited;
                m = "bytes";
                break;
            case ScalarType.FIXED32:
                t = WireType.Bit32;
                m = "fixed32";
                break;
            case ScalarType.SFIXED32:
                t = WireType.Bit32;
                m = "sfixed32";
                break;
            case ScalarType.SFIXED64:
                d = i || PbLong.from(value).isZero();
                t = WireType.Bit64;
                m = "sfixed64";
                break;
            case ScalarType.SINT32:
                m = "sint32";
                break;
            case ScalarType.SINT64:
                d = i || PbLong.from(value).isZero();
                m = "sint64";
                break;
        }
        return [t, m, i || d];
    }
}

/**
 * Creates an instance of the generic message, using the field
 * information.
 */
function reflectionCreate(type) {
    /**
     * This ternary can be removed in the next major version.
     * The `Object.create()` code path utilizes a new `messagePrototype`
     * property on the `IMessageType` which has this same `MESSAGE_TYPE`
     * non-enumerable property on it. Doing it this way means that we only
     * pay the cost of `Object.defineProperty()` once per `IMessageType`
     * class of once per "instance". The falsy code path is only provided
     * for backwards compatibility in cases where the runtime library is
     * updated without also updating the generated code.
     */
    const msg = type.messagePrototype
        ? Object.create(type.messagePrototype)
        : Object.defineProperty({}, MESSAGE_TYPE, { value: type });
    for (let field of type.fields) {
        let name = field.localName;
        if (field.opt)
            continue;
        if (field.oneof)
            msg[field.oneof] = { oneofKind: undefined };
        else if (field.repeat)
            msg[name] = [];
        else
            switch (field.kind) {
                case "scalar":
                    msg[name] = reflectionScalarDefault(field.T, field.L);
                    break;
                case "enum":
                    // we require 0 to be default value for all enums
                    msg[name] = 0;
                    break;
                case "map":
                    msg[name] = {};
                    break;
            }
    }
    return msg;
}

/**
 * Copy partial data into the target message.
 *
 * If a singular scalar or enum field is present in the source, it
 * replaces the field in the target.
 *
 * If a singular message field is present in the source, it is merged
 * with the target field by calling mergePartial() of the responsible
 * message type.
 *
 * If a repeated field is present in the source, its values replace
 * all values in the target array, removing extraneous values.
 * Repeated message fields are copied, not merged.
 *
 * If a map field is present in the source, entries are added to the
 * target map, replacing entries with the same key. Entries that only
 * exist in the target remain. Entries with message values are copied,
 * not merged.
 *
 * Note that this function differs from protobuf merge semantics,
 * which appends repeated fields.
 */
function reflectionMergePartial(info, target, source) {
    let fieldValue, // the field value we are working with
    input = source, output; // where we want our field value to go
    for (let field of info.fields) {
        let name = field.localName;
        if (field.oneof) {
            const group = input[field.oneof]; // this is the oneof`s group in the source
            if ((group === null || group === void 0 ? void 0 : group.oneofKind) == undefined) { // the user is free to omit
                continue; // we skip this field, and all other members too
            }
            fieldValue = group[name]; // our value comes from the the oneof group of the source
            output = target[field.oneof]; // and our output is the oneof group of the target
            output.oneofKind = group.oneofKind; // always update discriminator
            if (fieldValue == undefined) {
                delete output[name]; // remove any existing value
                continue; // skip further work on field
            }
        }
        else {
            fieldValue = input[name]; // we are using the source directly
            output = target; // we want our field value to go directly into the target
            if (fieldValue == undefined) {
                continue; // skip further work on field, existing value is used as is
            }
        }
        if (field.repeat)
            output[name].length = fieldValue.length; // resize target array to match source array
        // now we just work with `fieldValue` and `output` to merge the value
        switch (field.kind) {
            case "scalar":
            case "enum":
                if (field.repeat)
                    for (let i = 0; i < fieldValue.length; i++)
                        output[name][i] = fieldValue[i]; // not a reference type
                else
                    output[name] = fieldValue; // not a reference type
                break;
            case "message":
                let T = field.T();
                if (field.repeat)
                    for (let i = 0; i < fieldValue.length; i++)
                        output[name][i] = T.create(fieldValue[i]);
                else if (output[name] === undefined)
                    output[name] = T.create(fieldValue); // nothing to merge with
                else
                    T.mergePartial(output[name], fieldValue);
                break;
            case "map":
                // Map and repeated fields are simply overwritten, not appended or merged
                switch (field.V.kind) {
                    case "scalar":
                    case "enum":
                        Object.assign(output[name], fieldValue); // elements are not reference types
                        break;
                    case "message":
                        let T = field.V.T();
                        for (let k of Object.keys(fieldValue))
                            output[name][k] = T.create(fieldValue[k]);
                        break;
                }
                break;
        }
    }
}

/**
 * Determines whether two message of the same type have the same field values.
 * Checks for deep equality, traversing repeated fields, oneof groups, maps
 * and messages recursively.
 * Will also return true if both messages are `undefined`.
 */
function reflectionEquals(info, a, b) {
    if (a === b)
        return true;
    if (!a || !b)
        return false;
    for (let field of info.fields) {
        let localName = field.localName;
        let val_a = field.oneof ? a[field.oneof][localName] : a[localName];
        let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
        switch (field.kind) {
            case "enum":
            case "scalar":
                let t = field.kind == "enum" ? ScalarType.INT32 : field.T;
                if (!(field.repeat
                    ? repeatedPrimitiveEq(t, val_a, val_b)
                    : primitiveEq(t, val_a, val_b)))
                    return false;
                break;
            case "map":
                if (!(field.V.kind == "message"
                    ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b))
                    : repeatedPrimitiveEq(field.V.kind == "enum" ? ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
                    return false;
                break;
            case "message":
                let T = field.T();
                if (!(field.repeat
                    ? repeatedMsgEq(T, val_a, val_b)
                    : T.equals(val_a, val_b)))
                    return false;
                break;
        }
    }
    return true;
}
const objectValues = Object.values;
function primitiveEq(type, a, b) {
    if (a === b)
        return true;
    if (type !== ScalarType.BYTES)
        return false;
    let ba = a;
    let bb = b;
    if (ba.length !== bb.length)
        return false;
    for (let i = 0; i < ba.length; i++)
        if (ba[i] != bb[i])
            return false;
    return true;
}
function repeatedPrimitiveEq(type, a, b) {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!primitiveEq(type, a[i], b[i]))
            return false;
    return true;
}
function repeatedMsgEq(type, a, b) {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!type.equals(a[i], b[i]))
            return false;
    return true;
}

const baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
/**
 * This standard message type provides reflection-based
 * operations to work with a message.
 */
class MessageType {
    constructor(name, fields, options) {
        this.defaultCheckDepth = 16;
        this.typeName = name;
        this.fields = fields.map(normalizeFieldInfo);
        this.options = options !== null && options !== void 0 ? options : {};
        this.messagePrototype = Object.create(null, Object.assign(Object.assign({}, baseDescriptors), { [MESSAGE_TYPE]: { value: this } }));
        this.refTypeCheck = new ReflectionTypeCheck(this);
        this.refJsonReader = new ReflectionJsonReader(this);
        this.refJsonWriter = new ReflectionJsonWriter(this);
        this.refBinReader = new ReflectionBinaryReader(this);
        this.refBinWriter = new ReflectionBinaryWriter(this);
    }
    create(value) {
        let message = reflectionCreate(this);
        if (value !== undefined) {
            reflectionMergePartial(this, message, value);
        }
        return message;
    }
    /**
     * Clone the message.
     *
     * Unknown fields are discarded.
     */
    clone(message) {
        let copy = this.create();
        reflectionMergePartial(this, copy, message);
        return copy;
    }
    /**
     * Determines whether two message of the same type have the same field values.
     * Checks for deep equality, traversing repeated fields, oneof groups, maps
     * and messages recursively.
     * Will also return true if both messages are `undefined`.
     */
    equals(a, b) {
        return reflectionEquals(this, a, b);
    }
    /**
     * Is the given value assignable to our message type
     * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
     */
    is(arg, depth = this.defaultCheckDepth) {
        return this.refTypeCheck.is(arg, depth, false);
    }
    /**
     * Is the given value assignable to our message type,
     * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
     */
    isAssignable(arg, depth = this.defaultCheckDepth) {
        return this.refTypeCheck.is(arg, depth, true);
    }
    /**
     * Copy partial data into the target message.
     */
    mergePartial(target, source) {
        reflectionMergePartial(this, target, source);
    }
    /**
     * Create a new message from binary format.
     */
    fromBinary(data, options) {
        let opt = binaryReadOptions(options);
        return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
    }
    /**
     * Read a new message from a JSON value.
     */
    fromJson(json, options) {
        return this.internalJsonRead(json, jsonReadOptions(options));
    }
    /**
     * Read a new message from a JSON string.
     * This is equivalent to `T.fromJson(JSON.parse(json))`.
     */
    fromJsonString(json, options) {
        let value = JSON.parse(json);
        return this.fromJson(value, options);
    }
    /**
     * Write the message to canonical JSON value.
     */
    toJson(message, options) {
        return this.internalJsonWrite(message, jsonWriteOptions(options));
    }
    /**
     * Convert the message to canonical JSON string.
     * This is equivalent to `JSON.stringify(T.toJson(t))`
     */
    toJsonString(message, options) {
        var _a;
        let value = this.toJson(message, options);
        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
    }
    /**
     * Write the message to binary format.
     */
    toBinary(message, options) {
        let opt = binaryWriteOptions(options);
        return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
    }
    /**
     * This is an internal method. If you just want to read a message from
     * JSON, use `fromJson()` or `fromJsonString()`.
     *
     * Reads JSON value and merges the fields into the target
     * according to protobuf rules. If the target is omitted,
     * a new instance is created first.
     */
    internalJsonRead(json, options, target) {
        if (json !== null && typeof json == "object" && !Array.isArray(json)) {
            let message = target !== null && target !== void 0 ? target : this.create();
            this.refJsonReader.read(json, message, options);
            return message;
        }
        throw new Error(`Unable to parse message ${this.typeName} from JSON ${typeofJsonValue(json)}.`);
    }
    /**
     * This is an internal method. If you just want to write a message
     * to JSON, use `toJson()` or `toJsonString().
     *
     * Writes JSON value and returns it.
     */
    internalJsonWrite(message, options) {
        return this.refJsonWriter.write(message, options);
    }
    /**
     * This is an internal method. If you just want to write a message
     * in binary format, use `toBinary()`.
     *
     * Serializes the message in binary format and appends it to the given
     * writer. Returns passed writer.
     */
    internalBinaryWrite(message, writer, options) {
        this.refBinWriter.write(message, writer, options);
        return writer;
    }
    /**
     * This is an internal method. If you just want to read a message from
     * binary data, use `fromBinary()`.
     *
     * Reads data from binary format and merges the fields into
     * the target according to protobuf rules. If the target is
     * omitted, a new instance is created first.
     */
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create();
        this.refBinReader.read(reader, message, options, length);
        return message;
    }
}

function ProtoField(no, type, optional, repeat) {
  if (typeof type === "function") {
    return { kind: "message", no, type, optional: optional ?? false, repeat: repeat ?? false };
  } else {
    return { kind: "scalar", no, type, optional: optional ?? false, repeat: repeat ?? false };
  }
}
class NapProtoRealMsg {
  static {
    this.cache = /* @__PURE__ */ new WeakMap();
  }
  constructor(fields) {
    this._field = Object.keys(fields).map((key) => {
      const field = fields[key];
      if (field.kind === "scalar") {
        const repeatType = field.repeat ? [ScalarType.STRING, ScalarType.BYTES].includes(field.type) ? RepeatType.UNPACKED : RepeatType.PACKED : RepeatType.NO;
        return {
          no: field.no,
          name: key,
          kind: "scalar",
          T: field.type,
          opt: field.optional,
          repeat: repeatType
        };
      } else if (field.kind === "message") {
        return {
          no: field.no,
          name: key,
          kind: "message",
          repeat: field.repeat ? RepeatType.PACKED : RepeatType.NO,
          T: () => NapProtoRealMsg.getInstance(field.type())._proto_msg
        };
      }
    });
    this._proto_msg = new MessageType("nya", this._field);
  }
  static getInstance(fields) {
    let instance = this.cache.get(fields);
    if (!instance) {
      instance = new NapProtoRealMsg(fields);
      this.cache.set(fields, instance);
    }
    return instance;
  }
  encode(data) {
    return this._proto_msg.toBinary(this._proto_msg.create(data));
  }
  decode(data) {
    return this._proto_msg.fromBinary(data);
  }
}
class NapProtoMsg {
  constructor(fields) {
    this.realMsg = NapProtoRealMsg.getInstance(fields);
  }
  encode(data) {
    return this.realMsg.encode(data);
  }
  decode(data) {
    return this.realMsg.decode(data);
  }
}

class Frame {
  static pack(head, body) {
    const totalLength = 9 + head.length + body.length + 1;
    const buffer = Buffer.allocUnsafe(totalLength);
    buffer[0] = 40;
    buffer.writeUInt32BE(head.length, 1);
    buffer.writeUInt32BE(body.length, 5);
    head.copy(buffer, 9);
    body.copy(buffer, 9 + head.length);
    buffer[totalLength - 1] = 41;
    return buffer;
  }
  static unpack(frame) {
    assert$1(frame[0] === 40 && frame[frame.length - 1] === 41, "Invalid frame!");
    const headLen = frame.readUInt32BE(1);
    const bodyLen = frame.readUInt32BE(5);
    return [frame.subarray(9, 9 + headLen), frame.subarray(9 + headLen, 9 + headLen + bodyLen)];
  }
}

const BUF7 = Buffer.alloc(7);
const deltas = [
  2654435769,
  1013904242,
  3668340011,
  2027808484,
  387276957,
  3041712726,
  1401181199,
  4055616968,
  2415085441,
  774553914,
  3428989683,
  1788458156,
  147926629,
  2802362398,
  1161830871,
  3816266640
];
function _toUInt32(num) {
  return num >>> 0;
}
function _encrypt(x, y, k0, k1, k2, k3) {
  for (let i = 0; i < 16; ++i) {
    let aa = (_toUInt32((y << 4 >>> 0) + k0) ^ _toUInt32(y + deltas[i])) >>> 0 ^ _toUInt32(~~(y / 32) + k1);
    aa >>>= 0;
    x = _toUInt32(x + aa);
    let bb = (_toUInt32((x << 4 >>> 0) + k2) ^ _toUInt32(x + deltas[i])) >>> 0 ^ _toUInt32(~~(x / 32) + k3);
    bb >>>= 0;
    y = _toUInt32(y + bb);
  }
  return [x, y];
}
function encrypt(data, key) {
  let n = 6 - data.length >>> 0;
  n = n % 8 + 2;
  const v = Buffer.concat([Buffer.from([n - 2 | 248]), Buffer.allocUnsafe(n), data, BUF7]);
  const k0 = key.readUInt32BE(0);
  const k1 = key.readUInt32BE(4);
  const k2 = key.readUInt32BE(8);
  const k3 = key.readUInt32BE(12);
  let r1 = 0, r2 = 0, t1 = 0, t2 = 0;
  for (let i = 0; i < v.length; i += 8) {
    const a1 = v.readUInt32BE(i);
    const a2 = v.readUInt32BE(i + 4);
    const b1 = a1 ^ r1;
    const b2 = a2 ^ r2;
    const [x, y] = _encrypt(b1 >>> 0, b2 >>> 0, k0, k1, k2, k3);
    r1 = x ^ t1;
    r2 = y ^ t2;
    t1 = b1;
    t2 = b2;
    v.writeInt32BE(r1, i);
    v.writeInt32BE(r2, i + 4);
  }
  return v;
}

({
  comm: ProtoField(1, () => PlatInfo, true),
  selfUin: ProtoField(2, ScalarType.UINT32),
  subCmd: ProtoField(3, ScalarType.UINT32),
  field6: ProtoField(6, ScalarType.UINT32)
});
const PlatInfo = {
  imPlat: ProtoField(1, ScalarType.UINT32),
  osVersion: ProtoField(2, ScalarType.STRING, true),
  qVersion: ProtoField(3, ScalarType.STRING, true)
};
({
  retCode: ProtoField(1, ScalarType.UINT32),
  errMsg: ProtoField(2, ScalarType.STRING),
  subCmd: ProtoField(3, ScalarType.UINT32),
  userInfo: ProtoField(6, () => FaceRoamUserInfo)
});
const FaceRoamUserInfo = {
  fileName: ProtoField(1, ScalarType.STRING, false, true),
  deleteFile: ProtoField(2, ScalarType.STRING, false, true),
  bid: ProtoField(3, ScalarType.STRING),
  maxRoamSize: ProtoField(4, ScalarType.UINT32),
  emojiType: ProtoField(5, ScalarType.UINT32, false, true)
};
({
  state: ProtoField(1, ScalarType.INT32),
  sizeCache: ProtoField(2, ScalarType.INT32),
  unknownFields: ProtoField(3, ScalarType.BYTES),
  routingHead: ProtoField(4, () => RoutingHead),
  contentHead: ProtoField(5, () => ContentHead),
  messageBody: ProtoField(6, () => MessageBody),
  msgSeq: ProtoField(7, ScalarType.INT32),
  msgRand: ProtoField(8, ScalarType.INT32),
  syncCookie: ProtoField(9, ScalarType.BYTES),
  msgVia: ProtoField(10, ScalarType.INT32),
  dataStatist: ProtoField(11, ScalarType.INT32),
  messageControl: ProtoField(12, () => MessageControl),
  multiSendSeq: ProtoField(13, ScalarType.INT32)
});
({
  result: ProtoField(1, ScalarType.INT32),
  errMsg: ProtoField(2, ScalarType.STRING, true),
  timestamp1: ProtoField(3, ScalarType.UINT32),
  field10: ProtoField(10, ScalarType.UINT32),
  groupSequence: ProtoField(11, ScalarType.UINT32, true),
  timestamp2: ProtoField(12, ScalarType.UINT32),
  privateSequence: ProtoField(14, ScalarType.UINT32)
});
({
  status: ProtoField(1, ScalarType.UINT32),
  extStatus: ProtoField(2, ScalarType.UINT32),
  batteryStatus: ProtoField(3, ScalarType.UINT32),
  customExt: ProtoField(4, () => SetStatusCustomExt, true)
});
const SetStatusCustomExt = {
  faceId: ProtoField(1, ScalarType.UINT32),
  text: ProtoField(2, ScalarType.STRING, true),
  field3: ProtoField(3, ScalarType.UINT32)
};
({
  message: ProtoField(2, ScalarType.STRING)
});
const HttpConn = {
  field1: ProtoField(1, ScalarType.INT32),
  field2: ProtoField(2, ScalarType.INT32),
  field3: ProtoField(3, ScalarType.INT32),
  field4: ProtoField(4, ScalarType.INT32),
  tgt: ProtoField(5, ScalarType.STRING),
  field6: ProtoField(6, ScalarType.INT32),
  serviceTypes: ProtoField(7, ScalarType.INT32, false, true),
  field9: ProtoField(9, ScalarType.INT32),
  field10: ProtoField(10, ScalarType.INT32),
  field11: ProtoField(11, ScalarType.INT32),
  ver: ProtoField(15, ScalarType.STRING)
};
const HttpConn0x6ff_501 = {
  httpConn: ProtoField(1281, () => HttpConn)
};
const HttpConn0x6ff_501Response = {
  httpConn: ProtoField(1281, () => HttpConnResponse)
};
const HttpConnResponse = {
  sigSession: ProtoField(1, ScalarType.BYTES),
  sessionKey: ProtoField(2, ScalarType.BYTES),
  serverInfos: ProtoField(3, () => ServerInfo, false, true)
};
const ServerAddr = {
  type: ProtoField(1, ScalarType.UINT32),
  ip: ProtoField(2, ScalarType.FIXED32),
  port: ProtoField(3, ScalarType.UINT32),
  area: ProtoField(4, ScalarType.UINT32)
};
const ServerInfo = {
  serviceType: ProtoField(1, ScalarType.UINT32),
  serverAddrs: ProtoField(2, () => ServerAddr, false, true)
};

const MiniAppAdaptShareInfoReq = {
  appId: ProtoField(2, ScalarType.STRING),
  body: ProtoField(4, () => MiniAppAdaptShareInfoReqBody)
};
const MiniAppAdaptShareInfoReqBody = {
  extInfo: ProtoField(1, () => ExtInfo),
  appid: ProtoField(2, ScalarType.STRING),
  title: ProtoField(3, ScalarType.STRING),
  desc: ProtoField(4, ScalarType.STRING),
  time: ProtoField(5, ScalarType.UINT64),
  scene: ProtoField(6, ScalarType.UINT32),
  templateType: ProtoField(7, ScalarType.UINT32),
  businessType: ProtoField(8, ScalarType.UINT32),
  picUrl: ProtoField(9, ScalarType.STRING),
  vidUrl: ProtoField(10, ScalarType.STRING),
  jumpUrl: ProtoField(11, ScalarType.STRING),
  iconUrl: ProtoField(12, ScalarType.STRING),
  verType: ProtoField(13, ScalarType.UINT32),
  shareType: ProtoField(14, ScalarType.UINT32),
  versionId: ProtoField(15, ScalarType.STRING),
  withShareTicket: ProtoField(16, ScalarType.UINT32),
  webURL: ProtoField(17, ScalarType.STRING),
  appidRich: ProtoField(18, ScalarType.BYTES),
  template: ProtoField(19, () => Template),
  field20: ProtoField(20, ScalarType.STRING)
};
const ExtInfo = {
  field2: ProtoField(2, ScalarType.BYTES)
};
const Template = {
  templateId: ProtoField(1, ScalarType.STRING),
  templateData: ProtoField(2, ScalarType.STRING)
};
const MiniAppAdaptShareInfoResp = {
  field2: ProtoField(2, ScalarType.UINT32),
  field3: ProtoField(3, ScalarType.STRING),
  content: ProtoField(4, () => MiniAppAdaptShareInfoRespContent)
};
const MiniAppAdaptShareInfoRespContent = {
  jsonContent: ProtoField(2, ScalarType.STRING)
};

const DataHighwayHead = {
  version: ProtoField(1, ScalarType.UINT32),
  uin: ProtoField(2, ScalarType.STRING, true),
  command: ProtoField(3, ScalarType.STRING, true),
  seq: ProtoField(4, ScalarType.UINT32, true),
  retryTimes: ProtoField(5, ScalarType.UINT32, true),
  appId: ProtoField(6, ScalarType.UINT32),
  dataFlag: ProtoField(7, ScalarType.UINT32),
  commandId: ProtoField(8, ScalarType.UINT32),
  buildVer: ProtoField(9, ScalarType.BYTES, true)
};
const FileUploadExt = {
  unknown1: ProtoField(1, ScalarType.INT32),
  unknown2: ProtoField(2, ScalarType.INT32),
  unknown3: ProtoField(3, ScalarType.INT32),
  entry: ProtoField(100, () => FileUploadEntry),
  unknown200: ProtoField(200, ScalarType.INT32)
};
const FileUploadEntry = {
  busiBuff: ProtoField(100, () => ExcitingBusiInfo),
  fileEntry: ProtoField(200, () => ExcitingFileEntry),
  clientInfo: ProtoField(300, () => ExcitingClientInfo),
  fileNameInfo: ProtoField(400, () => ExcitingFileNameInfo),
  host: ProtoField(500, () => ExcitingHostConfig)
};
const ExcitingBusiInfo = {
  busId: ProtoField(1, ScalarType.INT32),
  senderUin: ProtoField(100, ScalarType.UINT64),
  receiverUin: ProtoField(200, ScalarType.UINT64),
  groupCode: ProtoField(400, ScalarType.UINT64)
};
const ExcitingFileEntry = {
  fileSize: ProtoField(100, ScalarType.UINT64),
  md5: ProtoField(200, ScalarType.BYTES),
  checkKey: ProtoField(300, ScalarType.BYTES),
  md5S2: ProtoField(400, ScalarType.BYTES),
  fileId: ProtoField(600, ScalarType.STRING),
  uploadKey: ProtoField(700, ScalarType.BYTES)
};
const ExcitingClientInfo = {
  clientType: ProtoField(100, ScalarType.INT32),
  appId: ProtoField(200, ScalarType.STRING),
  terminalType: ProtoField(300, ScalarType.INT32),
  clientVer: ProtoField(400, ScalarType.STRING),
  unknown: ProtoField(600, ScalarType.INT32)
};
const ExcitingFileNameInfo = {
  fileName: ProtoField(100, ScalarType.STRING)
};
const ExcitingHostConfig = {
  hosts: ProtoField(200, () => ExcitingHostInfo, false, true)
};
const ExcitingHostInfo = {
  url: ProtoField(1, () => ExcitingUrlInfo),
  port: ProtoField(2, ScalarType.UINT32)
};
const ExcitingUrlInfo = {
  unknown: ProtoField(1, ScalarType.INT32),
  host: ProtoField(2, ScalarType.STRING)
};
const LoginSigHead = {
  uint32LoginSigType: ProtoField(1, ScalarType.UINT32),
  bytesLoginSig: ProtoField(2, ScalarType.BYTES),
  appId: ProtoField(3, ScalarType.UINT32)
};
const NTV2RichMediaHighwayExt = {
  fileUuid: ProtoField(1, ScalarType.STRING),
  uKey: ProtoField(2, ScalarType.STRING),
  network: ProtoField(5, () => NTHighwayNetwork),
  msgInfoBody: ProtoField(6, () => MsgInfoBody, false, true),
  blockSize: ProtoField(10, ScalarType.UINT32),
  hash: ProtoField(11, () => NTHighwayHash)
};
const NTHighwayHash = {
  fileSha1: ProtoField(1, ScalarType.BYTES, false, true)
};
const NTHighwayNetwork = {
  ipv4s: ProtoField(1, () => NTHighwayIPv4, false, true)
};
const NTHighwayIPv4 = {
  domain: ProtoField(1, () => NTHighwayDomain),
  port: ProtoField(2, ScalarType.UINT32)
};
const NTHighwayDomain = {
  isEnable: ProtoField(1, ScalarType.BOOL),
  ip: ProtoField(2, ScalarType.STRING)
};
const ReqDataHighwayHead = {
  msgBaseHead: ProtoField(1, () => DataHighwayHead, true),
  msgSegHead: ProtoField(2, () => SegHead, true),
  bytesReqExtendInfo: ProtoField(3, ScalarType.BYTES, true),
  timestamp: ProtoField(4, ScalarType.UINT64),
  msgLoginSigHead: ProtoField(5, () => LoginSigHead, true)
};
const RespDataHighwayHead = {
  msgBaseHead: ProtoField(1, () => DataHighwayHead, true),
  msgSegHead: ProtoField(2, () => SegHead, true),
  errorCode: ProtoField(3, ScalarType.UINT32),
  allowRetry: ProtoField(4, ScalarType.UINT32),
  cacheCost: ProtoField(5, ScalarType.UINT32),
  htCost: ProtoField(6, ScalarType.UINT32),
  bytesRspExtendInfo: ProtoField(7, ScalarType.BYTES, true),
  timestamp: ProtoField(8, ScalarType.UINT64),
  range: ProtoField(9, ScalarType.UINT64),
  isReset: ProtoField(10, ScalarType.UINT32)
};
const SegHead = {
  serviceId: ProtoField(1, ScalarType.UINT32, true),
  filesize: ProtoField(2, ScalarType.UINT64),
  dataOffset: ProtoField(3, ScalarType.UINT64, true),
  dataLength: ProtoField(4, ScalarType.UINT32),
  retCode: ProtoField(5, ScalarType.UINT32, true),
  serviceTicket: ProtoField(6, ScalarType.BYTES),
  flag: ProtoField(7, ScalarType.UINT32, true),
  md5: ProtoField(8, ScalarType.BYTES),
  fileMd5: ProtoField(9, ScalarType.BYTES),
  cacheAddr: ProtoField(10, ScalarType.UINT32, true),
  queryTimes: ProtoField(11, ScalarType.UINT32),
  updateCacheIp: ProtoField(12, ScalarType.UINT32),
  cachePort: ProtoField(13, ScalarType.UINT32, true)
};
({
  type: ProtoField(1, ScalarType.UINT32),
  groupUin: ProtoField(2, ScalarType.UINT32),
  field3: ProtoField(3, () => GroupAvatarExtraField3),
  field5: ProtoField(5, ScalarType.UINT32),
  field6: ProtoField(6, ScalarType.UINT32)
});
const GroupAvatarExtraField3 = {
  field1: ProtoField(1, ScalarType.UINT32)
};

const LongMsgResult = {
  action: ProtoField(2, () => LongMsgAction)
};
const LongMsgAction = {
  actionCommand: ProtoField(1, ScalarType.STRING),
  actionData: ProtoField(2, () => LongMsgContent)
};
const LongMsgContent = {
  msgBody: ProtoField(1, () => PushMsgBody, false, true)
};
({
  uid: ProtoField(1, () => LongMsgUid, true),
  resId: ProtoField(2, ScalarType.STRING, true),
  acquire: ProtoField(3, ScalarType.BOOL)
});
const LongMsgUid = {
  uid: ProtoField(2, ScalarType.STRING, true)
};
const LongMsgSettings = {
  field1: ProtoField(1, ScalarType.UINT32),
  field2: ProtoField(2, ScalarType.UINT32),
  field3: ProtoField(3, ScalarType.UINT32),
  field4: ProtoField(4, ScalarType.UINT32)
};
({
  resId: ProtoField(3, ScalarType.STRING),
  payload: ProtoField(4, ScalarType.BYTES)
});
const SendLongMsgReq = {
  info: ProtoField(2, () => SendLongMsgInfo),
  settings: ProtoField(15, () => LongMsgSettings)
};
const SendLongMsgInfo = {
  type: ProtoField(1, ScalarType.UINT32),
  uid: ProtoField(2, () => LongMsgUid, true),
  groupUin: ProtoField(3, ScalarType.UINT32, true),
  payload: ProtoField(4, ScalarType.BYTES, true)
};
const SendLongMsgResp = {
  result: ProtoField(2, () => SendLongMsgResult),
  settings: ProtoField(15, () => LongMsgSettings)
};
const SendLongMsgResult = {
  resId: ProtoField(3, ScalarType.STRING)
};
({
  info: ProtoField(1, () => SsoGetGroupMsgInfo),
  direction: ProtoField(2, ScalarType.BOOL)
});
const SsoGetGroupMsgInfo = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  startSequence: ProtoField(2, ScalarType.UINT32),
  endSequence: ProtoField(3, ScalarType.UINT32)
};
({
  groupUin: ProtoField(3, ScalarType.UINT32),
  startSequence: ProtoField(4, ScalarType.UINT32),
  endSequence: ProtoField(5, ScalarType.UINT32),
  messages: ProtoField(6, () => PushMsgBody, false, true)
});
({
  friendUid: ProtoField(1, ScalarType.STRING, true),
  time: ProtoField(2, ScalarType.UINT32),
  random: ProtoField(3, ScalarType.UINT32),
  count: ProtoField(4, ScalarType.UINT32),
  direction: ProtoField(5, ScalarType.BOOL)
});
({
  friendUid: ProtoField(3, ScalarType.STRING),
  timestamp: ProtoField(5, ScalarType.UINT32),
  random: ProtoField(6, ScalarType.UINT32),
  messages: ProtoField(7, () => PushMsgBody, false, true)
});
({
  friendUid: ProtoField(2, ScalarType.STRING, true),
  startSequence: ProtoField(3, ScalarType.UINT32),
  endSequence: ProtoField(4, ScalarType.UINT32)
});
({
  friendUid: ProtoField(4, ScalarType.STRING),
  messages: ProtoField(7, () => PushMsgBody, false, true)
});

const C2C = {
  uin: ProtoField(1, ScalarType.UINT32, true),
  uid: ProtoField(2, ScalarType.STRING, true),
  field3: ProtoField(3, ScalarType.UINT32, true),
  sig: ProtoField(4, ScalarType.UINT32, true),
  receiverUin: ProtoField(5, ScalarType.UINT32, true),
  receiverUid: ProtoField(6, ScalarType.STRING, true)
};

const Attr = {
  codePage: ProtoField(1, ScalarType.INT32),
  time: ProtoField(2, ScalarType.INT32),
  random: ProtoField(3, ScalarType.INT32),
  color: ProtoField(4, ScalarType.INT32),
  size: ProtoField(5, ScalarType.INT32),
  effect: ProtoField(6, ScalarType.INT32),
  charSet: ProtoField(7, ScalarType.INT32),
  pitchAndFamily: ProtoField(8, ScalarType.INT32),
  fontName: ProtoField(9, ScalarType.STRING),
  reserveData: ProtoField(10, ScalarType.BYTES)
};
const NotOnlineFile = {
  fileType: ProtoField(1, ScalarType.INT32, true),
  sig: ProtoField(2, ScalarType.BYTES, true),
  fileUuid: ProtoField(3, ScalarType.STRING, true),
  fileMd5: ProtoField(4, ScalarType.BYTES, true),
  fileName: ProtoField(5, ScalarType.STRING, true),
  fileSize: ProtoField(6, ScalarType.INT64, true),
  note: ProtoField(7, ScalarType.BYTES, true),
  reserved: ProtoField(8, ScalarType.INT32, true),
  subcmd: ProtoField(9, ScalarType.INT32, true),
  microCloud: ProtoField(10, ScalarType.INT32, true),
  bytesFileUrls: ProtoField(11, ScalarType.BYTES, false, true),
  downloadFlag: ProtoField(12, ScalarType.INT32, true),
  dangerEvel: ProtoField(50, ScalarType.INT32, true),
  lifeTime: ProtoField(51, ScalarType.INT32, true),
  uploadTime: ProtoField(52, ScalarType.INT32, true),
  absFileType: ProtoField(53, ScalarType.INT32, true),
  clientType: ProtoField(54, ScalarType.INT32, true),
  expireTime: ProtoField(55, ScalarType.INT32, true),
  pbReserve: ProtoField(56, ScalarType.BYTES, true),
  fileHash: ProtoField(57, ScalarType.STRING, true)
};
const Ptt = {
  fileType: ProtoField(1, ScalarType.INT32),
  srcUin: ProtoField(2, ScalarType.UINT64),
  fileUuid: ProtoField(3, ScalarType.STRING),
  fileMd5: ProtoField(4, ScalarType.BYTES),
  fileName: ProtoField(5, ScalarType.STRING),
  fileSize: ProtoField(6, ScalarType.INT32),
  reserve: ProtoField(7, ScalarType.BYTES),
  fileId: ProtoField(8, ScalarType.INT32),
  serverIp: ProtoField(9, ScalarType.INT32),
  serverPort: ProtoField(10, ScalarType.INT32),
  boolValid: ProtoField(11, ScalarType.BOOL),
  signature: ProtoField(12, ScalarType.BYTES),
  shortcut: ProtoField(13, ScalarType.BYTES),
  fileKey: ProtoField(14, ScalarType.BYTES),
  magicPttIndex: ProtoField(15, ScalarType.INT32),
  voiceSwitch: ProtoField(16, ScalarType.INT32),
  pttUrl: ProtoField(17, ScalarType.BYTES),
  groupFileKey: ProtoField(18, ScalarType.STRING),
  time: ProtoField(19, ScalarType.INT32),
  downPara: ProtoField(20, ScalarType.BYTES),
  format: ProtoField(29, ScalarType.INT32),
  pbReserve: ProtoField(30, ScalarType.BYTES),
  bytesPttUrls: ProtoField(31, ScalarType.BYTES, false, true),
  downloadFlag: ProtoField(32, ScalarType.INT32)
};
const RichText = {
  attr: ProtoField(1, () => Attr, true),
  elems: ProtoField(2, () => Elem, false, true),
  notOnlineFile: ProtoField(3, () => NotOnlineFile, true),
  ptt: ProtoField(4, () => Ptt, true)
};
({
  id: ProtoField(1, ScalarType.STRING),
  renderData: ProtoField(2, () => RenderData),
  action: ProtoField(3, () => Action)
});
const RenderData = {
  label: ProtoField(1, ScalarType.STRING),
  visitedLabel: ProtoField(2, ScalarType.STRING),
  style: ProtoField(3, ScalarType.INT32)
};
const Action = {
  type: ProtoField(1, ScalarType.INT32),
  permission: ProtoField(2, () => Permission),
  unsupportTips: ProtoField(4, ScalarType.STRING),
  data: ProtoField(5, ScalarType.STRING),
  reply: ProtoField(7, ScalarType.BOOL),
  enter: ProtoField(8, ScalarType.BOOL)
};
const Permission = {
  type: ProtoField(1, ScalarType.INT32),
  specifyRoleIds: ProtoField(2, ScalarType.STRING, false, true),
  specifyUserIds: ProtoField(3, ScalarType.STRING, false, true)
};
const FileExtra = {
  file: ProtoField(1, () => NotOnlineFile),
  field6: ProtoField(6, () => PrivateFileExtra)
};
const PrivateFileExtra = {
  field2: ProtoField(2, () => PrivateFileExtraField2)
};
const PrivateFileExtraField2 = {
  field1: ProtoField(1, ScalarType.UINT32),
  fileUuid: ProtoField(4, ScalarType.STRING),
  fileName: ProtoField(5, ScalarType.STRING),
  field6: ProtoField(6, ScalarType.UINT32),
  field7: ProtoField(7, ScalarType.BYTES),
  field8: ProtoField(8, ScalarType.BYTES),
  timestamp1: ProtoField(9, ScalarType.UINT32),
  fileHash: ProtoField(14, ScalarType.STRING),
  selfUid: ProtoField(15, ScalarType.STRING),
  destUid: ProtoField(16, ScalarType.STRING)
};
const GroupFileExtra = {
  field1: ProtoField(1, ScalarType.UINT32),
  fileName: ProtoField(2, ScalarType.STRING),
  display: ProtoField(3, ScalarType.STRING),
  inner: ProtoField(7, () => GroupFileExtraInner)
};
const GroupFileExtraInner = {
  info: ProtoField(2, () => GroupFileExtraInfo)
};
const GroupFileExtraInfo = {
  busId: ProtoField(1, ScalarType.UINT32),
  fileId: ProtoField(2, ScalarType.STRING),
  fileSize: ProtoField(3, ScalarType.UINT64),
  fileName: ProtoField(4, ScalarType.STRING),
  field5: ProtoField(5, ScalarType.UINT32),
  fileSha: ProtoField(6, ScalarType.BYTES),
  extInfoString: ProtoField(7, ScalarType.STRING),
  fileMd5: ProtoField(8, ScalarType.BYTES)
};
({
  origUrl: ProtoField(30, ScalarType.STRING)
});
({
  type: ProtoField(1, ScalarType.UINT32),
  field7: ProtoField(7, ScalarType.UINT32),
  field8: ProtoField(8, ScalarType.UINT32)
});

const Elem = {
  text: ProtoField(1, () => Text, true),
  face: ProtoField(2, () => Face, true),
  onlineImage: ProtoField(3, () => OnlineImage, true),
  notOnlineImage: ProtoField(4, () => NotOnlineImage, true),
  transElem: ProtoField(5, () => TransElem, true),
  marketFace: ProtoField(6, () => MarketFace, true),
  customFace: ProtoField(8, () => CustomFace, true),
  elemFlags2: ProtoField(9, () => ElemFlags2, true),
  richMsg: ProtoField(12, () => RichMsg, true),
  groupFile: ProtoField(13, () => GroupFile, true),
  extraInfo: ProtoField(16, () => ExtraInfo, true),
  videoFile: ProtoField(19, () => VideoFile, true),
  anonymousGroupMessage: ProtoField(21, () => AnonymousGroupMessage, true),
  customElem: ProtoField(31, () => CustomElem, true),
  generalFlags: ProtoField(37, () => GeneralFlags, true),
  srcMsg: ProtoField(45, () => SrcMsg, true),
  lightAppElem: ProtoField(51, () => LightAppElem, true),
  commonElem: ProtoField(53, () => CommonElem, true)
};
const Text = {
  str: ProtoField(1, ScalarType.STRING, true),
  lint: ProtoField(2, ScalarType.STRING, true),
  attr6Buf: ProtoField(3, ScalarType.BYTES, true),
  attr7Buf: ProtoField(4, ScalarType.BYTES, true),
  buf: ProtoField(11, ScalarType.BYTES, true),
  pbReserve: ProtoField(12, ScalarType.BYTES, true)
};
const Face = {
  index: ProtoField(1, ScalarType.INT32, true),
  old: ProtoField(2, ScalarType.BYTES, true),
  buf: ProtoField(11, ScalarType.BYTES, true)
};
const OnlineImage = {
  guid: ProtoField(1, ScalarType.BYTES),
  filePath: ProtoField(2, ScalarType.BYTES),
  oldVerSendFile: ProtoField(3, ScalarType.BYTES)
};
const NotOnlineImage = {
  filePath: ProtoField(1, ScalarType.STRING),
  fileLen: ProtoField(2, ScalarType.UINT32),
  downloadPath: ProtoField(3, ScalarType.STRING),
  oldVerSendFile: ProtoField(4, ScalarType.BYTES),
  imgType: ProtoField(5, ScalarType.INT32),
  previewsImage: ProtoField(6, ScalarType.BYTES),
  picMd5: ProtoField(7, ScalarType.BYTES),
  picHeight: ProtoField(8, ScalarType.UINT32),
  picWidth: ProtoField(9, ScalarType.UINT32),
  resId: ProtoField(10, ScalarType.STRING),
  flag: ProtoField(11, ScalarType.BYTES),
  thumbUrl: ProtoField(12, ScalarType.STRING),
  original: ProtoField(13, ScalarType.INT32),
  bigUrl: ProtoField(14, ScalarType.STRING),
  origUrl: ProtoField(15, ScalarType.STRING),
  bizType: ProtoField(16, ScalarType.INT32),
  result: ProtoField(17, ScalarType.INT32),
  index: ProtoField(18, ScalarType.INT32),
  opFaceBuf: ProtoField(19, ScalarType.BYTES),
  oldPicMd5: ProtoField(20, ScalarType.BOOL),
  thumbWidth: ProtoField(21, ScalarType.INT32),
  thumbHeight: ProtoField(22, ScalarType.INT32),
  fileId: ProtoField(23, ScalarType.INT32),
  showLen: ProtoField(24, ScalarType.UINT32),
  downloadLen: ProtoField(25, ScalarType.UINT32),
  x400Url: ProtoField(26, ScalarType.STRING),
  x400Width: ProtoField(27, ScalarType.INT32),
  x400Height: ProtoField(28, ScalarType.INT32),
  pbRes: ProtoField(29, () => NotOnlineImage_PbReserve)
};
const NotOnlineImage_PbReserve = {
  subType: ProtoField(1, ScalarType.INT32),
  field3: ProtoField(3, ScalarType.INT32),
  field4: ProtoField(4, ScalarType.INT32),
  summary: ProtoField(8, ScalarType.STRING),
  field10: ProtoField(10, ScalarType.INT32),
  field20: ProtoField(20, () => NotOnlineImage_PbReserve2),
  url: ProtoField(30, ScalarType.STRING),
  md5Str: ProtoField(31, ScalarType.STRING)
};
const NotOnlineImage_PbReserve2 = {
  field1: ProtoField(1, ScalarType.INT32),
  field2: ProtoField(2, ScalarType.STRING),
  field3: ProtoField(3, ScalarType.INT32),
  field4: ProtoField(4, ScalarType.INT32),
  field5: ProtoField(5, ScalarType.INT32),
  field7: ProtoField(7, ScalarType.STRING)
};
const TransElem = {
  elemType: ProtoField(1, ScalarType.INT32),
  elemValue: ProtoField(2, ScalarType.BYTES)
};
const MarketFace = {
  faceName: ProtoField(1, ScalarType.STRING),
  itemType: ProtoField(2, ScalarType.INT32),
  faceInfo: ProtoField(3, ScalarType.INT32),
  faceId: ProtoField(4, ScalarType.BYTES),
  tabId: ProtoField(5, ScalarType.INT32),
  subType: ProtoField(6, ScalarType.INT32),
  key: ProtoField(7, ScalarType.STRING),
  param: ProtoField(8, ScalarType.BYTES),
  mediaType: ProtoField(9, ScalarType.INT32),
  imageWidth: ProtoField(10, ScalarType.INT32),
  imageHeight: ProtoField(11, ScalarType.INT32),
  mobileparam: ProtoField(12, ScalarType.BYTES),
  pbReserve: ProtoField(13, () => MarketFacePbRes)
};
const MarketFacePbRes = {
  field8: ProtoField(8, ScalarType.INT32)
};
const CustomFace = {
  guid: ProtoField(1, ScalarType.BYTES),
  filePath: ProtoField(2, ScalarType.STRING),
  shortcut: ProtoField(3, ScalarType.STRING),
  buffer: ProtoField(4, ScalarType.BYTES),
  flag: ProtoField(5, ScalarType.BYTES),
  oldData: ProtoField(6, ScalarType.BYTES, true),
  fileId: ProtoField(7, ScalarType.UINT32),
  serverIp: ProtoField(8, ScalarType.INT32, true),
  serverPort: ProtoField(9, ScalarType.INT32, true),
  fileType: ProtoField(10, ScalarType.INT32),
  signature: ProtoField(11, ScalarType.BYTES),
  useful: ProtoField(12, ScalarType.INT32),
  md5: ProtoField(13, ScalarType.BYTES),
  thumbUrl: ProtoField(14, ScalarType.STRING),
  bigUrl: ProtoField(15, ScalarType.STRING),
  origUrl: ProtoField(16, ScalarType.STRING),
  bizType: ProtoField(17, ScalarType.INT32),
  repeatIndex: ProtoField(18, ScalarType.INT32),
  repeatImage: ProtoField(19, ScalarType.INT32),
  imageType: ProtoField(20, ScalarType.INT32),
  index: ProtoField(21, ScalarType.INT32),
  width: ProtoField(22, ScalarType.INT32),
  height: ProtoField(23, ScalarType.INT32),
  source: ProtoField(24, ScalarType.INT32),
  size: ProtoField(25, ScalarType.UINT32),
  origin: ProtoField(26, ScalarType.INT32),
  thumbWidth: ProtoField(27, ScalarType.INT32, true),
  thumbHeight: ProtoField(28, ScalarType.INT32, true),
  showLen: ProtoField(29, ScalarType.INT32),
  downloadLen: ProtoField(30, ScalarType.INT32),
  x400Url: ProtoField(31, ScalarType.STRING, true),
  x400Width: ProtoField(32, ScalarType.INT32),
  x400Height: ProtoField(33, ScalarType.INT32),
  pbRes: ProtoField(34, () => CustomFace_PbReserve, true)
};
const CustomFace_PbReserve = {
  subType: ProtoField(1, ScalarType.INT32),
  summary: ProtoField(9, ScalarType.STRING)
};
const ElemFlags2 = {
  colorTextId: ProtoField(1, ScalarType.UINT32),
  msgId: ProtoField(2, ScalarType.UINT64),
  whisperSessionId: ProtoField(3, ScalarType.UINT32),
  pttChangeBit: ProtoField(4, ScalarType.UINT32),
  vipStatus: ProtoField(5, ScalarType.UINT32),
  compatibleId: ProtoField(6, ScalarType.UINT32),
  insts: ProtoField(7, () => Instance, false, true),
  msgRptCnt: ProtoField(8, ScalarType.UINT32),
  srcInst: ProtoField(9, () => Instance),
  longtitude: ProtoField(10, ScalarType.UINT32),
  latitude: ProtoField(11, ScalarType.UINT32),
  customFont: ProtoField(12, ScalarType.UINT32),
  pcSupportDef: ProtoField(13, () => PcSupportDef),
  crmFlags: ProtoField(14, ScalarType.UINT32, true)
};
const PcSupportDef = {
  pcPtlBegin: ProtoField(1, ScalarType.UINT32),
  pcPtlEnd: ProtoField(2, ScalarType.UINT32),
  macPtlBegin: ProtoField(3, ScalarType.UINT32),
  macPtlEnd: ProtoField(4, ScalarType.UINT32),
  ptlsSupport: ProtoField(5, ScalarType.INT32, false, true),
  ptlsNotSupport: ProtoField(6, ScalarType.UINT32, false, true)
};
const Instance = {
  appId: ProtoField(1, ScalarType.UINT32),
  instId: ProtoField(2, ScalarType.UINT32)
};
const RichMsg = {
  template1: ProtoField(1, ScalarType.BYTES, true),
  serviceId: ProtoField(2, ScalarType.INT32, true),
  msgResId: ProtoField(3, ScalarType.BYTES, true),
  rand: ProtoField(4, ScalarType.INT32, true),
  seq: ProtoField(5, ScalarType.UINT32, true)
};
const GroupFile = {
  filename: ProtoField(1, ScalarType.BYTES),
  fileSize: ProtoField(2, ScalarType.UINT64),
  fileId: ProtoField(3, ScalarType.BYTES),
  batchId: ProtoField(4, ScalarType.BYTES),
  fileKey: ProtoField(5, ScalarType.BYTES),
  mark: ProtoField(6, ScalarType.BYTES),
  sequence: ProtoField(7, ScalarType.UINT64),
  batchItemId: ProtoField(8, ScalarType.BYTES),
  feedMsgTime: ProtoField(9, ScalarType.INT32),
  pbReserve: ProtoField(10, ScalarType.BYTES)
};
const ExtraInfo = {
  nick: ProtoField(1, ScalarType.BYTES),
  groupCard: ProtoField(2, ScalarType.BYTES),
  level: ProtoField(3, ScalarType.INT32),
  flags: ProtoField(4, ScalarType.INT32),
  groupMask: ProtoField(5, ScalarType.INT32),
  msgTailId: ProtoField(6, ScalarType.INT32),
  senderTitle: ProtoField(7, ScalarType.BYTES),
  apnsTips: ProtoField(8, ScalarType.BYTES),
  uin: ProtoField(9, ScalarType.UINT64),
  msgStateFlag: ProtoField(10, ScalarType.INT32),
  apnsSoundType: ProtoField(11, ScalarType.INT32),
  newGroupFlag: ProtoField(12, ScalarType.INT32)
};
const VideoFile = {
  fileUuid: ProtoField(1, ScalarType.STRING),
  fileMd5: ProtoField(2, ScalarType.BYTES),
  fileName: ProtoField(3, ScalarType.STRING),
  fileFormat: ProtoField(4, ScalarType.INT32),
  fileTime: ProtoField(5, ScalarType.INT32),
  fileSize: ProtoField(6, ScalarType.INT32),
  thumbWidth: ProtoField(7, ScalarType.INT32),
  thumbHeight: ProtoField(8, ScalarType.INT32),
  thumbFileMd5: ProtoField(9, ScalarType.BYTES),
  source: ProtoField(10, ScalarType.BYTES),
  thumbFileSize: ProtoField(11, ScalarType.INT32),
  busiType: ProtoField(12, ScalarType.INT32),
  fromChatType: ProtoField(13, ScalarType.INT32),
  toChatType: ProtoField(14, ScalarType.INT32),
  boolSupportProgressive: ProtoField(15, ScalarType.BOOL),
  fileWidth: ProtoField(16, ScalarType.INT32),
  fileHeight: ProtoField(17, ScalarType.INT32),
  subBusiType: ProtoField(18, ScalarType.INT32),
  videoAttr: ProtoField(19, ScalarType.INT32),
  bytesThumbFileUrls: ProtoField(20, ScalarType.BYTES, false, true),
  bytesVideoFileUrls: ProtoField(21, ScalarType.BYTES, false, true),
  thumbDownloadFlag: ProtoField(22, ScalarType.INT32),
  videoDownloadFlag: ProtoField(23, ScalarType.INT32),
  pbReserve: ProtoField(24, ScalarType.BYTES)
};
const AnonymousGroupMessage = {
  flags: ProtoField(1, ScalarType.INT32),
  anonId: ProtoField(2, ScalarType.BYTES),
  anonNick: ProtoField(3, ScalarType.BYTES),
  headPortrait: ProtoField(4, ScalarType.INT32),
  expireTime: ProtoField(5, ScalarType.INT32),
  bubbleId: ProtoField(6, ScalarType.INT32),
  rankColor: ProtoField(7, ScalarType.BYTES)
};
const CustomElem = {
  desc: ProtoField(1, ScalarType.BYTES),
  data: ProtoField(2, ScalarType.BYTES),
  enumType: ProtoField(3, ScalarType.INT32),
  ext: ProtoField(4, ScalarType.BYTES),
  sound: ProtoField(5, ScalarType.BYTES)
};
const GeneralFlags = {
  bubbleDiyTextId: ProtoField(1, ScalarType.INT32),
  groupFlagNew: ProtoField(2, ScalarType.INT32),
  uin: ProtoField(3, ScalarType.UINT64),
  rpId: ProtoField(4, ScalarType.BYTES),
  prpFold: ProtoField(5, ScalarType.INT32),
  longTextFlag: ProtoField(6, ScalarType.INT32),
  longTextResId: ProtoField(7, ScalarType.STRING, true),
  groupType: ProtoField(8, ScalarType.INT32),
  toUinFlag: ProtoField(9, ScalarType.INT32),
  glamourLevel: ProtoField(10, ScalarType.INT32),
  memberLevel: ProtoField(11, ScalarType.INT32),
  groupRankSeq: ProtoField(12, ScalarType.UINT64),
  olympicTorch: ProtoField(13, ScalarType.INT32),
  babyqGuideMsgCookie: ProtoField(14, ScalarType.BYTES),
  uin32ExpertFlag: ProtoField(15, ScalarType.INT32),
  bubbleSubId: ProtoField(16, ScalarType.INT32),
  pendantId: ProtoField(17, ScalarType.UINT64),
  rpIndex: ProtoField(18, ScalarType.BYTES),
  pbReserve: ProtoField(19, ScalarType.BYTES)
};
const SrcMsg = {
  origSeqs: ProtoField(1, ScalarType.UINT32, false, true),
  senderUin: ProtoField(2, ScalarType.UINT64),
  time: ProtoField(3, ScalarType.INT32, true),
  flag: ProtoField(4, ScalarType.INT32, true),
  elems: ProtoField(5, () => Elem, false, true),
  type: ProtoField(6, ScalarType.INT32, true),
  richMsg: ProtoField(7, ScalarType.BYTES, true),
  pbReserve: ProtoField(8, () => SrcMsgPbRes, true),
  sourceMsg: ProtoField(9, ScalarType.BYTES, true),
  toUin: ProtoField(10, ScalarType.UINT64, true),
  troopName: ProtoField(11, ScalarType.BYTES, true)
};
const SrcMsgPbRes = {
  messageId: ProtoField(3, ScalarType.UINT64),
  senderUid: ProtoField(6, ScalarType.STRING, true),
  receiverUid: ProtoField(7, ScalarType.STRING, true),
  friendSeq: ProtoField(8, ScalarType.UINT32, true)
};
const LightAppElem = {
  data: ProtoField(1, ScalarType.BYTES),
  msgResid: ProtoField(2, ScalarType.BYTES, true)
};
const CommonElem = {
  serviceType: ProtoField(1, ScalarType.INT32),
  pbElem: ProtoField(2, ScalarType.BYTES),
  businessType: ProtoField(3, ScalarType.UINT32)
};
({
  faceId: ProtoField(1, ScalarType.INT32, true)
});
const MentionExtra = {
  type: ProtoField(3, ScalarType.INT32, true),
  uin: ProtoField(4, ScalarType.UINT32, true),
  field5: ProtoField(5, ScalarType.INT32, true),
  uid: ProtoField(9, ScalarType.STRING, true)
};
const QBigFaceExtra = {
  AniStickerPackId: ProtoField(1, ScalarType.STRING, true),
  AniStickerId: ProtoField(2, ScalarType.STRING, true),
  faceId: ProtoField(3, ScalarType.INT32, true),
  Field4: ProtoField(4, ScalarType.INT32, true),
  AniStickerType: ProtoField(5, ScalarType.INT32, true),
  field6: ProtoField(6, ScalarType.STRING, true),
  preview: ProtoField(7, ScalarType.STRING, true),
  field9: ProtoField(9, ScalarType.INT32, true)
};
const QSmallFaceExtra = {
  faceId: ProtoField(1, ScalarType.UINT32),
  preview: ProtoField(2, ScalarType.STRING),
  preview2: ProtoField(3, ScalarType.STRING)
};
const MarkdownData = {
  content: ProtoField(1, ScalarType.STRING)
};

({
  type: ProtoField(1, ScalarType.UINT32),
  groupUin: ProtoField(2, ScalarType.UINT32),
  field3: ProtoField(3, () => GroupRecallMsgField3),
  field4: ProtoField(4, () => GroupRecallMsgField4)
});
const GroupRecallMsgField3 = {
  sequence: ProtoField(1, ScalarType.UINT32),
  random: ProtoField(2, ScalarType.UINT32),
  field3: ProtoField(3, ScalarType.UINT32)
};
const GroupRecallMsgField4 = {
  field1: ProtoField(1, ScalarType.UINT32)
};

const ContentHead = {
  type: ProtoField(1, ScalarType.UINT32),
  subType: ProtoField(2, ScalarType.UINT32, true),
  divSeq: ProtoField(3, ScalarType.UINT32, true),
  msgId: ProtoField(4, ScalarType.UINT32, true),
  sequence: ProtoField(5, ScalarType.UINT32, true),
  timeStamp: ProtoField(6, ScalarType.UINT32, true),
  field7: ProtoField(7, ScalarType.UINT64, true),
  field8: ProtoField(8, ScalarType.UINT32, true),
  field9: ProtoField(9, ScalarType.UINT32, true),
  newId: ProtoField(12, ScalarType.UINT64, true),
  forward: ProtoField(15, () => ForwardHead, true)
};
const MessageBody = {
  richText: ProtoField(1, () => RichText, true),
  msgContent: ProtoField(2, ScalarType.BYTES, true),
  msgEncryptContent: ProtoField(3, ScalarType.BYTES, true)
};
({
  routingHead: ProtoField(1, () => RoutingHead, true),
  contentHead: ProtoField(2, () => ContentHead, true),
  body: ProtoField(3, () => MessageBody, true),
  clientSequence: ProtoField(4, ScalarType.UINT32, true),
  random: ProtoField(5, ScalarType.UINT32, true),
  syncCookie: ProtoField(6, ScalarType.BYTES, true),
  via: ProtoField(8, ScalarType.UINT32, true),
  dataStatist: ProtoField(9, ScalarType.UINT32, true),
  ctrl: ProtoField(12, () => MessageControl, true),
  multiSendSeq: ProtoField(14, ScalarType.UINT32)
});
const MessageControl = {
  msgFlag: ProtoField(1, ScalarType.INT32)
};
({
  message: ProtoField(1, () => PushMsgBody),
  status: ProtoField(3, ScalarType.INT32, true),
  pingFlag: ProtoField(5, ScalarType.INT32, true),
  generalFlag: ProtoField(9, ScalarType.INT32, true)
});
const GroupChangeInfo = {
  operator: ProtoField(1, () => GroupChangeOperator, true)
};
const GroupChangeOperator = {
  operatorUid: ProtoField(1, ScalarType.STRING, true)
};
const GroupChange = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  flag: ProtoField(2, ScalarType.UINT32),
  memberUid: ProtoField(3, ScalarType.STRING, true),
  decreaseType: ProtoField(4, ScalarType.UINT32),
  operatorInfo: ProtoField(5, ScalarType.BYTES, true),
  increaseType: ProtoField(6, ScalarType.UINT32),
  field7: ProtoField(7, ScalarType.BYTES, true)
};
const PushMsgBody = {
  responseHead: ProtoField(1, () => ResponseHead),
  contentHead: ProtoField(2, () => ContentHead),
  body: ProtoField(3, () => MessageBody, true)
};
const ResponseHead = {
  fromUin: ProtoField(1, ScalarType.UINT32),
  fromUid: ProtoField(2, ScalarType.STRING, true),
  type: ProtoField(3, ScalarType.UINT32),
  sigMap: ProtoField(4, ScalarType.UINT32),
  toUin: ProtoField(5, ScalarType.UINT32),
  toUid: ProtoField(6, ScalarType.STRING, true),
  forward: ProtoField(7, () => ResponseForward, true),
  grp: ProtoField(8, () => ResponseGrp, true)
};
const RoutingHead = {
  c2c: ProtoField(1, () => C2C, true),
  grp: ProtoField(2, () => Grp, true),
  grpTmp: ProtoField(3, () => GrpTmp, true),
  wpaTmp: ProtoField(6, () => WPATmp, true),
  trans0X211: ProtoField(15, () => Trans0X211, true)
};

({
  info: ProtoField(1, () => FriendRecallInfo),
  instId: ProtoField(2, ScalarType.UINT32),
  appId: ProtoField(3, ScalarType.UINT32),
  longMessageFlag: ProtoField(4, ScalarType.UINT32),
  reserved: ProtoField(5, ScalarType.BYTES)
});
const FriendRecallInfo = {
  fromUid: ProtoField(1, ScalarType.STRING),
  toUid: ProtoField(2, ScalarType.STRING),
  sequence: ProtoField(3, ScalarType.UINT32),
  newId: ProtoField(4, ScalarType.UINT64),
  time: ProtoField(5, ScalarType.UINT32),
  random: ProtoField(6, ScalarType.UINT32),
  pkgNum: ProtoField(7, ScalarType.UINT32),
  pkgIndex: ProtoField(8, ScalarType.UINT32),
  divSeq: ProtoField(9, ScalarType.UINT32)
};

const ForwardHead = {
  field1: ProtoField(1, ScalarType.UINT32, true),
  field2: ProtoField(2, ScalarType.UINT32, true),
  field3: ProtoField(3, ScalarType.UINT32, true),
  unknownBase64: ProtoField(5, ScalarType.STRING, true),
  avatar: ProtoField(6, ScalarType.STRING, true)
};
const Grp = {
  groupCode: ProtoField(1, ScalarType.UINT32, true)
};
const GrpTmp = {
  groupUin: ProtoField(1, ScalarType.UINT32, true),
  toUin: ProtoField(2, ScalarType.UINT32, true)
};
const ResponseForward = {
  friendName: ProtoField(6, ScalarType.STRING, true)
};
const ResponseGrp = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  memberName: ProtoField(4, ScalarType.STRING),
  unknown5: ProtoField(5, ScalarType.UINT32),
  groupName: ProtoField(7, ScalarType.STRING)
};
const Trans0X211 = {
  toUin: ProtoField(1, ScalarType.UINT64, true),
  ccCmd: ProtoField(2, ScalarType.UINT32, true),
  uid: ProtoField(8, ScalarType.STRING, true)
};
const WPATmp = {
  toUin: ProtoField(1, ScalarType.UINT64),
  sig: ProtoField(2, ScalarType.BYTES)
};

const NTV2RichMediaReq = {
  ReqHead: ProtoField(1, () => MultiMediaReqHead),
  Upload: ProtoField(2, () => UploadReq),
  Download: ProtoField(3, () => DownloadReq),
  DownloadRKey: ProtoField(4, () => DownloadRKeyReq),
  Delete: ProtoField(5, () => DeleteReq),
  UploadCompleted: ProtoField(6, () => UploadCompletedReq),
  MsgInfoAuth: ProtoField(7, () => MsgInfoAuthReq),
  UploadKeyRenewal: ProtoField(8, () => UploadKeyRenewalReq),
  DownloadSafe: ProtoField(9, () => DownloadSafeReq),
  Extension: ProtoField(99, ScalarType.BYTES, true)
};
const MultiMediaReqHead = {
  Common: ProtoField(1, () => CommonHead),
  Scene: ProtoField(2, () => SceneInfo),
  Client: ProtoField(3, () => ClientMeta)
};
const CommonHead = {
  RequestId: ProtoField(1, ScalarType.UINT32),
  Command: ProtoField(2, ScalarType.UINT32)
};
const SceneInfo = {
  RequestType: ProtoField(101, ScalarType.UINT32),
  BusinessType: ProtoField(102, ScalarType.UINT32),
  SceneType: ProtoField(200, ScalarType.UINT32),
  C2C: ProtoField(201, () => C2CUserInfo, true),
  Group: ProtoField(202, () => NTGroupInfo, true)
};
const C2CUserInfo = {
  AccountType: ProtoField(1, ScalarType.UINT32),
  TargetUid: ProtoField(2, ScalarType.STRING)
};
const NTGroupInfo = {
  GroupUin: ProtoField(1, ScalarType.UINT32)
};
const ClientMeta = {
  AgentType: ProtoField(1, ScalarType.UINT32)
};
const DownloadReq = {
  Node: ProtoField(1, () => IndexNode),
  Download: ProtoField(2, () => DownloadExt)
};
const IndexNode = {
  Info: ProtoField(1, () => FileInfo),
  FileUuid: ProtoField(2, ScalarType.STRING),
  StoreId: ProtoField(3, ScalarType.UINT32),
  UploadTime: ProtoField(4, ScalarType.UINT32),
  Ttl: ProtoField(5, ScalarType.UINT32),
  SubType: ProtoField(6, ScalarType.UINT32)
};
const FileInfo = {
  FileSize: ProtoField(1, ScalarType.UINT32),
  FileHash: ProtoField(2, ScalarType.STRING),
  FileSha1: ProtoField(3, ScalarType.STRING),
  FileName: ProtoField(4, ScalarType.STRING),
  Type: ProtoField(5, () => FileType),
  Width: ProtoField(6, ScalarType.UINT32),
  Height: ProtoField(7, ScalarType.UINT32),
  Time: ProtoField(8, ScalarType.UINT32),
  Original: ProtoField(9, ScalarType.UINT32)
};
const FileType = {
  Type: ProtoField(1, ScalarType.UINT32),
  PicFormat: ProtoField(2, ScalarType.UINT32),
  VideoFormat: ProtoField(3, ScalarType.UINT32),
  VoiceFormat: ProtoField(4, ScalarType.UINT32)
};
const DownloadExt = {
  Pic: ProtoField(1, () => PicDownloadExt),
  Video: ProtoField(2, () => VideoDownloadExt),
  Ptt: ProtoField(3, () => PttDownloadExt)
};
const VideoDownloadExt = {
  BusiType: ProtoField(1, ScalarType.UINT32),
  SceneType: ProtoField(2, ScalarType.UINT32),
  SubBusiType: ProtoField(3, ScalarType.UINT32)
};
const PicDownloadExt = {};
const PttDownloadExt = {};
const DownloadRKeyReq = {
  Types: ProtoField(1, ScalarType.INT32, false, true)
};
const DeleteReq = {
  Index: ProtoField(1, () => IndexNode, false, true),
  NeedRecallMsg: ProtoField(2, ScalarType.BOOL),
  MsgSeq: ProtoField(3, ScalarType.UINT64),
  MsgRandom: ProtoField(4, ScalarType.UINT64),
  MsgTime: ProtoField(5, ScalarType.UINT64)
};
const UploadCompletedReq = {
  SrvSendMsg: ProtoField(1, ScalarType.BOOL),
  ClientRandomId: ProtoField(2, ScalarType.UINT64),
  MsgInfo: ProtoField(3, () => MsgInfo),
  ClientSeq: ProtoField(4, ScalarType.UINT32)
};
const MsgInfoAuthReq = {
  Msg: ProtoField(1, ScalarType.BYTES),
  AuthTime: ProtoField(2, ScalarType.UINT64)
};
const DownloadSafeReq = {
  Index: ProtoField(1, () => IndexNode)
};
const UploadKeyRenewalReq = {
  OldUKey: ProtoField(1, ScalarType.STRING),
  SubType: ProtoField(2, ScalarType.UINT32)
};
const MsgInfo = {
  MsgInfoBody: ProtoField(1, () => MsgInfoBody, false, true),
  ExtBizInfo: ProtoField(2, () => ExtBizInfo)
};
const MsgInfoBody = {
  Index: ProtoField(1, () => IndexNode),
  Picture: ProtoField(2, () => PictureInfo),
  Video: ProtoField(3, () => VideoInfo),
  Audio: ProtoField(4, () => AudioInfo),
  FileExist: ProtoField(5, ScalarType.BOOL),
  HashSum: ProtoField(6, ScalarType.BYTES)
};
const VideoInfo = {};
const AudioInfo = {};
const PictureInfo = {
  UrlPath: ProtoField(1, ScalarType.STRING),
  Ext: ProtoField(2, () => PicUrlExtInfo),
  Domain: ProtoField(3, ScalarType.STRING)
};
const PicUrlExtInfo = {
  OriginalParameter: ProtoField(1, ScalarType.STRING),
  BigParameter: ProtoField(2, ScalarType.STRING),
  ThumbParameter: ProtoField(3, ScalarType.STRING)
};
const VideoExtInfo = {
  VideoCodecFormat: ProtoField(1, ScalarType.UINT32)
};
const ExtBizInfo = {
  Pic: ProtoField(1, () => PicExtBizInfo),
  Video: ProtoField(2, () => VideoExtBizInfo),
  Ptt: ProtoField(3, () => PttExtBizInfo),
  BusiType: ProtoField(10, ScalarType.UINT32)
};
const PttExtBizInfo = {
  SrcUin: ProtoField(1, ScalarType.UINT64),
  PttScene: ProtoField(2, ScalarType.UINT32),
  PttType: ProtoField(3, ScalarType.UINT32),
  ChangeVoice: ProtoField(4, ScalarType.UINT32),
  Waveform: ProtoField(5, ScalarType.BYTES),
  AutoConvertText: ProtoField(6, ScalarType.UINT32),
  BytesReserve: ProtoField(11, ScalarType.BYTES),
  BytesPbReserve: ProtoField(12, ScalarType.BYTES),
  BytesGeneralFlags: ProtoField(13, ScalarType.BYTES)
};
const VideoExtBizInfo = {
  FromScene: ProtoField(1, ScalarType.UINT32),
  ToScene: ProtoField(2, ScalarType.UINT32),
  BytesPbReserve: ProtoField(3, ScalarType.BYTES)
};
const PicExtBizInfo = {
  BizType: ProtoField(1, ScalarType.UINT32),
  TextSummary: ProtoField(2, ScalarType.STRING),
  BytesPbReserveC2c: ProtoField(11, ScalarType.BYTES),
  BytesPbReserveTroop: ProtoField(12, ScalarType.BYTES),
  FromScene: ProtoField(1001, ScalarType.UINT32),
  ToScene: ProtoField(1002, ScalarType.UINT32),
  OldFileId: ProtoField(1003, ScalarType.UINT32)
};
const UploadReq = {
  UploadInfo: ProtoField(1, () => UploadInfo, false, true),
  TryFastUploadCompleted: ProtoField(2, ScalarType.BOOL),
  SrvSendMsg: ProtoField(3, ScalarType.BOOL),
  ClientRandomId: ProtoField(4, ScalarType.UINT64),
  CompatQMsgSceneType: ProtoField(5, ScalarType.UINT32),
  ExtBizInfo: ProtoField(6, () => ExtBizInfo),
  ClientSeq: ProtoField(7, ScalarType.UINT32),
  NoNeedCompatMsg: ProtoField(8, ScalarType.BOOL)
};
const UploadInfo = {
  FileInfo: ProtoField(1, () => FileInfo),
  SubFileType: ProtoField(2, ScalarType.UINT32)
};

const NTV2RichMediaResp = {
  respHead: ProtoField(1, () => MultiMediaRespHead),
  upload: ProtoField(2, () => UploadResp),
  download: ProtoField(3, () => DownloadResp),
  downloadRKey: ProtoField(4, () => DownloadRKeyResp),
  delete: ProtoField(5, () => DeleteResp),
  uploadCompleted: ProtoField(6, () => UploadCompletedResp),
  msgInfoAuth: ProtoField(7, () => MsgInfoAuthResp),
  uploadKeyRenewal: ProtoField(8, () => UploadKeyRenewalResp),
  downloadSafe: ProtoField(9, () => DownloadSafeResp),
  extension: ProtoField(99, ScalarType.BYTES, true)
};
const MultiMediaRespHead = {
  common: ProtoField(1, () => CommonHead),
  retCode: ProtoField(2, ScalarType.UINT32),
  message: ProtoField(3, ScalarType.STRING)
};
const DownloadResp = {
  rKeyParam: ProtoField(1, ScalarType.STRING),
  rKeyTtlSecond: ProtoField(2, ScalarType.UINT32),
  info: ProtoField(3, () => DownloadInfo),
  rKeyCreateTime: ProtoField(4, ScalarType.UINT32)
};
const DownloadInfo = {
  domain: ProtoField(1, ScalarType.STRING),
  urlPath: ProtoField(2, ScalarType.STRING),
  httpsPort: ProtoField(3, ScalarType.UINT32),
  ipv4s: ProtoField(4, () => IPv4, false, true),
  ipv6s: ProtoField(5, () => IPv6, false, true),
  picUrlExtInfo: ProtoField(6, () => PicUrlExtInfo),
  videoExtInfo: ProtoField(7, () => VideoExtInfo)
};
const IPv4 = {
  outIP: ProtoField(1, ScalarType.UINT32),
  outPort: ProtoField(2, ScalarType.UINT32),
  inIP: ProtoField(3, ScalarType.UINT32),
  inPort: ProtoField(4, ScalarType.UINT32),
  ipType: ProtoField(5, ScalarType.UINT32)
};
const IPv6 = {
  outIP: ProtoField(1, ScalarType.BYTES),
  outPort: ProtoField(2, ScalarType.UINT32),
  inIP: ProtoField(3, ScalarType.BYTES),
  inPort: ProtoField(4, ScalarType.UINT32),
  ipType: ProtoField(5, ScalarType.UINT32)
};
const UploadResp = {
  uKey: ProtoField(1, ScalarType.STRING, true),
  uKeyTtlSecond: ProtoField(2, ScalarType.UINT32),
  ipv4s: ProtoField(3, () => IPv4, false, true),
  ipv6s: ProtoField(4, () => IPv6, false, true),
  msgSeq: ProtoField(5, ScalarType.UINT64),
  msgInfo: ProtoField(6, () => MsgInfo),
  ext: ProtoField(7, () => RichMediaStorageTransInfo, false, true),
  compatQMsg: ProtoField(8, ScalarType.BYTES),
  subFileInfos: ProtoField(10, () => SubFileInfo, false, true)
};
const RichMediaStorageTransInfo = {
  subType: ProtoField(1, ScalarType.UINT32),
  extType: ProtoField(2, ScalarType.UINT32),
  extValue: ProtoField(3, ScalarType.BYTES)
};
const SubFileInfo = {
  subType: ProtoField(1, ScalarType.UINT32),
  uKey: ProtoField(2, ScalarType.STRING),
  uKeyTtlSecond: ProtoField(3, ScalarType.UINT32),
  ipv4s: ProtoField(4, () => IPv4, false, true),
  ipv6s: ProtoField(5, () => IPv6, false, true)
};
const DownloadSafeResp = {};
const UploadKeyRenewalResp = {
  ukey: ProtoField(1, ScalarType.STRING),
  ukeyTtlSec: ProtoField(2, ScalarType.UINT64)
};
const MsgInfoAuthResp = {
  authCode: ProtoField(1, ScalarType.UINT32),
  msg: ProtoField(2, ScalarType.BYTES),
  resultTime: ProtoField(3, ScalarType.UINT64)
};
const UploadCompletedResp = {
  msgSeq: ProtoField(1, ScalarType.UINT64)
};
const DeleteResp = {};
const DownloadRKeyResp = {
  rKeys: ProtoField(1, () => RKeyInfo, false, true)
};
const RKeyInfo = {
  rkey: ProtoField(1, ScalarType.STRING),
  rkeyTtlSec: ProtoField(2, ScalarType.UINT64),
  storeId: ProtoField(3, ScalarType.UINT32),
  rkeyCreateTime: ProtoField(4, ScalarType.UINT32, true),
  type: ProtoField(5, ScalarType.UINT32, true)
};

const OidbSvcTrpcTcp0x6D6 = {
  file: ProtoField(1, () => OidbSvcTrpcTcp0x6D6Upload, true),
  download: ProtoField(3, () => OidbSvcTrpcTcp0x6D6Download, true),
  delete: ProtoField(4, () => OidbSvcTrpcTcp0x6D6Delete, true),
  rename: ProtoField(5, () => OidbSvcTrpcTcp0x6D6Rename, true),
  move: ProtoField(6, () => OidbSvcTrpcTcp0x6D6Move, true)
};
const OidbSvcTrpcTcp0x6D6Upload = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  appId: ProtoField(2, ScalarType.UINT32),
  busId: ProtoField(3, ScalarType.UINT32),
  entrance: ProtoField(4, ScalarType.UINT32),
  targetDirectory: ProtoField(5, ScalarType.STRING),
  fileName: ProtoField(6, ScalarType.STRING),
  localDirectory: ProtoField(7, ScalarType.STRING),
  fileSize: ProtoField(8, ScalarType.UINT64),
  fileSha1: ProtoField(9, ScalarType.BYTES),
  fileSha3: ProtoField(10, ScalarType.BYTES),
  fileMd5: ProtoField(11, ScalarType.BYTES),
  field15: ProtoField(15, ScalarType.BOOL)
};
const OidbSvcTrpcTcp0x6D6Download = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  appId: ProtoField(2, ScalarType.UINT32),
  busId: ProtoField(3, ScalarType.UINT32),
  fileId: ProtoField(4, ScalarType.STRING)
};
const OidbSvcTrpcTcp0x6D6Delete = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  busId: ProtoField(3, ScalarType.UINT32),
  fileId: ProtoField(5, ScalarType.STRING)
};
const OidbSvcTrpcTcp0x6D6Rename = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  busId: ProtoField(3, ScalarType.UINT32),
  fileId: ProtoField(4, ScalarType.STRING),
  parentFolder: ProtoField(5, ScalarType.STRING),
  newFileName: ProtoField(6, ScalarType.STRING)
};
const OidbSvcTrpcTcp0x6D6Move = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  appId: ProtoField(2, ScalarType.UINT32),
  busId: ProtoField(3, ScalarType.UINT32),
  fileId: ProtoField(4, ScalarType.STRING),
  parentDirectory: ProtoField(5, ScalarType.STRING),
  targetDirectory: ProtoField(6, ScalarType.STRING)
};
const OidbSvcTrpcTcp0x6D6Response = {
  upload: ProtoField(1, () => OidbSvcTrpcTcp0x6D6_0Response),
  download: ProtoField(3, () => OidbSvcTrpcTcp0x6D6_2Response),
  delete: ProtoField(4, () => OidbSvcTrpcTcp0x6D6_3_4_5Response),
  rename: ProtoField(5, () => OidbSvcTrpcTcp0x6D6_3_4_5Response),
  move: ProtoField(6, () => OidbSvcTrpcTcp0x6D6_3_4_5Response)
};
const OidbSvcTrpcTcp0x6D6_0Response = {
  retCode: ProtoField(1, ScalarType.INT32),
  retMsg: ProtoField(2, ScalarType.STRING),
  clientWording: ProtoField(3, ScalarType.STRING),
  uploadIp: ProtoField(4, ScalarType.STRING),
  serverDns: ProtoField(5, ScalarType.STRING),
  busId: ProtoField(6, ScalarType.INT32),
  fileId: ProtoField(7, ScalarType.STRING),
  checkKey: ProtoField(8, ScalarType.BYTES),
  fileKey: ProtoField(9, ScalarType.BYTES),
  boolFileExist: ProtoField(10, ScalarType.BOOL),
  uploadIpLanV4: ProtoField(12, ScalarType.STRING, false, true),
  uploadIpLanV6: ProtoField(13, ScalarType.STRING, false, true),
  uploadPort: ProtoField(14, ScalarType.UINT32)
};
const OidbSvcTrpcTcp0x6D6_2Response = {
  retCode: ProtoField(1, ScalarType.INT32),
  retMsg: ProtoField(2, ScalarType.STRING),
  clientWording: ProtoField(3, ScalarType.STRING),
  downloadIp: ProtoField(4, ScalarType.STRING),
  downloadDns: ProtoField(5, ScalarType.STRING),
  downloadUrl: ProtoField(6, ScalarType.BYTES),
  fileSha1: ProtoField(7, ScalarType.BYTES),
  fileSha3: ProtoField(8, ScalarType.BYTES),
  fileMd5: ProtoField(9, ScalarType.BYTES),
  cookieVal: ProtoField(10, ScalarType.BYTES),
  saveFileName: ProtoField(11, ScalarType.STRING),
  previewPort: ProtoField(12, ScalarType.UINT32)
};
const OidbSvcTrpcTcp0x6D6_3_4_5Response = {
  retCode: ProtoField(1, ScalarType.INT32),
  retMsg: ProtoField(2, ScalarType.STRING),
  clientWording: ProtoField(3, ScalarType.STRING)
};

const OidbSvcTrpcTcp0X8FC_2_Body = {
  targetUid: ProtoField(1, ScalarType.STRING),
  specialTitle: ProtoField(5, ScalarType.STRING),
  expiredTime: ProtoField(6, ScalarType.SINT32),
  uinName: ProtoField(7, ScalarType.STRING),
  targetName: ProtoField(8, ScalarType.STRING)
};
const OidbSvcTrpcTcp0X8FC_2 = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  body: ProtoField(3, ScalarType.BYTES)
};

const OidbSvcTrpcTcp0X9067_202 = {
  ReqHead: ProtoField(1, () => MultiMediaReqHead),
  DownloadRKeyReq: ProtoField(4, () => OidbSvcTrpcTcp0X9067_202Key)
};
const OidbSvcTrpcTcp0X9067_202Key = {
  key: ProtoField(1, ScalarType.INT32, false, true)
};
const OidbSvcTrpcTcp0X9067_202_RkeyList = {
  rkey: ProtoField(1, ScalarType.STRING),
  ttl: ProtoField(2, ScalarType.UINT64),
  time: ProtoField(4, ScalarType.UINT32),
  type: ProtoField(5, ScalarType.UINT32)
};
const OidbSvcTrpcTcp0X9067_202_Data = {
  rkeyList: ProtoField(1, () => OidbSvcTrpcTcp0X9067_202_RkeyList, false, true)
};
const OidbSvcTrpcTcp0X9067_202_Rsp_Body = {
  data: ProtoField(4, () => OidbSvcTrpcTcp0X9067_202_Data)
};

const OidbSvcTrpcTcp0X929D_0 = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  chatType: ProtoField(2, ScalarType.UINT32)
};
const OidbSvcTrpcTcp0X929D_0Resp = {
  content: ProtoField(1, () => OidbSvcTrpcTcp0X929D_0RespContent, false, true)
};
const OidbSvcTrpcTcp0X929D_0RespContent = {
  category: ProtoField(1, ScalarType.STRING),
  voices: ProtoField(2, () => OidbSvcTrpcTcp0X929D_0RespContentVoice, false, true)
};
const OidbSvcTrpcTcp0X929D_0RespContentVoice = {
  voiceId: ProtoField(1, ScalarType.STRING),
  voiceDisplayName: ProtoField(2, ScalarType.STRING),
  voiceExampleUrl: ProtoField(3, ScalarType.STRING)
};
const OidbSvcTrpcTcp0X929B_0 = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  voiceId: ProtoField(2, ScalarType.STRING),
  text: ProtoField(3, ScalarType.STRING),
  chatType: ProtoField(4, ScalarType.UINT32),
  session: ProtoField(5, () => OidbSvcTrpcTcp0X929B_0_Session)
};
const OidbSvcTrpcTcp0X929B_0_Session = {
  sessionId: ProtoField(1, ScalarType.UINT32)
};
const OidbSvcTrpcTcp0X929B_0Resp = {
  statusCode: ProtoField(1, ScalarType.UINT32),
  field2: ProtoField(2, ScalarType.UINT32, true),
  field3: ProtoField(3, ScalarType.UINT32),
  msgInfo: ProtoField(4, () => MsgInfo, true)
};

const OidbSvcTrpcTcp0XE37_1200 = {
  subCommand: ProtoField(1, ScalarType.UINT32, true),
  field2: ProtoField(2, ScalarType.INT32, true),
  body: ProtoField(14, () => OidbSvcTrpcTcp0XE37_1200Body, true),
  field101: ProtoField(101, ScalarType.INT32, true),
  field102: ProtoField(102, ScalarType.INT32, true),
  field200: ProtoField(200, ScalarType.INT32, true),
  field99999: ProtoField(99999, ScalarType.BYTES, true)
};
const OidbSvcTrpcTcp0XE37_1200Body = {
  receiverUid: ProtoField(10, ScalarType.STRING, true),
  fileUuid: ProtoField(20, ScalarType.STRING, true),
  type: ProtoField(30, ScalarType.INT32, true),
  fileHash: ProtoField(60, ScalarType.STRING, true),
  t2: ProtoField(601, ScalarType.INT32, true)
};
const OidbSvcTrpcTcp0XE37_1200Response = {
  command: ProtoField(1, ScalarType.UINT32, true),
  subCommand: ProtoField(2, ScalarType.UINT32, true),
  body: ProtoField(14, () => OidbSvcTrpcTcp0XE37_1200ResponseBody, true),
  field50: ProtoField(50, ScalarType.UINT32, true)
};
const OidbSvcTrpcTcp0XE37_1200ResponseBody = {
  field10: ProtoField(10, ScalarType.UINT32, true),
  state: ProtoField(20, ScalarType.STRING, true),
  result: ProtoField(30, () => OidbSvcTrpcTcp0XE37_1200Result, true),
  metadata: ProtoField(40, () => OidbSvcTrpcTcp0XE37_800_1200Metadata, true)
};
const OidbSvcTrpcTcp0XE37_1200Result = {
  server: ProtoField(20, ScalarType.STRING, true),
  port: ProtoField(40, ScalarType.UINT32, true),
  url: ProtoField(50, ScalarType.STRING, true),
  additionalServer: ProtoField(60, ScalarType.STRING, false, true),
  ssoPort: ProtoField(80, ScalarType.UINT32, true),
  ssoUrl: ProtoField(90, ScalarType.STRING, true),
  extra: ProtoField(120, ScalarType.BYTES, true)
};
const OidbSvcTrpcTcp0XE37_800_1200Metadata = {
  uin: ProtoField(1, ScalarType.UINT32, true),
  field2: ProtoField(2, ScalarType.UINT32, true),
  field3: ProtoField(3, ScalarType.UINT32, true),
  size: ProtoField(4, ScalarType.UINT32, true),
  timestamp: ProtoField(5, ScalarType.UINT32, true),
  fileUuid: ProtoField(6, ScalarType.STRING, true),
  fileName: ProtoField(7, ScalarType.STRING, true),
  field100: ProtoField(100, ScalarType.BYTES, true),
  field101: ProtoField(101, ScalarType.BYTES, true),
  field110: ProtoField(110, ScalarType.UINT32, true),
  timestamp1: ProtoField(130, ScalarType.UINT32, true),
  fileHash: ProtoField(140, ScalarType.STRING, true),
  field141: ProtoField(141, ScalarType.BYTES, true),
  field142: ProtoField(142, ScalarType.BYTES, true)
};

const OidbSvcTrpcTcp0XE37_1700 = {
  command: ProtoField(1, ScalarType.UINT32, true),
  seq: ProtoField(2, ScalarType.INT32, true),
  upload: ProtoField(19, () => ApplyUploadReqV3, true),
  businessId: ProtoField(101, ScalarType.INT32, true),
  clientType: ProtoField(102, ScalarType.INT32, true),
  flagSupportMediaPlatform: ProtoField(200, ScalarType.INT32, true)
};
const ApplyUploadReqV3 = {
  senderUid: ProtoField(10, ScalarType.STRING, true),
  receiverUid: ProtoField(20, ScalarType.STRING, true),
  fileSize: ProtoField(30, ScalarType.UINT32, true),
  fileName: ProtoField(40, ScalarType.STRING, true),
  md510MCheckSum: ProtoField(50, ScalarType.BYTES, true),
  sha1CheckSum: ProtoField(60, ScalarType.BYTES, true),
  localPath: ProtoField(70, ScalarType.STRING, true),
  md5CheckSum: ProtoField(110, ScalarType.BYTES, true),
  sha3CheckSum: ProtoField(120, ScalarType.BYTES, true)
};

const OidbSvcTrpcTcp0XE37_800 = {
  subCommand: ProtoField(1, ScalarType.UINT32),
  field2: ProtoField(2, ScalarType.INT32),
  body: ProtoField(10, () => OidbSvcTrpcTcp0XE37_800Body, true),
  field101: ProtoField(101, ScalarType.INT32),
  field102: ProtoField(102, ScalarType.INT32),
  field200: ProtoField(200, ScalarType.INT32)
};
const OidbSvcTrpcTcp0XE37_800Body = {
  senderUid: ProtoField(10, ScalarType.STRING, true),
  receiverUid: ProtoField(20, ScalarType.STRING, true),
  fileUuid: ProtoField(30, ScalarType.STRING, true),
  fileHash: ProtoField(40, ScalarType.STRING, true)
};
const OidbSvcTrpcTcp0XE37Response = {
  command: ProtoField(1, ScalarType.UINT32),
  seq: ProtoField(2, ScalarType.INT32),
  upload: ProtoField(19, () => ApplyUploadRespV3, true),
  businessId: ProtoField(101, ScalarType.INT32),
  clientType: ProtoField(102, ScalarType.INT32),
  flagSupportMediaPlatform: ProtoField(200, ScalarType.INT32)
};
const ApplyUploadRespV3 = {
  retCode: ProtoField(10, ScalarType.INT32),
  retMsg: ProtoField(20, ScalarType.STRING, true),
  totalSpace: ProtoField(30, ScalarType.INT64),
  usedSpace: ProtoField(40, ScalarType.INT64),
  uploadedSize: ProtoField(50, ScalarType.INT64),
  uploadIp: ProtoField(60, ScalarType.STRING, true),
  uploadDomain: ProtoField(70, ScalarType.STRING, true),
  uploadPort: ProtoField(80, ScalarType.UINT32),
  uuid: ProtoField(90, ScalarType.STRING, true),
  uploadKey: ProtoField(100, ScalarType.BYTES, true),
  boolFileExist: ProtoField(110, ScalarType.BOOL),
  packSize: ProtoField(120, ScalarType.INT32),
  uploadIpList: ProtoField(130, ScalarType.STRING, false, true),
  // repeated
  uploadHttpsPort: ProtoField(140, ScalarType.INT32),
  uploadHttpsDomain: ProtoField(150, ScalarType.STRING, true),
  uploadDns: ProtoField(160, ScalarType.STRING, true),
  uploadLanip: ProtoField(170, ScalarType.STRING, true),
  fileAddon: ProtoField(200, ScalarType.STRING, true),
  mediaPlatformUploadKey: ProtoField(220, ScalarType.BYTES, true)
};
({
  command: ProtoField(1, ScalarType.UINT32, true),
  subCommand: ProtoField(2, ScalarType.UINT32, true),
  body: ProtoField(10, () => OidbSvcTrpcTcp0XE37_800ResponseBody, true),
  field50: ProtoField(50, ScalarType.UINT32, true)
});
const OidbSvcTrpcTcp0XE37_800ResponseBody = {
  field10: ProtoField(10, ScalarType.UINT32, true),
  field30: ProtoField(30, () => OidbSvcTrpcTcp0XE37_800_1200Metadata, true)
};

const OidbSvcTrpcTcp0XEB7_Body = {
  uin: ProtoField(1, ScalarType.STRING),
  groupUin: ProtoField(2, ScalarType.STRING),
  version: ProtoField(3, ScalarType.STRING)
};
const OidbSvcTrpcTcp0XEB7 = {
  body: ProtoField(2, () => OidbSvcTrpcTcp0XEB7_Body)
};

const OidbSvcTrpcTcp0XED3_1 = {
  uin: ProtoField(1, ScalarType.UINT32),
  groupUin: ProtoField(2, ScalarType.UINT32),
  friendUin: ProtoField(5, ScalarType.UINT32),
  ext: ProtoField(6, ScalarType.UINT32, true)
};

const OidbSvcTrpcTcp0XFE1_2 = {
  uin: ProtoField(1, ScalarType.UINT32),
  key: ProtoField(3, () => OidbSvcTrpcTcp0XFE1_2Key, false, true)
};
const OidbSvcTrpcTcp0XFE1_2Key = {
  key: ProtoField(1, ScalarType.UINT32)
};
const OidbSvcTrpcTcp0XFE1_2RSP_Status = {
  key: ProtoField(1, ScalarType.UINT32),
  value: ProtoField(2, ScalarType.UINT64)
};
const OidbSvcTrpcTcp0XFE1_2RSP_Data = {
  status: ProtoField(2, () => OidbSvcTrpcTcp0XFE1_2RSP_Status)
};
const OidbSvcTrpcTcp0XFE1_2RSP = {
  data: ProtoField(1, () => OidbSvcTrpcTcp0XFE1_2RSP_Data)
};

const OidbSvcTrpcTcpBase = {
  command: ProtoField(1, ScalarType.UINT32),
  subCommand: ProtoField(2, ScalarType.UINT32),
  errorCode: ProtoField(3, ScalarType.UINT32),
  body: ProtoField(4, ScalarType.BYTES),
  errorMsg: ProtoField(5, ScalarType.STRING, true),
  isReserved: ProtoField(12, ScalarType.UINT32)
};
({
  body: ProtoField(4, ScalarType.BYTES)
});

class IHighwayUploader {
  trans;
  logger;
  constructor(trans, logger) {
    this.trans = trans;
    this.logger = logger;
  }
  encryptTransExt(key) {
    if (!this.trans.encrypt) return;
    this.trans.ext = encrypt(Buffer.from(this.trans.ext), Buffer.from(key));
  }
  timeout() {
    return new Promise((_, reject) => {
      setTimeout(
        () => {
          reject(new Error(`[Highway] timeout after ${this.trans.timeout}s`));
        },
        (this.trans.timeout ?? Infinity) * 1e3
      );
    });
  }
  buildPicUpHead(offset, bodyLength, bodyMd5) {
    return new NapProtoMsg(ReqDataHighwayHead).encode({
      msgBaseHead: {
        version: 1,
        uin: this.trans.uin,
        command: "PicUp.DataUp",
        seq: 0,
        retryTimes: 0,
        appId: 1600001604,
        dataFlag: 16,
        commandId: this.trans.cmd
      },
      msgSegHead: {
        serviceId: 0,
        filesize: BigInt(this.trans.size),
        dataOffset: BigInt(offset),
        dataLength: bodyLength,
        serviceTicket: this.trans.ticket,
        md5: bodyMd5,
        fileMd5: this.trans.sum,
        cacheAddr: 0,
        cachePort: 0
      },
      bytesReqExtendInfo: this.trans.ext,
      timestamp: BigInt(0),
      msgLoginSigHead: {
        uint32LoginSigType: 8,
        appId: 1600001604
      }
    });
  }
}

class HighwayTcpUploaderTransform extends stream__default.Transform {
  uploader;
  offset;
  constructor(uploader) {
    super();
    this.uploader = uploader;
    this.offset = 0;
  }
  _transform(data, _, callback) {
    let chunkOffset = 0;
    while (chunkOffset < data.length) {
      const chunkSize = Math.min(BlockSize, data.length - chunkOffset);
      const chunk = data.subarray(chunkOffset, chunkOffset + chunkSize);
      const chunkMd5 = crypto__default$1.createHash("md5").update(chunk).digest();
      const head = this.uploader.buildPicUpHead(this.offset, chunk.length, chunkMd5);
      chunkOffset += chunk.length;
      this.offset += chunk.length;
      this.push(Frame.pack(Buffer.from(head), chunk));
    }
    callback(null);
  }
}
class HighwayTcpUploader extends IHighwayUploader {
  async upload() {
    const controller = new AbortController();
    const { signal } = controller;
    const upload = new Promise((resolve, reject) => {
      const highwayTransForm = new HighwayTcpUploaderTransform(this);
      const socket = net__default.connect(this.trans.port, this.trans.server, () => {
        this.trans.data.pipe(highwayTransForm).pipe(socket, { end: false });
      });
      const handleRspHeader = (header) => {
        const rsp = new NapProtoMsg(RespDataHighwayHead).decode(header);
        if (rsp.errorCode !== 0) {
          socket.end();
          reject(new Error(`[Highway] tcpUpload failed (code=${rsp.errorCode})`));
        }
        const percent = ((Number(rsp.msgSegHead?.dataOffset) + Number(rsp.msgSegHead?.dataLength)) / Number(rsp.msgSegHead?.filesize)).toFixed(2);
        this.logger.debug(`[Highway] tcpUpload ${rsp.errorCode} | ${percent} | ${Buffer.from(header).toString("hex")}`);
        if (Number(rsp.msgSegHead?.dataOffset) + Number(rsp.msgSegHead?.dataLength) >= Number(rsp.msgSegHead?.filesize)) {
          this.logger.debug("[Highway] tcpUpload finished.");
          socket.end();
          resolve();
        }
      };
      socket.on("data", (chunk) => {
        if (signal.aborted) {
          socket.end();
          reject(new Error("Upload aborted due to timeout"));
        }
        const [head, _] = Frame.unpack(chunk);
        handleRspHeader(head);
      });
      socket.on("close", () => {
        this.logger.debug("[Highway] tcpUpload socket closed.");
        resolve();
      });
      socket.on("error", (err) => {
        socket.end();
        reject(new Error(`[Highway] tcpUpload socket.on error: ${err}`));
      });
      this.trans.data.on("error", (err) => {
        socket.end();
        reject(new Error(`[Highway] tcpUpload readable error: ${err}`));
      });
    });
    const timeout = this.timeout().catch((err) => {
      controller.abort();
      throw new Error(err.message);
    });
    await Promise.race([upload, timeout]);
  }
}

class HighwayHttpUploader extends IHighwayUploader {
  async upload() {
    const controller = new AbortController();
    const { signal } = controller;
    const upload = (async () => {
      let offset = 0;
      for await (const chunk of this.trans.data) {
        if (signal.aborted) {
          throw new Error("Upload aborted due to timeout");
        }
        const block = chunk;
        try {
          await this.uploadBlock(block, offset);
        } catch (err) {
          throw new Error(`[Highway] httpUpload Error uploading block at offset ${offset}: ${err}`);
        }
        offset += block.length;
      }
    })();
    const timeout = this.timeout().catch((err) => {
      controller.abort();
      throw new Error(err.message);
    });
    await Promise.race([upload, timeout]);
  }
  async uploadBlock(block, offset) {
    const chunkMD5 = crypto__default$1.createHash("md5").update(block).digest();
    const payload = this.buildPicUpHead(offset, block.length, chunkMD5);
    const frame = Frame.pack(Buffer.from(payload), block);
    const resp = await this.httpPostHighwayContent(frame, `http://${this.trans.server}:${this.trans.port}/cgi-bin/httpconn?htcmd=0x6FF0087&uin=${this.trans.uin}`);
    const [head, body] = Frame.unpack(resp);
    const headData = new NapProtoMsg(RespDataHighwayHead).decode(head);
    this.logger.debug(`[Highway] httpUploadBlock: ${headData.errorCode} | ${headData.msgSegHead?.retCode} | ${headData.bytesRspExtendInfo} | ${head.toString("hex")} | ${body.toString("hex")}`);
    if (headData.errorCode !== 0) throw new Error(`[Highway] httpUploadBlock failed (code=${headData.errorCode})`);
  }
  async httpPostHighwayContent(frame, serverURL) {
    return new Promise((resolve, reject) => {
      try {
        const options = {
          method: "POST",
          headers: {
            "Connection": "keep-alive",
            "Accept-Encoding": "identity",
            "User-Agent": "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2)",
            "Content-Length": frame.length.toString()
          }
        };
        const req = http.request(serverURL, options, (res) => {
          const data = [];
          res.on("data", (chunk) => {
            data.push(chunk);
          });
          res.on("end", () => {
            resolve(Buffer.concat(data));
          });
        });
        req.write(frame);
        req.on("error", (error) => {
          reject(error);
        });
      } catch (error) {
        reject(new Error(error.message));
      }
    });
  }
}

class PacketHighwayClient {
  sig;
  server = "htdata3.qq.com";
  port = 80;
  logger;
  constructor(sig, logger, server = "htdata3.qq.com", port = 80) {
    this.sig = sig;
    this.logger = logger;
  }
  changeServer(server, port) {
    this.server = server;
    this.port = port;
  }
  buildDataUpTrans(cmd, data, fileSize, md5, extendInfo, timeout = 1200) {
    return {
      uin: this.sig.uin,
      cmd,
      command: "PicUp.DataUp",
      data,
      sum: md5,
      size: fileSize,
      ticket: this.sig.sigSession,
      ext: extendInfo,
      encrypt: false,
      timeout,
      server: this.server,
      port: this.port
    };
  }
  async upload(cmd, data, fileSize, md5, extendInfo) {
    const trans = this.buildDataUpTrans(cmd, data, fileSize, md5, extendInfo);
    try {
      const tcpUploader = new HighwayTcpUploader(trans, this.logger);
      await tcpUploader.upload();
    } catch (e) {
      this.logger.error(`[Highway] upload failed: ${e}, fallback to http upload`);
      try {
        const httpUploader = new HighwayHttpUploader(trans, this.logger);
        await httpUploader.upload();
      } catch (e2) {
        this.logger.error(`[Highway] http upload failed: ${e2}`);
        throw e2;
      }
    }
  }
}

class ForwardMsgBuilder {
  static build(resId, msg, source, news, summary, prompt) {
    const id = crypto.randomUUID();
    const isGroupMsg = msg.some((m) => m.isGroupMsg);
    if (!source) {
      source = isGroupMsg ? "群聊的聊天记录" : msg.map((m) => m.senderName).filter((v, i, a) => a.indexOf(v) === i).slice(0, 4).join("和") + "的聊天记录";
    }
    if (!news) {
      news = msg.length === 0 ? [{
        text: "Nya~ This message is send from NapCat.Packet!"
      }] : msg.map((m) => ({
        text: `${m.senderName}: ${m.msg?.map((msg2) => msg2.preview).join("")}`
      }));
    }
    if (!summary) {
      summary = `查看${msg.length}条转发消息`;
    }
    if (!prompt) {
      prompt = "[聊天记录]";
    }
    return {
      app: "com.tencent.multimsg",
      config: {
        autosize: 1,
        forward: 1,
        round: 1,
        type: "normal",
        width: 300
      },
      desc: prompt,
      extra: {
        filename: id,
        tsum: msg.length
      },
      meta: {
        detail: {
          news,
          resid: resId,
          source,
          summary,
          uniseq: id
        }
      },
      prompt,
      ver: "0.0.0.5",
      view: "contact"
    };
  }
  static fromResId(resId) {
    return this.build(resId, []);
  }
  static fromPacketMsg(resId, packetMsg, source, news, summary, prompt) {
    return this.build(resId, packetMsg.map((msg) => ({
      senderName: msg.senderName,
      isGroupMsg: msg.groupId !== void 0,
      msg: msg.msg.map((m) => ({
        preview: m.valid ? m.toPreview() : "[该消息类型暂不支持查看]"
      }))
    })), source, news, summary, prompt);
  }
}

class IPacketMsgElement {
  constructor(rawElement) {
  }
  get valid() {
    return true;
  }
  buildContent() {
    return void 0;
  }
  buildElement() {
    return [];
  }
  toPreview() {
    return "[暂不支持该消息类型喵~]";
  }
}
class PacketMsgTextElement extends IPacketMsgElement {
  text;
  constructor(element) {
    super(element);
    this.text = element.textElement.content;
  }
  buildElement() {
    return [{
      text: {
        str: this.text
      }
    }];
  }
  toPreview() {
    return this.text;
  }
}
class PacketMsgAtElement extends PacketMsgTextElement {
  targetUid;
  atAll;
  constructor(element) {
    super(element);
    this.targetUid = element.textElement.atNtUid;
    this.atAll = element.textElement.atType === NTMsgAtType.ATTYPEALL;
  }
  buildElement() {
    return [{
      text: {
        str: this.text,
        pbReserve: new NapProtoMsg(MentionExtra).encode(
          {
            type: this.atAll ? 1 : 2,
            uin: 0,
            field5: 0,
            uid: this.targetUid
          }
        )
      }
    }];
  }
}
class PacketMsgReplyElement extends IPacketMsgElement {
  messageId;
  messageSeq;
  messageClientSeq;
  targetUin;
  targetUid;
  time;
  elems;
  constructor(element) {
    super(element);
    this.messageId = BigInt(element.replyElement.replayMsgId ?? 0);
    this.messageSeq = +(element.replyElement.replayMsgSeq ?? 0);
    this.messageClientSeq = +(element.replyElement.replyMsgClientSeq ?? 0);
    this.targetUin = +(element.replyElement.senderUin ?? 0);
    this.targetUid = element.replyElement.senderUidStr ?? "";
    this.time = +(element.replyElement.replyMsgTime ?? 0);
    this.elems = [];
  }
  get isGroupReply() {
    return this.messageClientSeq !== 0;
  }
  buildElement() {
    return [{
      srcMsg: {
        origSeqs: [this.isGroupReply ? this.messageClientSeq : this.messageSeq],
        senderUin: BigInt(this.targetUin),
        time: this.time,
        elems: [],
        // TODO: in replyElement.sourceMsgTextElems
        pbReserve: {
          messageId: this.messageId
        },
        toUin: BigInt(0)
      }
    }, {
      text: this.isGroupReply ? {
        str: "nya~",
        pbReserve: new NapProtoMsg(MentionExtra).encode({
          type: this.targetUin === 0 ? 1 : 2,
          uin: 0,
          field5: 0,
          uid: String(this.targetUid)
        })
      } : void 0
    }];
  }
  toPreview() {
    return "[回复消息]";
  }
}
class PacketMsgFaceElement extends IPacketMsgElement {
  faceId;
  isLargeFace;
  constructor(element) {
    super(element);
    this.faceId = element.faceElement.faceIndex;
    this.isLargeFace = element.faceElement.faceType === FaceType.AniSticke;
  }
  buildElement() {
    if (this.isLargeFace) {
      return [{
        commonElem: {
          serviceType: 37,
          pbElem: new NapProtoMsg(QBigFaceExtra).encode({
            aniStickerPackId: "1",
            aniStickerId: "8",
            faceId: this.faceId,
            field4: 1,
            field6: "",
            preview: "",
            field9: 1
          }),
          businessType: 1
        }
      }];
    } else if (this.faceId < 260) {
      return [{
        face: {
          index: this.faceId
        }
      }];
    } else {
      return [{
        commonElem: {
          serviceType: 33,
          pbElem: new NapProtoMsg(QSmallFaceExtra).encode({
            faceId: this.faceId,
            preview: "",
            preview2: ""
          }),
          businessType: 1
        }
      }];
    }
  }
  toPreview() {
    return "[表情]";
  }
}
class PacketMsgMarkFaceElement extends IPacketMsgElement {
  emojiName;
  emojiId;
  emojiPackageId;
  emojiKey;
  constructor(element) {
    super(element);
    this.emojiName = element.marketFaceElement.faceName;
    this.emojiId = element.marketFaceElement.emojiId;
    this.emojiPackageId = element.marketFaceElement.emojiPackageId;
    this.emojiKey = element.marketFaceElement.key;
  }
  buildElement() {
    return [{
      marketFace: {
        faceName: this.emojiName,
        itemType: 6,
        faceInfo: 1,
        faceId: Buffer.from(this.emojiId, "hex"),
        tabId: this.emojiPackageId,
        subType: 3,
        key: this.emojiKey,
        imageWidth: 300,
        imageHeight: 300,
        pbReserve: {
          field8: 1
        }
      }
    }];
  }
  toPreview() {
    return `${this.emojiName}`;
  }
}
class PacketMsgPicElement extends IPacketMsgElement {
  path;
  name;
  size;
  md5;
  width;
  height;
  picType;
  sha1 = null;
  msgInfo = null;
  groupPicExt = null;
  c2cPicExt = null;
  constructor(element) {
    super(element);
    this.path = element.picElement.sourcePath;
    this.name = element.picElement.fileName;
    this.size = +element.picElement.fileSize;
    this.md5 = element.picElement.md5HexStr ?? "";
    this.width = element.picElement.picWidth;
    this.height = element.picElement.picHeight;
    this.picType = element.picElement.picType;
  }
  get valid() {
    return !!this.msgInfo;
  }
  buildElement() {
    if (!this.msgInfo) return [];
    return [{
      commonElem: {
        serviceType: 48,
        pbElem: new NapProtoMsg(MsgInfo).encode(this.msgInfo),
        businessType: 10
      }
    }];
  }
  toPreview() {
    return "[图片]";
  }
}
class PacketMsgVideoElement extends IPacketMsgElement {
  fileSize;
  filePath;
  thumbSize;
  thumbPath;
  fileMd5;
  fileSha1;
  thumbMd5;
  thumbSha1;
  thumbWidth;
  thumbHeight;
  msgInfo = null;
  constructor(element) {
    super(element);
    this.fileSize = element.videoElement.fileSize;
    this.filePath = element.videoElement.filePath;
    this.thumbSize = element.videoElement.thumbSize;
    this.thumbPath = element.videoElement.thumbPath?.get(0);
    this.fileMd5 = element.videoElement.videoMd5;
    this.thumbMd5 = element.videoElement.thumbMd5;
    this.thumbWidth = element.videoElement.thumbWidth;
    this.thumbHeight = element.videoElement.thumbHeight;
  }
  get valid() {
    return !!this.msgInfo;
  }
  buildElement() {
    if (!this.msgInfo) return [];
    return [{
      commonElem: {
        serviceType: 48,
        pbElem: new NapProtoMsg(MsgInfo).encode(this.msgInfo),
        businessType: 21
      }
    }];
  }
  toPreview() {
    return "[视频]";
  }
}
class PacketMsgPttElement extends IPacketMsgElement {
  filePath;
  fileSize;
  fileMd5;
  fileSha1;
  fileDuration;
  msgInfo = null;
  constructor(element) {
    super(element);
    this.filePath = element.pttElement.filePath;
    this.fileSize = +element.pttElement.fileSize;
    this.fileMd5 = element.pttElement.md5HexStr;
    this.fileDuration = Math.round(element.pttElement.duration);
  }
  get valid() {
    return false;
  }
  buildElement() {
    return [];
  }
  toPreview() {
    return "[语音]";
  }
}
class PacketMsgFileElement extends IPacketMsgElement {
  fileName;
  filePath;
  fileSize;
  fileSha1;
  fileMd5;
  fileUuid;
  fileHash;
  isGroupFile;
  _private_send_uid;
  _private_recv_uid;
  _e37_800_rsp;
  constructor(element) {
    super(element);
    this.fileName = element.fileElement.fileName;
    this.filePath = element.fileElement.filePath;
    this.fileSize = +element.fileElement.fileSize;
  }
  get valid() {
    return this.isGroupFile || Boolean(this._e37_800_rsp);
  }
  buildContent() {
    if (this.isGroupFile || !this._e37_800_rsp) return void 0;
    return new NapProtoMsg(FileExtra).encode({
      file: {
        fileType: 0,
        fileUuid: this.fileUuid,
        fileMd5: this.fileMd5,
        fileName: this.fileName,
        fileSize: BigInt(this.fileSize),
        subcmd: 1,
        dangerEvel: 0,
        expireTime: Math.floor(Date.now() / 1e3) + 7 * 24 * 60 * 60,
        fileHash: this.fileHash
      },
      field6: {
        field2: {
          field1: this._e37_800_rsp?.body?.field30?.field110,
          fileUuid: this.fileUuid,
          fileName: this.fileName,
          field6: this._e37_800_rsp?.body?.field30?.field3,
          field7: this._e37_800_rsp?.body?.field30?.field101,
          field8: this._e37_800_rsp?.body?.field30?.field100,
          timestamp1: this._e37_800_rsp?.body?.field30?.timestamp1,
          fileHash: this.fileHash,
          selfUid: this._private_send_uid,
          destUid: this._private_recv_uid
        }
      }
    });
  }
  buildElement() {
    if (!this.isGroupFile) return [];
    const lb = Buffer.alloc(2);
    const transElemVal = new NapProtoMsg(GroupFileExtra).encode({
      field1: 6,
      fileName: this.fileName,
      inner: {
        info: {
          busId: 102,
          fileId: this.fileUuid,
          fileSize: BigInt(this.fileSize),
          fileName: this.fileName,
          fileSha: this.fileSha1,
          extInfoString: "",
          fileMd5: this.fileMd5
        }
      }
    });
    lb.writeUInt16BE(transElemVal.length);
    return [{
      transElem: {
        elemType: 24,
        elemValue: Buffer.concat([Buffer.from([1]), lb, transElemVal])
        // TLV
      }
    }];
  }
  toPreview() {
    return `[文件]${this.fileName}`;
  }
}
class PacketMsgLightAppElement extends IPacketMsgElement {
  payload;
  constructor(element) {
    super(element);
    this.payload = element.arkElement.bytesData;
  }
  buildElement() {
    return [{
      lightAppElem: {
        data: Buffer.concat([
          Buffer.from([1]),
          zlib.deflateSync(Buffer.from(this.payload, "utf-8"))
        ])
      }
    }];
  }
  toPreview() {
    return "[卡片消息]";
  }
}
class PacketMsgMarkDownElement extends IPacketMsgElement {
  content;
  constructor(element) {
    super(element);
    this.content = element.markdownElement.content;
  }
  buildElement() {
    return [{
      commonElem: {
        serviceType: 45,
        pbElem: new NapProtoMsg(MarkdownData).encode({
          content: this.content
        }),
        businessType: 1
      }
    }];
  }
  toPreview() {
    return `[Markdown消息 ${this.content}]`;
  }
}
class PacketMultiMsgElement extends IPacketMsgElement {
  resid;
  message;
  constructor(rawElement, message) {
    super(rawElement);
    this.resid = rawElement.structLongMsgElement.resId;
    this.message = message ?? [];
  }
  buildElement() {
    return [{
      lightAppElem: {
        data: Buffer.concat([
          Buffer.from([1]),
          zlib.deflateSync(Buffer.from(JSON.stringify(ForwardMsgBuilder.fromPacketMsg(this.resid, this.message)), "utf-8"))
        ])
      }
    }];
  }
  toPreview() {
    return "[聊天记录]";
  }
}

class PacketMsgBuilder {
  static failBackText = new PacketMsgTextElement(
    {
      textElement: { content: "[该消息类型暂不支持查看]" }
    }
  );
  buildFakeMsg(selfUid, element) {
    return element.map((node) => {
      const avatar = `https://q.qlogo.cn/headimg_dl?dst_uin=${node.senderUin}&spec=640&img_type=jpg`;
      const msgContent = node.msg.reduceRight((acc, msg) => {
        return acc ?? msg.buildContent();
      }, void 0);
      const msgElement = node.msg.flatMap((msg) => msg.buildElement() ?? []);
      if (!msgContent && !msgElement.length) {
        msgElement.push(PacketMsgBuilder.failBackText.buildElement());
      }
      return {
        responseHead: {
          fromUid: "",
          fromUin: node.senderUin,
          toUid: node.groupId ? void 0 : selfUid,
          forward: node.groupId ? void 0 : {
            friendName: node.senderName
          },
          grp: node.groupId ? {
            groupUin: node.groupId,
            memberName: node.senderName,
            unknown5: 2
          } : void 0
        },
        contentHead: {
          type: node.groupId ? 82 : 9,
          subType: node.groupId ? void 0 : 4,
          divSeq: node.groupId ? void 0 : 4,
          msgId: crypto$1.randomBytes(4).readUInt32LE(0),
          sequence: crypto$1.randomBytes(4).readUInt32LE(0),
          timeStamp: +node.time.toString().substring(0, 10),
          field7: BigInt(1),
          field8: 0,
          field9: 0,
          forward: {
            field1: 0,
            field2: 0,
            field3: node.groupId ? 0 : 2,
            unknownBase64: avatar,
            avatar
          }
        },
        body: {
          richText: {
            elems: msgElement
          },
          msgContent
        }
      };
    });
  }
}

const PacketHexStrBuilder = (str) => {
  return Buffer.from(str).toString("hex");
};
class PacketTransformer {
  msgBuilder;
  constructor() {
    this.msgBuilder = new PacketMsgBuilder();
  }
}

class FetchSessionKey extends PacketTransformer {
  constructor() {
    super();
  }
  build() {
    const req = new NapProtoMsg(HttpConn0x6ff_501).encode({
      httpConn: {
        field1: 0,
        field2: 0,
        field3: 16,
        field4: 1,
        field6: 3,
        serviceTypes: [1, 5, 10, 21],
        // tgt: "",  // TODO: do we really need tgt? seems not
        field9: 2,
        field10: 9,
        field11: 8,
        ver: "1.0.1"
      }
    });
    return {
      cmd: "HttpConn.0x6ff_501",
      data: PacketHexStrBuilder(req)
    };
  }
  parse(data) {
    return new NapProtoMsg(HttpConn0x6ff_501Response).decode(data);
  }
}
const FetchSessionKey$1 = new FetchSessionKey();

const int32ip2str = (ip) => {
  ip = ip & 4294967295;
  return [ip & 255, (ip & 65280) >> 8, (ip & 16711680) >> 16, (ip & 4278190080) >> 24 & 255].join(".");
};
const oidbIpv4s2HighwayIpv4s = (ipv4s) => {
  return ipv4s.map((ip) => {
    return {
      domain: {
        isEnable: true,
        ip: int32ip2str(ip.outIP ?? 0)
      },
      port: ip.outPort
    };
  });
};

class Sha1Stream {
  Sha1BlockSize = 64;
  Sha1DigestSize = 20;
  _padding = Buffer.concat([Buffer.from([128]), Buffer.alloc(63)]);
  _state = new Uint32Array(5);
  _count = new Uint32Array(2);
  _buffer = Buffer.allocUnsafe(this.Sha1BlockSize);
  _w = new Uint32Array(80);
  constructor() {
    this.reset();
  }
  reset() {
    this._state[0] = 1732584193;
    this._state[1] = 4023233417;
    this._state[2] = 2562383102;
    this._state[3] = 271733878;
    this._state[4] = 3285377520;
    this._count[0] = 0;
    this._count[1] = 0;
    this._buffer.fill(0);
  }
  rotateLeft(v, o) {
    return (v << o | v >>> 32 - o) >>> 0;
  }
  transform(chunk, offset) {
    const w = this._w;
    const view = new DataView(chunk.buffer, chunk.byteOffset + offset, 64);
    for (let i = 0; i < 16; i++) {
      w[i] = view.getUint32(i * 4, false);
    }
    for (let i = 16; i < 80; i++) {
      w[i] = this.rotateLeft(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16], 1) >>> 0;
    }
    let a = this._state[0];
    let b = this._state[1];
    let c = this._state[2];
    let d = this._state[3];
    let e = this._state[4];
    for (let i = 0; i < 80; i++) {
      let temp;
      if (i < 20) {
        temp = (b & c | ~b & d) + 1518500249;
      } else if (i < 40) {
        temp = (b ^ c ^ d) + 1859775393;
      } else if (i < 60) {
        temp = (b & c | b & d | c & d) + 2400959708;
      } else {
        temp = (b ^ c ^ d) + 3395469782;
      }
      temp += this.rotateLeft(a, 5) + e + w[i] >>> 0;
      e = d;
      d = c;
      c = this.rotateLeft(b, 30) >>> 0;
      b = a;
      a = temp;
    }
    this._state[0] = this._state[0] + a >>> 0;
    this._state[1] = this._state[1] + b >>> 0;
    this._state[2] = this._state[2] + c >>> 0;
    this._state[3] = this._state[3] + d >>> 0;
    this._state[4] = this._state[4] + e >>> 0;
  }
  update(data, len) {
    let index = (this._count[0] >>> 3 & 63) >>> 0;
    const dataLen = len ?? data.length;
    this._count[0] = this._count[0] + (dataLen << 3) >>> 0;
    if (this._count[0] < dataLen << 3) this._count[1] = this._count[1] + 1 >>> 0;
    this._count[1] = this._count[1] + (dataLen >>> 29) >>> 0;
    const partLen = this.Sha1BlockSize - index >>> 0;
    let i = 0;
    if (dataLen >= partLen) {
      data.copy(this._buffer, index, 0, partLen);
      this.transform(this._buffer, 0);
      for (i = partLen; i + this.Sha1BlockSize <= dataLen; i = i + this.Sha1BlockSize >>> 0) {
        this.transform(data, i);
      }
      index = 0;
    }
    data.copy(this._buffer, index, i, dataLen);
  }
  hash(bigEndian = true) {
    const digest = Buffer.allocUnsafe(this.Sha1DigestSize);
    if (bigEndian) {
      for (let i = 0; i < 5; i++) digest.writeUInt32BE(this._state[i], i * 4);
    } else {
      for (let i = 0; i < 5; i++) digest.writeUInt32LE(this._state[i], i * 4);
    }
    return digest;
  }
  final() {
    const digest = Buffer.allocUnsafe(this.Sha1DigestSize);
    const bits = Buffer.allocUnsafe(8);
    bits.writeUInt32BE(this._count[1], 0);
    bits.writeUInt32BE(this._count[0], 4);
    const index = (this._count[0] >>> 3 & 63) >>> 0;
    const padLen = (index < 56 ? 56 - index : 120 - index) >>> 0;
    this.update(this._padding, padLen);
    this.update(bits);
    for (let i = 0; i < 5; i++) {
      digest.writeUInt32BE(this._state[i], i * 4);
    }
    return digest;
  }
}

class CalculateStreamBytesTransform extends stream$1.Transform {
  blockSize = 1024 * 1024;
  sha1;
  buffer;
  bytesRead;
  byteArrayList;
  constructor() {
    super();
    this.sha1 = new Sha1Stream();
    this.buffer = Buffer.alloc(0);
    this.bytesRead = 0;
    this.byteArrayList = [];
  }
  _transform(chunk, _, callback) {
    try {
      this.buffer = Buffer.concat([this.buffer, chunk]);
      let offset = 0;
      while (this.buffer.length - offset >= this.sha1.Sha1BlockSize) {
        const block = this.buffer.subarray(offset, offset + this.sha1.Sha1BlockSize);
        this.sha1.update(block);
        offset += this.sha1.Sha1BlockSize;
        this.bytesRead += this.sha1.Sha1BlockSize;
        if (this.bytesRead % this.blockSize === 0) {
          const digest = this.sha1.hash(false);
          this.byteArrayList.push(Buffer.from(digest));
        }
      }
      this.buffer = this.buffer.subarray(offset);
      callback(null);
    } catch (err) {
      callback(err);
    }
  }
  _flush(callback) {
    try {
      if (this.buffer.length > 0) this.sha1.update(this.buffer);
      const finalDigest = this.sha1.final();
      this.byteArrayList.push(Buffer.from(finalDigest));
      for (const digest of this.byteArrayList) {
        this.push(digest);
      }
      callback(null);
    } catch (err) {
      callback(err);
    }
  }
}

function sha1Stream(readable) {
  return new Promise((resolve, reject) => {
    readable.on("error", reject);
    readable.pipe(crypto$1.createHash("sha1").on("error", reject).on("data", resolve));
  });
}
function md5Stream(readable) {
  return new Promise((resolve, reject) => {
    readable.on("error", reject);
    readable.pipe(crypto$1.createHash("md5").on("error", reject).on("data", resolve));
  });
}
function calculateSha1(filePath) {
  const readable = fs.createReadStream(filePath);
  return sha1Stream(readable);
}
function computeMd5AndLengthWithLimit(filePath, limit) {
  const readStream = fs.createReadStream(filePath, limit ? { start: 0, end: limit - 1 } : {});
  return md5Stream(readStream);
}
function calculateSha1StreamBytes(filePath) {
  return new Promise((resolve, reject) => {
    const readable = fs.createReadStream(filePath);
    const calculateStreamBytes = new CalculateStreamBytesTransform();
    const byteArrayList = [];
    calculateStreamBytes.on("data", (chunk) => {
      byteArrayList.push(chunk);
    });
    calculateStreamBytes.on("end", () => {
      resolve(byteArrayList);
    });
    calculateStreamBytes.on("error", (err) => {
      reject(err);
    });
    readable.pipe(calculateStreamBytes);
  });
}

class OidbBase extends PacketTransformer {
  constructor() {
    super();
  }
  build(cmd, subCmd, body, isUid = true, isLafter = false) {
    const data = new NapProtoMsg(OidbSvcTrpcTcpBase).encode({
      command: cmd,
      subCommand: subCmd,
      body,
      isReserved: isUid ? 1 : 0
    });
    return {
      cmd: `OidbSvcTrpcTcp.0x${cmd.toString(16).toUpperCase()}_${subCmd}`,
      data: PacketHexStrBuilder(data)
    };
  }
  parse(data) {
    const res = new NapProtoMsg(OidbSvcTrpcTcpBase).decode(data);
    if (res.errorCode !== 0) {
      throw new Error(`OidbSvcTrpcTcpBase parse error: ${res.errorMsg} (code=${res.errorCode})`);
    }
    return res;
  }
}
const OidbBase$1 = new OidbBase();

class UploadGroupImage extends PacketTransformer {
  constructor() {
    super();
  }
  build(groupUin, img) {
    const data = new NapProtoMsg(NTV2RichMediaReq).encode(
      {
        reqHead: {
          common: {
            requestId: 1,
            command: 100
          },
          scene: {
            requestType: 2,
            businessType: 1,
            sceneType: 2,
            group: {
              groupUin
            }
          },
          client: {
            agentType: 2
          }
        },
        upload: {
          uploadInfo: [
            {
              fileInfo: {
                fileSize: +img.size,
                fileHash: img.md5,
                fileSha1: img.sha1,
                fileName: img.name,
                type: {
                  type: 1,
                  picFormat: img.picType,
                  //TODO: extend NapCat imgType /cc @MliKiowa
                  videoFormat: 0,
                  voiceFormat: 0
                },
                width: img.width,
                height: img.height,
                time: 0,
                original: 1
              },
              subFileType: 0
            }
          ],
          tryFastUploadCompleted: true,
          srvSendMsg: false,
          clientRandomId: crypto__default$1.randomBytes(8).readBigUInt64BE() & BigInt("0x7FFFFFFFFFFFFFFF"),
          compatQMsgSceneType: 2,
          extBizInfo: {
            pic: {
              bytesPbReserveTroop: Buffer.from("0800180020004200500062009201009a0100a2010c080012001800200028003a00", "hex"),
              textSummary: "Nya~"
              // TODO:
            },
            video: {
              bytesPbReserve: Buffer.alloc(0)
            },
            ptt: {
              bytesPbReserve: Buffer.alloc(0),
              bytesReserve: Buffer.alloc(0),
              bytesGeneralFlags: Buffer.alloc(0)
            }
          },
          clientSeq: 0,
          noNeedCompatMsg: false
        }
      }
    );
    return OidbBase$1.build(4548, 100, data, true, false);
  }
  parse(data) {
    const oidbBody = OidbBase$1.parse(data).body;
    return new NapProtoMsg(NTV2RichMediaResp).decode(oidbBody);
  }
}
const UploadGroupImage$1 = new UploadGroupImage();

class FetchAiVoiceList extends PacketTransformer {
  constructor() {
    super();
  }
  build(groupUin, chatType) {
    const data = new NapProtoMsg(OidbSvcTrpcTcp0X929D_0).encode({
      groupUin,
      chatType
    });
    return OidbBase$1.build(37533, 0, data);
  }
  parse(data) {
    const oidbBody = OidbBase$1.parse(data).body;
    return new NapProtoMsg(OidbSvcTrpcTcp0X929D_0Resp).decode(oidbBody);
  }
}
const FetchAiVoiceList$1 = new FetchAiVoiceList();

class GetAiVoice extends PacketTransformer {
  constructor() {
    super();
  }
  build(groupUin, voiceId, text, sessionId, chatType) {
    const data = new NapProtoMsg(OidbSvcTrpcTcp0X929B_0).encode({
      groupUin,
      voiceId,
      text,
      chatType,
      session: {
        sessionId
      }
    });
    return OidbBase$1.build(37531, 0, data);
  }
  parse(data) {
    const oidbBody = OidbBase$1.parse(data).body;
    return new NapProtoMsg(OidbSvcTrpcTcp0X929B_0Resp).decode(oidbBody);
  }
}
const GetAiVoice$1 = new GetAiVoice();

class GetMiniAppAdaptShareInfo extends PacketTransformer {
  constructor() {
    super();
  }
  build(req) {
    const data = new NapProtoMsg(MiniAppAdaptShareInfoReq).encode({
      appId: req.sdkId,
      body: {
        extInfo: {
          field2: Buffer.alloc(0)
        },
        appid: req.appId,
        title: req.title,
        desc: req.desc,
        time: BigInt(Date.now()),
        scene: req.scene,
        templateType: req.templateType,
        businessType: req.businessType,
        picUrl: req.picUrl,
        vidUrl: "",
        jumpUrl: req.jumpUrl,
        iconUrl: req.iconUrl,
        verType: req.verType,
        shareType: req.shareType,
        versionId: req.versionId,
        withShareTicket: req.withShareTicket,
        webURL: "",
        appidRich: Buffer.alloc(0),
        template: {
          templateId: "",
          templateData: ""
        },
        field20: ""
      }
    });
    return {
      cmd: "LightAppSvc.mini_app_share.AdaptShareInfo",
      data: PacketHexStrBuilder(data)
    };
  }
  parse(data) {
    return new NapProtoMsg(MiniAppAdaptShareInfoResp).decode(data);
  }
}
const GetMiniAppAdaptShareInfo$1 = new GetMiniAppAdaptShareInfo();

class GroupSign extends PacketTransformer {
  constructor() {
    super();
  }
  build(uin, groupCode) {
    const body = new NapProtoMsg(OidbSvcTrpcTcp0XEB7).encode(
      {
        body: {
          uin: String(uin),
          groupUin: String(groupCode),
          version: "9.0.90"
        }
      }
    );
    return OidbBase$1.build(3767, 1, body, false, false);
  }
  parse(data) {
    return OidbBase$1.parse(data);
  }
}
const GroupSign$1 = new GroupSign();

class GetStrangerInfo extends PacketTransformer {
  constructor() {
    super();
  }
  build(uin) {
    const body = new NapProtoMsg(OidbSvcTrpcTcp0XFE1_2).encode({
      uin,
      key: [{ key: 27372 }]
    });
    return OidbBase$1.build(4065, 2, body);
  }
  parse(data) {
    const oidbBody = OidbBase$1.parse(data).body;
    return new NapProtoMsg(OidbSvcTrpcTcp0XFE1_2RSP).decode(oidbBody);
  }
}
const GetStrangerInfo$1 = new GetStrangerInfo();

class SendPoke extends PacketTransformer {
  constructor() {
    super();
  }
  build(peer, group) {
    const data = new NapProtoMsg(OidbSvcTrpcTcp0XED3_1).encode({
      uin: peer,
      groupUin: group,
      friendUin: group ?? peer,
      ext: 0
    });
    return OidbBase$1.build(3795, 1, data);
  }
  parse(data) {
    return OidbBase$1.parse(data);
  }
}
const SendPoke$1 = new SendPoke();

class SetSpecialTitle extends PacketTransformer {
  constructor() {
    super();
  }
  build(groupCode, uid, tittle) {
    const oidb_0x8FC_2_body = new NapProtoMsg(OidbSvcTrpcTcp0X8FC_2_Body).encode({
      targetUid: uid,
      specialTitle: tittle,
      expiredTime: -1,
      uinName: tittle
    });
    const oidb_0x8FC_2 = new NapProtoMsg(OidbSvcTrpcTcp0X8FC_2).encode({
      groupUin: +groupCode,
      body: oidb_0x8FC_2_body
    });
    return OidbBase$1.build(2300, 2, oidb_0x8FC_2, false, false);
  }
  parse(data) {
    return OidbBase$1.parse(data);
  }
}
const SetSpecialTitle$1 = new SetSpecialTitle();

class DownloadGroupFile extends PacketTransformer {
  constructor() {
    super();
  }
  build(groupUin, fileUUID) {
    const body = new NapProtoMsg(OidbSvcTrpcTcp0x6D6).encode({
      download: {
        groupUin,
        appId: 7,
        busId: 102,
        fileId: fileUUID
      }
    });
    return OidbBase$1.build(1750, 2, body, true, false);
  }
  parse(data) {
    const oidbBody = OidbBase$1.parse(data).body;
    const res = new NapProtoMsg(OidbSvcTrpcTcp0x6D6Response).decode(oidbBody);
    if (res.download.retCode !== 0) {
      throw new Error(`sendGroupFileDownloadReq error: ${res.download.clientWording} (code=${res.download.retCode})`);
    }
    return res;
  }
}
const DownloadGroupFile$1 = new DownloadGroupFile();

class DownloadGroupPtt extends PacketTransformer {
  constructor() {
    super();
  }
  build(groupUin, node) {
    const body = new NapProtoMsg(NTV2RichMediaReq).encode({
      reqHead: {
        common: {
          requestId: 4,
          command: 200
        },
        scene: {
          requestType: 1,
          businessType: 3,
          sceneType: 2,
          group: {
            groupUin
          }
        },
        client: {
          agentType: 2
        }
      },
      download: {
        node,
        download: {
          video: {
            busiType: 0,
            sceneType: 0
          }
        }
      }
    });
    return OidbBase$1.build(4718, 200, body, true, false);
  }
  parse(data) {
    const oidbBody = OidbBase$1.parse(data).body;
    return new NapProtoMsg(NTV2RichMediaResp).decode(oidbBody);
  }
}
const DownloadGroupPtt$1 = new DownloadGroupPtt();

class DownloadOfflineFile extends PacketTransformer {
  constructor() {
    super();
  }
  build(fileUUID, fileHash, senderUid, receiverUid) {
    const body = new NapProtoMsg(OidbSvcTrpcTcp0XE37_800).encode({
      subCommand: 800,
      field2: 0,
      body: {
        senderUid,
        receiverUid,
        fileUuid: fileUUID,
        fileHash
      },
      field101: 3,
      field102: 1,
      field200: 1
    });
    return OidbBase$1.build(3639, 800, body, false, false);
  }
  // TODO:check
  parse(data) {
    const oidbBody = OidbBase$1.parse(data).body;
    return new NapProtoMsg(OidbSvcTrpcTcp0XE37Response).decode(oidbBody);
  }
}
const DownloadOfflineFile$1 = new DownloadOfflineFile();

class DownloadPrivateFile extends PacketTransformer {
  constructor() {
    super();
  }
  build(selfUid, fileUUID, fileHash) {
    const body = new NapProtoMsg(OidbSvcTrpcTcp0XE37_1200).encode({
      subCommand: 1200,
      field2: 1,
      body: {
        receiverUid: selfUid,
        fileUuid: fileUUID,
        type: 2,
        fileHash,
        t2: 0
      },
      field101: 3,
      field102: 103,
      field200: 1,
      field99999: Buffer.from([192, 133, 44, 1])
    });
    return OidbBase$1.build(3639, 1200, body, false, false);
  }
  parse(data) {
    const oidbBody = OidbBase$1.parse(data).body;
    return new NapProtoMsg(OidbSvcTrpcTcp0XE37_1200Response).decode(oidbBody);
  }
}
new DownloadPrivateFile();

class UploadGroupFile extends PacketTransformer {
  constructor() {
    super();
  }
  build(groupUin, file) {
    const body = new NapProtoMsg(OidbSvcTrpcTcp0x6D6).encode({
      file: {
        groupUin,
        appId: 4,
        busId: 102,
        entrance: 6,
        targetDirectory: "/",
        // TODO:
        fileName: file.fileName,
        localDirectory: `/${file.fileName}`,
        fileSize: BigInt(file.fileSize),
        fileMd5: file.fileMd5,
        fileSha1: file.fileSha1,
        fileSha3: Buffer.alloc(0),
        field15: true
      }
    });
    return OidbBase$1.build(1750, 0, body, true, false);
  }
  parse(data) {
    const oidbBody = OidbBase$1.parse(data).body;
    return new NapProtoMsg(OidbSvcTrpcTcp0x6D6Response).decode(oidbBody);
  }
}
const UploadGroupFile$1 = new UploadGroupFile();

class UploadGroupPtt extends PacketTransformer {
  constructor() {
    super();
  }
  build(groupUin, ptt) {
    const data = new NapProtoMsg(NTV2RichMediaReq).encode({
      reqHead: {
        common: {
          requestId: 1,
          command: 100
        },
        scene: {
          requestType: 2,
          businessType: 3,
          sceneType: 2,
          group: {
            groupUin
          }
        },
        client: {
          agentType: 2
        }
      },
      upload: {
        uploadInfo: [
          {
            fileInfo: {
              fileSize: ptt.fileSize,
              fileHash: ptt.fileMd5,
              fileSha1: ptt.fileSha1,
              fileName: `${ptt.fileMd5}.amr`,
              type: {
                type: 3,
                picFormat: 0,
                videoFormat: 0,
                voiceFormat: 1
              },
              height: 0,
              width: 0,
              time: ptt.fileDuration,
              original: 0
            },
            subFileType: 0
          }
        ],
        tryFastUploadCompleted: true,
        srvSendMsg: false,
        clientRandomId: crypto__default$1.randomBytes(8).readBigUInt64BE() & BigInt("0x7FFFFFFFFFFFFFFF"),
        compatQMsgSceneType: 2,
        extBizInfo: {
          pic: {
            textSummary: "Nya~"
          },
          video: {
            bytesPbReserve: Buffer.alloc(0)
          },
          ptt: {
            bytesPbReserve: Buffer.alloc(0),
            bytesReserve: Buffer.from([8, 0, 56, 0]),
            bytesGeneralFlags: Buffer.from([154, 1, 7, 170, 3, 4, 8, 8, 18, 0])
          }
        },
        clientSeq: 0,
        noNeedCompatMsg: false
      }
    });
    return OidbBase$1.build(4718, 100, data, true, false);
  }
  parse(data) {
    const oidbBody = OidbBase$1.parse(data).body;
    return new NapProtoMsg(NTV2RichMediaResp).decode(oidbBody);
  }
}
const UploadGroupPtt$1 = new UploadGroupPtt();

class UploadGroupVideo extends PacketTransformer {
  constructor() {
    super();
  }
  build(groupUin, video) {
    if (!video.fileSize || !video.thumbSize) throw new Error("video.fileSize or video.thumbSize is empty");
    const data = new NapProtoMsg(NTV2RichMediaReq).encode({
      reqHead: {
        common: {
          requestId: 3,
          command: 100
        },
        scene: {
          requestType: 2,
          businessType: 2,
          sceneType: 2,
          group: {
            groupUin
          }
        },
        client: {
          agentType: 2
        }
      },
      upload: {
        uploadInfo: [
          {
            fileInfo: {
              fileSize: +video.fileSize,
              fileHash: video.fileMd5,
              fileSha1: video.fileSha1,
              fileName: "nya.mp4",
              type: {
                type: 2,
                picFormat: 0,
                videoFormat: 0,
                voiceFormat: 0
              },
              height: 0,
              width: 0,
              time: 0,
              original: 0
            },
            subFileType: 0
          },
          {
            fileInfo: {
              fileSize: +video.thumbSize,
              fileHash: video.thumbMd5,
              fileSha1: video.thumbSha1,
              fileName: "nya.jpg",
              type: {
                type: 1,
                picFormat: 0,
                videoFormat: 0,
                voiceFormat: 0
              },
              height: video.thumbHeight,
              width: video.thumbWidth,
              time: 0,
              original: 0
            },
            subFileType: 100
          }
        ],
        tryFastUploadCompleted: true,
        srvSendMsg: false,
        clientRandomId: crypto__default$1.randomBytes(8).readBigUInt64BE() & BigInt("0x7FFFFFFFFFFFFFFF"),
        compatQMsgSceneType: 2,
        extBizInfo: {
          pic: {
            bizType: 0,
            textSummary: "Nya~"
          },
          video: {
            bytesPbReserve: Buffer.from([128, 1, 0])
          },
          ptt: {
            bytesPbReserve: Buffer.alloc(0),
            bytesReserve: Buffer.alloc(0),
            bytesGeneralFlags: Buffer.alloc(0)
          }
        },
        clientSeq: 0,
        noNeedCompatMsg: false
      }
    });
    return OidbBase$1.build(4586, 100, data, true, false);
  }
  parse(data) {
    const oidbBody = OidbBase$1.parse(data).body;
    return new NapProtoMsg(NTV2RichMediaResp).decode(oidbBody);
  }
}
const UploadGroupVideo$1 = new UploadGroupVideo();

class UploadPrivateFile extends PacketTransformer {
  constructor() {
    super();
  }
  async build(selfUid, peerUid, file) {
    const body = new NapProtoMsg(OidbSvcTrpcTcp0XE37_1700).encode({
      command: 1700,
      seq: 0,
      upload: {
        senderUid: selfUid,
        receiverUid: peerUid,
        fileSize: file.fileSize,
        fileName: file.fileName,
        md510MCheckSum: await computeMd5AndLengthWithLimit(file.filePath, 10 * 1024 * 1024),
        sha1CheckSum: file.fileSha1,
        localPath: "/",
        md5CheckSum: file.fileMd5,
        sha3CheckSum: Buffer.alloc(0)
      },
      businessId: 3,
      clientType: 1,
      flagSupportMediaPlatform: 1
    });
    return OidbBase$1.build(3639, 1700, body, false, false);
  }
  parse(data) {
    const oidbBody = OidbBase$1.parse(data).body;
    return new NapProtoMsg(OidbSvcTrpcTcp0XE37Response).decode(oidbBody);
  }
}
const UploadPrivateFile$1 = new UploadPrivateFile();

class UploadPrivateImage extends PacketTransformer {
  constructor() {
    super();
  }
  build(peerUin, img) {
    const data = new NapProtoMsg(NTV2RichMediaReq).encode(
      {
        reqHead: {
          common: {
            requestId: 1,
            command: 100
          },
          scene: {
            requestType: 2,
            businessType: 1,
            sceneType: 1,
            c2C: {
              accountType: 2,
              targetUid: peerUin
            }
          },
          client: {
            agentType: 2
          }
        },
        upload: {
          uploadInfo: [
            {
              fileInfo: {
                fileSize: +img.size,
                fileHash: img.md5,
                fileSha1: img.sha1,
                fileName: img.name,
                type: {
                  type: 1,
                  picFormat: img.picType,
                  //TODO: extend NapCat imgType /cc @MliKiowa
                  videoFormat: 0,
                  voiceFormat: 0
                },
                width: img.width,
                height: img.height,
                time: 0,
                original: 1
              },
              subFileType: 0
            }
          ],
          tryFastUploadCompleted: true,
          srvSendMsg: false,
          clientRandomId: crypto__default$1.randomBytes(8).readBigUInt64BE() & BigInt("0x7FFFFFFFFFFFFFFF"),
          compatQMsgSceneType: 1,
          extBizInfo: {
            pic: {
              bytesPbReserveTroop: Buffer.from("0800180020004200500062009201009a0100a2010c080012001800200028003a00", "hex"),
              textSummary: "Nya~"
              // TODO:
            },
            video: {
              bytesPbReserve: Buffer.alloc(0)
            },
            ptt: {
              bytesPbReserve: Buffer.alloc(0),
              bytesReserve: Buffer.alloc(0),
              bytesGeneralFlags: Buffer.alloc(0)
            }
          },
          clientSeq: 0,
          noNeedCompatMsg: false
        }
      }
    );
    return OidbBase$1.build(4549, 100, data, true, false);
  }
  parse(data) {
    const oidbBody = OidbBase$1.parse(data).body;
    return new NapProtoMsg(NTV2RichMediaResp).decode(oidbBody);
  }
}
const UploadPrivateImage$1 = new UploadPrivateImage();

class UploadPrivatePtt extends PacketTransformer {
  constructor() {
    super();
  }
  build(peerUin, ptt) {
    const data = new NapProtoMsg(NTV2RichMediaReq).encode({
      reqHead: {
        common: {
          requestId: 4,
          command: 100
        },
        scene: {
          requestType: 2,
          businessType: 3,
          sceneType: 1,
          c2C: {
            accountType: 2,
            targetUid: peerUin
          }
        },
        client: {
          agentType: 2
        }
      },
      upload: {
        uploadInfo: [
          {
            fileInfo: {
              fileSize: ptt.fileSize,
              fileHash: ptt.fileMd5,
              fileSha1: ptt.fileSha1,
              fileName: `${ptt.fileMd5}.amr`,
              type: {
                type: 3,
                picFormat: 0,
                videoFormat: 0,
                voiceFormat: 1
              },
              height: 0,
              width: 0,
              time: ptt.fileDuration,
              original: 0
            },
            subFileType: 0
          }
        ],
        tryFastUploadCompleted: true,
        srvSendMsg: false,
        clientRandomId: crypto__default$1.randomBytes(8).readBigUInt64BE() & BigInt("0x7FFFFFFFFFFFFFFF"),
        compatQMsgSceneType: 1,
        extBizInfo: {
          pic: {
            textSummary: "Nya~"
          },
          ptt: {
            bytesReserve: Buffer.from([8, 0, 56, 0]),
            bytesGeneralFlags: Buffer.from([154, 1, 11, 170, 3, 8, 8, 4, 18, 4, 0, 0, 0, 0])
          }
        },
        clientSeq: 0,
        noNeedCompatMsg: false
      }
    });
    return OidbBase$1.build(4717, 100, data, true, false);
  }
  parse(data) {
    const oidbBody = OidbBase$1.parse(data).body;
    return new NapProtoMsg(NTV2RichMediaResp).decode(oidbBody);
  }
}
const UploadPrivatePtt$1 = new UploadPrivatePtt();

class UploadPrivateVideo extends PacketTransformer {
  constructor() {
    super();
  }
  build(peerUin, video) {
    if (!video.fileSize || !video.thumbSize) throw new Error("video.fileSize or video.thumbSize is empty");
    const data = new NapProtoMsg(NTV2RichMediaReq).encode({
      reqHead: {
        common: {
          requestId: 3,
          command: 100
        },
        scene: {
          requestType: 2,
          businessType: 2,
          sceneType: 1,
          c2C: {
            accountType: 2,
            targetUid: peerUin
          }
        },
        client: {
          agentType: 2
        }
      },
      upload: {
        uploadInfo: [
          {
            fileInfo: {
              fileSize: +video.fileSize,
              fileHash: video.fileMd5,
              fileSha1: video.fileSha1,
              fileName: "nya.mp4",
              type: {
                type: 2,
                picFormat: 0,
                videoFormat: 0,
                voiceFormat: 0
              },
              height: 0,
              width: 0,
              time: 0,
              original: 0
            },
            subFileType: 0
          },
          {
            fileInfo: {
              fileSize: +video.thumbSize,
              fileHash: video.thumbMd5,
              fileSha1: video.thumbSha1,
              fileName: "nya.jpg",
              type: {
                type: 1,
                picFormat: 0,
                videoFormat: 0,
                voiceFormat: 0
              },
              height: video.thumbHeight,
              width: video.thumbWidth,
              time: 0,
              original: 0
            },
            subFileType: 100
          }
        ],
        tryFastUploadCompleted: true,
        srvSendMsg: false,
        clientRandomId: crypto__default$1.randomBytes(8).readBigUInt64BE() & BigInt("0x7FFFFFFFFFFFFFFF"),
        compatQMsgSceneType: 2,
        extBizInfo: {
          pic: {
            bizType: 0,
            textSummary: "Nya~"
          },
          video: {
            bytesPbReserve: Buffer.from([128, 1, 0])
          },
          ptt: {
            bytesPbReserve: Buffer.alloc(0),
            bytesReserve: Buffer.alloc(0),
            bytesGeneralFlags: Buffer.alloc(0)
          }
        },
        clientSeq: 0,
        noNeedCompatMsg: false
      }
    });
    return OidbBase$1.build(4585, 100, data, true, false);
  }
  parse(data) {
    const oidbBody = OidbBase$1.parse(data).body;
    return new NapProtoMsg(NTV2RichMediaResp).decode(oidbBody);
  }
}
const UploadPrivateVideo$1 = new UploadPrivateVideo();

class UploadForwardMsg extends PacketTransformer {
  constructor() {
    super();
  }
  build(selfUid, msg, groupUin = 0) {
    const msgBody = this.msgBuilder.buildFakeMsg(selfUid, msg);
    const longMsgResultData = new NapProtoMsg(LongMsgResult).encode(
      {
        action: {
          actionCommand: "MultiMsg",
          actionData: {
            msgBody
          }
        }
      }
    );
    const payload = zlib__default.gzipSync(Buffer.from(longMsgResultData));
    const req = new NapProtoMsg(SendLongMsgReq).encode(
      {
        info: {
          type: groupUin === 0 ? 1 : 3,
          uid: {
            uid: groupUin === 0 ? selfUid : groupUin.toString()
          },
          groupUin,
          payload
        },
        settings: {
          field1: 4,
          field2: 1,
          field3: 7,
          field4: 0
        }
      }
    );
    return {
      cmd: "trpc.group.long_msg_interface.MsgService.SsoSendLongMsg",
      data: PacketHexStrBuilder(req)
    };
  }
  parse(data) {
    return new NapProtoMsg(SendLongMsgResp).decode(data);
  }
}
const UploadForwardMsg$1 = new UploadForwardMsg();

class FetchRkey extends PacketTransformer {
  constructor() {
    super();
  }
  build() {
    const data = new NapProtoMsg(OidbSvcTrpcTcp0X9067_202).encode({
      reqHead: {
        common: {
          requestId: 1,
          command: 202
        },
        scene: {
          requestType: 2,
          businessType: 1,
          sceneType: 0
        },
        client: {
          agentType: 2
        }
      },
      downloadRKeyReq: {
        key: [10, 20, 2]
      }
    });
    return OidbBase$1.build(36967, 202, data);
  }
  parse(data) {
    const oidbBody = OidbBase$1.parse(data).body;
    return new NapProtoMsg(OidbSvcTrpcTcp0X9067_202_Rsp_Body).decode(oidbBody);
  }
}
const FetchRkey$1 = new FetchRkey();

const BlockSize = 1024 * 1024;
class PacketHighwayContext {
  context;
  sig;
  logger;
  hwClient;
  cachedPrepareReq = null;
  constructor(context) {
    this.context = context;
    this.sig = {
      uin: String(context.napcore.basicInfo.uin),
      uid: context.napcore.basicInfo.uid,
      sigSession: null,
      sessionKey: null,
      serverAddr: []
    };
    this.logger = context.logger;
    this.hwClient = new PacketHighwayClient(this.sig, context.logger);
  }
  async checkAvailable() {
    if (this.sig.sigSession === null || this.sig.sessionKey === null) {
      if (this.cachedPrepareReq === null) {
        this.cachedPrepareReq = this.prepareUpload().finally(() => {
          this.cachedPrepareReq = null;
        });
      }
      await this.cachedPrepareReq;
    }
  }
  async prepareUpload() {
    this.logger.debug("[Highway] on prepareUpload!");
    const packet = FetchSessionKey$1.build();
    const req = await this.context.client.sendOidbPacket(packet, true);
    const rsp = FetchSessionKey$1.parse(req);
    this.sig.sigSession = rsp.httpConn.sigSession;
    this.sig.sessionKey = rsp.httpConn.sessionKey;
    for (const info of rsp.httpConn.serverInfos) {
      if (info.serviceType !== 1) continue;
      for (const addr of info.serverAddrs) {
        this.logger.debug(`[Highway PrepareUpload] server addr add: ${int32ip2str(addr.ip)}:${addr.port}`);
        this.sig.serverAddr.push({
          ip: int32ip2str(addr.ip),
          port: addr.port
        });
        this.hwClient.changeServer(int32ip2str(addr.ip), addr.port);
      }
    }
    if (this.sig.serverAddr.length === 0) {
      this.logger.warn("[Highway PrepareUpload] server addr is empty!");
    }
  }
  async uploadImage(peer, img) {
    await this.checkAvailable();
    if (peer.chatType === ChatType.KCHATTYPEGROUP) {
      await this.uploadGroupImage(+peer.peerUid, img);
    } else if (peer.chatType === ChatType.KCHATTYPEC2C) {
      await this.uploadC2CImage(peer.peerUid, img);
    } else {
      throw new Error(`[Highway] unsupported chatType: ${peer.chatType}`);
    }
  }
  async uploadVideo(peer, video) {
    await this.checkAvailable();
    if (+(video.fileSize ?? 0) > 1024 * 1024 * 100) {
      throw new Error(`[Highway] 视频文件过大: ${(+(video.fileSize ?? 0) / (1024 * 1024)).toFixed(2)} MB > 100 MB，请使用文件上传！`);
    }
    if (peer.chatType === ChatType.KCHATTYPEGROUP) {
      await this.uploadGroupVideo(+peer.peerUid, video);
    } else if (peer.chatType === ChatType.KCHATTYPEC2C) {
      await this.uploadC2CVideo(peer.peerUid, video);
    } else {
      throw new Error(`[Highway] unsupported chatType: ${peer.chatType}`);
    }
  }
  async uploadPtt(peer, ptt) {
    await this.checkAvailable();
    if (peer.chatType === ChatType.KCHATTYPEGROUP) {
      await this.uploadGroupPtt(+peer.peerUid, ptt);
    } else if (peer.chatType === ChatType.KCHATTYPEC2C) {
      await this.uploadC2CPtt(peer.peerUid, ptt);
    } else {
      throw new Error(`[Highway] unsupported chatType: ${peer.chatType}`);
    }
  }
  async uploadFile(peer, file) {
    await this.checkAvailable();
    if (peer.chatType === ChatType.KCHATTYPEGROUP) {
      await this.uploadGroupFile(+peer.peerUid, file);
    } else if (peer.chatType === ChatType.KCHATTYPEC2C) {
      await this.uploadC2CFile(peer.peerUid, file);
    } else {
      throw new Error(`[Highway] unsupported chatType: ${peer.chatType}`);
    }
  }
  async uploadGroupImage(groupUin, img) {
    img.sha1 = Buffer.from(await calculateSha1(img.path)).toString("hex");
    const req = UploadGroupImage$1.build(groupUin, img);
    const resp = await this.context.client.sendOidbPacket(req, true);
    const preRespData = UploadGroupImage$1.parse(resp);
    const ukey = preRespData.upload.uKey;
    if (ukey && ukey != "") {
      this.logger.debug(`[Highway] uploadGroupImageReq get upload ukey: ${ukey}, need upload!`);
      const index = preRespData.upload.msgInfo.msgInfoBody[0].index;
      const sha1 = Buffer.from(index.info.fileSha1, "hex");
      const md5 = Buffer.from(index.info.fileHash, "hex");
      const extend = new NapProtoMsg(NTV2RichMediaHighwayExt).encode({
        fileUuid: index.fileUuid,
        uKey: ukey,
        network: {
          ipv4S: oidbIpv4s2HighwayIpv4s(preRespData.upload.ipv4S)
        },
        msgInfoBody: preRespData.upload.msgInfo.msgInfoBody,
        blockSize: BlockSize,
        hash: {
          fileSha1: [sha1]
        }
      });
      await this.hwClient.upload(
        1004,
        fs__default.createReadStream(img.path, { highWaterMark: BlockSize }),
        img.size,
        md5,
        extend
      );
    } else {
      this.logger.debug(`[Highway] uploadGroupImageReq get upload invalid ukey ${ukey}, don't need upload!`);
    }
    img.msgInfo = preRespData.upload.msgInfo;
  }
  async uploadC2CImage(peerUid, img) {
    img.sha1 = Buffer.from(await calculateSha1(img.path)).toString("hex");
    const req = UploadPrivateImage$1.build(peerUid, img);
    const resp = await this.context.client.sendOidbPacket(req, true);
    const preRespData = UploadPrivateImage$1.parse(resp);
    const ukey = preRespData.upload.uKey;
    if (ukey && ukey != "") {
      this.logger.debug(`[Highway] uploadC2CImageReq get upload ukey: ${ukey}, need upload!`);
      const index = preRespData.upload.msgInfo.msgInfoBody[0].index;
      const sha1 = Buffer.from(index.info.fileSha1, "hex");
      const md5 = Buffer.from(index.info.fileHash, "hex");
      const extend = new NapProtoMsg(NTV2RichMediaHighwayExt).encode({
        fileUuid: index.fileUuid,
        uKey: ukey,
        network: {
          ipv4S: oidbIpv4s2HighwayIpv4s(preRespData.upload.ipv4S)
        },
        msgInfoBody: preRespData.upload.msgInfo.msgInfoBody,
        blockSize: BlockSize,
        hash: {
          fileSha1: [sha1]
        }
      });
      await this.hwClient.upload(
        1003,
        fs__default.createReadStream(img.path, { highWaterMark: BlockSize }),
        img.size,
        md5,
        extend
      );
    } else {
      this.logger.debug(`[Highway] uploadC2CImageReq get upload invalid ukey ${ukey}, don't need upload!`);
    }
    img.msgInfo = preRespData.upload.msgInfo;
  }
  async uploadGroupVideo(groupUin, video) {
    if (!video.filePath || !video.thumbPath) throw new Error("video.filePath or video.thumbPath is empty");
    video.fileSha1 = Buffer.from(await calculateSha1(video.filePath)).toString("hex");
    video.thumbSha1 = Buffer.from(await calculateSha1(video.thumbPath)).toString("hex");
    const req = UploadGroupVideo$1.build(groupUin, video);
    const resp = await this.context.client.sendOidbPacket(req, true);
    const preRespData = UploadGroupVideo$1.parse(resp);
    const ukey = preRespData.upload.uKey;
    if (ukey && ukey != "") {
      this.logger.debug(`[Highway] uploadGroupVideoReq get upload video ukey: ${ukey}, need upload!`);
      const index = preRespData.upload.msgInfo.msgInfoBody[0].index;
      const md5 = Buffer.from(index.info.fileHash, "hex");
      const extend = new NapProtoMsg(NTV2RichMediaHighwayExt).encode({
        fileUuid: index.fileUuid,
        uKey: ukey,
        network: {
          ipv4S: oidbIpv4s2HighwayIpv4s(preRespData.upload.ipv4S)
        },
        msgInfoBody: preRespData.upload.msgInfo.msgInfoBody,
        blockSize: BlockSize,
        hash: {
          fileSha1: await calculateSha1StreamBytes(video.filePath)
        }
      });
      await this.hwClient.upload(
        1005,
        fs__default.createReadStream(video.filePath, { highWaterMark: BlockSize }),
        +video.fileSize,
        md5,
        extend
      );
    } else {
      this.logger.debug(`[Highway] uploadGroupVideoReq get upload invalid ukey ${ukey}, don't need upload!`);
    }
    const subFile = preRespData.upload.subFileInfos[0];
    if (subFile.uKey && subFile.uKey != "") {
      this.logger.debug(`[Highway] uploadGroupVideoReq get upload video thumb ukey: ${subFile.uKey}, need upload!`);
      const index = preRespData.upload.msgInfo.msgInfoBody[1].index;
      const md5 = Buffer.from(index.info.fileHash, "hex");
      const sha1 = Buffer.from(index.info.fileSha1, "hex");
      const extend = new NapProtoMsg(NTV2RichMediaHighwayExt).encode({
        fileUuid: index.fileUuid,
        uKey: subFile.uKey,
        network: {
          ipv4S: oidbIpv4s2HighwayIpv4s(subFile.ipv4S)
        },
        msgInfoBody: preRespData.upload.msgInfo.msgInfoBody,
        blockSize: BlockSize,
        hash: {
          fileSha1: [sha1]
        }
      });
      await this.hwClient.upload(
        1006,
        fs__default.createReadStream(video.thumbPath, { highWaterMark: BlockSize }),
        +video.thumbSize,
        md5,
        extend
      );
    } else {
      this.logger.debug(`[Highway] uploadGroupVideoReq get upload invalid thumb ukey ${subFile.uKey}, don't need upload!`);
    }
    video.msgInfo = preRespData.upload.msgInfo;
  }
  async uploadC2CVideo(peerUid, video) {
    if (!video.filePath || !video.thumbPath) throw new Error("video.filePath or video.thumbPath is empty");
    video.fileSha1 = Buffer.from(await calculateSha1(video.filePath)).toString("hex");
    video.thumbSha1 = Buffer.from(await calculateSha1(video.thumbPath)).toString("hex");
    const req = UploadPrivateVideo$1.build(peerUid, video);
    const resp = await this.context.client.sendOidbPacket(req, true);
    const preRespData = UploadPrivateVideo$1.parse(resp);
    const ukey = preRespData.upload.uKey;
    if (ukey && ukey != "") {
      this.logger.debug(`[Highway] uploadC2CVideoReq get upload video ukey: ${ukey}, need upload!`);
      const index = preRespData.upload.msgInfo.msgInfoBody[0].index;
      const md5 = Buffer.from(index.info.fileHash, "hex");
      const extend = new NapProtoMsg(NTV2RichMediaHighwayExt).encode({
        fileUuid: index.fileUuid,
        uKey: ukey,
        network: {
          ipv4S: oidbIpv4s2HighwayIpv4s(preRespData.upload.ipv4S)
        },
        msgInfoBody: preRespData.upload.msgInfo.msgInfoBody,
        blockSize: BlockSize,
        hash: {
          fileSha1: await calculateSha1StreamBytes(video.filePath)
        }
      });
      await this.hwClient.upload(
        1001,
        fs__default.createReadStream(video.filePath, { highWaterMark: BlockSize }),
        +video.fileSize,
        md5,
        extend
      );
    } else {
      this.logger.debug(`[Highway] uploadC2CVideoReq get upload invalid ukey ${ukey}, don't need upload!`);
    }
    const subFile = preRespData.upload.subFileInfos[0];
    if (subFile.uKey && subFile.uKey != "") {
      this.logger.debug(`[Highway] uploadC2CVideoReq get upload video thumb ukey: ${subFile.uKey}, need upload!`);
      const index = preRespData.upload.msgInfo.msgInfoBody[1].index;
      const md5 = Buffer.from(index.info.fileHash, "hex");
      const sha1 = Buffer.from(index.info.fileSha1, "hex");
      const extend = new NapProtoMsg(NTV2RichMediaHighwayExt).encode({
        fileUuid: index.fileUuid,
        uKey: subFile.uKey,
        network: {
          ipv4S: oidbIpv4s2HighwayIpv4s(subFile.ipv4S)
        },
        msgInfoBody: preRespData.upload.msgInfo.msgInfoBody,
        blockSize: BlockSize,
        hash: {
          fileSha1: [sha1]
        }
      });
      await this.hwClient.upload(
        1002,
        fs__default.createReadStream(video.thumbPath, { highWaterMark: BlockSize }),
        +video.thumbSize,
        md5,
        extend
      );
    } else {
      this.logger.debug(`[Highway] uploadC2CVideoReq get upload invalid thumb ukey ${subFile.uKey}, don't need upload!`);
    }
    video.msgInfo = preRespData.upload.msgInfo;
  }
  async uploadGroupPtt(groupUin, ptt) {
    ptt.fileSha1 = Buffer.from(await calculateSha1(ptt.filePath)).toString("hex");
    const req = UploadGroupPtt$1.build(groupUin, ptt);
    const resp = await this.context.client.sendOidbPacket(req, true);
    const preRespData = UploadGroupPtt$1.parse(resp);
    const ukey = preRespData.upload.uKey;
    if (ukey && ukey != "") {
      this.logger.debug(`[Highway] uploadGroupPttReq get upload ptt ukey: ${ukey}, need upload!`);
      const index = preRespData.upload.msgInfo.msgInfoBody[0].index;
      const md5 = Buffer.from(index.info.fileHash, "hex");
      const sha1 = Buffer.from(index.info.fileSha1, "hex");
      const extend = new NapProtoMsg(NTV2RichMediaHighwayExt).encode({
        fileUuid: index.fileUuid,
        uKey: ukey,
        network: {
          ipv4S: oidbIpv4s2HighwayIpv4s(preRespData.upload.ipv4S)
        },
        msgInfoBody: preRespData.upload.msgInfo.msgInfoBody,
        blockSize: BlockSize,
        hash: {
          fileSha1: [sha1]
        }
      });
      await this.hwClient.upload(
        1008,
        fs__default.createReadStream(ptt.filePath, { highWaterMark: BlockSize }),
        ptt.fileSize,
        md5,
        extend
      );
    } else {
      this.logger.debug(`[Highway] uploadGroupPttReq get upload invalid ukey ${ukey}, don't need upload!`);
    }
    ptt.msgInfo = preRespData.upload.msgInfo;
  }
  async uploadC2CPtt(peerUid, ptt) {
    ptt.fileSha1 = Buffer.from(await calculateSha1(ptt.filePath)).toString("hex");
    const req = UploadPrivatePtt$1.build(peerUid, ptt);
    const resp = await this.context.client.sendOidbPacket(req, true);
    const preRespData = UploadPrivatePtt$1.parse(resp);
    const ukey = preRespData.upload.uKey;
    if (ukey && ukey != "") {
      this.logger.debug(`[Highway] uploadC2CPttReq get upload ptt ukey: ${ukey}, need upload!`);
      const index = preRespData.upload.msgInfo.msgInfoBody[0].index;
      const md5 = Buffer.from(index.info.fileHash, "hex");
      const sha1 = Buffer.from(index.info.fileSha1, "hex");
      const extend = new NapProtoMsg(NTV2RichMediaHighwayExt).encode({
        fileUuid: index.fileUuid,
        uKey: ukey,
        network: {
          ipv4S: oidbIpv4s2HighwayIpv4s(preRespData.upload.ipv4S)
        },
        msgInfoBody: preRespData.upload.msgInfo.msgInfoBody,
        blockSize: BlockSize,
        hash: {
          fileSha1: [sha1]
        }
      });
      await this.hwClient.upload(
        1007,
        fs__default.createReadStream(ptt.filePath, { highWaterMark: BlockSize }),
        ptt.fileSize,
        md5,
        extend
      );
    } else {
      this.logger.debug(`[Highway] uploadC2CPttReq get upload invalid ukey ${ukey}, don't need upload!`);
    }
    ptt.msgInfo = preRespData.upload.msgInfo;
  }
  async uploadGroupFile(groupUin, file) {
    file.isGroupFile = true;
    file.fileMd5 = await computeMd5AndLengthWithLimit(file.filePath);
    file.fileSha1 = await calculateSha1(file.filePath);
    const req = UploadGroupFile$1.build(groupUin, file);
    const resp = await this.context.client.sendOidbPacket(req, true);
    const preRespData = UploadGroupFile$1.parse(resp);
    if (!preRespData?.upload?.boolFileExist) {
      this.logger.debug(`[Highway] uploadGroupFileReq file not exist, need upload!`);
      const ext = new NapProtoMsg(FileUploadExt).encode({
        unknown1: 100,
        unknown2: 1,
        entry: {
          busiBuff: {
            senderUin: BigInt(this.sig.uin),
            receiverUin: BigInt(groupUin),
            groupCode: BigInt(groupUin)
          },
          fileEntry: {
            fileSize: BigInt(file.fileSize),
            md5: file.fileMd5,
            md5S2: file.fileMd5,
            checkKey: preRespData.upload.checkKey,
            fileId: preRespData.upload.fileId,
            uploadKey: preRespData.upload.fileKey
          },
          clientInfo: {
            clientType: 3,
            appId: "100",
            terminalType: 3,
            clientVer: "1.1.1",
            unknown: 4
          },
          fileNameInfo: {
            fileName: file.fileName
          },
          host: {
            hosts: [
              {
                url: {
                  host: preRespData.upload.uploadIp,
                  unknown: 1
                },
                port: preRespData.upload.uploadPort
              }
            ]
          }
        },
        unknown200: 0
      });
      await this.hwClient.upload(
        71,
        fs__default.createReadStream(file.filePath, { highWaterMark: BlockSize }),
        file.fileSize,
        file.fileMd5,
        ext
      );
    } else {
      this.logger.debug(`[Highway] uploadGroupFileReq file exist, don't need upload!`);
    }
    file.fileUuid = preRespData.upload.fileId;
  }
  async uploadC2CFile(peerUid, file) {
    file.isGroupFile = false;
    file.fileMd5 = await computeMd5AndLengthWithLimit(file.filePath);
    file.fileSha1 = await calculateSha1(file.filePath);
    const req = await UploadPrivateFile$1.build(this.sig.uid, peerUid, file);
    const res = await this.context.client.sendOidbPacket(req, true);
    const preRespData = UploadPrivateFile$1.parse(res);
    if (!preRespData.upload?.boolFileExist) {
      this.logger.debug(`[Highway] uploadC2CFileReq file not exist, need upload!`);
      const ext = new NapProtoMsg(FileUploadExt).encode({
        unknown1: 100,
        unknown2: 1,
        entry: {
          busiBuff: {
            senderUin: BigInt(this.sig.uin)
          },
          fileEntry: {
            fileSize: BigInt(file.fileSize),
            md5: file.fileMd5,
            md5S2: file.fileMd5,
            checkKey: file.fileSha1,
            fileId: preRespData.upload?.uuid,
            uploadKey: preRespData.upload?.mediaPlatformUploadKey
          },
          clientInfo: {
            clientType: 3,
            appId: "100",
            terminalType: 3,
            clientVer: "1.1.1",
            unknown: 4
          },
          fileNameInfo: {
            fileName: file.fileName
          },
          host: {
            hosts: [
              {
                url: {
                  host: preRespData.upload?.uploadIp,
                  unknown: 1
                },
                port: preRespData.upload?.uploadPort
              }
            ]
          }
        },
        unknown200: 1,
        unknown3: 0
      });
      await this.hwClient.upload(
        95,
        fs__default.createReadStream(file.filePath, { highWaterMark: BlockSize }),
        file.fileSize,
        file.fileMd5,
        ext
      );
    }
    file.fileUuid = preRespData.upload?.uuid;
    file.fileHash = preRespData.upload?.fileAddon;
    const fileExistReq = DownloadOfflineFile$1.build(file.fileUuid, file.fileHash, this.sig.uid, peerUid);
    const fileExistRes = await this.context.client.sendOidbPacket(fileExistReq, true);
    file._e37_800_rsp = DownloadOfflineFile$1.parse(fileExistRes);
    file._private_send_uid = this.sig.uid;
    file._private_recv_uid = peerUid;
  }
}

class PacketLogger {
  napLogger;
  constructor(context) {
    this.napLogger = context.napcore.logger;
  }
  _log(level, ...msg) {
    this.napLogger._log(level, "[Core] [Packet] " + msg);
  }
  debug(...msg) {
    this._log(LogLevel.DEBUG, msg);
  }
  info(...msg) {
    this._log(LogLevel.INFO, msg);
  }
  warn(...msg) {
    this._log(LogLevel.WARN, msg);
  }
  error(...msg) {
    this._log(LogLevel.ERROR, msg);
  }
  fatal(...msg) {
    this._log(LogLevel.FATAL, msg);
  }
}

class NapCoreContext {
  core;
  constructor(core) {
    this.core = core;
  }
  get logger() {
    return this.core.context.logger;
  }
  get basicInfo() {
    return {
      uin: +this.core.selfInfo.uin,
      uid: this.core.selfInfo.uid,
      uin2uid: (uin) => this.core.apis.UserApi.getUidByUinV2(String(uin)).then((res) => res ?? ""),
      uid2uin: (uid) => this.core.apis.UserApi.getUinByUidV2(uid).then((res) => +res)
    };
  }
  get config() {
    return this.core.configLoader.configData;
  }
  sendSsoCmdReqByContend = (cmd, trace_id) => this.core.context.session.getMsgService().sendSsoCmdReqByContend(cmd, trace_id);
}

class LRUCache {
  capacity;
  cache;
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = /* @__PURE__ */ new Map();
  }
  get(key) {
    const value = this.cache.get(key);
    if (value !== void 0) {
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }
  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey !== void 0) {
        this.cache.delete(firstKey);
      }
    }
    this.cache.set(key, value);
  }
  resetCapacity(newCapacity) {
    this.capacity = newCapacity;
    while (this.cache.size > this.capacity) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey !== void 0) {
        this.cache.delete(firstKey);
      }
    }
  }
}

function randText(len) {
  let text = "";
  const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (let i = 0; i < len; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}
class IPacketClient {
  context;
  cb = new LRUCache(500);
  // trace_id-type callback
  logStack;
  available = false;
  constructor(context, logStack) {
    this.context = context;
    this.logStack = logStack;
  }
  async registerCallback(trace_id, type, callback) {
    this.cb.put(createHash$1("md5").update(trace_id).digest("hex") + type, callback);
  }
  async sendCommand(cmd, data, trace_id, rsp = false, timeout = 2e4, sendcb = () => {
  }) {
    return new Promise((resolve, reject) => {
      if (!this.available) {
        reject(new Error("packetBackend 当前不可用！"));
      }
      const timeoutHandle = setTimeout(() => {
        reject(new Error(`sendCommand timed out after ${timeout} ms for ${cmd} with trace_id ${trace_id}`));
      }, timeout);
      this.registerCallback(trace_id, "send", async (json) => {
        sendcb(json);
        if (!rsp) {
          clearTimeout(timeoutHandle);
          resolve(json);
        }
      });
      if (rsp) {
        this.registerCallback(trace_id, "recv", async (json) => {
          clearTimeout(timeoutHandle);
          resolve(json);
        });
      }
      this.sendCommandImpl(cmd, data, trace_id);
    });
  }
  async sendPacket(cmd, data, rsp = false) {
    const md5 = crypto__default.createHash("md5").update(data).digest("hex");
    const trace_id = (randText(4) + md5 + data).slice(0, data.length / 2);
    return this.sendCommand(cmd, data, trace_id, rsp, 2e4, async () => {
      await this.context.napcore.sendSsoCmdReqByContend(cmd, trace_id);
    });
  }
  async sendOidbPacket(pkt, rsp = false) {
    return this.sendPacket(pkt.cmd, pkt.data, rsp);
  }
}

class NativePacketClient extends IPacketClient {
  supportedPlatforms = ["win32.x64", "linux.x64", "linux.arm64", "darwin.x64", "darwin.arm64"];
  MoeHooExport = { exports: {} };
  sendEvent = new LRUCache(500);
  // seq->trace_id
  constructor(context, logStack) {
    super(context, logStack);
  }
  check() {
    const platform = process.platform + "." + process.arch;
    if (!this.supportedPlatforms.includes(platform)) {
      this.logStack.pushLogWarn(`NativePacketClient: 不支持的平台: ${platform}`);
      return false;
    }
    const moehoo_path = path.join(dirname(fileURLToPath(import.meta.url)), "./moehoo/MoeHoo." + platform + ".node");
    if (!fs__default.existsSync(moehoo_path)) {
      this.logStack.pushLogWarn(`NativePacketClient: 缺失运行时文件: ${moehoo_path}`);
      return false;
    }
    return true;
  }
  async init(pid, recv, send) {
    const platform = process.platform + "." + process.arch;
    const moehoo_path = path.join(dirname(fileURLToPath(import.meta.url)), "./moehoo/MoeHoo." + platform + ".node");
    process.dlopen(this.MoeHooExport, moehoo_path, constants.dlopen.RTLD_LAZY);
    this.MoeHooExport.exports.InitHook?.(send, recv, (type, uin, cmd, seq, hex_data) => {
      const trace_id = createHash$1("md5").update(Buffer.from(hex_data, "hex")).digest("hex");
      if (type === 0 && this.cb.get(trace_id + "recv")) {
        this.sendEvent.put(seq, trace_id);
      }
      if (type === 1 && this.sendEvent.get(seq)) {
        const trace_id2 = this.sendEvent.get(seq);
        const callback = this.cb.get(trace_id2 + "recv");
        callback?.({ seq, cmd, hex_data });
      }
    });
    this.available = true;
  }
  sendCommandImpl(cmd, data, trace_id) {
    const trace_id_md5 = createHash$1("md5").update(trace_id).digest("hex");
    this.MoeHooExport.exports.SendPacket?.(cmd, data, trace_id_md5);
    this.cb.get(trace_id_md5 + "send")?.({ seq: 0, cmd, hex_data: "" });
  }
}

class WsPacketClient extends IPacketClient {
  websocket = null;
  reconnectAttempts = 0;
  maxReconnectAttempts = 60;
  // 现在暂时不可配置
  clientUrl;
  clientUrlWrap = (url) => `ws://${url}/ws`;
  isInitialized = false;
  initPayload = null;
  constructor(context, logStack) {
    super(context, logStack);
    this.clientUrl = this.context.napcore.config.packetServer ? this.clientUrlWrap(this.context.napcore.config.packetServer) : this.clientUrlWrap("127.0.0.1:8083");
  }
  check() {
    if (!this.context.napcore.config.packetServer) {
      this.logStack.pushLogWarn(`wsPacketClient 未配置服务器地址`);
      return false;
    }
    return true;
  }
  async init(pid, recv, send) {
    this.initPayload = { pid, recv, send };
    await this.connectWithRetry();
  }
  sendCommandImpl(cmd, data, trace_id) {
    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
      this.websocket.send(JSON.stringify({
        action: "send",
        cmd,
        data,
        trace_id
      }));
    } else {
      this.logStack.pushLogWarn(`WebSocket 未连接，无法发送命令: ${cmd}`);
    }
  }
  async connectWithRetry() {
    while (this.reconnectAttempts < this.maxReconnectAttempts) {
      try {
        await this.connect();
        return;
      } catch (error) {
        this.reconnectAttempts++;
        this.logStack.pushLogWarn(`第 ${this.reconnectAttempts}/${this.maxReconnectAttempts} 次尝试重连失败！`);
        await this.delay(5e3);
      }
    }
    this.logStack.pushLogError(`wsPacketClient 在 ${this.clientUrl} 达到最大重连次数 (${this.maxReconnectAttempts})！`);
    throw new Error(`无法连接到 WebSocket 服务器：${this.clientUrl}`);
  }
  connect() {
    return new Promise((resolve, reject) => {
      this.websocket = new WebSocket(this.clientUrl);
      this.websocket.onopen = () => {
        this.available = true;
        this.reconnectAttempts = 0;
        this.context.logger.info(`wsPacketClient 已连接到 ${this.clientUrl}`);
        if (!this.isInitialized && this.initPayload) {
          this.websocket.send(JSON.stringify({
            action: "init",
            ...this.initPayload
          }));
          this.isInitialized = true;
        }
        resolve();
      };
      this.websocket.onclose = () => {
        this.available = false;
        this.context.logger.warn(`WebSocket 连接关闭，尝试重连...`);
        reject(new Error("WebSocket 连接关闭"));
      };
      this.websocket.onmessage = (event) => this.handleMessage(event.data).catch((err) => {
        this.context.logger.error(`处理消息时出错: ${err}`);
      });
      this.websocket.onerror = (event) => {
        this.available = false;
        this.context.logger.error(`WebSocket 出错: ${event.message}`);
        this.websocket?.close();
        reject(new Error(`WebSocket 出错: ${event.message}`));
      };
    });
  }
  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  async handleMessage(message) {
    try {
      const json = JSON.parse(message.toString());
      const trace_id_md5 = json.trace_id_md5;
      const action = json?.type ?? "init";
      const event = this.cb.get(`${trace_id_md5}${action}`);
      if (event) await event(json.data);
    } catch (error) {
      this.context.logger.error(`解析ws消息时出错: ${error.message}`);
    }
  }
}

const clientPriority = {
  10: (context, logStack) => new NativePacketClient(context, logStack),
  1: (context, logStack) => new WsPacketClient(context, logStack)
};
class LogStack {
  stack = [];
  logger;
  constructor(logger) {
    this.logger = logger;
  }
  push(msg) {
    this.stack.push(msg);
  }
  pushLogInfo(msg) {
    this.logger.info(msg);
    this.stack.push(`${(/* @__PURE__ */ new Date()).toISOString()} [INFO] ${msg}`);
  }
  pushLogWarn(msg) {
    this.logger.warn(msg);
    this.stack.push(`${(/* @__PURE__ */ new Date()).toISOString()} [WARN] ${msg}`);
  }
  pushLogError(msg) {
    this.logger.error(msg);
    this.stack.push(`${(/* @__PURE__ */ new Date()).toISOString()} [ERROR] ${msg}`);
  }
  clear() {
    this.stack = [];
  }
  content() {
    return this.stack.join("\n");
  }
}
class PacketClientContext {
  context;
  logStack;
  _client;
  constructor(context) {
    this.context = context;
    this.logStack = new LogStack(context.logger);
    this._client = this.newClient();
  }
  get available() {
    return this._client.available;
  }
  get clientLogStack() {
    return this._client.logStack.content();
  }
  async init(pid, recv, send) {
    await this._client.init(pid, recv, send);
  }
  async sendOidbPacket(pkt, rsp) {
    const raw = await this._client.sendOidbPacket(pkt, rsp);
    return rsp ? Buffer.from(raw.hex_data, "hex") : void 0;
  }
  newClient() {
    const prefer = this.context.napcore.config.packetBackend;
    let client;
    switch (prefer) {
      case "native":
        this.context.logger.info("使用指定的 NativePacketClient 作为后端");
        client = new NativePacketClient(this.context, this.logStack);
        break;
      case "frida":
        this.context.logger.info("[Core] [Packet] 使用指定的 FridaPacketClient 作为后端");
        client = new WsPacketClient(this.context, this.logStack);
        break;
      case "auto":
      case void 0:
        client = this.judgeClient();
        break;
      default:
        this.context.logger.error(`未知的PacketBackend ${prefer}，请检查配置文件！`);
        client = null;
    }
    if (!client?.check()) {
      throw new Error("[Core] [Packet] 无可用的后端，NapCat.Packet将不会加载！");
    }
    if (!client) {
      throw new Error("[Core] [Packet] 后端异常，NapCat.Packet将不会加载！");
    }
    return client;
  }
  judgeClient() {
    const sortedClients = Object.entries(clientPriority).map(([priority, clientFactory]) => {
      const client = clientFactory(this.context, this.logStack);
      const score = +priority * +client.check();
      return { client, score };
    }).filter(({ score }) => score > 0).sort((a, b) => b.score - a.score);
    const selectedClient = sortedClients[0]?.client;
    if (!selectedClient) {
      throw new Error("[Core] [Packet] 无可用的后端，NapCat.Packet将不会加载！");
    }
    this.context.logger.info(`自动选择 ${selectedClient.constructor.name} 作为后端`);
    return selectedClient;
  }
}

class PacketOperationContext {
  context;
  constructor(context) {
    this.context = context;
  }
  async GroupPoke(groupUin, uin) {
    const req = SendPoke$1.build(groupUin, uin);
    await this.context.client.sendOidbPacket(req);
  }
  async FriendPoke(uin) {
    const req = SendPoke$1.build(uin);
    await this.context.client.sendOidbPacket(req);
  }
  async FetchRkey() {
    const req = FetchRkey$1.build();
    const resp = await this.context.client.sendOidbPacket(req, true);
    const res = FetchRkey$1.parse(resp);
    return res.data.rkeyList;
  }
  async GroupSign(groupUin) {
    const req = GroupSign$1.build(this.context.napcore.basicInfo.uin, groupUin);
    await this.context.client.sendOidbPacket(req);
  }
  async GetStrangerStatus(uin) {
    let status = 0;
    try {
      const req = GetStrangerInfo$1.build(uin);
      const resp = await this.context.client.sendOidbPacket(req, true);
      const res = GetStrangerInfo$1.parse(resp);
      const extBigInt = BigInt(res.data.status.value);
      if (extBigInt <= 10n) {
        return { status: Number(extBigInt) * 10, ext_status: 0 };
      }
      status = Number((extBigInt & 0xff00n) + (extBigInt >> 16n & 0xffn));
      return { status: 10, ext_status: status };
    } catch (e) {
      return void 0;
    }
  }
  async SetGroupSpecialTitle(groupUin, uid, tittle) {
    const req = SetSpecialTitle$1.build(groupUin, uid, tittle);
    await this.context.client.sendOidbPacket(req);
  }
  async UploadResources(msg, groupUin = 0) {
    const chatType = groupUin ? ChatType.KCHATTYPEGROUP : ChatType.KCHATTYPEC2C;
    const peerUid = groupUin ? String(groupUin) : this.context.napcore.basicInfo.uid;
    const reqList = msg.flatMap(
      (m) => m.msg.map((e) => {
        if (e instanceof PacketMsgPicElement) {
          return this.context.highway.uploadImage({ chatType, peerUid }, e);
        } else if (e instanceof PacketMsgVideoElement) {
          return this.context.highway.uploadVideo({ chatType, peerUid }, e);
        } else if (e instanceof PacketMsgPttElement) {
          return this.context.highway.uploadPtt({ chatType, peerUid }, e);
        } else if (e instanceof PacketMsgFileElement) {
          return this.context.highway.uploadFile({ chatType, peerUid }, e);
        }
        return null;
      }).filter(Boolean)
    );
    const res = await Promise.allSettled(reqList);
    this.context.logger.info(`上传资源${res.length}个，失败${res.filter((r) => r.status === "rejected").length}个`);
    res.forEach((result, index) => {
      if (result.status === "rejected") {
        this.context.logger.error(`上传第${index + 1}个资源失败：${result.reason.stack}`);
      }
    });
  }
  async UploadForwardMsg(msg, groupUin = 0) {
    await this.UploadResources(msg, groupUin);
    const req = UploadForwardMsg$1.build(this.context.napcore.basicInfo.uid, msg, groupUin);
    const resp = await this.context.client.sendOidbPacket(req, true);
    const res = UploadForwardMsg$1.parse(resp);
    return res.result.resId;
  }
  async GetGroupFileUrl(groupUin, fileUUID) {
    const req = DownloadGroupFile$1.build(groupUin, fileUUID);
    const resp = await this.context.client.sendOidbPacket(req, true);
    const res = DownloadGroupFile$1.parse(resp);
    return `https://${res.download.downloadDns}/ftn_handler/${Buffer.from(res.download.downloadUrl).toString("hex")}/?fname=`;
  }
  async GetGroupPttUrl(groupUin, node) {
    const req = DownloadGroupPtt$1.build(groupUin, node);
    const resp = await this.context.client.sendOidbPacket(req, true);
    const res = DownloadGroupPtt$1.parse(resp);
    return `https://${res.download.info.domain}${res.download.info.urlPath}${res.download.rKeyParam}`;
  }
  async GetMiniAppAdaptShareInfo(param) {
    const req = GetMiniAppAdaptShareInfo$1.build(param);
    const resp = await this.context.client.sendOidbPacket(req, true);
    const res = GetMiniAppAdaptShareInfo$1.parse(resp);
    return JSON.parse(res.content.jsonContent);
  }
  async FetchAiVoiceList(groupUin, chatType) {
    const req = FetchAiVoiceList$1.build(groupUin, chatType);
    const resp = await this.context.client.sendOidbPacket(req, true);
    const res = FetchAiVoiceList$1.parse(resp);
    if (!res.content) return null;
    return res.content.map((item) => {
      return {
        category: item.category,
        voices: item.voices
      };
    });
  }
  async GetAiVoice(groupUin, voiceId, text, chatType) {
    let reqTime = 0;
    const reqMaxTime = 30;
    const sessionId = crypto$1.randomBytes(4).readUInt32BE(0);
    while (true) {
      if (reqTime >= reqMaxTime) {
        throw new Error(`sendAiVoiceChatReq failed after ${reqMaxTime} times`);
      }
      reqTime++;
      const req = GetAiVoice$1.build(groupUin, voiceId, text, sessionId, chatType);
      const resp = await this.context.client.sendOidbPacket(req, true);
      const res = GetAiVoice$1.parse(resp);
      if (!res.msgInfo) continue;
      return res.msgInfo;
    }
  }
}

const SupportedElementTypes = [
  ElementType.TEXT,
  ElementType.PIC,
  ElementType.REPLY,
  ElementType.FACE,
  ElementType.MFACE,
  ElementType.VIDEO,
  ElementType.FILE,
  ElementType.PTT,
  ElementType.ARK,
  ElementType.MARKDOWN,
  ElementType.STRUCTLONGMSG
];
class PacketMsgConverter {
  isValidElementType(type) {
    return SupportedElementTypes.includes(type);
  }
  rawToPacketMsgConverters = {
    [ElementType.TEXT]: (element) => {
      if (element.textElement?.atType) {
        return new PacketMsgAtElement(element);
      }
      return new PacketMsgTextElement(element);
    },
    [ElementType.PIC]: (element) => {
      return new PacketMsgPicElement(element);
    },
    [ElementType.REPLY]: (element) => {
      return new PacketMsgReplyElement(element);
    },
    [ElementType.FACE]: (element) => {
      return new PacketMsgFaceElement(element);
    },
    [ElementType.MFACE]: (element) => {
      return new PacketMsgMarkFaceElement(element);
    },
    [ElementType.VIDEO]: (element) => {
      return new PacketMsgVideoElement(element);
    },
    [ElementType.FILE]: (element) => {
      return new PacketMsgFileElement(element);
    },
    [ElementType.PTT]: (element) => {
      return new PacketMsgPttElement(element);
    },
    [ElementType.ARK]: (element) => {
      return new PacketMsgLightAppElement(element);
    },
    [ElementType.MARKDOWN]: (element) => {
      return new PacketMsgMarkDownElement(element);
    },
    // TODO: check this logic, move it in arkElement?
    [ElementType.STRUCTLONGMSG]: (element) => {
      return new PacketMultiMsgElement(element);
    }
  };
  rawMsgWithSendMsgToPacketMsg(msg) {
    return {
      senderUid: msg.senderUid ?? "",
      senderUin: msg.senderUin,
      senderName: msg.senderName,
      groupId: msg.groupId,
      time: msg.time,
      msg: msg.msg.map((element) => {
        if (!this.isValidElementType(element.elementType)) return null;
        return this.rawToPacketMsgConverters[element.elementType](element);
      }).filter((e) => e !== null)
    };
  }
  rawMsgToPacketMsg(msg, ctxPeer) {
    return {
      seq: +msg.msgSeq,
      groupId: ctxPeer.chatType === ChatType.KCHATTYPEGROUP ? +msg.peerUid : void 0,
      senderUid: msg.senderUid,
      senderUin: +msg.senderUin,
      senderName: msg.sendMemberName && msg.sendMemberName !== "" ? msg.sendMemberName : msg.sendNickName && msg.sendNickName !== "" ? msg.sendNickName : "QQ用户",
      time: +msg.msgTime,
      msg: msg.elements.map((element) => {
        if (!this.isValidElementType(element.elementType)) return null;
        return this.rawToPacketMsgConverters[element.elementType](element);
      }).filter((e) => e !== null)
    };
  }
}

class PacketContext {
  napcore;
  logger;
  client;
  highway;
  msgConverter;
  operation;
  constructor(core) {
    this.napcore = new NapCoreContext(core);
    this.logger = new PacketLogger(this);
    this.client = new PacketClientContext(this);
    this.highway = new PacketHighwayContext(this);
    this.msgConverter = new PacketMsgConverter();
    this.operation = new PacketOperationContext(this);
  }
}

class PacketClientSession {
  context;
  constructor(core) {
    this.context = new PacketContext(core);
  }
  init(pid, recv, send) {
    return this.context.client.init(pid, recv, send);
  }
  get clientLogStack() {
    return this.context.client.clientLogStack;
  }
  get available() {
    return this.context.client.available;
  }
  get operation() {
    return this.context.operation;
  }
  // TODO: global message element adapter (?
  get msgConverter() {
    return this.context.msgConverter;
  }
}

const napCatVersion = "4.2.27";

const typedOffset = offset;
class NTQQPacketApi {
  context;
  core;
  logger;
  qqVersion;
  pkt;
  errStack = [];
  constructor(context, core) {
    this.context = context;
    this.core = core;
    this.logger = core.context.logger;
  }
  async initApi() {
    await this.InitSendPacket(this.context.basicInfoWrapper.getFullQQVesion()).then().catch((err) => {
      this.logger.logError(err);
      this.errStack.push(err);
    });
  }
  get available() {
    return this.pkt?.available ?? false;
  }
  get clientLogStack() {
    return this.pkt?.clientLogStack + "\n" + this.errStack.join("\n");
  }
  async InitSendPacket(qqVer) {
    this.qqVersion = qqVer;
    const table = typedOffset[qqVer + "-" + os.arch()];
    if (!table) {
      const err = `[Core] [Packet] PacketBackend 不支持当前QQ版本架构：${qqVer}-${os.arch()}，
            请参照 https://github.com/NapNeko/NapCatQQ/releases/tag/v${napCatVersion} 配置正确的QQ版本！`;
      this.logger.logError(err);
      this.errStack.push(err);
      return false;
    }
    if (this.core.configLoader.configData.packetBackend === "disable") {
      const err = "[Core] [Packet] 已禁用PacketBackend，NapCat.Packet将不会加载！";
      this.logger.logError(err);
      this.errStack.push(err);
      return false;
    }
    this.pkt = new PacketClientSession(this.core);
    await this.pkt.init(process.pid, table.recv, table.send);
    return true;
  }
}

var NapCatCoreWorkingEnv = /* @__PURE__ */ ((NapCatCoreWorkingEnv2) => {
  NapCatCoreWorkingEnv2[NapCatCoreWorkingEnv2["Unknown"] = 0] = "Unknown";
  NapCatCoreWorkingEnv2[NapCatCoreWorkingEnv2["Shell"] = 1] = "Shell";
  NapCatCoreWorkingEnv2[NapCatCoreWorkingEnv2["Framework"] = 2] = "Framework";
  return NapCatCoreWorkingEnv2;
})(NapCatCoreWorkingEnv || {});
function loadQQWrapper(QQVersion) {
  let appPath;
  if (os$1.platform() === "darwin") {
    appPath = path$1.resolve(path$1.dirname(process.execPath), "../Resources/app");
  } else if (os$1.platform() === "linux") {
    appPath = path$1.resolve(path$1.dirname(process.execPath), "./resources/app");
  } else {
    appPath = path$1.resolve(path$1.dirname(process.execPath), `./versions/${QQVersion}/`);
  }
  let wrapperNodePath = path$1.resolve(appPath, "wrapper.node");
  if (!fs$1.existsSync(wrapperNodePath)) {
    wrapperNodePath = path$1.join(appPath, `./resources/app/wrapper.node`);
  }
  if (!fs$1.existsSync(wrapperNodePath)) {
    wrapperNodePath = path$1.join(path$1.dirname(process.execPath), `./resources/app/versions/${QQVersion}/wrapper.node`);
  }
  const nativemodule = { exports: {} };
  process.dlopen(nativemodule, wrapperNodePath);
  return nativemodule.exports;
}
function getMajorPath(QQVersion) {
  let appPath;
  if (os$1.platform() === "darwin") {
    appPath = path$1.resolve(path$1.dirname(process.execPath), "../Resources/app");
  } else if (os$1.platform() === "linux") {
    appPath = path$1.resolve(path$1.dirname(process.execPath), "./resources/app");
  } else {
    appPath = path$1.resolve(path$1.dirname(process.execPath), `./versions/${QQVersion}/`);
  }
  let majorPath = path$1.resolve(appPath, "major.node");
  if (!fs$1.existsSync(majorPath)) {
    majorPath = path$1.join(appPath, `./resources/app/major.node`);
  }
  if (!fs$1.existsSync(majorPath)) {
    majorPath = path$1.join(path$1.dirname(process.execPath), `./resources/app/versions/${QQVersion}/major.node`);
  }
  return majorPath;
}
class NapCatCore {
  context;
  eventWrapper;
  NapCatDataPath = "";
  NapCatTempPath = "";
  apis;
  // runtime info, not readonly
  selfInfo;
  util;
  configLoader;
  // 通过构造器递过去的 runtime info 应该尽量少
  constructor(context, selfInfo) {
    this.selfInfo = selfInfo;
    this.context = context;
    this.util = this.context.wrapper.NodeQQNTWrapperUtil;
    this.eventWrapper = new NTEventWrapper(context.session);
    this.configLoader = new NapCatConfigLoader(this, this.context.pathWrapper.configPath);
    this.apis = {
      FileApi: new NTQQFileApi(this.context, this),
      SystemApi: new NTQQSystemApi(this.context, this),
      CollectionApi: new NTQQCollectionApi(this.context, this),
      PacketApi: new NTQQPacketApi(this.context, this),
      WebApi: new NTQQWebApi(this.context, this),
      FriendApi: new NTQQFriendApi(this.context, this),
      MsgApi: new NTQQMsgApi(this.context, this),
      UserApi: new NTQQUserApi(this.context, this),
      GroupApi: new NTQQGroupApi(this.context, this)
    };
  }
  async initCore() {
    this.NapCatDataPath = path$1.join(this.dataPath, "NapCat");
    fs$1.mkdirSync(this.NapCatDataPath, { recursive: true });
    this.NapCatTempPath = path$1.join(this.NapCatDataPath, "temp");
    if (!fs$1.existsSync(this.NapCatTempPath)) {
      fs$1.mkdirSync(this.NapCatTempPath, { recursive: true });
    }
    for (const apiKey in this.apis) {
      const api = this.apis[apiKey];
      if ("initApi" in api && typeof api.initApi === "function") {
        await api.initApi();
      }
    }
    this.initNapCatCoreListeners().then().catch((e) => this.context.logger.logError(e));
    this.context.logger.setFileLogEnabled(
      this.configLoader.configData.fileLog
    );
    this.context.logger.setConsoleLogEnabled(
      this.configLoader.configData.consoleLog
    );
    this.context.logger.setFileAndConsoleLogLevel(
      this.configLoader.configData.fileLogLevel,
      this.configLoader.configData.consoleLogLevel
    );
  }
  get dataPath() {
    let result = this.context.wrapper.NodeQQNTWrapperUtil.getNTUserDataInfoConfig();
    if (!result) {
      result = path$1.resolve(os$1.homedir(), "./.config/QQ");
      fs$1.mkdirSync(result, { recursive: true });
    }
    return result;
  }
  // Renamed from 'InitDataListener'
  async initNapCatCoreListeners() {
    const msgListener = new NodeIKernelMsgListener();
    msgListener.onKickedOffLine = (Info) => {
      this.context.logger.logError("[KickedOffLine] [" + Info.tipsTitle + "] " + Info.tipsDesc);
      this.selfInfo.online = false;
    };
    msgListener.onRecvMsg = (msgs) => {
      msgs.forEach((msg) => this.context.logger.logMessage(msg, this.selfInfo));
    };
    msgListener.onAddSendMsg = (msg) => {
      this.context.logger.logMessage(msg, this.selfInfo);
    };
    this.context.session.getMsgService().addKernelMsgListener(
      proxiedListenerOf(msgListener, this.context.logger)
    );
    const profileListener = new NodeIKernelProfileListener();
    profileListener.onProfileDetailInfoChanged = (profile) => {
      if (profile.uid === this.selfInfo.uid) {
        Object.assign(this.selfInfo, profile);
      }
    };
    profileListener.onSelfStatusChanged = (Info) => {
      if (Info.status == 20) {
        this.selfInfo.online = false;
        this.context.logger.log("账号状态变更为离线");
      } else {
        this.selfInfo.online = true;
      }
    };
    this.context.session.getProfileService().addKernelProfileListener(
      proxiedListenerOf(profileListener, this.context.logger)
    );
  }
}
async function genSessionConfig(guid, QQVersionAppid, QQVersion, selfUin, selfUid, account_path) {
  const downloadPath = path$1.join(account_path, "NapCat", "temp");
  fs$1.mkdirSync(downloadPath, { recursive: true });
  const platformMapping = {
    win32: PlatformType.KWINDOWS,
    darwin: PlatformType.KMAC,
    linux: PlatformType.KLINUX
  };
  const systemPlatform = platformMapping[os$1.platform()] ?? PlatformType.KWINDOWS;
  return {
    selfUin,
    selfUid,
    desktopPathConfig: {
      account_path
      // 可以通过NodeQQNTWrapperUtil().getNTUserDataInfoConfig()获取
    },
    clientVer: QQVersion,
    a2: "",
    d2: "",
    d2Key: "",
    machineId: "",
    platform: systemPlatform,
    // 3是Windows?
    platVer: systemVersion,
    // 系统版本号, 应该可以固定
    appid: QQVersionAppid,
    rdeliveryConfig: {
      appKey: "",
      systemId: 0,
      appId: "",
      logicEnvironment: "",
      platform: systemPlatform,
      language: "",
      sdkVersion: "",
      userId: "",
      appVersion: "",
      osVersion: "",
      bundleId: "",
      serverUrl: "",
      fixedAfterHitKeys: [""]
    },
    defaultFileDownloadPath: downloadPath,
    deviceInfo: {
      guid,
      buildVer: QQVersion,
      localId: 2052,
      devName: hostname,
      devType: systemName,
      vendorName: "",
      osVer: systemVersion,
      vendorOsName: systemName,
      setMute: false,
      vendorType: VendorType.KNOSETONIOS
    },
    deviceConfig: '{"appearance":{"isSplitViewMode":true},"msg":{}}'
  };
}

var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2["DEBUG"] = "debug";
  LogLevel2["INFO"] = "info";
  LogLevel2["WARN"] = "warn";
  LogLevel2["ERROR"] = "error";
  LogLevel2["FATAL"] = "fatal";
  return LogLevel2;
})(LogLevel || {});
function getFormattedTimestamp() {
  const now = /* @__PURE__ */ new Date();
  const year = now.getFullYear();
  const month = (now.getMonth() + 1).toString().padStart(2, "0");
  const day = now.getDate().toString().padStart(2, "0");
  const hours = now.getHours().toString().padStart(2, "0");
  const minutes = now.getMinutes().toString().padStart(2, "0");
  const seconds = now.getSeconds().toString().padStart(2, "0");
  const milliseconds = now.getMilliseconds().toString().padStart(3, "0");
  return `${year}-${month}-${day}_${hours}-${minutes}-${seconds}.${milliseconds}`;
}
const logEmitter = new EventEmitter();
class Subscription {
  static MAX_HISTORY = 100;
  static history = [];
  subscribe(listener) {
    for (const history of Subscription.history) {
      try {
        listener(history);
      } catch (_) {
      }
    }
    logEmitter.on("log", listener);
  }
  unsubscribe(listener) {
    logEmitter.off("log", listener);
  }
  notify(msg) {
    logEmitter.emit("log", msg);
    if (Subscription.history.length >= Subscription.MAX_HISTORY) {
      Subscription.history.shift();
    }
    Subscription.history.push(msg);
  }
}
const logSubscription = new Subscription();
class LogWrapper {
  fileLogEnabled = true;
  consoleLogEnabled = true;
  logger;
  constructor(logDir) {
    const filename = `${getFormattedTimestamp()}.log`;
    const logPath = path$1.join(logDir, filename);
    this.logger = winston.createLogger({
      level: "debug",
      format: winstonExports.format.combine(
        winstonExports.format.timestamp({ format: "MM-DD HH:mm:ss" }),
        winstonExports.format.printf(({ timestamp, level, message, ...meta }) => {
          const userInfo = meta.userInfo ? `${meta.userInfo} | ` : "";
          return `${timestamp} [${level}] ${userInfo}${message}`;
        })
      ),
      transports: [
        new winstonExports.transports.File({
          filename: logPath,
          level: "debug",
          maxsize: 5 * 1024 * 1024,
          // 5MB
          maxFiles: 5
        }),
        new winstonExports.transports.Console({
          format: winstonExports.format.combine(
            winstonExports.format.colorize(),
            winstonExports.format.printf(({ timestamp, level, message, ...meta }) => {
              const userInfo = meta.userInfo ? `${meta.userInfo} | ` : "";
              return `${timestamp} [${level}] ${userInfo}${message}`;
            })
          )
        })
      ]
    });
    this.setLogSelfInfo({ nick: "", uid: "" });
    this.cleanOldLogs(logDir);
  }
  cleanOldLogs(logDir) {
    const oneWeekAgo = Date.now() - 7 * 24 * 60 * 60 * 1e3;
    fs$2.readdir(logDir).then((files) => {
      files.forEach((file) => {
        const filePath = path$1.join(logDir, file);
        this.deleteOldLogFile(filePath, oneWeekAgo);
      });
    }).catch((err) => {
      this.logger.error("Failed to read log directory", err);
    });
  }
  deleteOldLogFile(filePath, oneWeekAgo) {
    fs$2.stat(filePath).then((stats) => {
      if (stats.mtime.getTime() < oneWeekAgo) {
        fs$2.unlink(filePath).catch((err) => {
          if (err) {
            if (err.code === "ENOENT") {
              this.logger.warn(`File already deleted: ${filePath}`);
            } else {
              this.logger.error("Failed to delete old log file", err);
            }
          } else {
            this.logger.info(`Deleted old log file: ${filePath}`);
          }
        });
      }
    }).catch((err) => {
      this.logger.error("Failed to get file stats", err);
    });
  }
  setFileAndConsoleLogLevel(fileLogLevel, consoleLogLevel) {
    this.logger.transports.forEach((transport) => {
      if (transport instanceof winstonExports.transports.File) {
        transport.level = fileLogLevel;
      } else if (transport instanceof winstonExports.transports.Console) {
        transport.level = consoleLogLevel;
      }
    });
  }
  setLogSelfInfo(selfInfo) {
    const userInfo = `${selfInfo.nick}`;
    this.logger.defaultMeta = { userInfo };
  }
  setFileLogEnabled(isEnabled) {
    this.fileLogEnabled = isEnabled;
    this.logger.transports.forEach((transport) => {
      if (transport instanceof winstonExports.transports.File) {
        transport.silent = !isEnabled;
      }
    });
  }
  setConsoleLogEnabled(isEnabled) {
    this.consoleLogEnabled = isEnabled;
    this.logger.transports.forEach((transport) => {
      if (transport instanceof winstonExports.transports.Console) {
        transport.silent = !isEnabled;
      }
    });
  }
  formatMsg(msg) {
    return msg.map((msgItem) => {
      if (msgItem instanceof Error) {
        return msgItem.stack;
      } else if (typeof msgItem === "object") {
        return JSON.stringify(truncateString(JSON.parse(JSON.stringify(msgItem, null, 2))));
      }
      return msgItem;
    }).join(" ");
  }
  _log(level, ...args) {
    const message = this.formatMsg(args);
    if (this.consoleLogEnabled && this.fileLogEnabled) {
      this.logger.log(level, message);
    } else if (this.consoleLogEnabled) {
      this.logger.log(level, message);
    } else if (this.fileLogEnabled) {
      this.logger.log(level, message.replace(/\x1B[@-_][0-?]*[ -/]*[@-~]/g, ""));
    }
    logSubscription.notify(JSON.stringify({ level, message }));
  }
  log(...args) {
    this._log("info" /* INFO */, ...args);
  }
  logDebug(...args) {
    this._log("debug" /* DEBUG */, ...args);
  }
  logError(...args) {
    this._log("error" /* ERROR */, ...args);
  }
  logWarn(...args) {
    this._log("warn" /* WARN */, ...args);
  }
  logFatal(...args) {
    this._log("fatal" /* FATAL */, ...args);
  }
  logMessage(msg, selfInfo) {
    const isSelfSent = msg.senderUin === selfInfo.uin;
    if (msg.elements[0]?.elementType === ElementType.GreyTip) {
      return;
    }
    this.log(`${isSelfSent ? "发送 ->" : "接收 <-"} ${rawMessageToText(msg)}`);
  }
}
function rawMessageToText(msg, recursiveLevel = 0) {
  if (recursiveLevel > 2) {
    return "...";
  }
  const tokens = [];
  if (msg.chatType == ChatType.KCHATTYPEC2C) {
    tokens.push(`私聊 (${msg.peerUin})`);
  } else if (msg.chatType == ChatType.KCHATTYPEGROUP) {
    if (recursiveLevel < 1) {
      tokens.push(`群聊 [${msg.peerName}(${msg.peerUin})]`);
    }
    if (msg.senderUin !== "0") {
      tokens.push(`[${msg.sendMemberName ?? msg.sendRemarkName ?? msg.sendNickName}(${msg.senderUin})]`);
    }
  } else if (msg.chatType == ChatType.KCHATTYPEDATALINE) {
    tokens.push("移动设备");
  } else {
    tokens.push(`临时消息 (${msg.peerUin})`);
  }
  for (const element of msg.elements) {
    tokens.push(msgElementToText(element, msg, recursiveLevel));
  }
  return tokens.join(" ");
}
function msgElementToText(element, msg, recursiveLevel) {
  if (element.textElement) {
    return textElementToText(element.textElement);
  }
  if (element.replyElement) {
    return replyElementToText(element.replyElement, msg, recursiveLevel);
  }
  if (element.picElement) {
    return "[图片]";
  }
  if (element.fileElement) {
    return `[文件 ${element.fileElement.fileName}]`;
  }
  if (element.videoElement) {
    return "[视频]";
  }
  if (element.pttElement) {
    return `[语音 ${element.pttElement.duration}s]`;
  }
  if (element.arkElement) {
    return "[卡片消息]";
  }
  if (element.faceElement) {
    return `[表情 ${element.faceElement.faceText ?? ""}]`;
  }
  if (element.marketFaceElement) {
    return element.marketFaceElement.faceName;
  }
  if (element.markdownElement) {
    return "[Markdown 消息]";
  }
  if (element.multiForwardMsgElement) {
    return "[转发消息]";
  }
  if (element.elementType === ElementType.GreyTip) {
    return "[灰条消息]";
  }
  return `[未实现 (ElementType = ${element.elementType})]`;
}
function textElementToText(textElement) {
  if (textElement.atType === NTMsgAtType.ATTYPEUNKNOWN) {
    const originalContentLines = textElement.content.split("\n");
    return `${originalContentLines[0]}${originalContentLines.length > 1 ? " ..." : ""}`;
  } else if (textElement.atType === NTMsgAtType.ATTYPEALL) {
    return `@全体成员`;
  } else if (textElement.atType === NTMsgAtType.ATTYPEONE) {
    return `${textElement.content} (${textElement.atUid})`;
  }
  return "";
}
function replyElementToText(replyElement, msg, recursiveLevel) {
  const recordMsgOrNull = msg.records.find((record) => replyElement.sourceMsgIdInRecords === record.msgId);
  return `[回复消息 ${recordMsgOrNull && recordMsgOrNull.peerUin != "284840486" && recordMsgOrNull.peerUin != "1094950020" ? rawMessageToText(recordMsgOrNull, recursiveLevel + 1) : `未找到消息记录 (MsgId = ${replyElement.sourceMsgIdInRecords})`}]`;
}

class NodeIDependsAdapter {
  onMSFStatusChange(statusType, changeReasonType) {
  }
  onMSFSsoError(args) {
  }
  getGroupCode(args) {
  }
}

class NodeIDispatcherAdapter {
  dispatchRequest(arg) {
  }
  dispatchCall(arg) {
  }
  dispatchCallWithJson(arg) {
  }
}

class NodeIGlobalAdapter {
  onLog(...args) {
  }
  onGetSrvCalTime(...args) {
  }
  onShowErrUITips(...args) {
  }
  fixPicImgType(...args) {
  }
  getAppSetting(...args) {
  }
  onInstallFinished(...args) {
  }
  onUpdateGeneralFlag(...args) {
  }
  onGetOfflineMsg(...args) {
  }
}

class NapCatPathWrapper {
  binaryPath;
  logsPath;
  configPath;
  cachePath;
  staticPath;
  constructor(mainPath = dirname(fileURLToPath(import.meta.url))) {
    this.binaryPath = mainPath;
    let writePath;
    if (os__default.platform() === "darwin") {
      writePath = path.join(os__default.homedir(), "Library", "Application Support", "QQ", "NapCat");
    } else {
      writePath = this.binaryPath;
    }
    this.logsPath = path.join(writePath, "logs");
    this.configPath = path.join(writePath, "config");
    this.cachePath = path.join(writePath, "cache");
    this.staticPath = path.join(this.binaryPath, "static");
    if (!fs__default.existsSync(this.logsPath)) {
      fs__default.mkdirSync(this.logsPath, { recursive: true });
    }
    if (!fs__default.existsSync(this.configPath)) {
      fs__default.mkdirSync(this.configPath, { recursive: true });
    }
    if (!fs__default.existsSync(this.cachePath)) {
      fs__default.mkdirSync(this.cachePath, { recursive: true });
    }
  }
}

const AppidTable = {
  "9.9.15-28060": {"appid":537246092,"qua":"V1_WIN_NQ_9.9.15_28060_GW_B"},
  "9.9.15-28131": {"appid":537246092,"qua":"V1_WIN_NQ_9.9.15_28131_GW_B"},
  "3.2.12-28060": {"appid":537246140,"qua":"V1_LNX_NQ_3.2.12_28060_GW_B"},
  "3.2.12-28131": {"appid":537246140,"qua":"V1_LNX_NQ_3.2.12_28131_GW_B"},
  "6.9.55-28131": {"appid":537246115,"qua":"V1_MAC_NQ_6.9.55_28131_GW_B"},
  "9.9.15-28327": {"appid":537249321,"qua":"V1_WIN_NQ_9.9.15_28327_GW_B"},
  "3.2.12-28327": {"appid":537249393,"qua":"V1_LNX_NQ_3.2.12_28327_GW_B"},
  "9.9.15-28418": {"appid":537249321,"qua":"V1_WIN_NQ_9.9.15_28418_GW_B"},
  "3.2.12-28418": {"appid":537249393,"qua":"V1_LNX_NQ_3.2.12_28418_GW_B"},
  "6.9.56-28418": {"appid":537249367,"qua":"V1_MAC_NQ_6.9.56_28418_GW_B"},
  "9.9.15-28498": {"appid":537249321,"qua":"V1_WIN_NQ_9.9.15_28498_GW_B"},
  "3.2.13-28788": {"appid":537249787,"qua":"V1_LNX_NQ_3.2.13_28788_GW_B"},
  "9.9.16-28788": {"appid":537249739,"qua":"V1_WIN_NQ_9.9.16_28788_GW_B"},
  "9.9.16-28971": {"appid":537249775,"qua":"V1_WIN_NQ_9.9.16_28971_GW_B"},
  "3.2.13-28971": {"appid":537249848,"qua":"V1_LNX_NQ_3.2.13_28971_GW_B"},
  "6.9.58-28971": {"appid":537249826,"qua":"V1_MAC_NQ_6.9.58_28971_GW_B"},
  "9.9.16-29271": {"appid":537249813,"qua":"V1_WIN_NQ_9.9.16_29271_GW_B"},
  "3.2.13-29271": {"appid":537249913,"qua":"V1_LNX_NQ_3.2.13_29271_GW_B"},
  "6.9.59-29271": {"appid":537249863,"qua":"V1_MAC_NQ_6.9.59_29271_GW_B"},
  "9.9.16-29456": {"appid":537249875,"qua":"V1_WIN_NQ_9.9.16_29456_GW_B"},
  "3.2.13-29456": {"appid":537249996,"qua":"V1_LNX_NQ_3.2.13_29456_GW_B"},
  "6.9.59-29456": {"appid":537249961,"qua":"V1_MAC_NQ_6.9.59_29456_GW_B"},
  "9.9.16-29927": {"appid":537255812,"qua":"V1_WIN_NQ_9.9.16_29927_GW_B"},
  "3.2.13-29927": {"appid":537255847,"qua":"V1_LNX_NQ_3.2.13_29927_GW_B"},
  "6.9.61-29927": {"appid":537255836,"qua":"V1_MAC_NQ_6.9.61_29927_GW_B"},
  "9.9.17-30366": {"appid":537258389,"qua":"V1_WIN_NQ_9.9.17_30366_GW_B"},
  "3.2.15-30366": {"appid":537258413,"qua":"V1_LNX_NQ_3.2.15_30366_GW_B"},
  "6.9.62-30366": {"appid":537258401,"qua":"V1_MAC_NQ_6.9.62_30366_GW_B"},
};

class QQBasicInfoWrapper {
  QQMainPath;
  QQPackageInfoPath;
  QQVersionConfigPath;
  isQuickUpdate;
  QQVersionConfig;
  QQPackageInfo;
  QQVersionAppid;
  QQVersionQua;
  context;
  constructor(context) {
    this.context = context;
    this.QQMainPath = process.execPath;
    this.QQVersionConfigPath = getQQVersionConfigPath(this.QQMainPath);
    this.isQuickUpdate = !!this.QQVersionConfigPath;
    this.QQVersionConfig = this.isQuickUpdate ? JSON.parse(fs$1.readFileSync(this.QQVersionConfigPath).toString()) : getDefaultQQVersionConfigInfo();
    this.QQPackageInfoPath = getQQPackageInfoPath(this.QQMainPath, this.QQVersionConfig?.curVersion);
    this.QQPackageInfo = JSON.parse(fs$1.readFileSync(this.QQPackageInfoPath).toString());
    const { appid: IQQVersionAppid, qua: IQQVersionQua } = this.getAppidV2();
    this.QQVersionAppid = IQQVersionAppid;
    this.QQVersionQua = IQQVersionQua;
  }
  //基础函数
  getQQBuildStr() {
    return this.isQuickUpdate ? this.QQVersionConfig?.buildId : this.QQPackageInfo?.buildVersion;
  }
  getFullQQVesion() {
    const version = this.isQuickUpdate ? this.QQVersionConfig?.curVersion : this.QQPackageInfo?.version;
    if (!version) throw new Error("QQ版本获取失败");
    return version;
  }
  requireMinNTQQBuild(buildStr) {
    const currentBuild = +(this.getQQBuildStr() ?? "0");
    if (currentBuild == 0) throw new Error("QQBuildStr获取失败");
    return currentBuild >= parseInt(buildStr);
  }
  //此方法不要直接使用
  getQUAFallback() {
    const platformMapping = {
      win32: `V1_WIN_${this.getFullQQVesion()}_${this.getQQBuildStr()}_GW_B`,
      darwin: `V1_MAC_${this.getFullQQVesion()}_${this.getQQBuildStr()}_GW_B`,
      linux: `V1_LNX_${this.getFullQQVesion()}_${this.getQQBuildStr()}_GW_B`
    };
    return platformMapping[systemPlatform] ?? platformMapping.win32;
  }
  getAppIdFallback() {
    const platformMapping = {
      win32: "537246092",
      darwin: "537246140",
      linux: "537246140"
    };
    return platformMapping[systemPlatform] ?? "537246092";
  }
  getAppidV2() {
    const appidTbale = AppidTable;
    const fullVersion = this.getFullQQVesion();
    if (fullVersion) {
      const data = appidTbale[fullVersion];
      if (data) {
        return data;
      }
    }
    try {
      const majorAppid = this.getAppidV2ByMajor(fullVersion);
      if (majorAppid) {
        this.context.logger.log(`[QQ版本兼容性检测] 当前版本Appid未内置 通过Major获取 为了更好的性能请尝试更新NapCat`);
        return { appid: majorAppid, qua: this.getQUAFallback() };
      }
    } catch (error) {
      this.context.logger.log(`[QQ版本兼容性检测] 通过Major 获取Appid异常 请检测NapCat/QQNT是否正常`);
    }
    this.context.logger.log(`[QQ版本兼容性检测] 获取Appid异常 请检测NapCat/QQNT是否正常`);
    this.context.logger.log(`[QQ版本兼容性检测] ${fullVersion} 版本兼容性不佳，可能会导致一些功能无法正常使用`);
    return { appid: this.getAppIdFallback(), qua: this.getQUAFallback() };
  }
  getAppidV2ByMajor(QQVersion) {
    const majorPath = getMajorPath(QQVersion);
    const appid = parseAppidFromMajor(majorPath);
    return appid;
  }
}

var commander$1 = {};

var argument = {};

var error = {};

/**
 * CommanderError class
 */

var hasRequiredError;

function requireError () {
	if (hasRequiredError) return error;
	hasRequiredError = 1;
	class CommanderError extends Error {
	  /**
	   * Constructs the CommanderError class
	   * @param {number} exitCode suggested exit code which could be used with process.exit
	   * @param {string} code an id string representing the error
	   * @param {string} message human-readable description of the error
	   */
	  constructor(exitCode, code, message) {
	    super(message);
	    // properly capture stack trace in Node.js
	    Error.captureStackTrace(this, this.constructor);
	    this.name = this.constructor.name;
	    this.code = code;
	    this.exitCode = exitCode;
	    this.nestedError = undefined;
	  }
	}

	/**
	 * InvalidArgumentError class
	 */
	class InvalidArgumentError extends CommanderError {
	  /**
	   * Constructs the InvalidArgumentError class
	   * @param {string} [message] explanation of why argument is invalid
	   */
	  constructor(message) {
	    super(1, 'commander.invalidArgument', message);
	    // properly capture stack trace in Node.js
	    Error.captureStackTrace(this, this.constructor);
	    this.name = this.constructor.name;
	  }
	}

	error.CommanderError = CommanderError;
	error.InvalidArgumentError = InvalidArgumentError;
	return error;
}

var hasRequiredArgument;

function requireArgument () {
	if (hasRequiredArgument) return argument;
	hasRequiredArgument = 1;
	const { InvalidArgumentError } = requireError();

	class Argument {
	  /**
	   * Initialize a new command argument with the given name and description.
	   * The default is that the argument is required, and you can explicitly
	   * indicate this with <> around the name. Put [] around the name for an optional argument.
	   *
	   * @param {string} name
	   * @param {string} [description]
	   */

	  constructor(name, description) {
	    this.description = description || '';
	    this.variadic = false;
	    this.parseArg = undefined;
	    this.defaultValue = undefined;
	    this.defaultValueDescription = undefined;
	    this.argChoices = undefined;

	    switch (name[0]) {
	      case '<': // e.g. <required>
	        this.required = true;
	        this._name = name.slice(1, -1);
	        break;
	      case '[': // e.g. [optional]
	        this.required = false;
	        this._name = name.slice(1, -1);
	        break;
	      default:
	        this.required = true;
	        this._name = name;
	        break;
	    }

	    if (this._name.length > 3 && this._name.slice(-3) === '...') {
	      this.variadic = true;
	      this._name = this._name.slice(0, -3);
	    }
	  }

	  /**
	   * Return argument name.
	   *
	   * @return {string}
	   */

	  name() {
	    return this._name;
	  }

	  /**
	   * @package
	   */

	  _concatValue(value, previous) {
	    if (previous === this.defaultValue || !Array.isArray(previous)) {
	      return [value];
	    }

	    return previous.concat(value);
	  }

	  /**
	   * Set the default value, and optionally supply the description to be displayed in the help.
	   *
	   * @param {*} value
	   * @param {string} [description]
	   * @return {Argument}
	   */

	  default(value, description) {
	    this.defaultValue = value;
	    this.defaultValueDescription = description;
	    return this;
	  }

	  /**
	   * Set the custom handler for processing CLI command arguments into argument values.
	   *
	   * @param {Function} [fn]
	   * @return {Argument}
	   */

	  argParser(fn) {
	    this.parseArg = fn;
	    return this;
	  }

	  /**
	   * Only allow argument value to be one of choices.
	   *
	   * @param {string[]} values
	   * @return {Argument}
	   */

	  choices(values) {
	    this.argChoices = values.slice();
	    this.parseArg = (arg, previous) => {
	      if (!this.argChoices.includes(arg)) {
	        throw new InvalidArgumentError(
	          `Allowed choices are ${this.argChoices.join(', ')}.`,
	        );
	      }
	      if (this.variadic) {
	        return this._concatValue(arg, previous);
	      }
	      return arg;
	    };
	    return this;
	  }

	  /**
	   * Make argument required.
	   *
	   * @returns {Argument}
	   */
	  argRequired() {
	    this.required = true;
	    return this;
	  }

	  /**
	   * Make argument optional.
	   *
	   * @returns {Argument}
	   */
	  argOptional() {
	    this.required = false;
	    return this;
	  }
	}

	/**
	 * Takes an argument and returns its human readable equivalent for help usage.
	 *
	 * @param {Argument} arg
	 * @return {string}
	 * @private
	 */

	function humanReadableArgName(arg) {
	  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');

	  return arg.required ? '<' + nameOutput + '>' : '[' + nameOutput + ']';
	}

	argument.Argument = Argument;
	argument.humanReadableArgName = humanReadableArgName;
	return argument;
}

var command = {};

var help = {};

var hasRequiredHelp;

function requireHelp () {
	if (hasRequiredHelp) return help;
	hasRequiredHelp = 1;
	const { humanReadableArgName } = requireArgument();

	/**
	 * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`
	 * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types
	 * @typedef { import("./argument.js").Argument } Argument
	 * @typedef { import("./command.js").Command } Command
	 * @typedef { import("./option.js").Option } Option
	 */

	// Although this is a class, methods are static in style to allow override using subclass or just functions.
	class Help {
	  constructor() {
	    this.helpWidth = undefined;
	    this.sortSubcommands = false;
	    this.sortOptions = false;
	    this.showGlobalOptions = false;
	  }

	  /**
	   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
	   *
	   * @param {Command} cmd
	   * @returns {Command[]}
	   */

	  visibleCommands(cmd) {
	    const visibleCommands = cmd.commands.filter((cmd) => !cmd._hidden);
	    const helpCommand = cmd._getHelpCommand();
	    if (helpCommand && !helpCommand._hidden) {
	      visibleCommands.push(helpCommand);
	    }
	    if (this.sortSubcommands) {
	      visibleCommands.sort((a, b) => {
	        // @ts-ignore: because overloaded return type
	        return a.name().localeCompare(b.name());
	      });
	    }
	    return visibleCommands;
	  }

	  /**
	   * Compare options for sort.
	   *
	   * @param {Option} a
	   * @param {Option} b
	   * @returns {number}
	   */
	  compareOptions(a, b) {
	    const getSortKey = (option) => {
	      // WYSIWYG for order displayed in help. Short used for comparison if present. No special handling for negated.
	      return option.short
	        ? option.short.replace(/^-/, '')
	        : option.long.replace(/^--/, '');
	    };
	    return getSortKey(a).localeCompare(getSortKey(b));
	  }

	  /**
	   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
	   *
	   * @param {Command} cmd
	   * @returns {Option[]}
	   */

	  visibleOptions(cmd) {
	    const visibleOptions = cmd.options.filter((option) => !option.hidden);
	    // Built-in help option.
	    const helpOption = cmd._getHelpOption();
	    if (helpOption && !helpOption.hidden) {
	      // Automatically hide conflicting flags. Bit dubious but a historical behaviour that is convenient for single-command programs.
	      const removeShort = helpOption.short && cmd._findOption(helpOption.short);
	      const removeLong = helpOption.long && cmd._findOption(helpOption.long);
	      if (!removeShort && !removeLong) {
	        visibleOptions.push(helpOption); // no changes needed
	      } else if (helpOption.long && !removeLong) {
	        visibleOptions.push(
	          cmd.createOption(helpOption.long, helpOption.description),
	        );
	      } else if (helpOption.short && !removeShort) {
	        visibleOptions.push(
	          cmd.createOption(helpOption.short, helpOption.description),
	        );
	      }
	    }
	    if (this.sortOptions) {
	      visibleOptions.sort(this.compareOptions);
	    }
	    return visibleOptions;
	  }

	  /**
	   * Get an array of the visible global options. (Not including help.)
	   *
	   * @param {Command} cmd
	   * @returns {Option[]}
	   */

	  visibleGlobalOptions(cmd) {
	    if (!this.showGlobalOptions) return [];

	    const globalOptions = [];
	    for (
	      let ancestorCmd = cmd.parent;
	      ancestorCmd;
	      ancestorCmd = ancestorCmd.parent
	    ) {
	      const visibleOptions = ancestorCmd.options.filter(
	        (option) => !option.hidden,
	      );
	      globalOptions.push(...visibleOptions);
	    }
	    if (this.sortOptions) {
	      globalOptions.sort(this.compareOptions);
	    }
	    return globalOptions;
	  }

	  /**
	   * Get an array of the arguments if any have a description.
	   *
	   * @param {Command} cmd
	   * @returns {Argument[]}
	   */

	  visibleArguments(cmd) {
	    // Side effect! Apply the legacy descriptions before the arguments are displayed.
	    if (cmd._argsDescription) {
	      cmd.registeredArguments.forEach((argument) => {
	        argument.description =
	          argument.description || cmd._argsDescription[argument.name()] || '';
	      });
	    }

	    // If there are any arguments with a description then return all the arguments.
	    if (cmd.registeredArguments.find((argument) => argument.description)) {
	      return cmd.registeredArguments;
	    }
	    return [];
	  }

	  /**
	   * Get the command term to show in the list of subcommands.
	   *
	   * @param {Command} cmd
	   * @returns {string}
	   */

	  subcommandTerm(cmd) {
	    // Legacy. Ignores custom usage string, and nested commands.
	    const args = cmd.registeredArguments
	      .map((arg) => humanReadableArgName(arg))
	      .join(' ');
	    return (
	      cmd._name +
	      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +
	      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option
	      (args ? ' ' + args : '')
	    );
	  }

	  /**
	   * Get the option term to show in the list of options.
	   *
	   * @param {Option} option
	   * @returns {string}
	   */

	  optionTerm(option) {
	    return option.flags;
	  }

	  /**
	   * Get the argument term to show in the list of arguments.
	   *
	   * @param {Argument} argument
	   * @returns {string}
	   */

	  argumentTerm(argument) {
	    return argument.name();
	  }

	  /**
	   * Get the longest command term length.
	   *
	   * @param {Command} cmd
	   * @param {Help} helper
	   * @returns {number}
	   */

	  longestSubcommandTermLength(cmd, helper) {
	    return helper.visibleCommands(cmd).reduce((max, command) => {
	      return Math.max(max, helper.subcommandTerm(command).length);
	    }, 0);
	  }

	  /**
	   * Get the longest option term length.
	   *
	   * @param {Command} cmd
	   * @param {Help} helper
	   * @returns {number}
	   */

	  longestOptionTermLength(cmd, helper) {
	    return helper.visibleOptions(cmd).reduce((max, option) => {
	      return Math.max(max, helper.optionTerm(option).length);
	    }, 0);
	  }

	  /**
	   * Get the longest global option term length.
	   *
	   * @param {Command} cmd
	   * @param {Help} helper
	   * @returns {number}
	   */

	  longestGlobalOptionTermLength(cmd, helper) {
	    return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
	      return Math.max(max, helper.optionTerm(option).length);
	    }, 0);
	  }

	  /**
	   * Get the longest argument term length.
	   *
	   * @param {Command} cmd
	   * @param {Help} helper
	   * @returns {number}
	   */

	  longestArgumentTermLength(cmd, helper) {
	    return helper.visibleArguments(cmd).reduce((max, argument) => {
	      return Math.max(max, helper.argumentTerm(argument).length);
	    }, 0);
	  }

	  /**
	   * Get the command usage to be displayed at the top of the built-in help.
	   *
	   * @param {Command} cmd
	   * @returns {string}
	   */

	  commandUsage(cmd) {
	    // Usage
	    let cmdName = cmd._name;
	    if (cmd._aliases[0]) {
	      cmdName = cmdName + '|' + cmd._aliases[0];
	    }
	    let ancestorCmdNames = '';
	    for (
	      let ancestorCmd = cmd.parent;
	      ancestorCmd;
	      ancestorCmd = ancestorCmd.parent
	    ) {
	      ancestorCmdNames = ancestorCmd.name() + ' ' + ancestorCmdNames;
	    }
	    return ancestorCmdNames + cmdName + ' ' + cmd.usage();
	  }

	  /**
	   * Get the description for the command.
	   *
	   * @param {Command} cmd
	   * @returns {string}
	   */

	  commandDescription(cmd) {
	    // @ts-ignore: because overloaded return type
	    return cmd.description();
	  }

	  /**
	   * Get the subcommand summary to show in the list of subcommands.
	   * (Fallback to description for backwards compatibility.)
	   *
	   * @param {Command} cmd
	   * @returns {string}
	   */

	  subcommandDescription(cmd) {
	    // @ts-ignore: because overloaded return type
	    return cmd.summary() || cmd.description();
	  }

	  /**
	   * Get the option description to show in the list of options.
	   *
	   * @param {Option} option
	   * @return {string}
	   */

	  optionDescription(option) {
	    const extraInfo = [];

	    if (option.argChoices) {
	      extraInfo.push(
	        // use stringify to match the display of the default value
	        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`,
	      );
	    }
	    if (option.defaultValue !== undefined) {
	      // default for boolean and negated more for programmer than end user,
	      // but show true/false for boolean option as may be for hand-rolled env or config processing.
	      const showDefault =
	        option.required ||
	        option.optional ||
	        (option.isBoolean() && typeof option.defaultValue === 'boolean');
	      if (showDefault) {
	        extraInfo.push(
	          `default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`,
	        );
	      }
	    }
	    // preset for boolean and negated are more for programmer than end user
	    if (option.presetArg !== undefined && option.optional) {
	      extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
	    }
	    if (option.envVar !== undefined) {
	      extraInfo.push(`env: ${option.envVar}`);
	    }
	    if (extraInfo.length > 0) {
	      return `${option.description} (${extraInfo.join(', ')})`;
	    }

	    return option.description;
	  }

	  /**
	   * Get the argument description to show in the list of arguments.
	   *
	   * @param {Argument} argument
	   * @return {string}
	   */

	  argumentDescription(argument) {
	    const extraInfo = [];
	    if (argument.argChoices) {
	      extraInfo.push(
	        // use stringify to match the display of the default value
	        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`,
	      );
	    }
	    if (argument.defaultValue !== undefined) {
	      extraInfo.push(
	        `default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`,
	      );
	    }
	    if (extraInfo.length > 0) {
	      const extraDescripton = `(${extraInfo.join(', ')})`;
	      if (argument.description) {
	        return `${argument.description} ${extraDescripton}`;
	      }
	      return extraDescripton;
	    }
	    return argument.description;
	  }

	  /**
	   * Generate the built-in help text.
	   *
	   * @param {Command} cmd
	   * @param {Help} helper
	   * @returns {string}
	   */

	  formatHelp(cmd, helper) {
	    const termWidth = helper.padWidth(cmd, helper);
	    const helpWidth = helper.helpWidth || 80;
	    const itemIndentWidth = 2;
	    const itemSeparatorWidth = 2; // between term and description
	    function formatItem(term, description) {
	      if (description) {
	        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
	        return helper.wrap(
	          fullText,
	          helpWidth - itemIndentWidth,
	          termWidth + itemSeparatorWidth,
	        );
	      }
	      return term;
	    }
	    function formatList(textArray) {
	      return textArray.join('\n').replace(/^/gm, ' '.repeat(itemIndentWidth));
	    }

	    // Usage
	    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];

	    // Description
	    const commandDescription = helper.commandDescription(cmd);
	    if (commandDescription.length > 0) {
	      output = output.concat([
	        helper.wrap(commandDescription, helpWidth, 0),
	        '',
	      ]);
	    }

	    // Arguments
	    const argumentList = helper.visibleArguments(cmd).map((argument) => {
	      return formatItem(
	        helper.argumentTerm(argument),
	        helper.argumentDescription(argument),
	      );
	    });
	    if (argumentList.length > 0) {
	      output = output.concat(['Arguments:', formatList(argumentList), '']);
	    }

	    // Options
	    const optionList = helper.visibleOptions(cmd).map((option) => {
	      return formatItem(
	        helper.optionTerm(option),
	        helper.optionDescription(option),
	      );
	    });
	    if (optionList.length > 0) {
	      output = output.concat(['Options:', formatList(optionList), '']);
	    }

	    if (this.showGlobalOptions) {
	      const globalOptionList = helper
	        .visibleGlobalOptions(cmd)
	        .map((option) => {
	          return formatItem(
	            helper.optionTerm(option),
	            helper.optionDescription(option),
	          );
	        });
	      if (globalOptionList.length > 0) {
	        output = output.concat([
	          'Global Options:',
	          formatList(globalOptionList),
	          '',
	        ]);
	      }
	    }

	    // Commands
	    const commandList = helper.visibleCommands(cmd).map((cmd) => {
	      return formatItem(
	        helper.subcommandTerm(cmd),
	        helper.subcommandDescription(cmd),
	      );
	    });
	    if (commandList.length > 0) {
	      output = output.concat(['Commands:', formatList(commandList), '']);
	    }

	    return output.join('\n');
	  }

	  /**
	   * Calculate the pad width from the maximum term length.
	   *
	   * @param {Command} cmd
	   * @param {Help} helper
	   * @returns {number}
	   */

	  padWidth(cmd, helper) {
	    return Math.max(
	      helper.longestOptionTermLength(cmd, helper),
	      helper.longestGlobalOptionTermLength(cmd, helper),
	      helper.longestSubcommandTermLength(cmd, helper),
	      helper.longestArgumentTermLength(cmd, helper),
	    );
	  }

	  /**
	   * Wrap the given string to width characters per line, with lines after the first indented.
	   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
	   *
	   * @param {string} str
	   * @param {number} width
	   * @param {number} indent
	   * @param {number} [minColumnWidth=40]
	   * @return {string}
	   *
	   */

	  wrap(str, width, indent, minColumnWidth = 40) {
	    // Full \s characters, minus the linefeeds.
	    const indents =
	      ' \\f\\t\\v\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff';
	    // Detect manually wrapped and indented strings by searching for line break followed by spaces.
	    const manualIndent = new RegExp(`[\\n][${indents}]+`);
	    if (str.match(manualIndent)) return str;
	    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).
	    const columnWidth = width - indent;
	    if (columnWidth < minColumnWidth) return str;

	    const leadingStr = str.slice(0, indent);
	    const columnText = str.slice(indent).replace('\r\n', '\n');
	    const indentString = ' '.repeat(indent);
	    const zeroWidthSpace = '\u200B';
	    const breaks = `\\s${zeroWidthSpace}`;
	    // Match line end (so empty lines don't collapse),
	    // or as much text as will fit in column, or excess text up to first break.
	    const regex = new RegExp(
	      `\n|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`,
	      'g',
	    );
	    const lines = columnText.match(regex) || [];
	    return (
	      leadingStr +
	      lines
	        .map((line, i) => {
	          if (line === '\n') return ''; // preserve empty lines
	          return (i > 0 ? indentString : '') + line.trimEnd();
	        })
	        .join('\n')
	    );
	  }
	}

	help.Help = Help;
	return help;
}

var option = {};

var hasRequiredOption;

function requireOption () {
	if (hasRequiredOption) return option;
	hasRequiredOption = 1;
	const { InvalidArgumentError } = requireError();

	class Option {
	  /**
	   * Initialize a new `Option` with the given `flags` and `description`.
	   *
	   * @param {string} flags
	   * @param {string} [description]
	   */

	  constructor(flags, description) {
	    this.flags = flags;
	    this.description = description || '';

	    this.required = flags.includes('<'); // A value must be supplied when the option is specified.
	    this.optional = flags.includes('['); // A value is optional when the option is specified.
	    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument
	    this.variadic = /\w\.\.\.[>\]]$/.test(flags); // The option can take multiple values.
	    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.
	    const optionFlags = splitOptionFlags(flags);
	    this.short = optionFlags.shortFlag;
	    this.long = optionFlags.longFlag;
	    this.negate = false;
	    if (this.long) {
	      this.negate = this.long.startsWith('--no-');
	    }
	    this.defaultValue = undefined;
	    this.defaultValueDescription = undefined;
	    this.presetArg = undefined;
	    this.envVar = undefined;
	    this.parseArg = undefined;
	    this.hidden = false;
	    this.argChoices = undefined;
	    this.conflictsWith = [];
	    this.implied = undefined;
	  }

	  /**
	   * Set the default value, and optionally supply the description to be displayed in the help.
	   *
	   * @param {*} value
	   * @param {string} [description]
	   * @return {Option}
	   */

	  default(value, description) {
	    this.defaultValue = value;
	    this.defaultValueDescription = description;
	    return this;
	  }

	  /**
	   * Preset to use when option used without option-argument, especially optional but also boolean and negated.
	   * The custom processing (parseArg) is called.
	   *
	   * @example
	   * new Option('--color').default('GREYSCALE').preset('RGB');
	   * new Option('--donate [amount]').preset('20').argParser(parseFloat);
	   *
	   * @param {*} arg
	   * @return {Option}
	   */

	  preset(arg) {
	    this.presetArg = arg;
	    return this;
	  }

	  /**
	   * Add option name(s) that conflict with this option.
	   * An error will be displayed if conflicting options are found during parsing.
	   *
	   * @example
	   * new Option('--rgb').conflicts('cmyk');
	   * new Option('--js').conflicts(['ts', 'jsx']);
	   *
	   * @param {(string | string[])} names
	   * @return {Option}
	   */

	  conflicts(names) {
	    this.conflictsWith = this.conflictsWith.concat(names);
	    return this;
	  }

	  /**
	   * Specify implied option values for when this option is set and the implied options are not.
	   *
	   * The custom processing (parseArg) is not called on the implied values.
	   *
	   * @example
	   * program
	   *   .addOption(new Option('--log', 'write logging information to file'))
	   *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
	   *
	   * @param {object} impliedOptionValues
	   * @return {Option}
	   */
	  implies(impliedOptionValues) {
	    let newImplied = impliedOptionValues;
	    if (typeof impliedOptionValues === 'string') {
	      // string is not documented, but easy mistake and we can do what user probably intended.
	      newImplied = { [impliedOptionValues]: true };
	    }
	    this.implied = Object.assign(this.implied || {}, newImplied);
	    return this;
	  }

	  /**
	   * Set environment variable to check for option value.
	   *
	   * An environment variable is only used if when processed the current option value is
	   * undefined, or the source of the current value is 'default' or 'config' or 'env'.
	   *
	   * @param {string} name
	   * @return {Option}
	   */

	  env(name) {
	    this.envVar = name;
	    return this;
	  }

	  /**
	   * Set the custom handler for processing CLI option arguments into option values.
	   *
	   * @param {Function} [fn]
	   * @return {Option}
	   */

	  argParser(fn) {
	    this.parseArg = fn;
	    return this;
	  }

	  /**
	   * Whether the option is mandatory and must have a value after parsing.
	   *
	   * @param {boolean} [mandatory=true]
	   * @return {Option}
	   */

	  makeOptionMandatory(mandatory = true) {
	    this.mandatory = !!mandatory;
	    return this;
	  }

	  /**
	   * Hide option in help.
	   *
	   * @param {boolean} [hide=true]
	   * @return {Option}
	   */

	  hideHelp(hide = true) {
	    this.hidden = !!hide;
	    return this;
	  }

	  /**
	   * @package
	   */

	  _concatValue(value, previous) {
	    if (previous === this.defaultValue || !Array.isArray(previous)) {
	      return [value];
	    }

	    return previous.concat(value);
	  }

	  /**
	   * Only allow option value to be one of choices.
	   *
	   * @param {string[]} values
	   * @return {Option}
	   */

	  choices(values) {
	    this.argChoices = values.slice();
	    this.parseArg = (arg, previous) => {
	      if (!this.argChoices.includes(arg)) {
	        throw new InvalidArgumentError(
	          `Allowed choices are ${this.argChoices.join(', ')}.`,
	        );
	      }
	      if (this.variadic) {
	        return this._concatValue(arg, previous);
	      }
	      return arg;
	    };
	    return this;
	  }

	  /**
	   * Return option name.
	   *
	   * @return {string}
	   */

	  name() {
	    if (this.long) {
	      return this.long.replace(/^--/, '');
	    }
	    return this.short.replace(/^-/, '');
	  }

	  /**
	   * Return option name, in a camelcase format that can be used
	   * as a object attribute key.
	   *
	   * @return {string}
	   */

	  attributeName() {
	    return camelcase(this.name().replace(/^no-/, ''));
	  }

	  /**
	   * Check if `arg` matches the short or long flag.
	   *
	   * @param {string} arg
	   * @return {boolean}
	   * @package
	   */

	  is(arg) {
	    return this.short === arg || this.long === arg;
	  }

	  /**
	   * Return whether a boolean option.
	   *
	   * Options are one of boolean, negated, required argument, or optional argument.
	   *
	   * @return {boolean}
	   * @package
	   */

	  isBoolean() {
	    return !this.required && !this.optional && !this.negate;
	  }
	}

	/**
	 * This class is to make it easier to work with dual options, without changing the existing
	 * implementation. We support separate dual options for separate positive and negative options,
	 * like `--build` and `--no-build`, which share a single option value. This works nicely for some
	 * use cases, but is tricky for others where we want separate behaviours despite
	 * the single shared option value.
	 */
	class DualOptions {
	  /**
	   * @param {Option[]} options
	   */
	  constructor(options) {
	    this.positiveOptions = new Map();
	    this.negativeOptions = new Map();
	    this.dualOptions = new Set();
	    options.forEach((option) => {
	      if (option.negate) {
	        this.negativeOptions.set(option.attributeName(), option);
	      } else {
	        this.positiveOptions.set(option.attributeName(), option);
	      }
	    });
	    this.negativeOptions.forEach((value, key) => {
	      if (this.positiveOptions.has(key)) {
	        this.dualOptions.add(key);
	      }
	    });
	  }

	  /**
	   * Did the value come from the option, and not from possible matching dual option?
	   *
	   * @param {*} value
	   * @param {Option} option
	   * @returns {boolean}
	   */
	  valueFromOption(value, option) {
	    const optionKey = option.attributeName();
	    if (!this.dualOptions.has(optionKey)) return true;

	    // Use the value to deduce if (probably) came from the option.
	    const preset = this.negativeOptions.get(optionKey).presetArg;
	    const negativeValue = preset !== undefined ? preset : false;
	    return option.negate === (negativeValue === value);
	  }
	}

	/**
	 * Convert string from kebab-case to camelCase.
	 *
	 * @param {string} str
	 * @return {string}
	 * @private
	 */

	function camelcase(str) {
	  return str.split('-').reduce((str, word) => {
	    return str + word[0].toUpperCase() + word.slice(1);
	  });
	}

	/**
	 * Split the short and long flag out of something like '-m,--mixed <value>'
	 *
	 * @private
	 */

	function splitOptionFlags(flags) {
	  let shortFlag;
	  let longFlag;
	  // Use original very loose parsing to maintain backwards compatibility for now,
	  // which allowed for example unintended `-sw, --short-word` [sic].
	  const flagParts = flags.split(/[ |,]+/);
	  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
	    shortFlag = flagParts.shift();
	  longFlag = flagParts.shift();
	  // Add support for lone short flag without significantly changing parsing!
	  if (!shortFlag && /^-[^-]$/.test(longFlag)) {
	    shortFlag = longFlag;
	    longFlag = undefined;
	  }
	  return { shortFlag, longFlag };
	}

	option.Option = Option;
	option.DualOptions = DualOptions;
	return option;
}

var suggestSimilar = {};

var hasRequiredSuggestSimilar;

function requireSuggestSimilar () {
	if (hasRequiredSuggestSimilar) return suggestSimilar;
	hasRequiredSuggestSimilar = 1;
	const maxDistance = 3;

	function editDistance(a, b) {
	  // https://en.wikipedia.org/wiki/Damerau–Levenshtein_distance
	  // Calculating optimal string alignment distance, no substring is edited more than once.
	  // (Simple implementation.)

	  // Quick early exit, return worst case.
	  if (Math.abs(a.length - b.length) > maxDistance)
	    return Math.max(a.length, b.length);

	  // distance between prefix substrings of a and b
	  const d = [];

	  // pure deletions turn a into empty string
	  for (let i = 0; i <= a.length; i++) {
	    d[i] = [i];
	  }
	  // pure insertions turn empty string into b
	  for (let j = 0; j <= b.length; j++) {
	    d[0][j] = j;
	  }

	  // fill matrix
	  for (let j = 1; j <= b.length; j++) {
	    for (let i = 1; i <= a.length; i++) {
	      let cost = 1;
	      if (a[i - 1] === b[j - 1]) {
	        cost = 0;
	      } else {
	        cost = 1;
	      }
	      d[i][j] = Math.min(
	        d[i - 1][j] + 1, // deletion
	        d[i][j - 1] + 1, // insertion
	        d[i - 1][j - 1] + cost, // substitution
	      );
	      // transposition
	      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
	        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
	      }
	    }
	  }

	  return d[a.length][b.length];
	}

	/**
	 * Find close matches, restricted to same number of edits.
	 *
	 * @param {string} word
	 * @param {string[]} candidates
	 * @returns {string}
	 */

	function suggestSimilar$1(word, candidates) {
	  if (!candidates || candidates.length === 0) return '';
	  // remove possible duplicates
	  candidates = Array.from(new Set(candidates));

	  const searchingOptions = word.startsWith('--');
	  if (searchingOptions) {
	    word = word.slice(2);
	    candidates = candidates.map((candidate) => candidate.slice(2));
	  }

	  let similar = [];
	  let bestDistance = maxDistance;
	  const minSimilarity = 0.4;
	  candidates.forEach((candidate) => {
	    if (candidate.length <= 1) return; // no one character guesses

	    const distance = editDistance(word, candidate);
	    const length = Math.max(word.length, candidate.length);
	    const similarity = (length - distance) / length;
	    if (similarity > minSimilarity) {
	      if (distance < bestDistance) {
	        // better edit distance, throw away previous worse matches
	        bestDistance = distance;
	        similar = [candidate];
	      } else if (distance === bestDistance) {
	        similar.push(candidate);
	      }
	    }
	  });

	  similar.sort((a, b) => a.localeCompare(b));
	  if (searchingOptions) {
	    similar = similar.map((candidate) => `--${candidate}`);
	  }

	  if (similar.length > 1) {
	    return `\n(Did you mean one of ${similar.join(', ')}?)`;
	  }
	  if (similar.length === 1) {
	    return `\n(Did you mean ${similar[0]}?)`;
	  }
	  return '';
	}

	suggestSimilar.suggestSimilar = suggestSimilar$1;
	return suggestSimilar;
}

var hasRequiredCommand;

function requireCommand () {
	if (hasRequiredCommand) return command;
	hasRequiredCommand = 1;
	const EventEmitter$1 = EventEmitter.EventEmitter;
	const childProcess = require$$1$2;
	const path = path$1;
	const fs = fs$1;
	const process = require$$4;

	const { Argument, humanReadableArgName } = requireArgument();
	const { CommanderError } = requireError();
	const { Help } = requireHelp();
	const { Option, DualOptions } = requireOption();
	const { suggestSimilar } = requireSuggestSimilar();

	class Command extends EventEmitter$1 {
	  /**
	   * Initialize a new `Command`.
	   *
	   * @param {string} [name]
	   */

	  constructor(name) {
	    super();
	    /** @type {Command[]} */
	    this.commands = [];
	    /** @type {Option[]} */
	    this.options = [];
	    this.parent = null;
	    this._allowUnknownOption = false;
	    this._allowExcessArguments = true;
	    /** @type {Argument[]} */
	    this.registeredArguments = [];
	    this._args = this.registeredArguments; // deprecated old name
	    /** @type {string[]} */
	    this.args = []; // cli args with options removed
	    this.rawArgs = [];
	    this.processedArgs = []; // like .args but after custom processing and collecting variadic
	    this._scriptPath = null;
	    this._name = name || '';
	    this._optionValues = {};
	    this._optionValueSources = {}; // default, env, cli etc
	    this._storeOptionsAsProperties = false;
	    this._actionHandler = null;
	    this._executableHandler = false;
	    this._executableFile = null; // custom name for executable
	    this._executableDir = null; // custom search directory for subcommands
	    this._defaultCommandName = null;
	    this._exitCallback = null;
	    this._aliases = [];
	    this._combineFlagAndOptionalValue = true;
	    this._description = '';
	    this._summary = '';
	    this._argsDescription = undefined; // legacy
	    this._enablePositionalOptions = false;
	    this._passThroughOptions = false;
	    this._lifeCycleHooks = {}; // a hash of arrays
	    /** @type {(boolean | string)} */
	    this._showHelpAfterError = false;
	    this._showSuggestionAfterError = true;

	    // see .configureOutput() for docs
	    this._outputConfiguration = {
	      writeOut: (str) => process.stdout.write(str),
	      writeErr: (str) => process.stderr.write(str),
	      getOutHelpWidth: () =>
	        process.stdout.isTTY ? process.stdout.columns : undefined,
	      getErrHelpWidth: () =>
	        process.stderr.isTTY ? process.stderr.columns : undefined,
	      outputError: (str, write) => write(str),
	    };

	    this._hidden = false;
	    /** @type {(Option | null | undefined)} */
	    this._helpOption = undefined; // Lazy created on demand. May be null if help option is disabled.
	    this._addImplicitHelpCommand = undefined; // undecided whether true or false yet, not inherited
	    /** @type {Command} */
	    this._helpCommand = undefined; // lazy initialised, inherited
	    this._helpConfiguration = {};
	  }

	  /**
	   * Copy settings that are useful to have in common across root command and subcommands.
	   *
	   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
	   *
	   * @param {Command} sourceCommand
	   * @return {Command} `this` command for chaining
	   */
	  copyInheritedSettings(sourceCommand) {
	    this._outputConfiguration = sourceCommand._outputConfiguration;
	    this._helpOption = sourceCommand._helpOption;
	    this._helpCommand = sourceCommand._helpCommand;
	    this._helpConfiguration = sourceCommand._helpConfiguration;
	    this._exitCallback = sourceCommand._exitCallback;
	    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
	    this._combineFlagAndOptionalValue =
	      sourceCommand._combineFlagAndOptionalValue;
	    this._allowExcessArguments = sourceCommand._allowExcessArguments;
	    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
	    this._showHelpAfterError = sourceCommand._showHelpAfterError;
	    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;

	    return this;
	  }

	  /**
	   * @returns {Command[]}
	   * @private
	   */

	  _getCommandAndAncestors() {
	    const result = [];
	    // eslint-disable-next-line @typescript-eslint/no-this-alias
	    for (let command = this; command; command = command.parent) {
	      result.push(command);
	    }
	    return result;
	  }

	  /**
	   * Define a command.
	   *
	   * There are two styles of command: pay attention to where to put the description.
	   *
	   * @example
	   * // Command implemented using action handler (description is supplied separately to `.command`)
	   * program
	   *   .command('clone <source> [destination]')
	   *   .description('clone a repository into a newly created directory')
	   *   .action((source, destination) => {
	   *     console.log('clone command called');
	   *   });
	   *
	   * // Command implemented using separate executable file (description is second parameter to `.command`)
	   * program
	   *   .command('start <service>', 'start named service')
	   *   .command('stop [service]', 'stop named service, or all if no name supplied');
	   *
	   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
	   * @param {(object | string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
	   * @param {object} [execOpts] - configuration options (for executable)
	   * @return {Command} returns new command for action handler, or `this` for executable command
	   */

	  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
	    let desc = actionOptsOrExecDesc;
	    let opts = execOpts;
	    if (typeof desc === 'object' && desc !== null) {
	      opts = desc;
	      desc = null;
	    }
	    opts = opts || {};
	    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);

	    const cmd = this.createCommand(name);
	    if (desc) {
	      cmd.description(desc);
	      cmd._executableHandler = true;
	    }
	    if (opts.isDefault) this._defaultCommandName = cmd._name;
	    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden
	    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor
	    if (args) cmd.arguments(args);
	    this._registerCommand(cmd);
	    cmd.parent = this;
	    cmd.copyInheritedSettings(this);

	    if (desc) return this;
	    return cmd;
	  }

	  /**
	   * Factory routine to create a new unattached command.
	   *
	   * See .command() for creating an attached subcommand, which uses this routine to
	   * create the command. You can override createCommand to customise subcommands.
	   *
	   * @param {string} [name]
	   * @return {Command} new command
	   */

	  createCommand(name) {
	    return new Command(name);
	  }

	  /**
	   * You can customise the help with a subclass of Help by overriding createHelp,
	   * or by overriding Help properties using configureHelp().
	   *
	   * @return {Help}
	   */

	  createHelp() {
	    return Object.assign(new Help(), this.configureHelp());
	  }

	  /**
	   * You can customise the help by overriding Help properties using configureHelp(),
	   * or with a subclass of Help by overriding createHelp().
	   *
	   * @param {object} [configuration] - configuration options
	   * @return {(Command | object)} `this` command for chaining, or stored configuration
	   */

	  configureHelp(configuration) {
	    if (configuration === undefined) return this._helpConfiguration;

	    this._helpConfiguration = configuration;
	    return this;
	  }

	  /**
	   * The default output goes to stdout and stderr. You can customise this for special
	   * applications. You can also customise the display of errors by overriding outputError.
	   *
	   * The configuration properties are all functions:
	   *
	   *     // functions to change where being written, stdout and stderr
	   *     writeOut(str)
	   *     writeErr(str)
	   *     // matching functions to specify width for wrapping help
	   *     getOutHelpWidth()
	   *     getErrHelpWidth()
	   *     // functions based on what is being written out
	   *     outputError(str, write) // used for displaying errors, and not used for displaying help
	   *
	   * @param {object} [configuration] - configuration options
	   * @return {(Command | object)} `this` command for chaining, or stored configuration
	   */

	  configureOutput(configuration) {
	    if (configuration === undefined) return this._outputConfiguration;

	    Object.assign(this._outputConfiguration, configuration);
	    return this;
	  }

	  /**
	   * Display the help or a custom message after an error occurs.
	   *
	   * @param {(boolean|string)} [displayHelp]
	   * @return {Command} `this` command for chaining
	   */
	  showHelpAfterError(displayHelp = true) {
	    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;
	    this._showHelpAfterError = displayHelp;
	    return this;
	  }

	  /**
	   * Display suggestion of similar commands for unknown commands, or options for unknown options.
	   *
	   * @param {boolean} [displaySuggestion]
	   * @return {Command} `this` command for chaining
	   */
	  showSuggestionAfterError(displaySuggestion = true) {
	    this._showSuggestionAfterError = !!displaySuggestion;
	    return this;
	  }

	  /**
	   * Add a prepared subcommand.
	   *
	   * See .command() for creating an attached subcommand which inherits settings from its parent.
	   *
	   * @param {Command} cmd - new subcommand
	   * @param {object} [opts] - configuration options
	   * @return {Command} `this` command for chaining
	   */

	  addCommand(cmd, opts) {
	    if (!cmd._name) {
	      throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
	    }

	    opts = opts || {};
	    if (opts.isDefault) this._defaultCommandName = cmd._name;
	    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation

	    this._registerCommand(cmd);
	    cmd.parent = this;
	    cmd._checkForBrokenPassThrough();

	    return this;
	  }

	  /**
	   * Factory routine to create a new unattached argument.
	   *
	   * See .argument() for creating an attached argument, which uses this routine to
	   * create the argument. You can override createArgument to return a custom argument.
	   *
	   * @param {string} name
	   * @param {string} [description]
	   * @return {Argument} new argument
	   */

	  createArgument(name, description) {
	    return new Argument(name, description);
	  }

	  /**
	   * Define argument syntax for command.
	   *
	   * The default is that the argument is required, and you can explicitly
	   * indicate this with <> around the name. Put [] around the name for an optional argument.
	   *
	   * @example
	   * program.argument('<input-file>');
	   * program.argument('[output-file]');
	   *
	   * @param {string} name
	   * @param {string} [description]
	   * @param {(Function|*)} [fn] - custom argument processing function
	   * @param {*} [defaultValue]
	   * @return {Command} `this` command for chaining
	   */
	  argument(name, description, fn, defaultValue) {
	    const argument = this.createArgument(name, description);
	    if (typeof fn === 'function') {
	      argument.default(defaultValue).argParser(fn);
	    } else {
	      argument.default(fn);
	    }
	    this.addArgument(argument);
	    return this;
	  }

	  /**
	   * Define argument syntax for command, adding multiple at once (without descriptions).
	   *
	   * See also .argument().
	   *
	   * @example
	   * program.arguments('<cmd> [env]');
	   *
	   * @param {string} names
	   * @return {Command} `this` command for chaining
	   */

	  arguments(names) {
	    names
	      .trim()
	      .split(/ +/)
	      .forEach((detail) => {
	        this.argument(detail);
	      });
	    return this;
	  }

	  /**
	   * Define argument syntax for command, adding a prepared argument.
	   *
	   * @param {Argument} argument
	   * @return {Command} `this` command for chaining
	   */
	  addArgument(argument) {
	    const previousArgument = this.registeredArguments.slice(-1)[0];
	    if (previousArgument && previousArgument.variadic) {
	      throw new Error(
	        `only the last argument can be variadic '${previousArgument.name()}'`,
	      );
	    }
	    if (
	      argument.required &&
	      argument.defaultValue !== undefined &&
	      argument.parseArg === undefined
	    ) {
	      throw new Error(
	        `a default value for a required argument is never used: '${argument.name()}'`,
	      );
	    }
	    this.registeredArguments.push(argument);
	    return this;
	  }

	  /**
	   * Customise or override default help command. By default a help command is automatically added if your command has subcommands.
	   *
	   * @example
	   *    program.helpCommand('help [cmd]');
	   *    program.helpCommand('help [cmd]', 'show help');
	   *    program.helpCommand(false); // suppress default help command
	   *    program.helpCommand(true); // add help command even if no subcommands
	   *
	   * @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added
	   * @param {string} [description] - custom description
	   * @return {Command} `this` command for chaining
	   */

	  helpCommand(enableOrNameAndArgs, description) {
	    if (typeof enableOrNameAndArgs === 'boolean') {
	      this._addImplicitHelpCommand = enableOrNameAndArgs;
	      return this;
	    }

	    enableOrNameAndArgs = enableOrNameAndArgs ?? 'help [command]';
	    const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/);
	    const helpDescription = description ?? 'display help for command';

	    const helpCommand = this.createCommand(helpName);
	    helpCommand.helpOption(false);
	    if (helpArgs) helpCommand.arguments(helpArgs);
	    if (helpDescription) helpCommand.description(helpDescription);

	    this._addImplicitHelpCommand = true;
	    this._helpCommand = helpCommand;

	    return this;
	  }

	  /**
	   * Add prepared custom help command.
	   *
	   * @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`
	   * @param {string} [deprecatedDescription] - deprecated custom description used with custom name only
	   * @return {Command} `this` command for chaining
	   */
	  addHelpCommand(helpCommand, deprecatedDescription) {
	    // If not passed an object, call through to helpCommand for backwards compatibility,
	    // as addHelpCommand was originally used like helpCommand is now.
	    if (typeof helpCommand !== 'object') {
	      this.helpCommand(helpCommand, deprecatedDescription);
	      return this;
	    }

	    this._addImplicitHelpCommand = true;
	    this._helpCommand = helpCommand;
	    return this;
	  }

	  /**
	   * Lazy create help command.
	   *
	   * @return {(Command|null)}
	   * @package
	   */
	  _getHelpCommand() {
	    const hasImplicitHelpCommand =
	      this._addImplicitHelpCommand ??
	      (this.commands.length &&
	        !this._actionHandler &&
	        !this._findCommand('help'));

	    if (hasImplicitHelpCommand) {
	      if (this._helpCommand === undefined) {
	        this.helpCommand(undefined, undefined); // use default name and description
	      }
	      return this._helpCommand;
	    }
	    return null;
	  }

	  /**
	   * Add hook for life cycle event.
	   *
	   * @param {string} event
	   * @param {Function} listener
	   * @return {Command} `this` command for chaining
	   */

	  hook(event, listener) {
	    const allowedValues = ['preSubcommand', 'preAction', 'postAction'];
	    if (!allowedValues.includes(event)) {
	      throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
	    }
	    if (this._lifeCycleHooks[event]) {
	      this._lifeCycleHooks[event].push(listener);
	    } else {
	      this._lifeCycleHooks[event] = [listener];
	    }
	    return this;
	  }

	  /**
	   * Register callback to use as replacement for calling process.exit.
	   *
	   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
	   * @return {Command} `this` command for chaining
	   */

	  exitOverride(fn) {
	    if (fn) {
	      this._exitCallback = fn;
	    } else {
	      this._exitCallback = (err) => {
	        if (err.code !== 'commander.executeSubCommandAsync') {
	          throw err;
	        }
	      };
	    }
	    return this;
	  }

	  /**
	   * Call process.exit, and _exitCallback if defined.
	   *
	   * @param {number} exitCode exit code for using with process.exit
	   * @param {string} code an id string representing the error
	   * @param {string} message human-readable description of the error
	   * @return never
	   * @private
	   */

	  _exit(exitCode, code, message) {
	    if (this._exitCallback) {
	      this._exitCallback(new CommanderError(exitCode, code, message));
	      // Expecting this line is not reached.
	    }
	    process.exit(exitCode);
	  }

	  /**
	   * Register callback `fn` for the command.
	   *
	   * @example
	   * program
	   *   .command('serve')
	   *   .description('start service')
	   *   .action(function() {
	   *      // do work here
	   *   });
	   *
	   * @param {Function} fn
	   * @return {Command} `this` command for chaining
	   */

	  action(fn) {
	    const listener = (args) => {
	      // The .action callback takes an extra parameter which is the command or options.
	      const expectedArgsCount = this.registeredArguments.length;
	      const actionArgs = args.slice(0, expectedArgsCount);
	      if (this._storeOptionsAsProperties) {
	        actionArgs[expectedArgsCount] = this; // backwards compatible "options"
	      } else {
	        actionArgs[expectedArgsCount] = this.opts();
	      }
	      actionArgs.push(this);

	      return fn.apply(this, actionArgs);
	    };
	    this._actionHandler = listener;
	    return this;
	  }

	  /**
	   * Factory routine to create a new unattached option.
	   *
	   * See .option() for creating an attached option, which uses this routine to
	   * create the option. You can override createOption to return a custom option.
	   *
	   * @param {string} flags
	   * @param {string} [description]
	   * @return {Option} new option
	   */

	  createOption(flags, description) {
	    return new Option(flags, description);
	  }

	  /**
	   * Wrap parseArgs to catch 'commander.invalidArgument'.
	   *
	   * @param {(Option | Argument)} target
	   * @param {string} value
	   * @param {*} previous
	   * @param {string} invalidArgumentMessage
	   * @private
	   */

	  _callParseArg(target, value, previous, invalidArgumentMessage) {
	    try {
	      return target.parseArg(value, previous);
	    } catch (err) {
	      if (err.code === 'commander.invalidArgument') {
	        const message = `${invalidArgumentMessage} ${err.message}`;
	        this.error(message, { exitCode: err.exitCode, code: err.code });
	      }
	      throw err;
	    }
	  }

	  /**
	   * Check for option flag conflicts.
	   * Register option if no conflicts found, or throw on conflict.
	   *
	   * @param {Option} option
	   * @private
	   */

	  _registerOption(option) {
	    const matchingOption =
	      (option.short && this._findOption(option.short)) ||
	      (option.long && this._findOption(option.long));
	    if (matchingOption) {
	      const matchingFlag =
	        option.long && this._findOption(option.long)
	          ? option.long
	          : option.short;
	      throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
	    }

	    this.options.push(option);
	  }

	  /**
	   * Check for command name and alias conflicts with existing commands.
	   * Register command if no conflicts found, or throw on conflict.
	   *
	   * @param {Command} command
	   * @private
	   */

	  _registerCommand(command) {
	    const knownBy = (cmd) => {
	      return [cmd.name()].concat(cmd.aliases());
	    };

	    const alreadyUsed = knownBy(command).find((name) =>
	      this._findCommand(name),
	    );
	    if (alreadyUsed) {
	      const existingCmd = knownBy(this._findCommand(alreadyUsed)).join('|');
	      const newCmd = knownBy(command).join('|');
	      throw new Error(
	        `cannot add command '${newCmd}' as already have command '${existingCmd}'`,
	      );
	    }

	    this.commands.push(command);
	  }

	  /**
	   * Add an option.
	   *
	   * @param {Option} option
	   * @return {Command} `this` command for chaining
	   */
	  addOption(option) {
	    this._registerOption(option);

	    const oname = option.name();
	    const name = option.attributeName();

	    // store default value
	    if (option.negate) {
	      // --no-foo is special and defaults foo to true, unless a --foo option is already defined
	      const positiveLongFlag = option.long.replace(/^--no-/, '--');
	      if (!this._findOption(positiveLongFlag)) {
	        this.setOptionValueWithSource(
	          name,
	          option.defaultValue === undefined ? true : option.defaultValue,
	          'default',
	        );
	      }
	    } else if (option.defaultValue !== undefined) {
	      this.setOptionValueWithSource(name, option.defaultValue, 'default');
	    }

	    // handler for cli and env supplied values
	    const handleOptionValue = (val, invalidValueMessage, valueSource) => {
	      // val is null for optional option used without an optional-argument.
	      // val is undefined for boolean and negated option.
	      if (val == null && option.presetArg !== undefined) {
	        val = option.presetArg;
	      }

	      // custom processing
	      const oldValue = this.getOptionValue(name);
	      if (val !== null && option.parseArg) {
	        val = this._callParseArg(option, val, oldValue, invalidValueMessage);
	      } else if (val !== null && option.variadic) {
	        val = option._concatValue(val, oldValue);
	      }

	      // Fill-in appropriate missing values. Long winded but easy to follow.
	      if (val == null) {
	        if (option.negate) {
	          val = false;
	        } else if (option.isBoolean() || option.optional) {
	          val = true;
	        } else {
	          val = ''; // not normal, parseArg might have failed or be a mock function for testing
	        }
	      }
	      this.setOptionValueWithSource(name, val, valueSource);
	    };

	    this.on('option:' + oname, (val) => {
	      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
	      handleOptionValue(val, invalidValueMessage, 'cli');
	    });

	    if (option.envVar) {
	      this.on('optionEnv:' + oname, (val) => {
	        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
	        handleOptionValue(val, invalidValueMessage, 'env');
	      });
	    }

	    return this;
	  }

	  /**
	   * Internal implementation shared by .option() and .requiredOption()
	   *
	   * @return {Command} `this` command for chaining
	   * @private
	   */
	  _optionEx(config, flags, description, fn, defaultValue) {
	    if (typeof flags === 'object' && flags instanceof Option) {
	      throw new Error(
	        'To add an Option object use addOption() instead of option() or requiredOption()',
	      );
	    }
	    const option = this.createOption(flags, description);
	    option.makeOptionMandatory(!!config.mandatory);
	    if (typeof fn === 'function') {
	      option.default(defaultValue).argParser(fn);
	    } else if (fn instanceof RegExp) {
	      // deprecated
	      const regex = fn;
	      fn = (val, def) => {
	        const m = regex.exec(val);
	        return m ? m[0] : def;
	      };
	      option.default(defaultValue).argParser(fn);
	    } else {
	      option.default(fn);
	    }

	    return this.addOption(option);
	  }

	  /**
	   * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
	   *
	   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
	   * option-argument is indicated by `<>` and an optional option-argument by `[]`.
	   *
	   * See the README for more details, and see also addOption() and requiredOption().
	   *
	   * @example
	   * program
	   *     .option('-p, --pepper', 'add pepper')
	   *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
	   *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
	   *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
	   *
	   * @param {string} flags
	   * @param {string} [description]
	   * @param {(Function|*)} [parseArg] - custom option processing function or default value
	   * @param {*} [defaultValue]
	   * @return {Command} `this` command for chaining
	   */

	  option(flags, description, parseArg, defaultValue) {
	    return this._optionEx({}, flags, description, parseArg, defaultValue);
	  }

	  /**
	   * Add a required option which must have a value after parsing. This usually means
	   * the option must be specified on the command line. (Otherwise the same as .option().)
	   *
	   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
	   *
	   * @param {string} flags
	   * @param {string} [description]
	   * @param {(Function|*)} [parseArg] - custom option processing function or default value
	   * @param {*} [defaultValue]
	   * @return {Command} `this` command for chaining
	   */

	  requiredOption(flags, description, parseArg, defaultValue) {
	    return this._optionEx(
	      { mandatory: true },
	      flags,
	      description,
	      parseArg,
	      defaultValue,
	    );
	  }

	  /**
	   * Alter parsing of short flags with optional values.
	   *
	   * @example
	   * // for `.option('-f,--flag [value]'):
	   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
	   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
	   *
	   * @param {boolean} [combine] - if `true` or omitted, an optional value can be specified directly after the flag.
	   * @return {Command} `this` command for chaining
	   */
	  combineFlagAndOptionalValue(combine = true) {
	    this._combineFlagAndOptionalValue = !!combine;
	    return this;
	  }

	  /**
	   * Allow unknown options on the command line.
	   *
	   * @param {boolean} [allowUnknown] - if `true` or omitted, no error will be thrown for unknown options.
	   * @return {Command} `this` command for chaining
	   */
	  allowUnknownOption(allowUnknown = true) {
	    this._allowUnknownOption = !!allowUnknown;
	    return this;
	  }

	  /**
	   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
	   *
	   * @param {boolean} [allowExcess] - if `true` or omitted, no error will be thrown for excess arguments.
	   * @return {Command} `this` command for chaining
	   */
	  allowExcessArguments(allowExcess = true) {
	    this._allowExcessArguments = !!allowExcess;
	    return this;
	  }

	  /**
	   * Enable positional options. Positional means global options are specified before subcommands which lets
	   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
	   * The default behaviour is non-positional and global options may appear anywhere on the command line.
	   *
	   * @param {boolean} [positional]
	   * @return {Command} `this` command for chaining
	   */
	  enablePositionalOptions(positional = true) {
	    this._enablePositionalOptions = !!positional;
	    return this;
	  }

	  /**
	   * Pass through options that come after command-arguments rather than treat them as command-options,
	   * so actual command-options come before command-arguments. Turning this on for a subcommand requires
	   * positional options to have been enabled on the program (parent commands).
	   * The default behaviour is non-positional and options may appear before or after command-arguments.
	   *
	   * @param {boolean} [passThrough] for unknown options.
	   * @return {Command} `this` command for chaining
	   */
	  passThroughOptions(passThrough = true) {
	    this._passThroughOptions = !!passThrough;
	    this._checkForBrokenPassThrough();
	    return this;
	  }

	  /**
	   * @private
	   */

	  _checkForBrokenPassThrough() {
	    if (
	      this.parent &&
	      this._passThroughOptions &&
	      !this.parent._enablePositionalOptions
	    ) {
	      throw new Error(
	        `passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`,
	      );
	    }
	  }

	  /**
	   * Whether to store option values as properties on command object,
	   * or store separately (specify false). In both cases the option values can be accessed using .opts().
	   *
	   * @param {boolean} [storeAsProperties=true]
	   * @return {Command} `this` command for chaining
	   */

	  storeOptionsAsProperties(storeAsProperties = true) {
	    if (this.options.length) {
	      throw new Error('call .storeOptionsAsProperties() before adding options');
	    }
	    if (Object.keys(this._optionValues).length) {
	      throw new Error(
	        'call .storeOptionsAsProperties() before setting option values',
	      );
	    }
	    this._storeOptionsAsProperties = !!storeAsProperties;
	    return this;
	  }

	  /**
	   * Retrieve option value.
	   *
	   * @param {string} key
	   * @return {object} value
	   */

	  getOptionValue(key) {
	    if (this._storeOptionsAsProperties) {
	      return this[key];
	    }
	    return this._optionValues[key];
	  }

	  /**
	   * Store option value.
	   *
	   * @param {string} key
	   * @param {object} value
	   * @return {Command} `this` command for chaining
	   */

	  setOptionValue(key, value) {
	    return this.setOptionValueWithSource(key, value, undefined);
	  }

	  /**
	   * Store option value and where the value came from.
	   *
	   * @param {string} key
	   * @param {object} value
	   * @param {string} source - expected values are default/config/env/cli/implied
	   * @return {Command} `this` command for chaining
	   */

	  setOptionValueWithSource(key, value, source) {
	    if (this._storeOptionsAsProperties) {
	      this[key] = value;
	    } else {
	      this._optionValues[key] = value;
	    }
	    this._optionValueSources[key] = source;
	    return this;
	  }

	  /**
	   * Get source of option value.
	   * Expected values are default | config | env | cli | implied
	   *
	   * @param {string} key
	   * @return {string}
	   */

	  getOptionValueSource(key) {
	    return this._optionValueSources[key];
	  }

	  /**
	   * Get source of option value. See also .optsWithGlobals().
	   * Expected values are default | config | env | cli | implied
	   *
	   * @param {string} key
	   * @return {string}
	   */

	  getOptionValueSourceWithGlobals(key) {
	    // global overwrites local, like optsWithGlobals
	    let source;
	    this._getCommandAndAncestors().forEach((cmd) => {
	      if (cmd.getOptionValueSource(key) !== undefined) {
	        source = cmd.getOptionValueSource(key);
	      }
	    });
	    return source;
	  }

	  /**
	   * Get user arguments from implied or explicit arguments.
	   * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
	   *
	   * @private
	   */

	  _prepareUserArgs(argv, parseOptions) {
	    if (argv !== undefined && !Array.isArray(argv)) {
	      throw new Error('first parameter to parse must be array or undefined');
	    }
	    parseOptions = parseOptions || {};

	    // auto-detect argument conventions if nothing supplied
	    if (argv === undefined && parseOptions.from === undefined) {
	      if (process.versions?.electron) {
	        parseOptions.from = 'electron';
	      }
	      // check node specific options for scenarios where user CLI args follow executable without scriptname
	      const execArgv = process.execArgv ?? [];
	      if (
	        execArgv.includes('-e') ||
	        execArgv.includes('--eval') ||
	        execArgv.includes('-p') ||
	        execArgv.includes('--print')
	      ) {
	        parseOptions.from = 'eval'; // internal usage, not documented
	      }
	    }

	    // default to using process.argv
	    if (argv === undefined) {
	      argv = process.argv;
	    }
	    this.rawArgs = argv.slice();

	    // extract the user args and scriptPath
	    let userArgs;
	    switch (parseOptions.from) {
	      case undefined:
	      case 'node':
	        this._scriptPath = argv[1];
	        userArgs = argv.slice(2);
	        break;
	      case 'electron':
	        // @ts-ignore: because defaultApp is an unknown property
	        if (process.defaultApp) {
	          this._scriptPath = argv[1];
	          userArgs = argv.slice(2);
	        } else {
	          userArgs = argv.slice(1);
	        }
	        break;
	      case 'user':
	        userArgs = argv.slice(0);
	        break;
	      case 'eval':
	        userArgs = argv.slice(1);
	        break;
	      default:
	        throw new Error(
	          `unexpected parse option { from: '${parseOptions.from}' }`,
	        );
	    }

	    // Find default name for program from arguments.
	    if (!this._name && this._scriptPath)
	      this.nameFromFilename(this._scriptPath);
	    this._name = this._name || 'program';

	    return userArgs;
	  }

	  /**
	   * Parse `argv`, setting options and invoking commands when defined.
	   *
	   * Use parseAsync instead of parse if any of your action handlers are async.
	   *
	   * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
	   *
	   * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
	   * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
	   * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
	   * - `'user'`: just user arguments
	   *
	   * @example
	   * program.parse(); // parse process.argv and auto-detect electron and special node flags
	   * program.parse(process.argv); // assume argv[0] is app and argv[1] is script
	   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
	   *
	   * @param {string[]} [argv] - optional, defaults to process.argv
	   * @param {object} [parseOptions] - optionally specify style of options with from: node/user/electron
	   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
	   * @return {Command} `this` command for chaining
	   */

	  parse(argv, parseOptions) {
	    const userArgs = this._prepareUserArgs(argv, parseOptions);
	    this._parseCommand([], userArgs);

	    return this;
	  }

	  /**
	   * Parse `argv`, setting options and invoking commands when defined.
	   *
	   * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
	   *
	   * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
	   * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
	   * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
	   * - `'user'`: just user arguments
	   *
	   * @example
	   * await program.parseAsync(); // parse process.argv and auto-detect electron and special node flags
	   * await program.parseAsync(process.argv); // assume argv[0] is app and argv[1] is script
	   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
	   *
	   * @param {string[]} [argv]
	   * @param {object} [parseOptions]
	   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
	   * @return {Promise}
	   */

	  async parseAsync(argv, parseOptions) {
	    const userArgs = this._prepareUserArgs(argv, parseOptions);
	    await this._parseCommand([], userArgs);

	    return this;
	  }

	  /**
	   * Execute a sub-command executable.
	   *
	   * @private
	   */

	  _executeSubCommand(subcommand, args) {
	    args = args.slice();
	    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.
	    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];

	    function findFile(baseDir, baseName) {
	      // Look for specified file
	      const localBin = path.resolve(baseDir, baseName);
	      if (fs.existsSync(localBin)) return localBin;

	      // Stop looking if candidate already has an expected extension.
	      if (sourceExt.includes(path.extname(baseName))) return undefined;

	      // Try all the extensions.
	      const foundExt = sourceExt.find((ext) =>
	        fs.existsSync(`${localBin}${ext}`),
	      );
	      if (foundExt) return `${localBin}${foundExt}`;

	      return undefined;
	    }

	    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.
	    this._checkForMissingMandatoryOptions();
	    this._checkForConflictingOptions();

	    // executableFile and executableDir might be full path, or just a name
	    let executableFile =
	      subcommand._executableFile || `${this._name}-${subcommand._name}`;
	    let executableDir = this._executableDir || '';
	    if (this._scriptPath) {
	      let resolvedScriptPath; // resolve possible symlink for installed npm binary
	      try {
	        resolvedScriptPath = fs.realpathSync(this._scriptPath);
	      } catch (err) {
	        resolvedScriptPath = this._scriptPath;
	      }
	      executableDir = path.resolve(
	        path.dirname(resolvedScriptPath),
	        executableDir,
	      );
	    }

	    // Look for a local file in preference to a command in PATH.
	    if (executableDir) {
	      let localFile = findFile(executableDir, executableFile);

	      // Legacy search using prefix of script name instead of command name
	      if (!localFile && !subcommand._executableFile && this._scriptPath) {
	        const legacyName = path.basename(
	          this._scriptPath,
	          path.extname(this._scriptPath),
	        );
	        if (legacyName !== this._name) {
	          localFile = findFile(
	            executableDir,
	            `${legacyName}-${subcommand._name}`,
	          );
	        }
	      }
	      executableFile = localFile || executableFile;
	    }

	    launchWithNode = sourceExt.includes(path.extname(executableFile));

	    let proc;
	    if (process.platform !== 'win32') {
	      if (launchWithNode) {
	        args.unshift(executableFile);
	        // add executable arguments to spawn
	        args = incrementNodeInspectorPort(process.execArgv).concat(args);

	        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });
	      } else {
	        proc = childProcess.spawn(executableFile, args, { stdio: 'inherit' });
	      }
	    } else {
	      args.unshift(executableFile);
	      // add executable arguments to spawn
	      args = incrementNodeInspectorPort(process.execArgv).concat(args);
	      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });
	    }

	    if (!proc.killed) {
	      // testing mainly to avoid leak warnings during unit tests with mocked spawn
	      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
	      signals.forEach((signal) => {
	        process.on(signal, () => {
	          if (proc.killed === false && proc.exitCode === null) {
	            // @ts-ignore because signals not typed to known strings
	            proc.kill(signal);
	          }
	        });
	      });
	    }

	    // By default terminate process when spawned process terminates.
	    const exitCallback = this._exitCallback;
	    proc.on('close', (code) => {
	      code = code ?? 1; // code is null if spawned process terminated due to a signal
	      if (!exitCallback) {
	        process.exit(code);
	      } else {
	        exitCallback(
	          new CommanderError(
	            code,
	            'commander.executeSubCommandAsync',
	            '(close)',
	          ),
	        );
	      }
	    });
	    proc.on('error', (err) => {
	      // @ts-ignore: because err.code is an unknown property
	      if (err.code === 'ENOENT') {
	        const executableDirMessage = executableDir
	          ? `searched for local subcommand relative to directory '${executableDir}'`
	          : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';
	        const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
	        throw new Error(executableMissing);
	        // @ts-ignore: because err.code is an unknown property
	      } else if (err.code === 'EACCES') {
	        throw new Error(`'${executableFile}' not executable`);
	      }
	      if (!exitCallback) {
	        process.exit(1);
	      } else {
	        const wrappedError = new CommanderError(
	          1,
	          'commander.executeSubCommandAsync',
	          '(error)',
	        );
	        wrappedError.nestedError = err;
	        exitCallback(wrappedError);
	      }
	    });

	    // Store the reference to the child process
	    this.runningCommand = proc;
	  }

	  /**
	   * @private
	   */

	  _dispatchSubcommand(commandName, operands, unknown) {
	    const subCommand = this._findCommand(commandName);
	    if (!subCommand) this.help({ error: true });

	    let promiseChain;
	    promiseChain = this._chainOrCallSubCommandHook(
	      promiseChain,
	      subCommand,
	      'preSubcommand',
	    );
	    promiseChain = this._chainOrCall(promiseChain, () => {
	      if (subCommand._executableHandler) {
	        this._executeSubCommand(subCommand, operands.concat(unknown));
	      } else {
	        return subCommand._parseCommand(operands, unknown);
	      }
	    });
	    return promiseChain;
	  }

	  /**
	   * Invoke help directly if possible, or dispatch if necessary.
	   * e.g. help foo
	   *
	   * @private
	   */

	  _dispatchHelpCommand(subcommandName) {
	    if (!subcommandName) {
	      this.help();
	    }
	    const subCommand = this._findCommand(subcommandName);
	    if (subCommand && !subCommand._executableHandler) {
	      subCommand.help();
	    }

	    // Fallback to parsing the help flag to invoke the help.
	    return this._dispatchSubcommand(
	      subcommandName,
	      [],
	      [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? '--help'],
	    );
	  }

	  /**
	   * Check this.args against expected this.registeredArguments.
	   *
	   * @private
	   */

	  _checkNumberOfArguments() {
	    // too few
	    this.registeredArguments.forEach((arg, i) => {
	      if (arg.required && this.args[i] == null) {
	        this.missingArgument(arg.name());
	      }
	    });
	    // too many
	    if (
	      this.registeredArguments.length > 0 &&
	      this.registeredArguments[this.registeredArguments.length - 1].variadic
	    ) {
	      return;
	    }
	    if (this.args.length > this.registeredArguments.length) {
	      this._excessArguments(this.args);
	    }
	  }

	  /**
	   * Process this.args using this.registeredArguments and save as this.processedArgs!
	   *
	   * @private
	   */

	  _processArguments() {
	    const myParseArg = (argument, value, previous) => {
	      // Extra processing for nice error message on parsing failure.
	      let parsedValue = value;
	      if (value !== null && argument.parseArg) {
	        const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
	        parsedValue = this._callParseArg(
	          argument,
	          value,
	          previous,
	          invalidValueMessage,
	        );
	      }
	      return parsedValue;
	    };

	    this._checkNumberOfArguments();

	    const processedArgs = [];
	    this.registeredArguments.forEach((declaredArg, index) => {
	      let value = declaredArg.defaultValue;
	      if (declaredArg.variadic) {
	        // Collect together remaining arguments for passing together as an array.
	        if (index < this.args.length) {
	          value = this.args.slice(index);
	          if (declaredArg.parseArg) {
	            value = value.reduce((processed, v) => {
	              return myParseArg(declaredArg, v, processed);
	            }, declaredArg.defaultValue);
	          }
	        } else if (value === undefined) {
	          value = [];
	        }
	      } else if (index < this.args.length) {
	        value = this.args[index];
	        if (declaredArg.parseArg) {
	          value = myParseArg(declaredArg, value, declaredArg.defaultValue);
	        }
	      }
	      processedArgs[index] = value;
	    });
	    this.processedArgs = processedArgs;
	  }

	  /**
	   * Once we have a promise we chain, but call synchronously until then.
	   *
	   * @param {(Promise|undefined)} promise
	   * @param {Function} fn
	   * @return {(Promise|undefined)}
	   * @private
	   */

	  _chainOrCall(promise, fn) {
	    // thenable
	    if (promise && promise.then && typeof promise.then === 'function') {
	      // already have a promise, chain callback
	      return promise.then(() => fn());
	    }
	    // callback might return a promise
	    return fn();
	  }

	  /**
	   *
	   * @param {(Promise|undefined)} promise
	   * @param {string} event
	   * @return {(Promise|undefined)}
	   * @private
	   */

	  _chainOrCallHooks(promise, event) {
	    let result = promise;
	    const hooks = [];
	    this._getCommandAndAncestors()
	      .reverse()
	      .filter((cmd) => cmd._lifeCycleHooks[event] !== undefined)
	      .forEach((hookedCommand) => {
	        hookedCommand._lifeCycleHooks[event].forEach((callback) => {
	          hooks.push({ hookedCommand, callback });
	        });
	      });
	    if (event === 'postAction') {
	      hooks.reverse();
	    }

	    hooks.forEach((hookDetail) => {
	      result = this._chainOrCall(result, () => {
	        return hookDetail.callback(hookDetail.hookedCommand, this);
	      });
	    });
	    return result;
	  }

	  /**
	   *
	   * @param {(Promise|undefined)} promise
	   * @param {Command} subCommand
	   * @param {string} event
	   * @return {(Promise|undefined)}
	   * @private
	   */

	  _chainOrCallSubCommandHook(promise, subCommand, event) {
	    let result = promise;
	    if (this._lifeCycleHooks[event] !== undefined) {
	      this._lifeCycleHooks[event].forEach((hook) => {
	        result = this._chainOrCall(result, () => {
	          return hook(this, subCommand);
	        });
	      });
	    }
	    return result;
	  }

	  /**
	   * Process arguments in context of this command.
	   * Returns action result, in case it is a promise.
	   *
	   * @private
	   */

	  _parseCommand(operands, unknown) {
	    const parsed = this.parseOptions(unknown);
	    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env
	    this._parseOptionsImplied();
	    operands = operands.concat(parsed.operands);
	    unknown = parsed.unknown;
	    this.args = operands.concat(unknown);

	    if (operands && this._findCommand(operands[0])) {
	      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
	    }
	    if (
	      this._getHelpCommand() &&
	      operands[0] === this._getHelpCommand().name()
	    ) {
	      return this._dispatchHelpCommand(operands[1]);
	    }
	    if (this._defaultCommandName) {
	      this._outputHelpIfRequested(unknown); // Run the help for default command from parent rather than passing to default command
	      return this._dispatchSubcommand(
	        this._defaultCommandName,
	        operands,
	        unknown,
	      );
	    }
	    if (
	      this.commands.length &&
	      this.args.length === 0 &&
	      !this._actionHandler &&
	      !this._defaultCommandName
	    ) {
	      // probably missing subcommand and no handler, user needs help (and exit)
	      this.help({ error: true });
	    }

	    this._outputHelpIfRequested(parsed.unknown);
	    this._checkForMissingMandatoryOptions();
	    this._checkForConflictingOptions();

	    // We do not always call this check to avoid masking a "better" error, like unknown command.
	    const checkForUnknownOptions = () => {
	      if (parsed.unknown.length > 0) {
	        this.unknownOption(parsed.unknown[0]);
	      }
	    };

	    const commandEvent = `command:${this.name()}`;
	    if (this._actionHandler) {
	      checkForUnknownOptions();
	      this._processArguments();

	      let promiseChain;
	      promiseChain = this._chainOrCallHooks(promiseChain, 'preAction');
	      promiseChain = this._chainOrCall(promiseChain, () =>
	        this._actionHandler(this.processedArgs),
	      );
	      if (this.parent) {
	        promiseChain = this._chainOrCall(promiseChain, () => {
	          this.parent.emit(commandEvent, operands, unknown); // legacy
	        });
	      }
	      promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');
	      return promiseChain;
	    }
	    if (this.parent && this.parent.listenerCount(commandEvent)) {
	      checkForUnknownOptions();
	      this._processArguments();
	      this.parent.emit(commandEvent, operands, unknown); // legacy
	    } else if (operands.length) {
	      if (this._findCommand('*')) {
	        // legacy default command
	        return this._dispatchSubcommand('*', operands, unknown);
	      }
	      if (this.listenerCount('command:*')) {
	        // skip option check, emit event for possible misspelling suggestion
	        this.emit('command:*', operands, unknown);
	      } else if (this.commands.length) {
	        this.unknownCommand();
	      } else {
	        checkForUnknownOptions();
	        this._processArguments();
	      }
	    } else if (this.commands.length) {
	      checkForUnknownOptions();
	      // This command has subcommands and nothing hooked up at this level, so display help (and exit).
	      this.help({ error: true });
	    } else {
	      checkForUnknownOptions();
	      this._processArguments();
	      // fall through for caller to handle after calling .parse()
	    }
	  }

	  /**
	   * Find matching command.
	   *
	   * @private
	   * @return {Command | undefined}
	   */
	  _findCommand(name) {
	    if (!name) return undefined;
	    return this.commands.find(
	      (cmd) => cmd._name === name || cmd._aliases.includes(name),
	    );
	  }

	  /**
	   * Return an option matching `arg` if any.
	   *
	   * @param {string} arg
	   * @return {Option}
	   * @package
	   */

	  _findOption(arg) {
	    return this.options.find((option) => option.is(arg));
	  }

	  /**
	   * Display an error message if a mandatory option does not have a value.
	   * Called after checking for help flags in leaf subcommand.
	   *
	   * @private
	   */

	  _checkForMissingMandatoryOptions() {
	    // Walk up hierarchy so can call in subcommand after checking for displaying help.
	    this._getCommandAndAncestors().forEach((cmd) => {
	      cmd.options.forEach((anOption) => {
	        if (
	          anOption.mandatory &&
	          cmd.getOptionValue(anOption.attributeName()) === undefined
	        ) {
	          cmd.missingMandatoryOptionValue(anOption);
	        }
	      });
	    });
	  }

	  /**
	   * Display an error message if conflicting options are used together in this.
	   *
	   * @private
	   */
	  _checkForConflictingLocalOptions() {
	    const definedNonDefaultOptions = this.options.filter((option) => {
	      const optionKey = option.attributeName();
	      if (this.getOptionValue(optionKey) === undefined) {
	        return false;
	      }
	      return this.getOptionValueSource(optionKey) !== 'default';
	    });

	    const optionsWithConflicting = definedNonDefaultOptions.filter(
	      (option) => option.conflictsWith.length > 0,
	    );

	    optionsWithConflicting.forEach((option) => {
	      const conflictingAndDefined = definedNonDefaultOptions.find((defined) =>
	        option.conflictsWith.includes(defined.attributeName()),
	      );
	      if (conflictingAndDefined) {
	        this._conflictingOption(option, conflictingAndDefined);
	      }
	    });
	  }

	  /**
	   * Display an error message if conflicting options are used together.
	   * Called after checking for help flags in leaf subcommand.
	   *
	   * @private
	   */
	  _checkForConflictingOptions() {
	    // Walk up hierarchy so can call in subcommand after checking for displaying help.
	    this._getCommandAndAncestors().forEach((cmd) => {
	      cmd._checkForConflictingLocalOptions();
	    });
	  }

	  /**
	   * Parse options from `argv` removing known options,
	   * and return argv split into operands and unknown arguments.
	   *
	   * Examples:
	   *
	   *     argv => operands, unknown
	   *     --known kkk op => [op], []
	   *     op --known kkk => [op], []
	   *     sub --unknown uuu op => [sub], [--unknown uuu op]
	   *     sub -- --unknown uuu op => [sub --unknown uuu op], []
	   *
	   * @param {string[]} argv
	   * @return {{operands: string[], unknown: string[]}}
	   */

	  parseOptions(argv) {
	    const operands = []; // operands, not options or values
	    const unknown = []; // first unknown option and remaining unknown args
	    let dest = operands;
	    const args = argv.slice();

	    function maybeOption(arg) {
	      return arg.length > 1 && arg[0] === '-';
	    }

	    // parse options
	    let activeVariadicOption = null;
	    while (args.length) {
	      const arg = args.shift();

	      // literal
	      if (arg === '--') {
	        if (dest === unknown) dest.push(arg);
	        dest.push(...args);
	        break;
	      }

	      if (activeVariadicOption && !maybeOption(arg)) {
	        this.emit(`option:${activeVariadicOption.name()}`, arg);
	        continue;
	      }
	      activeVariadicOption = null;

	      if (maybeOption(arg)) {
	        const option = this._findOption(arg);
	        // recognised option, call listener to assign value with possible custom processing
	        if (option) {
	          if (option.required) {
	            const value = args.shift();
	            if (value === undefined) this.optionMissingArgument(option);
	            this.emit(`option:${option.name()}`, value);
	          } else if (option.optional) {
	            let value = null;
	            // historical behaviour is optional value is following arg unless an option
	            if (args.length > 0 && !maybeOption(args[0])) {
	              value = args.shift();
	            }
	            this.emit(`option:${option.name()}`, value);
	          } else {
	            // boolean flag
	            this.emit(`option:${option.name()}`);
	          }
	          activeVariadicOption = option.variadic ? option : null;
	          continue;
	        }
	      }

	      // Look for combo options following single dash, eat first one if known.
	      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
	        const option = this._findOption(`-${arg[1]}`);
	        if (option) {
	          if (
	            option.required ||
	            (option.optional && this._combineFlagAndOptionalValue)
	          ) {
	            // option with value following in same argument
	            this.emit(`option:${option.name()}`, arg.slice(2));
	          } else {
	            // boolean option, emit and put back remainder of arg for further processing
	            this.emit(`option:${option.name()}`);
	            args.unshift(`-${arg.slice(2)}`);
	          }
	          continue;
	        }
	      }

	      // Look for known long flag with value, like --foo=bar
	      if (/^--[^=]+=/.test(arg)) {
	        const index = arg.indexOf('=');
	        const option = this._findOption(arg.slice(0, index));
	        if (option && (option.required || option.optional)) {
	          this.emit(`option:${option.name()}`, arg.slice(index + 1));
	          continue;
	        }
	      }

	      // Not a recognised option by this command.
	      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.

	      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.
	      if (maybeOption(arg)) {
	        dest = unknown;
	      }

	      // If using positionalOptions, stop processing our options at subcommand.
	      if (
	        (this._enablePositionalOptions || this._passThroughOptions) &&
	        operands.length === 0 &&
	        unknown.length === 0
	      ) {
	        if (this._findCommand(arg)) {
	          operands.push(arg);
	          if (args.length > 0) unknown.push(...args);
	          break;
	        } else if (
	          this._getHelpCommand() &&
	          arg === this._getHelpCommand().name()
	        ) {
	          operands.push(arg);
	          if (args.length > 0) operands.push(...args);
	          break;
	        } else if (this._defaultCommandName) {
	          unknown.push(arg);
	          if (args.length > 0) unknown.push(...args);
	          break;
	        }
	      }

	      // If using passThroughOptions, stop processing options at first command-argument.
	      if (this._passThroughOptions) {
	        dest.push(arg);
	        if (args.length > 0) dest.push(...args);
	        break;
	      }

	      // add arg
	      dest.push(arg);
	    }

	    return { operands, unknown };
	  }

	  /**
	   * Return an object containing local option values as key-value pairs.
	   *
	   * @return {object}
	   */
	  opts() {
	    if (this._storeOptionsAsProperties) {
	      // Preserve original behaviour so backwards compatible when still using properties
	      const result = {};
	      const len = this.options.length;

	      for (let i = 0; i < len; i++) {
	        const key = this.options[i].attributeName();
	        result[key] =
	          key === this._versionOptionName ? this._version : this[key];
	      }
	      return result;
	    }

	    return this._optionValues;
	  }

	  /**
	   * Return an object containing merged local and global option values as key-value pairs.
	   *
	   * @return {object}
	   */
	  optsWithGlobals() {
	    // globals overwrite locals
	    return this._getCommandAndAncestors().reduce(
	      (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
	      {},
	    );
	  }

	  /**
	   * Display error message and exit (or call exitOverride).
	   *
	   * @param {string} message
	   * @param {object} [errorOptions]
	   * @param {string} [errorOptions.code] - an id string representing the error
	   * @param {number} [errorOptions.exitCode] - used with process.exit
	   */
	  error(message, errorOptions) {
	    // output handling
	    this._outputConfiguration.outputError(
	      `${message}\n`,
	      this._outputConfiguration.writeErr,
	    );
	    if (typeof this._showHelpAfterError === 'string') {
	      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`);
	    } else if (this._showHelpAfterError) {
	      this._outputConfiguration.writeErr('\n');
	      this.outputHelp({ error: true });
	    }

	    // exit handling
	    const config = errorOptions || {};
	    const exitCode = config.exitCode || 1;
	    const code = config.code || 'commander.error';
	    this._exit(exitCode, code, message);
	  }

	  /**
	   * Apply any option related environment variables, if option does
	   * not have a value from cli or client code.
	   *
	   * @private
	   */
	  _parseOptionsEnv() {
	    this.options.forEach((option) => {
	      if (option.envVar && option.envVar in process.env) {
	        const optionKey = option.attributeName();
	        // Priority check. Do not overwrite cli or options from unknown source (client-code).
	        if (
	          this.getOptionValue(optionKey) === undefined ||
	          ['default', 'config', 'env'].includes(
	            this.getOptionValueSource(optionKey),
	          )
	        ) {
	          if (option.required || option.optional) {
	            // option can take a value
	            // keep very simple, optional always takes value
	            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);
	          } else {
	            // boolean
	            // keep very simple, only care that envVar defined and not the value
	            this.emit(`optionEnv:${option.name()}`);
	          }
	        }
	      }
	    });
	  }

	  /**
	   * Apply any implied option values, if option is undefined or default value.
	   *
	   * @private
	   */
	  _parseOptionsImplied() {
	    const dualHelper = new DualOptions(this.options);
	    const hasCustomOptionValue = (optionKey) => {
	      return (
	        this.getOptionValue(optionKey) !== undefined &&
	        !['default', 'implied'].includes(this.getOptionValueSource(optionKey))
	      );
	    };
	    this.options
	      .filter(
	        (option) =>
	          option.implied !== undefined &&
	          hasCustomOptionValue(option.attributeName()) &&
	          dualHelper.valueFromOption(
	            this.getOptionValue(option.attributeName()),
	            option,
	          ),
	      )
	      .forEach((option) => {
	        Object.keys(option.implied)
	          .filter((impliedKey) => !hasCustomOptionValue(impliedKey))
	          .forEach((impliedKey) => {
	            this.setOptionValueWithSource(
	              impliedKey,
	              option.implied[impliedKey],
	              'implied',
	            );
	          });
	      });
	  }

	  /**
	   * Argument `name` is missing.
	   *
	   * @param {string} name
	   * @private
	   */

	  missingArgument(name) {
	    const message = `error: missing required argument '${name}'`;
	    this.error(message, { code: 'commander.missingArgument' });
	  }

	  /**
	   * `Option` is missing an argument.
	   *
	   * @param {Option} option
	   * @private
	   */

	  optionMissingArgument(option) {
	    const message = `error: option '${option.flags}' argument missing`;
	    this.error(message, { code: 'commander.optionMissingArgument' });
	  }

	  /**
	   * `Option` does not have a value, and is a mandatory option.
	   *
	   * @param {Option} option
	   * @private
	   */

	  missingMandatoryOptionValue(option) {
	    const message = `error: required option '${option.flags}' not specified`;
	    this.error(message, { code: 'commander.missingMandatoryOptionValue' });
	  }

	  /**
	   * `Option` conflicts with another option.
	   *
	   * @param {Option} option
	   * @param {Option} conflictingOption
	   * @private
	   */
	  _conflictingOption(option, conflictingOption) {
	    // The calling code does not know whether a negated option is the source of the
	    // value, so do some work to take an educated guess.
	    const findBestOptionFromValue = (option) => {
	      const optionKey = option.attributeName();
	      const optionValue = this.getOptionValue(optionKey);
	      const negativeOption = this.options.find(
	        (target) => target.negate && optionKey === target.attributeName(),
	      );
	      const positiveOption = this.options.find(
	        (target) => !target.negate && optionKey === target.attributeName(),
	      );
	      if (
	        negativeOption &&
	        ((negativeOption.presetArg === undefined && optionValue === false) ||
	          (negativeOption.presetArg !== undefined &&
	            optionValue === negativeOption.presetArg))
	      ) {
	        return negativeOption;
	      }
	      return positiveOption || option;
	    };

	    const getErrorMessage = (option) => {
	      const bestOption = findBestOptionFromValue(option);
	      const optionKey = bestOption.attributeName();
	      const source = this.getOptionValueSource(optionKey);
	      if (source === 'env') {
	        return `environment variable '${bestOption.envVar}'`;
	      }
	      return `option '${bestOption.flags}'`;
	    };

	    const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
	    this.error(message, { code: 'commander.conflictingOption' });
	  }

	  /**
	   * Unknown option `flag`.
	   *
	   * @param {string} flag
	   * @private
	   */

	  unknownOption(flag) {
	    if (this._allowUnknownOption) return;
	    let suggestion = '';

	    if (flag.startsWith('--') && this._showSuggestionAfterError) {
	      // Looping to pick up the global options too
	      let candidateFlags = [];
	      // eslint-disable-next-line @typescript-eslint/no-this-alias
	      let command = this;
	      do {
	        const moreFlags = command
	          .createHelp()
	          .visibleOptions(command)
	          .filter((option) => option.long)
	          .map((option) => option.long);
	        candidateFlags = candidateFlags.concat(moreFlags);
	        command = command.parent;
	      } while (command && !command._enablePositionalOptions);
	      suggestion = suggestSimilar(flag, candidateFlags);
	    }

	    const message = `error: unknown option '${flag}'${suggestion}`;
	    this.error(message, { code: 'commander.unknownOption' });
	  }

	  /**
	   * Excess arguments, more than expected.
	   *
	   * @param {string[]} receivedArgs
	   * @private
	   */

	  _excessArguments(receivedArgs) {
	    if (this._allowExcessArguments) return;

	    const expected = this.registeredArguments.length;
	    const s = expected === 1 ? '' : 's';
	    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';
	    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
	    this.error(message, { code: 'commander.excessArguments' });
	  }

	  /**
	   * Unknown command.
	   *
	   * @private
	   */

	  unknownCommand() {
	    const unknownName = this.args[0];
	    let suggestion = '';

	    if (this._showSuggestionAfterError) {
	      const candidateNames = [];
	      this.createHelp()
	        .visibleCommands(this)
	        .forEach((command) => {
	          candidateNames.push(command.name());
	          // just visible alias
	          if (command.alias()) candidateNames.push(command.alias());
	        });
	      suggestion = suggestSimilar(unknownName, candidateNames);
	    }

	    const message = `error: unknown command '${unknownName}'${suggestion}`;
	    this.error(message, { code: 'commander.unknownCommand' });
	  }

	  /**
	   * Get or set the program version.
	   *
	   * This method auto-registers the "-V, --version" option which will print the version number.
	   *
	   * You can optionally supply the flags and description to override the defaults.
	   *
	   * @param {string} [str]
	   * @param {string} [flags]
	   * @param {string} [description]
	   * @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments
	   */

	  version(str, flags, description) {
	    if (str === undefined) return this._version;
	    this._version = str;
	    flags = flags || '-V, --version';
	    description = description || 'output the version number';
	    const versionOption = this.createOption(flags, description);
	    this._versionOptionName = versionOption.attributeName();
	    this._registerOption(versionOption);

	    this.on('option:' + versionOption.name(), () => {
	      this._outputConfiguration.writeOut(`${str}\n`);
	      this._exit(0, 'commander.version', str);
	    });
	    return this;
	  }

	  /**
	   * Set the description.
	   *
	   * @param {string} [str]
	   * @param {object} [argsDescription]
	   * @return {(string|Command)}
	   */
	  description(str, argsDescription) {
	    if (str === undefined && argsDescription === undefined)
	      return this._description;
	    this._description = str;
	    if (argsDescription) {
	      this._argsDescription = argsDescription;
	    }
	    return this;
	  }

	  /**
	   * Set the summary. Used when listed as subcommand of parent.
	   *
	   * @param {string} [str]
	   * @return {(string|Command)}
	   */
	  summary(str) {
	    if (str === undefined) return this._summary;
	    this._summary = str;
	    return this;
	  }

	  /**
	   * Set an alias for the command.
	   *
	   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
	   *
	   * @param {string} [alias]
	   * @return {(string|Command)}
	   */

	  alias(alias) {
	    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility

	    /** @type {Command} */
	    // eslint-disable-next-line @typescript-eslint/no-this-alias
	    let command = this;
	    if (
	      this.commands.length !== 0 &&
	      this.commands[this.commands.length - 1]._executableHandler
	    ) {
	      // assume adding alias for last added executable subcommand, rather than this
	      command = this.commands[this.commands.length - 1];
	    }

	    if (alias === command._name)
	      throw new Error("Command alias can't be the same as its name");
	    const matchingCommand = this.parent?._findCommand(alias);
	    if (matchingCommand) {
	      // c.f. _registerCommand
	      const existingCmd = [matchingCommand.name()]
	        .concat(matchingCommand.aliases())
	        .join('|');
	      throw new Error(
	        `cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`,
	      );
	    }

	    command._aliases.push(alias);
	    return this;
	  }

	  /**
	   * Set aliases for the command.
	   *
	   * Only the first alias is shown in the auto-generated help.
	   *
	   * @param {string[]} [aliases]
	   * @return {(string[]|Command)}
	   */

	  aliases(aliases) {
	    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().
	    if (aliases === undefined) return this._aliases;

	    aliases.forEach((alias) => this.alias(alias));
	    return this;
	  }

	  /**
	   * Set / get the command usage `str`.
	   *
	   * @param {string} [str]
	   * @return {(string|Command)}
	   */

	  usage(str) {
	    if (str === undefined) {
	      if (this._usage) return this._usage;

	      const args = this.registeredArguments.map((arg) => {
	        return humanReadableArgName(arg);
	      });
	      return []
	        .concat(
	          this.options.length || this._helpOption !== null ? '[options]' : [],
	          this.commands.length ? '[command]' : [],
	          this.registeredArguments.length ? args : [],
	        )
	        .join(' ');
	    }

	    this._usage = str;
	    return this;
	  }

	  /**
	   * Get or set the name of the command.
	   *
	   * @param {string} [str]
	   * @return {(string|Command)}
	   */

	  name(str) {
	    if (str === undefined) return this._name;
	    this._name = str;
	    return this;
	  }

	  /**
	   * Set the name of the command from script filename, such as process.argv[1],
	   * or require.main.filename, or __filename.
	   *
	   * (Used internally and public although not documented in README.)
	   *
	   * @example
	   * program.nameFromFilename(require.main.filename);
	   *
	   * @param {string} filename
	   * @return {Command}
	   */

	  nameFromFilename(filename) {
	    this._name = path.basename(filename, path.extname(filename));

	    return this;
	  }

	  /**
	   * Get or set the directory for searching for executable subcommands of this command.
	   *
	   * @example
	   * program.executableDir(__dirname);
	   * // or
	   * program.executableDir('subcommands');
	   *
	   * @param {string} [path]
	   * @return {(string|null|Command)}
	   */

	  executableDir(path) {
	    if (path === undefined) return this._executableDir;
	    this._executableDir = path;
	    return this;
	  }

	  /**
	   * Return program help documentation.
	   *
	   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
	   * @return {string}
	   */

	  helpInformation(contextOptions) {
	    const helper = this.createHelp();
	    if (helper.helpWidth === undefined) {
	      helper.helpWidth =
	        contextOptions && contextOptions.error
	          ? this._outputConfiguration.getErrHelpWidth()
	          : this._outputConfiguration.getOutHelpWidth();
	    }
	    return helper.formatHelp(this, helper);
	  }

	  /**
	   * @private
	   */

	  _getHelpContext(contextOptions) {
	    contextOptions = contextOptions || {};
	    const context = { error: !!contextOptions.error };
	    let write;
	    if (context.error) {
	      write = (arg) => this._outputConfiguration.writeErr(arg);
	    } else {
	      write = (arg) => this._outputConfiguration.writeOut(arg);
	    }
	    context.write = contextOptions.write || write;
	    context.command = this;
	    return context;
	  }

	  /**
	   * Output help information for this command.
	   *
	   * Outputs built-in help, and custom text added using `.addHelpText()`.
	   *
	   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
	   */

	  outputHelp(contextOptions) {
	    let deprecatedCallback;
	    if (typeof contextOptions === 'function') {
	      deprecatedCallback = contextOptions;
	      contextOptions = undefined;
	    }
	    const context = this._getHelpContext(contextOptions);

	    this._getCommandAndAncestors()
	      .reverse()
	      .forEach((command) => command.emit('beforeAllHelp', context));
	    this.emit('beforeHelp', context);

	    let helpInformation = this.helpInformation(context);
	    if (deprecatedCallback) {
	      helpInformation = deprecatedCallback(helpInformation);
	      if (
	        typeof helpInformation !== 'string' &&
	        !Buffer.isBuffer(helpInformation)
	      ) {
	        throw new Error('outputHelp callback must return a string or a Buffer');
	      }
	    }
	    context.write(helpInformation);

	    if (this._getHelpOption()?.long) {
	      this.emit(this._getHelpOption().long); // deprecated
	    }
	    this.emit('afterHelp', context);
	    this._getCommandAndAncestors().forEach((command) =>
	      command.emit('afterAllHelp', context),
	    );
	  }

	  /**
	   * You can pass in flags and a description to customise the built-in help option.
	   * Pass in false to disable the built-in help option.
	   *
	   * @example
	   * program.helpOption('-?, --help' 'show help'); // customise
	   * program.helpOption(false); // disable
	   *
	   * @param {(string | boolean)} flags
	   * @param {string} [description]
	   * @return {Command} `this` command for chaining
	   */

	  helpOption(flags, description) {
	    // Support disabling built-in help option.
	    if (typeof flags === 'boolean') {
	      if (flags) {
	        this._helpOption = this._helpOption ?? undefined; // preserve existing option
	      } else {
	        this._helpOption = null; // disable
	      }
	      return this;
	    }

	    // Customise flags and description.
	    flags = flags ?? '-h, --help';
	    description = description ?? 'display help for command';
	    this._helpOption = this.createOption(flags, description);

	    return this;
	  }

	  /**
	   * Lazy create help option.
	   * Returns null if has been disabled with .helpOption(false).
	   *
	   * @returns {(Option | null)} the help option
	   * @package
	   */
	  _getHelpOption() {
	    // Lazy create help option on demand.
	    if (this._helpOption === undefined) {
	      this.helpOption(undefined, undefined);
	    }
	    return this._helpOption;
	  }

	  /**
	   * Supply your own option to use for the built-in help option.
	   * This is an alternative to using helpOption() to customise the flags and description etc.
	   *
	   * @param {Option} option
	   * @return {Command} `this` command for chaining
	   */
	  addHelpOption(option) {
	    this._helpOption = option;
	    return this;
	  }

	  /**
	   * Output help information and exit.
	   *
	   * Outputs built-in help, and custom text added using `.addHelpText()`.
	   *
	   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
	   */

	  help(contextOptions) {
	    this.outputHelp(contextOptions);
	    let exitCode = process.exitCode || 0;
	    if (
	      exitCode === 0 &&
	      contextOptions &&
	      typeof contextOptions !== 'function' &&
	      contextOptions.error
	    ) {
	      exitCode = 1;
	    }
	    // message: do not have all displayed text available so only passing placeholder.
	    this._exit(exitCode, 'commander.help', '(outputHelp)');
	  }

	  /**
	   * Add additional text to be displayed with the built-in help.
	   *
	   * Position is 'before' or 'after' to affect just this command,
	   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
	   *
	   * @param {string} position - before or after built-in help
	   * @param {(string | Function)} text - string to add, or a function returning a string
	   * @return {Command} `this` command for chaining
	   */
	  addHelpText(position, text) {
	    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];
	    if (!allowedValues.includes(position)) {
	      throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
	    }
	    const helpEvent = `${position}Help`;
	    this.on(helpEvent, (context) => {
	      let helpStr;
	      if (typeof text === 'function') {
	        helpStr = text({ error: context.error, command: context.command });
	      } else {
	        helpStr = text;
	      }
	      // Ignore falsy value when nothing to output.
	      if (helpStr) {
	        context.write(`${helpStr}\n`);
	      }
	    });
	    return this;
	  }

	  /**
	   * Output help information if help flags specified
	   *
	   * @param {Array} args - array of options to search for help flags
	   * @private
	   */

	  _outputHelpIfRequested(args) {
	    const helpOption = this._getHelpOption();
	    const helpRequested = helpOption && args.find((arg) => helpOption.is(arg));
	    if (helpRequested) {
	      this.outputHelp();
	      // (Do not have all displayed text available so only passing placeholder.)
	      this._exit(0, 'commander.helpDisplayed', '(outputHelp)');
	    }
	  }
	}

	/**
	 * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
	 *
	 * @param {string[]} args - array of arguments from node.execArgv
	 * @returns {string[]}
	 * @private
	 */

	function incrementNodeInspectorPort(args) {
	  // Testing for these options:
	  //  --inspect[=[host:]port]
	  //  --inspect-brk[=[host:]port]
	  //  --inspect-port=[host:]port
	  return args.map((arg) => {
	    if (!arg.startsWith('--inspect')) {
	      return arg;
	    }
	    let debugOption;
	    let debugHost = '127.0.0.1';
	    let debugPort = '9229';
	    let match;
	    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
	      // e.g. --inspect
	      debugOption = match[1];
	    } else if (
	      (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null
	    ) {
	      debugOption = match[1];
	      if (/^\d+$/.test(match[3])) {
	        // e.g. --inspect=1234
	        debugPort = match[3];
	      } else {
	        // e.g. --inspect=localhost
	        debugHost = match[3];
	      }
	    } else if (
	      (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null
	    ) {
	      // e.g. --inspect=localhost:1234
	      debugOption = match[1];
	      debugHost = match[3];
	      debugPort = match[4];
	    }

	    if (debugOption && debugPort !== '0') {
	      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
	    }
	    return arg;
	  });
	}

	command.Command = Command;
	return command;
}

var hasRequiredCommander;

function requireCommander () {
	if (hasRequiredCommander) return commander$1;
	hasRequiredCommander = 1;
	const { Argument } = requireArgument();
	const { Command } = requireCommand();
	const { CommanderError, InvalidArgumentError } = requireError();
	const { Help } = requireHelp();
	const { Option } = requireOption();

	commander$1.program = new Command();

	commander$1.createCommand = (name) => new Command(name);
	commander$1.createOption = (flags, description) => new Option(flags, description);
	commander$1.createArgument = (name, description) => new Argument(name, description);

	/**
	 * Expose classes
	 */

	commander$1.Command = Command;
	commander$1.Option = Option;
	commander$1.Argument = Argument;
	commander$1.Help = Help;

	commander$1.CommanderError = CommanderError;
	commander$1.InvalidArgumentError = InvalidArgumentError;
	commander$1.InvalidOptionArgumentError = InvalidArgumentError; // Deprecated
	return commander$1;
}

var commanderExports = requireCommander();
const commander = /*@__PURE__*/getDefaultExportFromCjs(commanderExports);

// wrapper to provide named exports for ESM.
const {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError, // deprecated old name
  Command,
  Argument,
  Option,
  Help,
} = commander;

class OB11ConfigLoader extends ConfigBase {
  constructor(core, configPath) {
    super("onebot11", core, configPath, false);
  }
}

class OB11ActiveHttpAdapter {
  constructor(name, config, core, obContext, actions) {
    this.name = name;
    this.core = core;
    this.obContext = obContext;
    this.actions = actions;
    this.logger = core.context.logger;
    this.config = structuredClone(config);
  }
  logger;
  isEnable = false;
  config;
  onEvent(event) {
    if (!this.isEnable) {
      return;
    }
    const headers = {
      "Content-Type": "application/json",
      "x-self-id": this.core.selfInfo.uin
    };
    const msgStr = JSON.stringify(event);
    if (this.config.token && this.config.token.length > 0) {
      const hmac = createHmac("sha1", this.config.token);
      hmac.update(msgStr);
      const sig = hmac.digest("hex");
      headers["x-signature"] = "sha1=" + sig;
    }
    RequestUtil.HttpGetText(this.config.url, "POST", msgStr, headers).then(async (res) => {
      let resJson;
      try {
        resJson = JSON.parse(res);
      } catch (e) {
        this.logger.logDebug("[OneBot] [Http Client] 新消息事件HTTP上报没有返回快速操作，不需要处理");
        return;
      }
      try {
        this.obContext.apis.QuickActionApi.handleQuickOperation(event, resJson).catch((e) => this.logger.logError(e));
      } catch (e) {
        this.logger.logError("[OneBot] [Http Client] 新消息事件HTTP上报返回快速操作失败", e);
      }
    }).catch((e) => {
      this.logger.logError("[OneBot] [Http Client] 新消息事件HTTP上报失败", e);
    });
  }
  open() {
    this.isEnable = true;
  }
  close() {
    this.isEnable = false;
  }
  async reload(newconfig) {
    const wasEnabled = this.isEnable;
    const oldUrl = this.config.url;
    this.config = newconfig;
    if (newconfig.enable && !wasEnabled) {
      this.open();
      return OB11NetworkReloadType.NetWorkOpen;
    } else if (!newconfig.enable && wasEnabled) {
      this.close();
      return OB11NetworkReloadType.NetWorkClose;
    }
    if (oldUrl !== newconfig.url) {
      return OB11NetworkReloadType.NetWorkReload;
    }
    return OB11NetworkReloadType.Normal;
  }
}

var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2["META"] = "meta_event";
  EventType2["REQUEST"] = "request";
  EventType2["NOTICE"] = "notice";
  EventType2["MESSAGE"] = "message";
  EventType2["MESSAGE_SENT"] = "message_sent";
  return EventType2;
})(EventType || {});
class OneBotEvent {
  time = Math.floor(Date.now() / 1e3);
  self_id;
  constructor(core) {
    this.self_id = parseInt(core.selfInfo.uin);
  }
}

class OB11BaseMetaEvent extends OneBotEvent {
  post_type = EventType.META;
}

class OB11HeartbeatEvent extends OB11BaseMetaEvent {
  meta_event_type = "heartbeat";
  status;
  interval;
  constructor(core, interval, isOnline, isGood) {
    super(core);
    this.interval = interval;
    this.status = {
      online: isOnline,
      good: isGood
    };
  }
}

var ActionName = /* @__PURE__ */ ((ActionName2) => {
  ActionName2["SendPrivateMsg"] = "send_private_msg";
  ActionName2["SendGroupMsg"] = "send_group_msg";
  ActionName2["SendMsg"] = "send_msg";
  ActionName2["DeleteMsg"] = "delete_msg";
  ActionName2["GetMsg"] = "get_msg";
  ActionName2["GoCQHTTP_GetForwardMsg"] = "get_forward_msg";
  ActionName2["SendLike"] = "send_like";
  ActionName2["SetGroupKick"] = "set_group_kick";
  ActionName2["SetGroupBan"] = "set_group_ban";
  ActionName2["SetGroupWholeBan"] = "set_group_whole_ban";
  ActionName2["SetGroupAdmin"] = "set_group_admin";
  ActionName2["SetGroupCard"] = "set_group_card";
  ActionName2["SetGroupName"] = "set_group_name";
  ActionName2["SetGroupLeave"] = "set_group_leave";
  ActionName2["SetSpecialTittle"] = "set_group_special_title";
  ActionName2["SetFriendAddRequest"] = "set_friend_add_request";
  ActionName2["SetGroupAddRequest"] = "set_group_add_request";
  ActionName2["GetLoginInfo"] = "get_login_info";
  ActionName2["GoCQHTTP_GetStrangerInfo"] = "get_stranger_info";
  ActionName2["GetFriendList"] = "get_friend_list";
  ActionName2["GetGroupInfo"] = "get_group_info";
  ActionName2["GetGroupList"] = "get_group_list";
  ActionName2["GetGroupMemberInfo"] = "get_group_member_info";
  ActionName2["GetGroupMemberList"] = "get_group_member_list";
  ActionName2["GetGroupHonorInfo"] = "get_group_honor_info";
  ActionName2["GetCookies"] = "get_cookies";
  ActionName2["GetCSRF"] = "get_csrf_token";
  ActionName2["GetCredentials"] = "get_credentials";
  ActionName2["GetRecord"] = "get_record";
  ActionName2["GetImage"] = "get_image";
  ActionName2["CanSendImage"] = "can_send_image";
  ActionName2["CanSendRecord"] = "can_send_record";
  ActionName2["GetStatus"] = "get_status";
  ActionName2["GetVersionInfo"] = "get_version_info";
  ActionName2["SetQQProfile"] = "set_qq_profile";
  ActionName2["GoCQHTTP_GetModelShow"] = "_get_model_show";
  ActionName2["GoCQHTTP_SetModelShow"] = "_set_model_show";
  ActionName2["GetOnlineClient"] = "get_online_clients";
  ActionName2["GoCQHTTP_DeleteFriend"] = "delete_friend";
  ActionName2["GoCQHTTP_MarkMsgAsRead"] = "mark_msg_as_read";
  ActionName2["GoCQHTTP_SendGroupForwardMsg"] = "send_group_forward_msg";
  ActionName2["GoCQHTTP_SendPrivateForwardMsg"] = "send_private_forward_msg";
  ActionName2["GoCQHTTP_GetGroupMsgHistory"] = "get_group_msg_history";
  ActionName2["OCRImage"] = "ocr_image";
  ActionName2["IOCRImage"] = ".ocr_image";
  ActionName2["GetGroupSystemMsg"] = "get_group_system_msg";
  ActionName2["GoCQHTTP_GetEssenceMsg"] = "get_essence_msg_list";
  ActionName2["GoCQHTTP_GetGroupAtAllRemain"] = "get_group_at_all_remain";
  ActionName2["SetGroupPortrait"] = "set_group_portrait";
  ActionName2["SetEssenceMsg"] = "set_essence_msg";
  ActionName2["DelEssenceMsg"] = "delete_essence_msg";
  ActionName2["GoCQHTTP_SendGroupNotice"] = "_send_group_notice";
  ActionName2["GoCQHTTP_GetGroupNotice"] = "_get_group_notice";
  ActionName2["GoCQHTTP_UploadGroupFile"] = "upload_group_file";
  ActionName2["GOCQHTTP_DeleteGroupFile"] = "delete_group_file";
  ActionName2["GoCQHTTP_CreateGroupFileFolder"] = "create_group_file_folder";
  ActionName2["GoCQHTTP_DeleteGroupFileFolder"] = "delete_group_folder";
  ActionName2["GoCQHTTP_GetGroupFileSystemInfo"] = "get_group_file_system_info";
  ActionName2["GoCQHTTP_GetGroupRootFiles"] = "get_group_root_files";
  ActionName2["GoCQHTTP_GetGroupFilesByFolder"] = "get_group_files_by_folder";
  ActionName2["GOCQHTTP_GetGroupFileUrl"] = "get_group_file_url";
  ActionName2["GOCQHTTP_UploadPrivateFile"] = "upload_private_file";
  ActionName2["GoCQHTTP_DownloadFile"] = "download_file";
  ActionName2["GoCQHTTP_CheckUrlSafely"] = "check_url_safely";
  ActionName2["GoCQHTTP_GetWordSlices"] = ".get_word_slices";
  ActionName2["GoCQHTTP_HandleQuickAction"] = ".handle_quick_operation";
  ActionName2["Unknown"] = "unknown";
  ActionName2["SharePeer"] = "ArkSharePeer";
  ActionName2["ShareGroupEx"] = "ArkShareGroup";
  ActionName2["GetRobotUinRange"] = "get_robot_uin_range";
  ActionName2["SetOnlineStatus"] = "set_online_status";
  ActionName2["GetFriendsWithCategory"] = "get_friends_with_category";
  ActionName2["SetQQAvatar"] = "set_qq_avatar";
  ActionName2["GetFile"] = "get_file";
  ActionName2["ForwardFriendSingleMsg"] = "forward_friend_single_msg";
  ActionName2["ForwardGroupSingleMsg"] = "forward_group_single_msg";
  ActionName2["TranslateEnWordToZn"] = "translate_en2zh";
  ActionName2["SetMsgEmojiLike"] = "set_msg_emoji_like";
  ActionName2["GoCQHTTP_SendForwardMsg"] = "send_forward_msg";
  ActionName2["MarkPrivateMsgAsRead"] = "mark_private_msg_as_read";
  ActionName2["MarkGroupMsgAsRead"] = "mark_group_msg_as_read";
  ActionName2["GetFriendMsgHistory"] = "get_friend_msg_history";
  ActionName2["CreateCollection"] = "create_collection";
  ActionName2["GetCollectionList"] = "get_collection_list";
  ActionName2["SetLongNick"] = "set_self_longnick";
  ActionName2["GetRecentContact"] = "get_recent_contact";
  ActionName2["_MarkAllMsgAsRead"] = "_mark_all_as_read";
  ActionName2["GetProfileLike"] = "get_profile_like";
  ActionName2["FetchCustomFace"] = "fetch_custom_face";
  ActionName2["FetchEmojiLike"] = "fetch_emoji_like";
  ActionName2["SetInputStatus"] = "set_input_status";
  ActionName2["GetGroupInfoEx"] = "get_group_info_ex";
  ActionName2["GetGroupIgnoreAddRequest"] = "get_group_ignore_add_request";
  ActionName2["DelGroupNotice"] = "_del_group_notice";
  ActionName2["FetchUserProfileLike"] = "fetch_user_profile_like";
  ActionName2["FriendPoke"] = "friend_poke";
  ActionName2["GroupPoke"] = "group_poke";
  ActionName2["GetPacketStatus"] = "nc_get_packet_status";
  ActionName2["GetUserStatus"] = "nc_get_user_status";
  ActionName2["GetRkey"] = "nc_get_rkey";
  ActionName2["GetGroupShutList"] = "get_group_shut_list";
  ActionName2["GetGuildList"] = "get_guild_list";
  ActionName2["GetGuildProfile"] = "get_guild_service_profile";
  ActionName2["GetGroupIgnoredNotifies"] = "get_group_ignored_notifies";
  ActionName2["SetGroupSign"] = "set_group_sign";
  ActionName2["SendGroupSign"] = "send_group_sign";
  ActionName2["GetMiniAppArk"] = "get_mini_app_ark";
  ActionName2["GetAiRecord"] = "get_ai_record";
  ActionName2["GetAiCharacters"] = "get_ai_characters";
  ActionName2["SendGroupAiRecord"] = "send_group_ai_record";
  return ActionName2;
})(ActionName || {});

var ajv = {exports: {}};

var core$1 = {};

var validate = {};

var boolSchema = {};

var errors = {};

var codegen = {};

var code$1 = {};

var hasRequiredCode$1;

function requireCode$1 () {
	if (hasRequiredCode$1) return code$1;
	hasRequiredCode$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
		// eslint-disable-next-line @typescript-eslint/no-extraneous-class
		class _CodeOrName {
		}
		exports._CodeOrName = _CodeOrName;
		exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
		class Name extends _CodeOrName {
		    constructor(s) {
		        super();
		        if (!exports.IDENTIFIER.test(s))
		            throw new Error("CodeGen: name must be a valid identifier");
		        this.str = s;
		    }
		    toString() {
		        return this.str;
		    }
		    emptyStr() {
		        return false;
		    }
		    get names() {
		        return { [this.str]: 1 };
		    }
		}
		exports.Name = Name;
		class _Code extends _CodeOrName {
		    constructor(code) {
		        super();
		        this._items = typeof code === "string" ? [code] : code;
		    }
		    toString() {
		        return this.str;
		    }
		    emptyStr() {
		        if (this._items.length > 1)
		            return false;
		        const item = this._items[0];
		        return item === "" || item === '""';
		    }
		    get str() {
		        var _a;
		        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, "")));
		    }
		    get names() {
		        var _a;
		        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {
		            if (c instanceof Name)
		                names[c.str] = (names[c.str] || 0) + 1;
		            return names;
		        }, {})));
		    }
		}
		exports._Code = _Code;
		exports.nil = new _Code("");
		function _(strs, ...args) {
		    const code = [strs[0]];
		    let i = 0;
		    while (i < args.length) {
		        addCodeArg(code, args[i]);
		        code.push(strs[++i]);
		    }
		    return new _Code(code);
		}
		exports._ = _;
		const plus = new _Code("+");
		function str(strs, ...args) {
		    const expr = [safeStringify(strs[0])];
		    let i = 0;
		    while (i < args.length) {
		        expr.push(plus);
		        addCodeArg(expr, args[i]);
		        expr.push(plus, safeStringify(strs[++i]));
		    }
		    optimize(expr);
		    return new _Code(expr);
		}
		exports.str = str;
		function addCodeArg(code, arg) {
		    if (arg instanceof _Code)
		        code.push(...arg._items);
		    else if (arg instanceof Name)
		        code.push(arg);
		    else
		        code.push(interpolate(arg));
		}
		exports.addCodeArg = addCodeArg;
		function optimize(expr) {
		    let i = 1;
		    while (i < expr.length - 1) {
		        if (expr[i] === plus) {
		            const res = mergeExprItems(expr[i - 1], expr[i + 1]);
		            if (res !== undefined) {
		                expr.splice(i - 1, 3, res);
		                continue;
		            }
		            expr[i++] = "+";
		        }
		        i++;
		    }
		}
		function mergeExprItems(a, b) {
		    if (b === '""')
		        return a;
		    if (a === '""')
		        return b;
		    if (typeof a == "string") {
		        if (b instanceof Name || a[a.length - 1] !== '"')
		            return;
		        if (typeof b != "string")
		            return `${a.slice(0, -1)}${b}"`;
		        if (b[0] === '"')
		            return a.slice(0, -1) + b.slice(1);
		        return;
		    }
		    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
		        return `"${a}${b.slice(1)}`;
		    return;
		}
		function strConcat(c1, c2) {
		    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;
		}
		exports.strConcat = strConcat;
		// TODO do not allow arrays here
		function interpolate(x) {
		    return typeof x == "number" || typeof x == "boolean" || x === null
		        ? x
		        : safeStringify(Array.isArray(x) ? x.join(",") : x);
		}
		function stringify(x) {
		    return new _Code(safeStringify(x));
		}
		exports.stringify = stringify;
		function safeStringify(x) {
		    return JSON.stringify(x)
		        .replace(/\u2028/g, "\\u2028")
		        .replace(/\u2029/g, "\\u2029");
		}
		exports.safeStringify = safeStringify;
		function getProperty(key) {
		    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;
		}
		exports.getProperty = getProperty;
		//Does best effort to format the name properly
		function getEsmExportName(key) {
		    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
		        return new _Code(`${key}`);
		    }
		    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
		}
		exports.getEsmExportName = getEsmExportName;
		function regexpCode(rx) {
		    return new _Code(rx.toString());
		}
		exports.regexpCode = regexpCode;
		
	} (code$1));
	return code$1;
}

var scope = {};

var hasRequiredScope;

function requireScope () {
	if (hasRequiredScope) return scope;
	hasRequiredScope = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
		const code_1 = requireCode$1();
		class ValueError extends Error {
		    constructor(name) {
		        super(`CodeGen: "code" for ${name} not defined`);
		        this.value = name.value;
		    }
		}
		var UsedValueState;
		(function (UsedValueState) {
		    UsedValueState[UsedValueState["Started"] = 0] = "Started";
		    UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
		})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
		exports.varKinds = {
		    const: new code_1.Name("const"),
		    let: new code_1.Name("let"),
		    var: new code_1.Name("var"),
		};
		class Scope {
		    constructor({ prefixes, parent } = {}) {
		        this._names = {};
		        this._prefixes = prefixes;
		        this._parent = parent;
		    }
		    toName(nameOrPrefix) {
		        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
		    }
		    name(prefix) {
		        return new code_1.Name(this._newName(prefix));
		    }
		    _newName(prefix) {
		        const ng = this._names[prefix] || this._nameGroup(prefix);
		        return `${prefix}${ng.index++}`;
		    }
		    _nameGroup(prefix) {
		        var _a, _b;
		        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {
		            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
		        }
		        return (this._names[prefix] = { prefix, index: 0 });
		    }
		}
		exports.Scope = Scope;
		class ValueScopeName extends code_1.Name {
		    constructor(prefix, nameStr) {
		        super(nameStr);
		        this.prefix = prefix;
		    }
		    setValue(value, { property, itemIndex }) {
		        this.value = value;
		        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;
		    }
		}
		exports.ValueScopeName = ValueScopeName;
		const line = (0, code_1._) `\n`;
		class ValueScope extends Scope {
		    constructor(opts) {
		        super(opts);
		        this._values = {};
		        this._scope = opts.scope;
		        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
		    }
		    get() {
		        return this._scope;
		    }
		    name(prefix) {
		        return new ValueScopeName(prefix, this._newName(prefix));
		    }
		    value(nameOrPrefix, value) {
		        var _a;
		        if (value.ref === undefined)
		            throw new Error("CodeGen: ref must be passed in value");
		        const name = this.toName(nameOrPrefix);
		        const { prefix } = name;
		        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
		        let vs = this._values[prefix];
		        if (vs) {
		            const _name = vs.get(valueKey);
		            if (_name)
		                return _name;
		        }
		        else {
		            vs = this._values[prefix] = new Map();
		        }
		        vs.set(valueKey, name);
		        const s = this._scope[prefix] || (this._scope[prefix] = []);
		        const itemIndex = s.length;
		        s[itemIndex] = value.ref;
		        name.setValue(value, { property: prefix, itemIndex });
		        return name;
		    }
		    getValue(prefix, keyOrRef) {
		        const vs = this._values[prefix];
		        if (!vs)
		            return;
		        return vs.get(keyOrRef);
		    }
		    scopeRefs(scopeName, values = this._values) {
		        return this._reduceValues(values, (name) => {
		            if (name.scopePath === undefined)
		                throw new Error(`CodeGen: name "${name}" has no value`);
		            return (0, code_1._) `${scopeName}${name.scopePath}`;
		        });
		    }
		    scopeCode(values = this._values, usedValues, getCode) {
		        return this._reduceValues(values, (name) => {
		            if (name.value === undefined)
		                throw new Error(`CodeGen: name "${name}" has no value`);
		            return name.value.code;
		        }, usedValues, getCode);
		    }
		    _reduceValues(values, valueCode, usedValues = {}, getCode) {
		        let code = code_1.nil;
		        for (const prefix in values) {
		            const vs = values[prefix];
		            if (!vs)
		                continue;
		            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
		            vs.forEach((name) => {
		                if (nameSet.has(name))
		                    return;
		                nameSet.set(name, UsedValueState.Started);
		                let c = valueCode(name);
		                if (c) {
		                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
		                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;
		                }
		                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
		                    code = (0, code_1._) `${code}${c}${this.opts._n}`;
		                }
		                else {
		                    throw new ValueError(name);
		                }
		                nameSet.set(name, UsedValueState.Completed);
		            });
		        }
		        return code;
		    }
		}
		exports.ValueScope = ValueScope;
		
	} (scope));
	return scope;
}

var hasRequiredCodegen;

function requireCodegen () {
	if (hasRequiredCodegen) return codegen;
	hasRequiredCodegen = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
		const code_1 = requireCode$1();
		const scope_1 = requireScope();
		var code_2 = requireCode$1();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return code_2._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return code_2.str; } });
		Object.defineProperty(exports, "strConcat", { enumerable: true, get: function () { return code_2.strConcat; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return code_2.nil; } });
		Object.defineProperty(exports, "getProperty", { enumerable: true, get: function () { return code_2.getProperty; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return code_2.stringify; } });
		Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function () { return code_2.regexpCode; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return code_2.Name; } });
		var scope_2 = requireScope();
		Object.defineProperty(exports, "Scope", { enumerable: true, get: function () { return scope_2.Scope; } });
		Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function () { return scope_2.ValueScope; } });
		Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });
		Object.defineProperty(exports, "varKinds", { enumerable: true, get: function () { return scope_2.varKinds; } });
		exports.operators = {
		    GT: new code_1._Code(">"),
		    GTE: new code_1._Code(">="),
		    LT: new code_1._Code("<"),
		    LTE: new code_1._Code("<="),
		    EQ: new code_1._Code("==="),
		    NEQ: new code_1._Code("!=="),
		    NOT: new code_1._Code("!"),
		    OR: new code_1._Code("||"),
		    AND: new code_1._Code("&&"),
		    ADD: new code_1._Code("+"),
		};
		class Node {
		    optimizeNodes() {
		        return this;
		    }
		    optimizeNames(_names, _constants) {
		        return this;
		    }
		}
		class Def extends Node {
		    constructor(varKind, name, rhs) {
		        super();
		        this.varKind = varKind;
		        this.name = name;
		        this.rhs = rhs;
		    }
		    render({ es5, _n }) {
		        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
		        const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
		        return `${varKind} ${this.name}${rhs};` + _n;
		    }
		    optimizeNames(names, constants) {
		        if (!names[this.name.str])
		            return;
		        if (this.rhs)
		            this.rhs = optimizeExpr(this.rhs, names, constants);
		        return this;
		    }
		    get names() {
		        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
		    }
		}
		class Assign extends Node {
		    constructor(lhs, rhs, sideEffects) {
		        super();
		        this.lhs = lhs;
		        this.rhs = rhs;
		        this.sideEffects = sideEffects;
		    }
		    render({ _n }) {
		        return `${this.lhs} = ${this.rhs};` + _n;
		    }
		    optimizeNames(names, constants) {
		        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
		            return;
		        this.rhs = optimizeExpr(this.rhs, names, constants);
		        return this;
		    }
		    get names() {
		        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
		        return addExprNames(names, this.rhs);
		    }
		}
		class AssignOp extends Assign {
		    constructor(lhs, op, rhs, sideEffects) {
		        super(lhs, rhs, sideEffects);
		        this.op = op;
		    }
		    render({ _n }) {
		        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
		    }
		}
		class Label extends Node {
		    constructor(label) {
		        super();
		        this.label = label;
		        this.names = {};
		    }
		    render({ _n }) {
		        return `${this.label}:` + _n;
		    }
		}
		class Break extends Node {
		    constructor(label) {
		        super();
		        this.label = label;
		        this.names = {};
		    }
		    render({ _n }) {
		        const label = this.label ? ` ${this.label}` : "";
		        return `break${label};` + _n;
		    }
		}
		class Throw extends Node {
		    constructor(error) {
		        super();
		        this.error = error;
		    }
		    render({ _n }) {
		        return `throw ${this.error};` + _n;
		    }
		    get names() {
		        return this.error.names;
		    }
		}
		class AnyCode extends Node {
		    constructor(code) {
		        super();
		        this.code = code;
		    }
		    render({ _n }) {
		        return `${this.code};` + _n;
		    }
		    optimizeNodes() {
		        return `${this.code}` ? this : undefined;
		    }
		    optimizeNames(names, constants) {
		        this.code = optimizeExpr(this.code, names, constants);
		        return this;
		    }
		    get names() {
		        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
		    }
		}
		class ParentNode extends Node {
		    constructor(nodes = []) {
		        super();
		        this.nodes = nodes;
		    }
		    render(opts) {
		        return this.nodes.reduce((code, n) => code + n.render(opts), "");
		    }
		    optimizeNodes() {
		        const { nodes } = this;
		        let i = nodes.length;
		        while (i--) {
		            const n = nodes[i].optimizeNodes();
		            if (Array.isArray(n))
		                nodes.splice(i, 1, ...n);
		            else if (n)
		                nodes[i] = n;
		            else
		                nodes.splice(i, 1);
		        }
		        return nodes.length > 0 ? this : undefined;
		    }
		    optimizeNames(names, constants) {
		        const { nodes } = this;
		        let i = nodes.length;
		        while (i--) {
		            // iterating backwards improves 1-pass optimization
		            const n = nodes[i];
		            if (n.optimizeNames(names, constants))
		                continue;
		            subtractNames(names, n.names);
		            nodes.splice(i, 1);
		        }
		        return nodes.length > 0 ? this : undefined;
		    }
		    get names() {
		        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
		    }
		}
		class BlockNode extends ParentNode {
		    render(opts) {
		        return "{" + opts._n + super.render(opts) + "}" + opts._n;
		    }
		}
		class Root extends ParentNode {
		}
		class Else extends BlockNode {
		}
		Else.kind = "else";
		class If extends BlockNode {
		    constructor(condition, nodes) {
		        super(nodes);
		        this.condition = condition;
		    }
		    render(opts) {
		        let code = `if(${this.condition})` + super.render(opts);
		        if (this.else)
		            code += "else " + this.else.render(opts);
		        return code;
		    }
		    optimizeNodes() {
		        super.optimizeNodes();
		        const cond = this.condition;
		        if (cond === true)
		            return this.nodes; // else is ignored here
		        let e = this.else;
		        if (e) {
		            const ns = e.optimizeNodes();
		            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
		        }
		        if (e) {
		            if (cond === false)
		                return e instanceof If ? e : e.nodes;
		            if (this.nodes.length)
		                return this;
		            return new If(not(cond), e instanceof If ? [e] : e.nodes);
		        }
		        if (cond === false || !this.nodes.length)
		            return undefined;
		        return this;
		    }
		    optimizeNames(names, constants) {
		        var _a;
		        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
		        if (!(super.optimizeNames(names, constants) || this.else))
		            return;
		        this.condition = optimizeExpr(this.condition, names, constants);
		        return this;
		    }
		    get names() {
		        const names = super.names;
		        addExprNames(names, this.condition);
		        if (this.else)
		            addNames(names, this.else.names);
		        return names;
		    }
		}
		If.kind = "if";
		class For extends BlockNode {
		}
		For.kind = "for";
		class ForLoop extends For {
		    constructor(iteration) {
		        super();
		        this.iteration = iteration;
		    }
		    render(opts) {
		        return `for(${this.iteration})` + super.render(opts);
		    }
		    optimizeNames(names, constants) {
		        if (!super.optimizeNames(names, constants))
		            return;
		        this.iteration = optimizeExpr(this.iteration, names, constants);
		        return this;
		    }
		    get names() {
		        return addNames(super.names, this.iteration.names);
		    }
		}
		class ForRange extends For {
		    constructor(varKind, name, from, to) {
		        super();
		        this.varKind = varKind;
		        this.name = name;
		        this.from = from;
		        this.to = to;
		    }
		    render(opts) {
		        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
		        const { name, from, to } = this;
		        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
		    }
		    get names() {
		        const names = addExprNames(super.names, this.from);
		        return addExprNames(names, this.to);
		    }
		}
		class ForIter extends For {
		    constructor(loop, varKind, name, iterable) {
		        super();
		        this.loop = loop;
		        this.varKind = varKind;
		        this.name = name;
		        this.iterable = iterable;
		    }
		    render(opts) {
		        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
		    }
		    optimizeNames(names, constants) {
		        if (!super.optimizeNames(names, constants))
		            return;
		        this.iterable = optimizeExpr(this.iterable, names, constants);
		        return this;
		    }
		    get names() {
		        return addNames(super.names, this.iterable.names);
		    }
		}
		class Func extends BlockNode {
		    constructor(name, args, async) {
		        super();
		        this.name = name;
		        this.args = args;
		        this.async = async;
		    }
		    render(opts) {
		        const _async = this.async ? "async " : "";
		        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
		    }
		}
		Func.kind = "func";
		class Return extends ParentNode {
		    render(opts) {
		        return "return " + super.render(opts);
		    }
		}
		Return.kind = "return";
		class Try extends BlockNode {
		    render(opts) {
		        let code = "try" + super.render(opts);
		        if (this.catch)
		            code += this.catch.render(opts);
		        if (this.finally)
		            code += this.finally.render(opts);
		        return code;
		    }
		    optimizeNodes() {
		        var _a, _b;
		        super.optimizeNodes();
		        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
		        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
		        return this;
		    }
		    optimizeNames(names, constants) {
		        var _a, _b;
		        super.optimizeNames(names, constants);
		        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
		        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
		        return this;
		    }
		    get names() {
		        const names = super.names;
		        if (this.catch)
		            addNames(names, this.catch.names);
		        if (this.finally)
		            addNames(names, this.finally.names);
		        return names;
		    }
		}
		class Catch extends BlockNode {
		    constructor(error) {
		        super();
		        this.error = error;
		    }
		    render(opts) {
		        return `catch(${this.error})` + super.render(opts);
		    }
		}
		Catch.kind = "catch";
		class Finally extends BlockNode {
		    render(opts) {
		        return "finally" + super.render(opts);
		    }
		}
		Finally.kind = "finally";
		class CodeGen {
		    constructor(extScope, opts = {}) {
		        this._values = {};
		        this._blockStarts = [];
		        this._constants = {};
		        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
		        this._extScope = extScope;
		        this._scope = new scope_1.Scope({ parent: extScope });
		        this._nodes = [new Root()];
		    }
		    toString() {
		        return this._root.render(this.opts);
		    }
		    // returns unique name in the internal scope
		    name(prefix) {
		        return this._scope.name(prefix);
		    }
		    // reserves unique name in the external scope
		    scopeName(prefix) {
		        return this._extScope.name(prefix);
		    }
		    // reserves unique name in the external scope and assigns value to it
		    scopeValue(prefixOrName, value) {
		        const name = this._extScope.value(prefixOrName, value);
		        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
		        vs.add(name);
		        return name;
		    }
		    getScopeValue(prefix, keyOrRef) {
		        return this._extScope.getValue(prefix, keyOrRef);
		    }
		    // return code that assigns values in the external scope to the names that are used internally
		    // (same names that were returned by gen.scopeName or gen.scopeValue)
		    scopeRefs(scopeName) {
		        return this._extScope.scopeRefs(scopeName, this._values);
		    }
		    scopeCode() {
		        return this._extScope.scopeCode(this._values);
		    }
		    _def(varKind, nameOrPrefix, rhs, constant) {
		        const name = this._scope.toName(nameOrPrefix);
		        if (rhs !== undefined && constant)
		            this._constants[name.str] = rhs;
		        this._leafNode(new Def(varKind, name, rhs));
		        return name;
		    }
		    // `const` declaration (`var` in es5 mode)
		    const(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
		    }
		    // `let` declaration with optional assignment (`var` in es5 mode)
		    let(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
		    }
		    // `var` declaration with optional assignment
		    var(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
		    }
		    // assignment code
		    assign(lhs, rhs, sideEffects) {
		        return this._leafNode(new Assign(lhs, rhs, sideEffects));
		    }
		    // `+=` code
		    add(lhs, rhs) {
		        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
		    }
		    // appends passed SafeExpr to code or executes Block
		    code(c) {
		        if (typeof c == "function")
		            c();
		        else if (c !== code_1.nil)
		            this._leafNode(new AnyCode(c));
		        return this;
		    }
		    // returns code for object literal for the passed argument list of key-value pairs
		    object(...keyValues) {
		        const code = ["{"];
		        for (const [key, value] of keyValues) {
		            if (code.length > 1)
		                code.push(",");
		            code.push(key);
		            if (key !== value || this.opts.es5) {
		                code.push(":");
		                (0, code_1.addCodeArg)(code, value);
		            }
		        }
		        code.push("}");
		        return new code_1._Code(code);
		    }
		    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
		    if(condition, thenBody, elseBody) {
		        this._blockNode(new If(condition));
		        if (thenBody && elseBody) {
		            this.code(thenBody).else().code(elseBody).endIf();
		        }
		        else if (thenBody) {
		            this.code(thenBody).endIf();
		        }
		        else if (elseBody) {
		            throw new Error('CodeGen: "else" body without "then" body');
		        }
		        return this;
		    }
		    // `else if` clause - invalid without `if` or after `else` clauses
		    elseIf(condition) {
		        return this._elseNode(new If(condition));
		    }
		    // `else` clause - only valid after `if` or `else if` clauses
		    else() {
		        return this._elseNode(new Else());
		    }
		    // end `if` statement (needed if gen.if was used only with condition)
		    endIf() {
		        return this._endBlockNode(If, Else);
		    }
		    _for(node, forBody) {
		        this._blockNode(node);
		        if (forBody)
		            this.code(forBody).endFor();
		        return this;
		    }
		    // a generic `for` clause (or statement if `forBody` is passed)
		    for(iteration, forBody) {
		        return this._for(new ForLoop(iteration), forBody);
		    }
		    // `for` statement for a range of values
		    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
		        const name = this._scope.toName(nameOrPrefix);
		        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
		    }
		    // `for-of` statement (in es5 mode replace with a normal for loop)
		    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
		        const name = this._scope.toName(nameOrPrefix);
		        if (this.opts.es5) {
		            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
		            return this.forRange("_i", 0, (0, code_1._) `${arr}.length`, (i) => {
		                this.var(name, (0, code_1._) `${arr}[${i}]`);
		                forBody(name);
		            });
		        }
		        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
		    }
		    // `for-in` statement.
		    // With option `ownProperties` replaced with a `for-of` loop for object keys
		    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
		        if (this.opts.ownProperties) {
		            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);
		        }
		        const name = this._scope.toName(nameOrPrefix);
		        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
		    }
		    // end `for` loop
		    endFor() {
		        return this._endBlockNode(For);
		    }
		    // `label` statement
		    label(label) {
		        return this._leafNode(new Label(label));
		    }
		    // `break` statement
		    break(label) {
		        return this._leafNode(new Break(label));
		    }
		    // `return` statement
		    return(value) {
		        const node = new Return();
		        this._blockNode(node);
		        this.code(value);
		        if (node.nodes.length !== 1)
		            throw new Error('CodeGen: "return" should have one node');
		        return this._endBlockNode(Return);
		    }
		    // `try` statement
		    try(tryBody, catchCode, finallyCode) {
		        if (!catchCode && !finallyCode)
		            throw new Error('CodeGen: "try" without "catch" and "finally"');
		        const node = new Try();
		        this._blockNode(node);
		        this.code(tryBody);
		        if (catchCode) {
		            const error = this.name("e");
		            this._currNode = node.catch = new Catch(error);
		            catchCode(error);
		        }
		        if (finallyCode) {
		            this._currNode = node.finally = new Finally();
		            this.code(finallyCode);
		        }
		        return this._endBlockNode(Catch, Finally);
		    }
		    // `throw` statement
		    throw(error) {
		        return this._leafNode(new Throw(error));
		    }
		    // start self-balancing block
		    block(body, nodeCount) {
		        this._blockStarts.push(this._nodes.length);
		        if (body)
		            this.code(body).endBlock(nodeCount);
		        return this;
		    }
		    // end the current self-balancing block
		    endBlock(nodeCount) {
		        const len = this._blockStarts.pop();
		        if (len === undefined)
		            throw new Error("CodeGen: not in self-balancing block");
		        const toClose = this._nodes.length - len;
		        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
		            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
		        }
		        this._nodes.length = len;
		        return this;
		    }
		    // `function` heading (or definition if funcBody is passed)
		    func(name, args = code_1.nil, async, funcBody) {
		        this._blockNode(new Func(name, args, async));
		        if (funcBody)
		            this.code(funcBody).endFunc();
		        return this;
		    }
		    // end function definition
		    endFunc() {
		        return this._endBlockNode(Func);
		    }
		    optimize(n = 1) {
		        while (n-- > 0) {
		            this._root.optimizeNodes();
		            this._root.optimizeNames(this._root.names, this._constants);
		        }
		    }
		    _leafNode(node) {
		        this._currNode.nodes.push(node);
		        return this;
		    }
		    _blockNode(node) {
		        this._currNode.nodes.push(node);
		        this._nodes.push(node);
		    }
		    _endBlockNode(N1, N2) {
		        const n = this._currNode;
		        if (n instanceof N1 || (N2 && n instanceof N2)) {
		            this._nodes.pop();
		            return this;
		        }
		        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
		    }
		    _elseNode(node) {
		        const n = this._currNode;
		        if (!(n instanceof If)) {
		            throw new Error('CodeGen: "else" without "if"');
		        }
		        this._currNode = n.else = node;
		        return this;
		    }
		    get _root() {
		        return this._nodes[0];
		    }
		    get _currNode() {
		        const ns = this._nodes;
		        return ns[ns.length - 1];
		    }
		    set _currNode(node) {
		        const ns = this._nodes;
		        ns[ns.length - 1] = node;
		    }
		}
		exports.CodeGen = CodeGen;
		function addNames(names, from) {
		    for (const n in from)
		        names[n] = (names[n] || 0) + (from[n] || 0);
		    return names;
		}
		function addExprNames(names, from) {
		    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
		}
		function optimizeExpr(expr, names, constants) {
		    if (expr instanceof code_1.Name)
		        return replaceName(expr);
		    if (!canOptimize(expr))
		        return expr;
		    return new code_1._Code(expr._items.reduce((items, c) => {
		        if (c instanceof code_1.Name)
		            c = replaceName(c);
		        if (c instanceof code_1._Code)
		            items.push(...c._items);
		        else
		            items.push(c);
		        return items;
		    }, []));
		    function replaceName(n) {
		        const c = constants[n.str];
		        if (c === undefined || names[n.str] !== 1)
		            return n;
		        delete names[n.str];
		        return c;
		    }
		    function canOptimize(e) {
		        return (e instanceof code_1._Code &&
		            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));
		    }
		}
		function subtractNames(names, from) {
		    for (const n in from)
		        names[n] = (names[n] || 0) - (from[n] || 0);
		}
		function not(x) {
		    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._) `!${par(x)}`;
		}
		exports.not = not;
		const andCode = mappend(exports.operators.AND);
		// boolean AND (&&) expression with the passed arguments
		function and(...args) {
		    return args.reduce(andCode);
		}
		exports.and = and;
		const orCode = mappend(exports.operators.OR);
		// boolean OR (||) expression with the passed arguments
		function or(...args) {
		    return args.reduce(orCode);
		}
		exports.or = or;
		function mappend(op) {
		    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);
		}
		function par(x) {
		    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;
		}
		
	} (codegen));
	return codegen;
}

var util$1 = {};

var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$1;
	hasRequiredUtil$1 = 1;
	Object.defineProperty(util$1, "__esModule", { value: true });
	util$1.checkStrictMode = util$1.getErrorPath = util$1.Type = util$1.useFunc = util$1.setEvaluated = util$1.evaluatedPropsToName = util$1.mergeEvaluated = util$1.eachItem = util$1.unescapeJsonPointer = util$1.escapeJsonPointer = util$1.escapeFragment = util$1.unescapeFragment = util$1.schemaRefOrVal = util$1.schemaHasRulesButRef = util$1.schemaHasRules = util$1.checkUnknownRules = util$1.alwaysValidSchema = util$1.toHash = void 0;
	const codegen_1 = requireCodegen();
	const code_1 = requireCode$1();
	// TODO refactor to use Set
	function toHash(arr) {
	    const hash = {};
	    for (const item of arr)
	        hash[item] = true;
	    return hash;
	}
	util$1.toHash = toHash;
	function alwaysValidSchema(it, schema) {
	    if (typeof schema == "boolean")
	        return schema;
	    if (Object.keys(schema).length === 0)
	        return true;
	    checkUnknownRules(it, schema);
	    return !schemaHasRules(schema, it.self.RULES.all);
	}
	util$1.alwaysValidSchema = alwaysValidSchema;
	function checkUnknownRules(it, schema = it.schema) {
	    const { opts, self } = it;
	    if (!opts.strictSchema)
	        return;
	    if (typeof schema === "boolean")
	        return;
	    const rules = self.RULES.keywords;
	    for (const key in schema) {
	        if (!rules[key])
	            checkStrictMode(it, `unknown keyword: "${key}"`);
	    }
	}
	util$1.checkUnknownRules = checkUnknownRules;
	function schemaHasRules(schema, rules) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (rules[key])
	            return true;
	    return false;
	}
	util$1.schemaHasRules = schemaHasRules;
	function schemaHasRulesButRef(schema, RULES) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (key !== "$ref" && RULES.all[key])
	            return true;
	    return false;
	}
	util$1.schemaHasRulesButRef = schemaHasRulesButRef;
	function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
	    if (!$data) {
	        if (typeof schema == "number" || typeof schema == "boolean")
	            return schema;
	        if (typeof schema == "string")
	            return (0, codegen_1._) `${schema}`;
	    }
	    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
	}
	util$1.schemaRefOrVal = schemaRefOrVal;
	function unescapeFragment(str) {
	    return unescapeJsonPointer(decodeURIComponent(str));
	}
	util$1.unescapeFragment = unescapeFragment;
	function escapeFragment(str) {
	    return encodeURIComponent(escapeJsonPointer(str));
	}
	util$1.escapeFragment = escapeFragment;
	function escapeJsonPointer(str) {
	    if (typeof str == "number")
	        return `${str}`;
	    return str.replace(/~/g, "~0").replace(/\//g, "~1");
	}
	util$1.escapeJsonPointer = escapeJsonPointer;
	function unescapeJsonPointer(str) {
	    return str.replace(/~1/g, "/").replace(/~0/g, "~");
	}
	util$1.unescapeJsonPointer = unescapeJsonPointer;
	function eachItem(xs, f) {
	    if (Array.isArray(xs)) {
	        for (const x of xs)
	            f(x);
	    }
	    else {
	        f(xs);
	    }
	}
	util$1.eachItem = eachItem;
	function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {
	    return (gen, from, to, toName) => {
	        const res = to === undefined
	            ? from
	            : to instanceof codegen_1.Name
	                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
	                : from instanceof codegen_1.Name
	                    ? (mergeToName(gen, to, from), from)
	                    : mergeValues(from, to);
	        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
	    };
	}
	util$1.mergeEvaluated = {
	    props: makeMergeEvaluated({
	        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {
	            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));
	        }),
	        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {
	            if (from === true) {
	                gen.assign(to, true);
	            }
	            else {
	                gen.assign(to, (0, codegen_1._) `${to} || {}`);
	                setEvaluated(gen, to, from);
	            }
	        }),
	        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
	        resultToName: evaluatedPropsToName,
	    }),
	    items: makeMergeEvaluated({
	        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
	        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),
	        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
	        resultToName: (gen, items) => gen.var("items", items),
	    }),
	};
	function evaluatedPropsToName(gen, ps) {
	    if (ps === true)
	        return gen.var("props", true);
	    const props = gen.var("props", (0, codegen_1._) `{}`);
	    if (ps !== undefined)
	        setEvaluated(gen, props, ps);
	    return props;
	}
	util$1.evaluatedPropsToName = evaluatedPropsToName;
	function setEvaluated(gen, props, ps) {
	    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));
	}
	util$1.setEvaluated = setEvaluated;
	const snippets = {};
	function useFunc(gen, f) {
	    return gen.scopeValue("func", {
	        ref: f,
	        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),
	    });
	}
	util$1.useFunc = useFunc;
	var Type;
	(function (Type) {
	    Type[Type["Num"] = 0] = "Num";
	    Type[Type["Str"] = 1] = "Str";
	})(Type || (util$1.Type = Type = {}));
	function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
	    // let path
	    if (dataProp instanceof codegen_1.Name) {
	        const isNumber = dataPropType === Type.Num;
	        return jsPropertySyntax
	            ? isNumber
	                ? (0, codegen_1._) `"[" + ${dataProp} + "]"`
	                : (0, codegen_1._) `"['" + ${dataProp} + "']"`
	            : isNumber
	                ? (0, codegen_1._) `"/" + ${dataProp}`
	                : (0, codegen_1._) `"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`; // TODO maybe use global escapePointer
	    }
	    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
	}
	util$1.getErrorPath = getErrorPath;
	function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
	    if (!mode)
	        return;
	    msg = `strict mode: ${msg}`;
	    if (mode === true)
	        throw new Error(msg);
	    it.self.logger.warn(msg);
	}
	util$1.checkStrictMode = checkStrictMode;
	
	return util$1;
}

var names = {};

var hasRequiredNames;

function requireNames () {
	if (hasRequiredNames) return names;
	hasRequiredNames = 1;
	Object.defineProperty(names, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const names$1 = {
	    // validation function arguments
	    data: new codegen_1.Name("data"), // data passed to validation function
	    // args passed from referencing schema
	    valCxt: new codegen_1.Name("valCxt"), // validation/data context - should not be used directly, it is destructured to the names below
	    instancePath: new codegen_1.Name("instancePath"),
	    parentData: new codegen_1.Name("parentData"),
	    parentDataProperty: new codegen_1.Name("parentDataProperty"),
	    rootData: new codegen_1.Name("rootData"), // root data - same as the data passed to the first/top validation function
	    dynamicAnchors: new codegen_1.Name("dynamicAnchors"), // used to support recursiveRef and dynamicRef
	    // function scoped variables
	    vErrors: new codegen_1.Name("vErrors"), // null or array of validation errors
	    errors: new codegen_1.Name("errors"), // counter of validation errors
	    this: new codegen_1.Name("this"),
	    // "globals"
	    self: new codegen_1.Name("self"),
	    scope: new codegen_1.Name("scope"),
	    // JTD serialize/parse name for JSON string and position
	    json: new codegen_1.Name("json"),
	    jsonPos: new codegen_1.Name("jsonPos"),
	    jsonLen: new codegen_1.Name("jsonLen"),
	    jsonPart: new codegen_1.Name("jsonPart"),
	};
	names.default = names$1;
	
	return names;
}

var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
		const codegen_1 = requireCodegen();
		const util_1 = requireUtil$1();
		const names_1 = requireNames();
		exports.keywordError = {
		    message: ({ keyword }) => (0, codegen_1.str) `must pass "${keyword}" keyword validation`,
		};
		exports.keyword$DataError = {
		    message: ({ keyword, schemaType }) => schemaType
		        ? (0, codegen_1.str) `"${keyword}" keyword must be ${schemaType} ($data)`
		        : (0, codegen_1.str) `"${keyword}" keyword is invalid ($data)`,
		};
		function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
		    const { it } = cxt;
		    const { gen, compositeRule, allErrors } = it;
		    const errObj = errorObjectCode(cxt, error, errorPaths);
		    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {
		        addError(gen, errObj);
		    }
		    else {
		        returnErrors(it, (0, codegen_1._) `[${errObj}]`);
		    }
		}
		exports.reportError = reportError;
		function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
		    const { it } = cxt;
		    const { gen, compositeRule, allErrors } = it;
		    const errObj = errorObjectCode(cxt, error, errorPaths);
		    addError(gen, errObj);
		    if (!(compositeRule || allErrors)) {
		        returnErrors(it, names_1.default.vErrors);
		    }
		}
		exports.reportExtraError = reportExtraError;
		function resetErrorsCount(gen, errsCount) {
		    gen.assign(names_1.default.errors, errsCount);
		    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
		}
		exports.resetErrorsCount = resetErrorsCount;
		function extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {
		    /* istanbul ignore if */
		    if (errsCount === undefined)
		        throw new Error("ajv implementation error");
		    const err = gen.name("err");
		    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
		        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);
		        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
		        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);
		        if (it.opts.verbose) {
		            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);
		            gen.assign((0, codegen_1._) `${err}.data`, data);
		        }
		    });
		}
		exports.extendErrors = extendErrors;
		function addError(gen, errObj) {
		    const err = gen.const("err", errObj);
		    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);
		    gen.code((0, codegen_1._) `${names_1.default.errors}++`);
		}
		function returnErrors(it, errs) {
		    const { gen, validateName, schemaEnv } = it;
		    if (schemaEnv.$async) {
		        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);
		    }
		    else {
		        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);
		        gen.return(false);
		    }
		}
		const E = {
		    keyword: new codegen_1.Name("keyword"),
		    schemaPath: new codegen_1.Name("schemaPath"), // also used in JTD errors
		    params: new codegen_1.Name("params"),
		    propertyName: new codegen_1.Name("propertyName"),
		    message: new codegen_1.Name("message"),
		    schema: new codegen_1.Name("schema"),
		    parentSchema: new codegen_1.Name("parentSchema"),
		};
		function errorObjectCode(cxt, error, errorPaths) {
		    const { createErrors } = cxt.it;
		    if (createErrors === false)
		        return (0, codegen_1._) `{}`;
		    return errorObject(cxt, error, errorPaths);
		}
		function errorObject(cxt, error, errorPaths = {}) {
		    const { gen, it } = cxt;
		    const keyValues = [
		        errorInstancePath(it, errorPaths),
		        errorSchemaPath(cxt, errorPaths),
		    ];
		    extraErrorProps(cxt, error, keyValues);
		    return gen.object(...keyValues);
		}
		function errorInstancePath({ errorPath }, { instancePath }) {
		    const instPath = instancePath
		        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`
		        : errorPath;
		    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
		}
		function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
		    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;
		    if (schemaPath) {
		        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
		    }
		    return [E.schemaPath, schPath];
		}
		function extraErrorProps(cxt, { params, message }, keyValues) {
		    const { keyword, data, schemaValue, it } = cxt;
		    const { opts, propertyName, topSchemaRef, schemaPath } = it;
		    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._) `{}`]);
		    if (opts.messages) {
		        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
		    }
		    if (opts.verbose) {
		        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
		    }
		    if (propertyName)
		        keyValues.push([E.propertyName, propertyName]);
		}
		
	} (errors));
	return errors;
}

var hasRequiredBoolSchema;

function requireBoolSchema () {
	if (hasRequiredBoolSchema) return boolSchema;
	hasRequiredBoolSchema = 1;
	Object.defineProperty(boolSchema, "__esModule", { value: true });
	boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
	const errors_1 = requireErrors();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const boolError = {
	    message: "boolean schema is false",
	};
	function topBoolOrEmptySchema(it) {
	    const { gen, schema, validateName } = it;
	    if (schema === false) {
	        falseSchemaError(it, false);
	    }
	    else if (typeof schema == "object" && schema.$async === true) {
	        gen.return(names_1.default.data);
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, null);
	        gen.return(true);
	    }
	}
	boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
	function boolOrEmptySchema(it, valid) {
	    const { gen, schema } = it;
	    if (schema === false) {
	        gen.var(valid, false); // TODO var
	        falseSchemaError(it);
	    }
	    else {
	        gen.var(valid, true); // TODO var
	    }
	}
	boolSchema.boolOrEmptySchema = boolOrEmptySchema;
	function falseSchemaError(it, overrideAllErrors) {
	    const { gen, data } = it;
	    // TODO maybe some other interface should be used for non-keyword validation errors...
	    const cxt = {
	        gen,
	        keyword: "false schema",
	        data,
	        schema: false,
	        schemaCode: false,
	        schemaValue: false,
	        params: {},
	        it,
	    };
	    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
	}
	
	return boolSchema;
}

var dataType = {};

var rules = {};

var hasRequiredRules;

function requireRules () {
	if (hasRequiredRules) return rules;
	hasRequiredRules = 1;
	Object.defineProperty(rules, "__esModule", { value: true });
	rules.getRules = rules.isJSONType = void 0;
	const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
	const jsonTypes = new Set(_jsonTypes);
	function isJSONType(x) {
	    return typeof x == "string" && jsonTypes.has(x);
	}
	rules.isJSONType = isJSONType;
	function getRules() {
	    const groups = {
	        number: { type: "number", rules: [] },
	        string: { type: "string", rules: [] },
	        array: { type: "array", rules: [] },
	        object: { type: "object", rules: [] },
	    };
	    return {
	        types: { ...groups, integer: true, boolean: true, null: true },
	        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
	        post: { rules: [] },
	        all: {},
	        keywords: {},
	    };
	}
	rules.getRules = getRules;
	
	return rules;
}

var applicability = {};

var hasRequiredApplicability;

function requireApplicability () {
	if (hasRequiredApplicability) return applicability;
	hasRequiredApplicability = 1;
	Object.defineProperty(applicability, "__esModule", { value: true });
	applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
	function schemaHasRulesForType({ schema, self }, type) {
	    const group = self.RULES.types[type];
	    return group && group !== true && shouldUseGroup(schema, group);
	}
	applicability.schemaHasRulesForType = schemaHasRulesForType;
	function shouldUseGroup(schema, group) {
	    return group.rules.some((rule) => shouldUseRule(schema, rule));
	}
	applicability.shouldUseGroup = shouldUseGroup;
	function shouldUseRule(schema, rule) {
	    var _a;
	    return (schema[rule.keyword] !== undefined ||
	        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));
	}
	applicability.shouldUseRule = shouldUseRule;
	
	return applicability;
}

var hasRequiredDataType;

function requireDataType () {
	if (hasRequiredDataType) return dataType;
	hasRequiredDataType = 1;
	Object.defineProperty(dataType, "__esModule", { value: true });
	dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
	const rules_1 = requireRules();
	const applicability_1 = requireApplicability();
	const errors_1 = requireErrors();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	var DataType;
	(function (DataType) {
	    DataType[DataType["Correct"] = 0] = "Correct";
	    DataType[DataType["Wrong"] = 1] = "Wrong";
	})(DataType || (dataType.DataType = DataType = {}));
	function getSchemaTypes(schema) {
	    const types = getJSONTypes(schema.type);
	    const hasNull = types.includes("null");
	    if (hasNull) {
	        if (schema.nullable === false)
	            throw new Error("type: null contradicts nullable: false");
	    }
	    else {
	        if (!types.length && schema.nullable !== undefined) {
	            throw new Error('"nullable" cannot be used without "type"');
	        }
	        if (schema.nullable === true)
	            types.push("null");
	    }
	    return types;
	}
	dataType.getSchemaTypes = getSchemaTypes;
	// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
	function getJSONTypes(ts) {
	    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
	    if (types.every(rules_1.isJSONType))
	        return types;
	    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
	}
	dataType.getJSONTypes = getJSONTypes;
	function coerceAndCheckDataType(it, types) {
	    const { gen, data, opts } = it;
	    const coerceTo = coerceToTypes(types, opts.coerceTypes);
	    const checkTypes = types.length > 0 &&
	        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
	    if (checkTypes) {
	        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
	        gen.if(wrongType, () => {
	            if (coerceTo.length)
	                coerceData(it, types, coerceTo);
	            else
	                reportTypeError(it);
	        });
	    }
	    return checkTypes;
	}
	dataType.coerceAndCheckDataType = coerceAndCheckDataType;
	const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
	function coerceToTypes(types, coerceTypes) {
	    return coerceTypes
	        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))
	        : [];
	}
	function coerceData(it, types, coerceTo) {
	    const { gen, data, opts } = it;
	    const dataType = gen.let("dataType", (0, codegen_1._) `typeof ${data}`);
	    const coerced = gen.let("coerced", (0, codegen_1._) `undefined`);
	    if (opts.coerceTypes === "array") {
	        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen
	            .assign(data, (0, codegen_1._) `${data}[0]`)
	            .assign(dataType, (0, codegen_1._) `typeof ${data}`)
	            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
	    }
	    gen.if((0, codegen_1._) `${coerced} !== undefined`);
	    for (const t of coerceTo) {
	        if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
	            coerceSpecificType(t);
	        }
	    }
	    gen.else();
	    reportTypeError(it);
	    gen.endIf();
	    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {
	        gen.assign(data, coerced);
	        assignParentData(it, coerced);
	    });
	    function coerceSpecificType(t) {
	        switch (t) {
	            case "string":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} == "number" || ${dataType} == "boolean"`)
	                    .assign(coerced, (0, codegen_1._) `"" + ${data}`)
	                    .elseIf((0, codegen_1._) `${data} === null`)
	                    .assign(coerced, (0, codegen_1._) `""`);
	                return;
	            case "number":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`)
	                    .assign(coerced, (0, codegen_1._) `+${data}`);
	                return;
	            case "integer":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`)
	                    .assign(coerced, (0, codegen_1._) `+${data}`);
	                return;
	            case "boolean":
	                gen
	                    .elseIf((0, codegen_1._) `${data} === "false" || ${data} === 0 || ${data} === null`)
	                    .assign(coerced, false)
	                    .elseIf((0, codegen_1._) `${data} === "true" || ${data} === 1`)
	                    .assign(coerced, true);
	                return;
	            case "null":
	                gen.elseIf((0, codegen_1._) `${data} === "" || ${data} === 0 || ${data} === false`);
	                gen.assign(coerced, null);
	                return;
	            case "array":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`)
	                    .assign(coerced, (0, codegen_1._) `[${data}]`);
	        }
	    }
	}
	function assignParentData({ gen, parentData, parentDataProperty }, expr) {
	    // TODO use gen.property
	    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));
	}
	function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
	    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
	    let cond;
	    switch (dataType) {
	        case "null":
	            return (0, codegen_1._) `${data} ${EQ} null`;
	        case "array":
	            cond = (0, codegen_1._) `Array.isArray(${data})`;
	            break;
	        case "object":
	            cond = (0, codegen_1._) `${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
	            break;
	        case "integer":
	            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);
	            break;
	        case "number":
	            cond = numCond();
	            break;
	        default:
	            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;
	    }
	    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
	    function numCond(_cond = codegen_1.nil) {
	        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);
	    }
	}
	dataType.checkDataType = checkDataType;
	function checkDataTypes(dataTypes, data, strictNums, correct) {
	    if (dataTypes.length === 1) {
	        return checkDataType(dataTypes[0], data, strictNums, correct);
	    }
	    let cond;
	    const types = (0, util_1.toHash)(dataTypes);
	    if (types.array && types.object) {
	        const notObj = (0, codegen_1._) `typeof ${data} != "object"`;
	        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;
	        delete types.null;
	        delete types.array;
	        delete types.object;
	    }
	    else {
	        cond = codegen_1.nil;
	    }
	    if (types.number)
	        delete types.integer;
	    for (const t in types)
	        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
	    return cond;
	}
	dataType.checkDataTypes = checkDataTypes;
	const typeError = {
	    message: ({ schema }) => `must be ${schema}`,
	    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,
	};
	function reportTypeError(it) {
	    const cxt = getTypeErrorContext(it);
	    (0, errors_1.reportError)(cxt, typeError);
	}
	dataType.reportTypeError = reportTypeError;
	function getTypeErrorContext(it) {
	    const { gen, data, schema } = it;
	    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
	    return {
	        gen,
	        keyword: "type",
	        data,
	        schema: schema.type,
	        schemaCode,
	        schemaValue: schemaCode,
	        parentSchema: schema,
	        params: {},
	        it,
	    };
	}
	
	return dataType;
}

var defaults = {};

var hasRequiredDefaults;

function requireDefaults () {
	if (hasRequiredDefaults) return defaults;
	hasRequiredDefaults = 1;
	Object.defineProperty(defaults, "__esModule", { value: true });
	defaults.assignDefaults = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	function assignDefaults(it, ty) {
	    const { properties, items } = it.schema;
	    if (ty === "object" && properties) {
	        for (const key in properties) {
	            assignDefault(it, key, properties[key].default);
	        }
	    }
	    else if (ty === "array" && Array.isArray(items)) {
	        items.forEach((sch, i) => assignDefault(it, i, sch.default));
	    }
	}
	defaults.assignDefaults = assignDefaults;
	function assignDefault(it, prop, defaultValue) {
	    const { gen, compositeRule, data, opts } = it;
	    if (defaultValue === undefined)
	        return;
	    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;
	    if (compositeRule) {
	        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
	        return;
	    }
	    let condition = (0, codegen_1._) `${childData} === undefined`;
	    if (opts.useDefaults === "empty") {
	        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === ""`;
	    }
	    // `${childData} === undefined` +
	    // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
	    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
	}
	
	return defaults;
}

var keyword = {};

var code = {};

var hasRequiredCode;

function requireCode () {
	if (hasRequiredCode) return code;
	hasRequiredCode = 1;
	Object.defineProperty(code, "__esModule", { value: true });
	code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const names_1 = requireNames();
	const util_2 = requireUtil$1();
	function checkReportMissingProp(cxt, prop) {
	    const { gen, data, it } = cxt;
	    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
	        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);
	        cxt.error();
	    });
	}
	code.checkReportMissingProp = checkReportMissingProp;
	function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
	    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));
	}
	code.checkMissingProp = checkMissingProp;
	function reportMissingProp(cxt, missing) {
	    cxt.setParams({ missingProperty: missing }, true);
	    cxt.error();
	}
	code.reportMissingProp = reportMissingProp;
	function hasPropFunc(gen) {
	    return gen.scopeValue("func", {
	        // eslint-disable-next-line @typescript-eslint/unbound-method
	        ref: Object.prototype.hasOwnProperty,
	        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,
	    });
	}
	code.hasPropFunc = hasPropFunc;
	function isOwnProperty(gen, data, property) {
	    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;
	}
	code.isOwnProperty = isOwnProperty;
	function propertyInData(gen, data, property, ownProperties) {
	    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
	    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;
	}
	code.propertyInData = propertyInData;
	function noPropertyInData(gen, data, property, ownProperties) {
	    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;
	    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
	}
	code.noPropertyInData = noPropertyInData;
	function allSchemaProperties(schemaMap) {
	    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
	}
	code.allSchemaProperties = allSchemaProperties;
	function schemaProperties(it, schemaMap) {
	    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
	}
	code.schemaProperties = schemaProperties;
	function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
	    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
	    const valCxt = [
	        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
	        [names_1.default.parentData, it.parentData],
	        [names_1.default.parentDataProperty, it.parentDataProperty],
	        [names_1.default.rootData, names_1.default.rootData],
	    ];
	    if (it.opts.dynamicRef)
	        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
	    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;
	    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;
	}
	code.callValidateCode = callValidateCode;
	const newRegExp = (0, codegen_1._) `new RegExp`;
	function usePattern({ gen, it: { opts } }, pattern) {
	    const u = opts.unicodeRegExp ? "u" : "";
	    const { regExp } = opts.code;
	    const rx = regExp(pattern, u);
	    return gen.scopeValue("pattern", {
	        key: rx.toString(),
	        ref: rx,
	        code: (0, codegen_1._) `${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,
	    });
	}
	code.usePattern = usePattern;
	function validateArray(cxt) {
	    const { gen, data, keyword, it } = cxt;
	    const valid = gen.name("valid");
	    if (it.allErrors) {
	        const validArr = gen.let("valid", true);
	        validateItems(() => gen.assign(validArr, false));
	        return validArr;
	    }
	    gen.var(valid, true);
	    validateItems(() => gen.break());
	    return valid;
	    function validateItems(notValid) {
	        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	        gen.forRange("i", 0, len, (i) => {
	            cxt.subschema({
	                keyword,
	                dataProp: i,
	                dataPropType: util_1.Type.Num,
	            }, valid);
	            gen.if((0, codegen_1.not)(valid), notValid);
	        });
	    }
	}
	code.validateArray = validateArray;
	function validateUnion(cxt) {
	    const { gen, schema, keyword, it } = cxt;
	    /* istanbul ignore if */
	    if (!Array.isArray(schema))
	        throw new Error("ajv implementation error");
	    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
	    if (alwaysValid && !it.opts.unevaluated)
	        return;
	    const valid = gen.let("valid", false);
	    const schValid = gen.name("_valid");
	    gen.block(() => schema.forEach((_sch, i) => {
	        const schCxt = cxt.subschema({
	            keyword,
	            schemaProp: i,
	            compositeRule: true,
	        }, schValid);
	        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);
	        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
	        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
	        // or if all properties and items were evaluated (it.props === true && it.items === true)
	        if (!merged)
	            gen.if((0, codegen_1.not)(valid));
	    }));
	    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	}
	code.validateUnion = validateUnion;
	
	return code;
}

var hasRequiredKeyword;

function requireKeyword () {
	if (hasRequiredKeyword) return keyword;
	hasRequiredKeyword = 1;
	Object.defineProperty(keyword, "__esModule", { value: true });
	keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const code_1 = requireCode();
	const errors_1 = requireErrors();
	function macroKeywordCode(cxt, def) {
	    const { gen, keyword, schema, parentSchema, it } = cxt;
	    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
	    const schemaRef = useKeyword(gen, keyword, macroSchema);
	    if (it.opts.validateSchema !== false)
	        it.self.validateSchema(macroSchema, true);
	    const valid = gen.name("valid");
	    cxt.subschema({
	        schema: macroSchema,
	        schemaPath: codegen_1.nil,
	        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
	        topSchemaRef: schemaRef,
	        compositeRule: true,
	    }, valid);
	    cxt.pass(valid, () => cxt.error(true));
	}
	keyword.macroKeywordCode = macroKeywordCode;
	function funcKeywordCode(cxt, def) {
	    var _a;
	    const { gen, keyword, schema, parentSchema, $data, it } = cxt;
	    checkAsyncKeyword(it, def);
	    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
	    const validateRef = useKeyword(gen, keyword, validate);
	    const valid = gen.let("valid");
	    cxt.block$data(valid, validateKeyword);
	    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
	    function validateKeyword() {
	        if (def.errors === false) {
	            assignValid();
	            if (def.modifying)
	                modifyData(cxt);
	            reportErrs(() => cxt.error());
	        }
	        else {
	            const ruleErrs = def.async ? validateAsync() : validateSync();
	            if (def.modifying)
	                modifyData(cxt);
	            reportErrs(() => addErrs(cxt, ruleErrs));
	        }
	    }
	    function validateAsync() {
	        const ruleErrs = gen.let("ruleErrs", null);
	        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));
	        return ruleErrs;
	    }
	    function validateSync() {
	        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;
	        gen.assign(validateErrs, null);
	        assignValid(codegen_1.nil);
	        return validateErrs;
	    }
	    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {
	        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
	        const passSchema = !(("compile" in def && !$data) || def.schema === false);
	        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
	    }
	    function reportErrs(errors) {
	        var _a;
	        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
	    }
	}
	keyword.funcKeywordCode = funcKeywordCode;
	function modifyData(cxt) {
	    const { gen, data, it } = cxt;
	    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));
	}
	function addErrs(cxt, errs) {
	    const { gen } = cxt;
	    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {
	        gen
	            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)
	            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
	        (0, errors_1.extendErrors)(cxt);
	    }, () => cxt.error());
	}
	function checkAsyncKeyword({ schemaEnv }, def) {
	    if (def.async && !schemaEnv.$async)
	        throw new Error("async keyword in sync schema");
	}
	function useKeyword(gen, keyword, result) {
	    if (result === undefined)
	        throw new Error(`keyword "${keyword}" failed to compile`);
	    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
	}
	function validSchemaType(schema, schemaType, allowUndefined = false) {
	    // TODO add tests
	    return (!schemaType.length ||
	        schemaType.some((st) => st === "array"
	            ? Array.isArray(schema)
	            : st === "object"
	                ? schema && typeof schema == "object" && !Array.isArray(schema)
	                : typeof schema == st || (allowUndefined && typeof schema == "undefined")));
	}
	keyword.validSchemaType = validSchemaType;
	function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
	    /* istanbul ignore if */
	    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
	        throw new Error("ajv implementation error");
	    }
	    const deps = def.dependencies;
	    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
	        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
	    }
	    if (def.validateSchema) {
	        const valid = def.validateSchema(schema[keyword]);
	        if (!valid) {
	            const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
	                self.errorsText(def.validateSchema.errors);
	            if (opts.validateSchema === "log")
	                self.logger.error(msg);
	            else
	                throw new Error(msg);
	        }
	    }
	}
	keyword.validateKeywordUsage = validateKeywordUsage;
	
	return keyword;
}

var subschema = {};

var hasRequiredSubschema;

function requireSubschema () {
	if (hasRequiredSubschema) return subschema;
	hasRequiredSubschema = 1;
	Object.defineProperty(subschema, "__esModule", { value: true });
	subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
	    if (keyword !== undefined && schema !== undefined) {
	        throw new Error('both "keyword" and "schema" passed, only one allowed');
	    }
	    if (keyword !== undefined) {
	        const sch = it.schema[keyword];
	        return schemaProp === undefined
	            ? {
	                schema: sch,
	                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
	                errSchemaPath: `${it.errSchemaPath}/${keyword}`,
	            }
	            : {
	                schema: sch[schemaProp],
	                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
	                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,
	            };
	    }
	    if (schema !== undefined) {
	        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
	            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
	        }
	        return {
	            schema,
	            schemaPath,
	            topSchemaRef,
	            errSchemaPath,
	        };
	    }
	    throw new Error('either "keyword" or "schema" must be passed');
	}
	subschema.getSubschema = getSubschema;
	function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
	    if (data !== undefined && dataProp !== undefined) {
	        throw new Error('both "data" and "dataProp" passed, only one allowed');
	    }
	    const { gen } = it;
	    if (dataProp !== undefined) {
	        const { errorPath, dataPathArr, opts } = it;
	        const nextData = gen.let("data", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
	        dataContextProps(nextData);
	        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
	        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;
	        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
	    }
	    if (data !== undefined) {
	        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true); // replaceable if used once?
	        dataContextProps(nextData);
	        if (propertyName !== undefined)
	            subschema.propertyName = propertyName;
	        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
	    }
	    if (dataTypes)
	        subschema.dataTypes = dataTypes;
	    function dataContextProps(_nextData) {
	        subschema.data = _nextData;
	        subschema.dataLevel = it.dataLevel + 1;
	        subschema.dataTypes = [];
	        it.definedProperties = new Set();
	        subschema.parentData = it.data;
	        subschema.dataNames = [...it.dataNames, _nextData];
	    }
	}
	subschema.extendSubschemaData = extendSubschemaData;
	function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
	    if (compositeRule !== undefined)
	        subschema.compositeRule = compositeRule;
	    if (createErrors !== undefined)
	        subschema.createErrors = createErrors;
	    if (allErrors !== undefined)
	        subschema.allErrors = allErrors;
	    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
	    subschema.jtdMetadata = jtdMetadata; // not inherited
	}
	subschema.extendSubschemaMode = extendSubschemaMode;
	
	return subschema;
}

var resolve = {};

var fastDeepEqual;
var hasRequiredFastDeepEqual;

function requireFastDeepEqual () {
	if (hasRequiredFastDeepEqual) return fastDeepEqual;
	hasRequiredFastDeepEqual = 1;

	// do not edit .js files directly - edit src/index.jst



	fastDeepEqual = function equal(a, b) {
	  if (a === b) return true;

	  if (a && b && typeof a == 'object' && typeof b == 'object') {
	    if (a.constructor !== b.constructor) return false;

	    var length, i, keys;
	    if (Array.isArray(a)) {
	      length = a.length;
	      if (length != b.length) return false;
	      for (i = length; i-- !== 0;)
	        if (!equal(a[i], b[i])) return false;
	      return true;
	    }



	    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
	    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
	    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

	    keys = Object.keys(a);
	    length = keys.length;
	    if (length !== Object.keys(b).length) return false;

	    for (i = length; i-- !== 0;)
	      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

	    for (i = length; i-- !== 0;) {
	      var key = keys[i];

	      if (!equal(a[key], b[key])) return false;
	    }

	    return true;
	  }

	  // true if both NaN, false otherwise
	  return a!==a && b!==b;
	};
	return fastDeepEqual;
}

var jsonSchemaTraverse = {exports: {}};

var hasRequiredJsonSchemaTraverse;

function requireJsonSchemaTraverse () {
	if (hasRequiredJsonSchemaTraverse) return jsonSchemaTraverse.exports;
	hasRequiredJsonSchemaTraverse = 1;

	var traverse = jsonSchemaTraverse.exports = function (schema, opts, cb) {
	  // Legacy support for v0.3.1 and earlier.
	  if (typeof opts == 'function') {
	    cb = opts;
	    opts = {};
	  }

	  cb = opts.cb || cb;
	  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
	  var post = cb.post || function() {};

	  _traverse(opts, pre, post, schema, '', schema);
	};


	traverse.keywords = {
	  additionalItems: true,
	  items: true,
	  contains: true,
	  additionalProperties: true,
	  propertyNames: true,
	  not: true,
	  if: true,
	  then: true,
	  else: true
	};

	traverse.arrayKeywords = {
	  items: true,
	  allOf: true,
	  anyOf: true,
	  oneOf: true
	};

	traverse.propsKeywords = {
	  $defs: true,
	  definitions: true,
	  properties: true,
	  patternProperties: true,
	  dependencies: true
	};

	traverse.skipKeywords = {
	  default: true,
	  enum: true,
	  const: true,
	  required: true,
	  maximum: true,
	  minimum: true,
	  exclusiveMaximum: true,
	  exclusiveMinimum: true,
	  multipleOf: true,
	  maxLength: true,
	  minLength: true,
	  pattern: true,
	  format: true,
	  maxItems: true,
	  minItems: true,
	  uniqueItems: true,
	  maxProperties: true,
	  minProperties: true
	};


	function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
	  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
	    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
	    for (var key in schema) {
	      var sch = schema[key];
	      if (Array.isArray(sch)) {
	        if (key in traverse.arrayKeywords) {
	          for (var i=0; i<sch.length; i++)
	            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
	        }
	      } else if (key in traverse.propsKeywords) {
	        if (sch && typeof sch == 'object') {
	          for (var prop in sch)
	            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
	        }
	      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
	        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
	      }
	    }
	    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
	  }
	}


	function escapeJsonPtr(str) {
	  return str.replace(/~/g, '~0').replace(/\//g, '~1');
	}
	return jsonSchemaTraverse.exports;
}

var hasRequiredResolve;

function requireResolve () {
	if (hasRequiredResolve) return resolve;
	hasRequiredResolve = 1;
	Object.defineProperty(resolve, "__esModule", { value: true });
	resolve.getSchemaRefs = resolve.resolveUrl = resolve.normalizeId = resolve._getFullPath = resolve.getFullPath = resolve.inlineRef = void 0;
	const util_1 = requireUtil$1();
	const equal = requireFastDeepEqual();
	const traverse = requireJsonSchemaTraverse();
	// TODO refactor to use keyword definitions
	const SIMPLE_INLINED = new Set([
	    "type",
	    "format",
	    "pattern",
	    "maxLength",
	    "minLength",
	    "maxProperties",
	    "minProperties",
	    "maxItems",
	    "minItems",
	    "maximum",
	    "minimum",
	    "uniqueItems",
	    "multipleOf",
	    "required",
	    "enum",
	    "const",
	]);
	function inlineRef(schema, limit = true) {
	    if (typeof schema == "boolean")
	        return true;
	    if (limit === true)
	        return !hasRef(schema);
	    if (!limit)
	        return false;
	    return countKeys(schema) <= limit;
	}
	resolve.inlineRef = inlineRef;
	const REF_KEYWORDS = new Set([
	    "$ref",
	    "$recursiveRef",
	    "$recursiveAnchor",
	    "$dynamicRef",
	    "$dynamicAnchor",
	]);
	function hasRef(schema) {
	    for (const key in schema) {
	        if (REF_KEYWORDS.has(key))
	            return true;
	        const sch = schema[key];
	        if (Array.isArray(sch) && sch.some(hasRef))
	            return true;
	        if (typeof sch == "object" && hasRef(sch))
	            return true;
	    }
	    return false;
	}
	function countKeys(schema) {
	    let count = 0;
	    for (const key in schema) {
	        if (key === "$ref")
	            return Infinity;
	        count++;
	        if (SIMPLE_INLINED.has(key))
	            continue;
	        if (typeof schema[key] == "object") {
	            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));
	        }
	        if (count === Infinity)
	            return Infinity;
	    }
	    return count;
	}
	function getFullPath(resolver, id = "", normalize) {
	    if (normalize !== false)
	        id = normalizeId(id);
	    const p = resolver.parse(id);
	    return _getFullPath(resolver, p);
	}
	resolve.getFullPath = getFullPath;
	function _getFullPath(resolver, p) {
	    const serialized = resolver.serialize(p);
	    return serialized.split("#")[0] + "#";
	}
	resolve._getFullPath = _getFullPath;
	const TRAILING_SLASH_HASH = /#\/?$/;
	function normalizeId(id) {
	    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
	}
	resolve.normalizeId = normalizeId;
	function resolveUrl(resolver, baseId, id) {
	    id = normalizeId(id);
	    return resolver.resolve(baseId, id);
	}
	resolve.resolveUrl = resolveUrl;
	const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
	function getSchemaRefs(schema, baseId) {
	    if (typeof schema == "boolean")
	        return {};
	    const { schemaId, uriResolver } = this.opts;
	    const schId = normalizeId(schema[schemaId] || baseId);
	    const baseIds = { "": schId };
	    const pathPrefix = getFullPath(uriResolver, schId, false);
	    const localRefs = {};
	    const schemaRefs = new Set();
	    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
	        if (parentJsonPtr === undefined)
	            return;
	        const fullPath = pathPrefix + jsonPtr;
	        let innerBaseId = baseIds[parentJsonPtr];
	        if (typeof sch[schemaId] == "string")
	            innerBaseId = addRef.call(this, sch[schemaId]);
	        addAnchor.call(this, sch.$anchor);
	        addAnchor.call(this, sch.$dynamicAnchor);
	        baseIds[jsonPtr] = innerBaseId;
	        function addRef(ref) {
	            // eslint-disable-next-line @typescript-eslint/unbound-method
	            const _resolve = this.opts.uriResolver.resolve;
	            ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
	            if (schemaRefs.has(ref))
	                throw ambiguos(ref);
	            schemaRefs.add(ref);
	            let schOrRef = this.refs[ref];
	            if (typeof schOrRef == "string")
	                schOrRef = this.refs[schOrRef];
	            if (typeof schOrRef == "object") {
	                checkAmbiguosRef(sch, schOrRef.schema, ref);
	            }
	            else if (ref !== normalizeId(fullPath)) {
	                if (ref[0] === "#") {
	                    checkAmbiguosRef(sch, localRefs[ref], ref);
	                    localRefs[ref] = sch;
	                }
	                else {
	                    this.refs[ref] = fullPath;
	                }
	            }
	            return ref;
	        }
	        function addAnchor(anchor) {
	            if (typeof anchor == "string") {
	                if (!ANCHOR.test(anchor))
	                    throw new Error(`invalid anchor "${anchor}"`);
	                addRef.call(this, `#${anchor}`);
	            }
	        }
	    });
	    return localRefs;
	    function checkAmbiguosRef(sch1, sch2, ref) {
	        if (sch2 !== undefined && !equal(sch1, sch2))
	            throw ambiguos(ref);
	    }
	    function ambiguos(ref) {
	        return new Error(`reference "${ref}" resolves to more than one schema`);
	    }
	}
	resolve.getSchemaRefs = getSchemaRefs;
	
	return resolve;
}

var hasRequiredValidate;

function requireValidate () {
	if (hasRequiredValidate) return validate;
	hasRequiredValidate = 1;
	Object.defineProperty(validate, "__esModule", { value: true });
	validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
	const boolSchema_1 = requireBoolSchema();
	const dataType_1 = requireDataType();
	const applicability_1 = requireApplicability();
	const dataType_2 = requireDataType();
	const defaults_1 = requireDefaults();
	const keyword_1 = requireKeyword();
	const subschema_1 = requireSubschema();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const resolve_1 = requireResolve();
	const util_1 = requireUtil$1();
	const errors_1 = requireErrors();
	// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
	function validateFunctionCode(it) {
	    if (isSchemaObj(it)) {
	        checkKeywords(it);
	        if (schemaCxtHasRules(it)) {
	            topSchemaObjCode(it);
	            return;
	        }
	    }
	    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
	}
	validate.validateFunctionCode = validateFunctionCode;
	function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
	    if (opts.code.es5) {
	        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
	            gen.code((0, codegen_1._) `"use strict"; ${funcSourceUrl(schema, opts)}`);
	            destructureValCxtES5(gen, opts);
	            gen.code(body);
	        });
	    }
	    else {
	        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
	    }
	}
	function destructureValCxt(opts) {
	    return (0, codegen_1._) `{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
	}
	function destructureValCxtES5(gen, opts) {
	    gen.if(names_1.default.valCxt, () => {
	        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);
	        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);
	        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
	        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);
	        if (opts.dynamicRef)
	            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
	    }, () => {
	        gen.var(names_1.default.instancePath, (0, codegen_1._) `""`);
	        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);
	        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);
	        gen.var(names_1.default.rootData, names_1.default.data);
	        if (opts.dynamicRef)
	            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);
	    });
	}
	function topSchemaObjCode(it) {
	    const { schema, opts, gen } = it;
	    validateFunction(it, () => {
	        if (opts.$comment && schema.$comment)
	            commentKeyword(it);
	        checkNoDefault(it);
	        gen.let(names_1.default.vErrors, null);
	        gen.let(names_1.default.errors, 0);
	        if (opts.unevaluated)
	            resetEvaluated(it);
	        typeAndKeywords(it);
	        returnResults(it);
	    });
	    return;
	}
	function resetEvaluated(it) {
	    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
	    const { gen, validateName } = it;
	    it.evaluated = gen.const("evaluated", (0, codegen_1._) `${validateName}.evaluated`);
	    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));
	    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));
	}
	function funcSourceUrl(schema, opts) {
	    const schId = typeof schema == "object" && schema[opts.schemaId];
	    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;
	}
	// schema compilation - this function is used recursively to generate code for sub-schemas
	function subschemaCode(it, valid) {
	    if (isSchemaObj(it)) {
	        checkKeywords(it);
	        if (schemaCxtHasRules(it)) {
	            subSchemaObjCode(it, valid);
	            return;
	        }
	    }
	    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
	}
	function schemaCxtHasRules({ schema, self }) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (self.RULES.all[key])
	            return true;
	    return false;
	}
	function isSchemaObj(it) {
	    return typeof it.schema != "boolean";
	}
	function subSchemaObjCode(it, valid) {
	    const { schema, gen, opts } = it;
	    if (opts.$comment && schema.$comment)
	        commentKeyword(it);
	    updateContext(it);
	    checkAsyncSchema(it);
	    const errsCount = gen.const("_errs", names_1.default.errors);
	    typeAndKeywords(it, errsCount);
	    // TODO var
	    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
	}
	function checkKeywords(it) {
	    (0, util_1.checkUnknownRules)(it);
	    checkRefsAndKeywords(it);
	}
	function typeAndKeywords(it, errsCount) {
	    if (it.opts.jtd)
	        return schemaKeywords(it, [], false, errsCount);
	    const types = (0, dataType_1.getSchemaTypes)(it.schema);
	    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
	    schemaKeywords(it, types, !checkedTypes, errsCount);
	}
	function checkRefsAndKeywords(it) {
	    const { schema, errSchemaPath, opts, self } = it;
	    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
	        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
	    }
	}
	function checkNoDefault(it) {
	    const { schema, opts } = it;
	    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
	        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
	    }
	}
	function updateContext(it) {
	    const schId = it.schema[it.opts.schemaId];
	    if (schId)
	        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
	}
	function checkAsyncSchema(it) {
	    if (it.schema.$async && !it.schemaEnv.$async)
	        throw new Error("async schema in sync schema");
	}
	function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
	    const msg = schema.$comment;
	    if (opts.$comment === true) {
	        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);
	    }
	    else if (typeof opts.$comment == "function") {
	        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;
	        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
	        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
	    }
	}
	function returnResults(it) {
	    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
	    if (schemaEnv.$async) {
	        // TODO assign unevaluated
	        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);
	        if (opts.unevaluated)
	            assignEvaluated(it);
	        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);
	    }
	}
	function assignEvaluated({ gen, evaluated, props, items }) {
	    if (props instanceof codegen_1.Name)
	        gen.assign((0, codegen_1._) `${evaluated}.props`, props);
	    if (items instanceof codegen_1.Name)
	        gen.assign((0, codegen_1._) `${evaluated}.items`, items);
	}
	function schemaKeywords(it, types, typeErrors, errsCount) {
	    const { gen, schema, data, allErrors, opts, self } = it;
	    const { RULES } = self;
	    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
	        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast
	        return;
	    }
	    if (!opts.jtd)
	        checkStrictTypes(it, types);
	    gen.block(() => {
	        for (const group of RULES.rules)
	            groupKeywords(group);
	        groupKeywords(RULES.post);
	    });
	    function groupKeywords(group) {
	        if (!(0, applicability_1.shouldUseGroup)(schema, group))
	            return;
	        if (group.type) {
	            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
	            iterateKeywords(it, group);
	            if (types.length === 1 && types[0] === group.type && typeErrors) {
	                gen.else();
	                (0, dataType_2.reportTypeError)(it);
	            }
	            gen.endIf();
	        }
	        else {
	            iterateKeywords(it, group);
	        }
	        // TODO make it "ok" call?
	        if (!allErrors)
	            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);
	    }
	}
	function iterateKeywords(it, group) {
	    const { gen, schema, opts: { useDefaults }, } = it;
	    if (useDefaults)
	        (0, defaults_1.assignDefaults)(it, group.type);
	    gen.block(() => {
	        for (const rule of group.rules) {
	            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
	                keywordCode(it, rule.keyword, rule.definition, group.type);
	            }
	        }
	    });
	}
	function checkStrictTypes(it, types) {
	    if (it.schemaEnv.meta || !it.opts.strictTypes)
	        return;
	    checkContextTypes(it, types);
	    if (!it.opts.allowUnionTypes)
	        checkMultipleTypes(it, types);
	    checkKeywordTypes(it, it.dataTypes);
	}
	function checkContextTypes(it, types) {
	    if (!types.length)
	        return;
	    if (!it.dataTypes.length) {
	        it.dataTypes = types;
	        return;
	    }
	    types.forEach((t) => {
	        if (!includesType(it.dataTypes, t)) {
	            strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
	        }
	    });
	    narrowSchemaTypes(it, types);
	}
	function checkMultipleTypes(it, ts) {
	    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
	        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
	    }
	}
	function checkKeywordTypes(it, ts) {
	    const rules = it.self.RULES.all;
	    for (const keyword in rules) {
	        const rule = rules[keyword];
	        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
	            const { type } = rule.definition;
	            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
	                strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
	            }
	        }
	    }
	}
	function hasApplicableType(schTs, kwdT) {
	    return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
	}
	function includesType(ts, t) {
	    return ts.includes(t) || (t === "integer" && ts.includes("number"));
	}
	function narrowSchemaTypes(it, withTypes) {
	    const ts = [];
	    for (const t of it.dataTypes) {
	        if (includesType(withTypes, t))
	            ts.push(t);
	        else if (withTypes.includes("integer") && t === "number")
	            ts.push("integer");
	    }
	    it.dataTypes = ts;
	}
	function strictTypesError(it, msg) {
	    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
	    msg += ` at "${schemaPath}" (strictTypes)`;
	    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
	}
	class KeywordCxt {
	    constructor(it, def, keyword) {
	        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
	        this.gen = it.gen;
	        this.allErrors = it.allErrors;
	        this.keyword = keyword;
	        this.data = it.data;
	        this.schema = it.schema[keyword];
	        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
	        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
	        this.schemaType = def.schemaType;
	        this.parentSchema = it.schema;
	        this.params = {};
	        this.it = it;
	        this.def = def;
	        if (this.$data) {
	            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
	        }
	        else {
	            this.schemaCode = this.schemaValue;
	            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
	                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
	            }
	        }
	        if ("code" in def ? def.trackErrors : def.errors !== false) {
	            this.errsCount = it.gen.const("_errs", names_1.default.errors);
	        }
	    }
	    result(condition, successAction, failAction) {
	        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
	    }
	    failResult(condition, successAction, failAction) {
	        this.gen.if(condition);
	        if (failAction)
	            failAction();
	        else
	            this.error();
	        if (successAction) {
	            this.gen.else();
	            successAction();
	            if (this.allErrors)
	                this.gen.endIf();
	        }
	        else {
	            if (this.allErrors)
	                this.gen.endIf();
	            else
	                this.gen.else();
	        }
	    }
	    pass(condition, failAction) {
	        this.failResult((0, codegen_1.not)(condition), undefined, failAction);
	    }
	    fail(condition) {
	        if (condition === undefined) {
	            this.error();
	            if (!this.allErrors)
	                this.gen.if(false); // this branch will be removed by gen.optimize
	            return;
	        }
	        this.gen.if(condition);
	        this.error();
	        if (this.allErrors)
	            this.gen.endIf();
	        else
	            this.gen.else();
	    }
	    fail$data(condition) {
	        if (!this.$data)
	            return this.fail(condition);
	        const { schemaCode } = this;
	        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
	    }
	    error(append, errorParams, errorPaths) {
	        if (errorParams) {
	            this.setParams(errorParams);
	            this._error(append, errorPaths);
	            this.setParams({});
	            return;
	        }
	        this._error(append, errorPaths);
	    }
	    _error(append, errorPaths) {
	        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
	    }
	    $dataError() {
	        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
	    }
	    reset() {
	        if (this.errsCount === undefined)
	            throw new Error('add "trackErrors" to keyword definition');
	        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
	    }
	    ok(cond) {
	        if (!this.allErrors)
	            this.gen.if(cond);
	    }
	    setParams(obj, assign) {
	        if (assign)
	            Object.assign(this.params, obj);
	        else
	            this.params = obj;
	    }
	    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
	        this.gen.block(() => {
	            this.check$data(valid, $dataValid);
	            codeBlock();
	        });
	    }
	    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
	        if (!this.$data)
	            return;
	        const { gen, schemaCode, schemaType, def } = this;
	        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));
	        if (valid !== codegen_1.nil)
	            gen.assign(valid, true);
	        if (schemaType.length || def.validateSchema) {
	            gen.elseIf(this.invalid$data());
	            this.$dataError();
	            if (valid !== codegen_1.nil)
	                gen.assign(valid, false);
	        }
	        gen.else();
	    }
	    invalid$data() {
	        const { gen, schemaCode, schemaType, def, it } = this;
	        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
	        function wrong$DataType() {
	            if (schemaType.length) {
	                /* istanbul ignore if */
	                if (!(schemaCode instanceof codegen_1.Name))
	                    throw new Error("ajv implementation error");
	                const st = Array.isArray(schemaType) ? schemaType : [schemaType];
	                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
	            }
	            return codegen_1.nil;
	        }
	        function invalid$DataSchema() {
	            if (def.validateSchema) {
	                const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
	                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;
	            }
	            return codegen_1.nil;
	        }
	    }
	    subschema(appl, valid) {
	        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
	        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
	        (0, subschema_1.extendSubschemaMode)(subschema, appl);
	        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
	        subschemaCode(nextContext, valid);
	        return nextContext;
	    }
	    mergeEvaluated(schemaCxt, toName) {
	        const { it, gen } = this;
	        if (!it.opts.unevaluated)
	            return;
	        if (it.props !== true && schemaCxt.props !== undefined) {
	            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
	        }
	        if (it.items !== true && schemaCxt.items !== undefined) {
	            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
	        }
	    }
	    mergeValidEvaluated(schemaCxt, valid) {
	        const { it, gen } = this;
	        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
	            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
	            return true;
	        }
	    }
	}
	validate.KeywordCxt = KeywordCxt;
	function keywordCode(it, keyword, def, ruleType) {
	    const cxt = new KeywordCxt(it, def, keyword);
	    if ("code" in def) {
	        def.code(cxt, ruleType);
	    }
	    else if (cxt.$data && def.validate) {
	        (0, keyword_1.funcKeywordCode)(cxt, def);
	    }
	    else if ("macro" in def) {
	        (0, keyword_1.macroKeywordCode)(cxt, def);
	    }
	    else if (def.compile || def.validate) {
	        (0, keyword_1.funcKeywordCode)(cxt, def);
	    }
	}
	const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
	const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, { dataLevel, dataNames, dataPathArr }) {
	    let jsonPointer;
	    let data;
	    if ($data === "")
	        return names_1.default.rootData;
	    if ($data[0] === "/") {
	        if (!JSON_POINTER.test($data))
	            throw new Error(`Invalid JSON-pointer: ${$data}`);
	        jsonPointer = $data;
	        data = names_1.default.rootData;
	    }
	    else {
	        const matches = RELATIVE_JSON_POINTER.exec($data);
	        if (!matches)
	            throw new Error(`Invalid JSON-pointer: ${$data}`);
	        const up = +matches[1];
	        jsonPointer = matches[2];
	        if (jsonPointer === "#") {
	            if (up >= dataLevel)
	                throw new Error(errorMsg("property/index", up));
	            return dataPathArr[dataLevel - up];
	        }
	        if (up > dataLevel)
	            throw new Error(errorMsg("data", up));
	        data = dataNames[dataLevel - up];
	        if (!jsonPointer)
	            return data;
	    }
	    let expr = data;
	    const segments = jsonPointer.split("/");
	    for (const segment of segments) {
	        if (segment) {
	            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
	            expr = (0, codegen_1._) `${expr} && ${data}`;
	        }
	    }
	    return expr;
	    function errorMsg(pointerType, up) {
	        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
	    }
	}
	validate.getData = getData;
	
	return validate;
}

var validation_error = {};

var hasRequiredValidation_error;

function requireValidation_error () {
	if (hasRequiredValidation_error) return validation_error;
	hasRequiredValidation_error = 1;
	Object.defineProperty(validation_error, "__esModule", { value: true });
	class ValidationError extends Error {
	    constructor(errors) {
	        super("validation failed");
	        this.errors = errors;
	        this.ajv = this.validation = true;
	    }
	}
	validation_error.default = ValidationError;
	
	return validation_error;
}

var ref_error = {};

var hasRequiredRef_error;

function requireRef_error () {
	if (hasRequiredRef_error) return ref_error;
	hasRequiredRef_error = 1;
	Object.defineProperty(ref_error, "__esModule", { value: true });
	const resolve_1 = requireResolve();
	class MissingRefError extends Error {
	    constructor(resolver, baseId, ref, msg) {
	        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
	        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
	        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
	    }
	}
	ref_error.default = MissingRefError;
	
	return ref_error;
}

var compile = {};

var hasRequiredCompile;

function requireCompile () {
	if (hasRequiredCompile) return compile;
	hasRequiredCompile = 1;
	Object.defineProperty(compile, "__esModule", { value: true });
	compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
	const codegen_1 = requireCodegen();
	const validation_error_1 = requireValidation_error();
	const names_1 = requireNames();
	const resolve_1 = requireResolve();
	const util_1 = requireUtil$1();
	const validate_1 = requireValidate();
	class SchemaEnv {
	    constructor(env) {
	        var _a;
	        this.refs = {};
	        this.dynamicAnchors = {};
	        let schema;
	        if (typeof env.schema == "object")
	            schema = env.schema;
	        this.schema = env.schema;
	        this.schemaId = env.schemaId;
	        this.root = env.root || this;
	        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
	        this.schemaPath = env.schemaPath;
	        this.localRefs = env.localRefs;
	        this.meta = env.meta;
	        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
	        this.refs = {};
	    }
	}
	compile.SchemaEnv = SchemaEnv;
	// let codeSize = 0
	// let nodeCount = 0
	// Compiles schema in SchemaEnv
	function compileSchema(sch) {
	    // TODO refactor - remove compilations
	    const _sch = getCompilingSchema.call(this, sch);
	    if (_sch)
	        return _sch;
	    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails
	    const { es5, lines } = this.opts.code;
	    const { ownProperties } = this.opts;
	    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
	    let _ValidationError;
	    if (sch.$async) {
	        _ValidationError = gen.scopeValue("Error", {
	            ref: validation_error_1.default,
	            code: (0, codegen_1._) `require("ajv/dist/runtime/validation_error").default`,
	        });
	    }
	    const validateName = gen.scopeName("validate");
	    sch.validateName = validateName;
	    const schemaCxt = {
	        gen,
	        allErrors: this.opts.allErrors,
	        data: names_1.default.data,
	        parentData: names_1.default.parentData,
	        parentDataProperty: names_1.default.parentDataProperty,
	        dataNames: [names_1.default.data],
	        dataPathArr: [codegen_1.nil], // TODO can its length be used as dataLevel if nil is removed?
	        dataLevel: 0,
	        dataTypes: [],
	        definedProperties: new Set(),
	        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true
	            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }
	            : { ref: sch.schema }),
	        validateName,
	        ValidationError: _ValidationError,
	        schema: sch.schema,
	        schemaEnv: sch,
	        rootId,
	        baseId: sch.baseId || rootId,
	        schemaPath: codegen_1.nil,
	        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
	        errorPath: (0, codegen_1._) `""`,
	        opts: this.opts,
	        self: this,
	    };
	    let sourceCode;
	    try {
	        this._compilations.add(sch);
	        (0, validate_1.validateFunctionCode)(schemaCxt);
	        gen.optimize(this.opts.code.optimize);
	        // gen.optimize(1)
	        const validateCode = gen.toString();
	        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
	        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
	        if (this.opts.code.process)
	            sourceCode = this.opts.code.process(sourceCode, sch);
	        // console.log("\n\n\n *** \n", sourceCode)
	        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
	        const validate = makeValidate(this, this.scope.get());
	        this.scope.value(validateName, { ref: validate });
	        validate.errors = null;
	        validate.schema = sch.schema;
	        validate.schemaEnv = sch;
	        if (sch.$async)
	            validate.$async = true;
	        if (this.opts.code.source === true) {
	            validate.source = { validateName, validateCode, scopeValues: gen._values };
	        }
	        if (this.opts.unevaluated) {
	            const { props, items } = schemaCxt;
	            validate.evaluated = {
	                props: props instanceof codegen_1.Name ? undefined : props,
	                items: items instanceof codegen_1.Name ? undefined : items,
	                dynamicProps: props instanceof codegen_1.Name,
	                dynamicItems: items instanceof codegen_1.Name,
	            };
	            if (validate.source)
	                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
	        }
	        sch.validate = validate;
	        return sch;
	    }
	    catch (e) {
	        delete sch.validate;
	        delete sch.validateName;
	        if (sourceCode)
	            this.logger.error("Error compiling schema, function code:", sourceCode);
	        // console.log("\n\n\n *** \n", sourceCode, this.opts)
	        throw e;
	    }
	    finally {
	        this._compilations.delete(sch);
	    }
	}
	compile.compileSchema = compileSchema;
	function resolveRef(root, baseId, ref) {
	    var _a;
	    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
	    const schOrFunc = root.refs[ref];
	    if (schOrFunc)
	        return schOrFunc;
	    let _sch = resolve.call(this, root, ref);
	    if (_sch === undefined) {
	        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv
	        const { schemaId } = this.opts;
	        if (schema)
	            _sch = new SchemaEnv({ schema, schemaId, root, baseId });
	    }
	    if (_sch === undefined)
	        return;
	    return (root.refs[ref] = inlineOrCompile.call(this, _sch));
	}
	compile.resolveRef = resolveRef;
	function inlineOrCompile(sch) {
	    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
	        return sch.schema;
	    return sch.validate ? sch : compileSchema.call(this, sch);
	}
	// Index of schema compilation in the currently compiled list
	function getCompilingSchema(schEnv) {
	    for (const sch of this._compilations) {
	        if (sameSchemaEnv(sch, schEnv))
	            return sch;
	    }
	}
	compile.getCompilingSchema = getCompilingSchema;
	function sameSchemaEnv(s1, s2) {
	    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
	}
	// resolve and compile the references ($ref)
	// TODO returns AnySchemaObject (if the schema can be inlined) or validation function
	function resolve(root, // information about the root schema for the current schema
	ref // reference to resolve
	) {
	    let sch;
	    while (typeof (sch = this.refs[ref]) == "string")
	        ref = sch;
	    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
	}
	// Resolve schema, its root and baseId
	function resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
	ref // reference to resolve
	) {
	    const p = this.opts.uriResolver.parse(ref);
	    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
	    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
	    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
	    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
	        return getJsonPointer.call(this, p, root);
	    }
	    const id = (0, resolve_1.normalizeId)(refPath);
	    const schOrRef = this.refs[id] || this.schemas[id];
	    if (typeof schOrRef == "string") {
	        const sch = resolveSchema.call(this, root, schOrRef);
	        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
	            return;
	        return getJsonPointer.call(this, p, sch);
	    }
	    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
	        return;
	    if (!schOrRef.validate)
	        compileSchema.call(this, schOrRef);
	    if (id === (0, resolve_1.normalizeId)(ref)) {
	        const { schema } = schOrRef;
	        const { schemaId } = this.opts;
	        const schId = schema[schemaId];
	        if (schId)
	            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
	        return new SchemaEnv({ schema, schemaId, root, baseId });
	    }
	    return getJsonPointer.call(this, p, schOrRef);
	}
	compile.resolveSchema = resolveSchema;
	const PREVENT_SCOPE_CHANGE = new Set([
	    "properties",
	    "patternProperties",
	    "enum",
	    "dependencies",
	    "definitions",
	]);
	function getJsonPointer(parsedRef, { baseId, schema, root }) {
	    var _a;
	    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
	        return;
	    for (const part of parsedRef.fragment.slice(1).split("/")) {
	        if (typeof schema === "boolean")
	            return;
	        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
	        if (partSchema === undefined)
	            return;
	        schema = partSchema;
	        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
	        const schId = typeof schema === "object" && schema[this.opts.schemaId];
	        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
	            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
	        }
	    }
	    let env;
	    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
	        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
	        env = resolveSchema.call(this, root, $ref);
	    }
	    // even though resolution failed we need to return SchemaEnv to throw exception
	    // so that compileAsync loads missing schema.
	    const { schemaId } = this.opts;
	    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
	    if (env.schema !== env.root.schema)
	        return env;
	    return undefined;
	}
	
	return compile;
}

const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$1 = "object";
const required$1 = ["$data"];
const properties$2 = {"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}};
const additionalProperties$1 = false;
const require$$9 = {
  $id: $id$1,
  description,
  type: type$1,
  required: required$1,
  properties: properties$2,
  additionalProperties: additionalProperties$1,
};

var uri = {};

var fastUri = {exports: {}};

var scopedChars;
var hasRequiredScopedChars;

function requireScopedChars () {
	if (hasRequiredScopedChars) return scopedChars;
	hasRequiredScopedChars = 1;

	const HEX = {
	  0: 0,
	  1: 1,
	  2: 2,
	  3: 3,
	  4: 4,
	  5: 5,
	  6: 6,
	  7: 7,
	  8: 8,
	  9: 9,
	  a: 10,
	  A: 10,
	  b: 11,
	  B: 11,
	  c: 12,
	  C: 12,
	  d: 13,
	  D: 13,
	  e: 14,
	  E: 14,
	  f: 15,
	  F: 15
	};

	scopedChars = {
	  HEX
	};
	return scopedChars;
}

var utils;
var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;

	const { HEX } = requireScopedChars();

	function normalizeIPv4 (host) {
	  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }
	  const matches = host.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || [];
	  const [address] = matches;
	  if (address) {
	    return { host: stripLeadingZeros(address, '.'), isIPV4: true }
	  } else {
	    return { host, isIPV4: false }
	  }
	}

	/**
	 * @param {string[]} input
	 * @param {boolean} [keepZero=false]
	 * @returns {string|undefined}
	 */
	function stringArrayToHexStripped (input, keepZero = false) {
	  let acc = '';
	  let strip = true;
	  for (const c of input) {
	    if (HEX[c] === undefined) return undefined
	    if (c !== '0' && strip === true) strip = false;
	    if (!strip) acc += c;
	  }
	  if (keepZero && acc.length === 0) acc = '0';
	  return acc
	}

	function getIPV6 (input) {
	  let tokenCount = 0;
	  const output = { error: false, address: '', zone: '' };
	  const address = [];
	  const buffer = [];
	  let isZone = false;
	  let endipv6Encountered = false;
	  let endIpv6 = false;

	  function consume () {
	    if (buffer.length) {
	      if (isZone === false) {
	        const hex = stringArrayToHexStripped(buffer);
	        if (hex !== undefined) {
	          address.push(hex);
	        } else {
	          output.error = true;
	          return false
	        }
	      }
	      buffer.length = 0;
	    }
	    return true
	  }

	  for (let i = 0; i < input.length; i++) {
	    const cursor = input[i];
	    if (cursor === '[' || cursor === ']') { continue }
	    if (cursor === ':') {
	      if (endipv6Encountered === true) {
	        endIpv6 = true;
	      }
	      if (!consume()) { break }
	      tokenCount++;
	      address.push(':');
	      if (tokenCount > 7) {
	        // not valid
	        output.error = true;
	        break
	      }
	      if (i - 1 >= 0 && input[i - 1] === ':') {
	        endipv6Encountered = true;
	      }
	      continue
	    } else if (cursor === '%') {
	      if (!consume()) { break }
	      // switch to zone detection
	      isZone = true;
	    } else {
	      buffer.push(cursor);
	      continue
	    }
	  }
	  if (buffer.length) {
	    if (isZone) {
	      output.zone = buffer.join('');
	    } else if (endIpv6) {
	      address.push(buffer.join(''));
	    } else {
	      address.push(stringArrayToHexStripped(buffer));
	    }
	  }
	  output.address = address.join('');
	  return output
	}

	function normalizeIPv6 (host, opts = {}) {
	  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }
	  const ipv6 = getIPV6(host);

	  if (!ipv6.error) {
	    let newHost = ipv6.address;
	    let escapedHost = ipv6.address;
	    if (ipv6.zone) {
	      newHost += '%' + ipv6.zone;
	      escapedHost += '%25' + ipv6.zone;
	    }
	    return { host: newHost, escapedHost, isIPV6: true }
	  } else {
	    return { host, isIPV6: false }
	  }
	}

	function stripLeadingZeros (str, token) {
	  let out = '';
	  let skip = true;
	  const l = str.length;
	  for (let i = 0; i < l; i++) {
	    const c = str[i];
	    if (c === '0' && skip) {
	      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {
	        out += c;
	        skip = false;
	      }
	    } else {
	      if (c === token) {
	        skip = true;
	      } else {
	        skip = false;
	      }
	      out += c;
	    }
	  }
	  return out
	}

	function findToken (str, token) {
	  let ind = 0;
	  for (let i = 0; i < str.length; i++) {
	    if (str[i] === token) ind++;
	  }
	  return ind
	}

	const RDS1 = /^\.\.?\//u;
	const RDS2 = /^\/\.(?:\/|$)/u;
	const RDS3 = /^\/\.\.(?:\/|$)/u;
	const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;

	function removeDotSegments (input) {
	  const output = [];

	  while (input.length) {
	    if (input.match(RDS1)) {
	      input = input.replace(RDS1, '');
	    } else if (input.match(RDS2)) {
	      input = input.replace(RDS2, '/');
	    } else if (input.match(RDS3)) {
	      input = input.replace(RDS3, '/');
	      output.pop();
	    } else if (input === '.' || input === '..') {
	      input = '';
	    } else {
	      const im = input.match(RDS5);
	      if (im) {
	        const s = im[0];
	        input = input.slice(s.length);
	        output.push(s);
	      } else {
	        throw new Error('Unexpected dot segment condition')
	      }
	    }
	  }
	  return output.join('')
	}

	function normalizeComponentEncoding (components, esc) {
	  const func = esc !== true ? escape : unescape;
	  if (components.scheme !== undefined) {
	    components.scheme = func(components.scheme);
	  }
	  if (components.userinfo !== undefined) {
	    components.userinfo = func(components.userinfo);
	  }
	  if (components.host !== undefined) {
	    components.host = func(components.host);
	  }
	  if (components.path !== undefined) {
	    components.path = func(components.path);
	  }
	  if (components.query !== undefined) {
	    components.query = func(components.query);
	  }
	  if (components.fragment !== undefined) {
	    components.fragment = func(components.fragment);
	  }
	  return components
	}

	function recomposeAuthority (components, options) {
	  const uriTokens = [];

	  if (components.userinfo !== undefined) {
	    uriTokens.push(components.userinfo);
	    uriTokens.push('@');
	  }

	  if (components.host !== undefined) {
	    let host = unescape(components.host);
	    const ipV4res = normalizeIPv4(host);

	    if (ipV4res.isIPV4) {
	      host = ipV4res.host;
	    } else {
	      const ipV6res = normalizeIPv6(ipV4res.host, { isIPV4: false });
	      if (ipV6res.isIPV6 === true) {
	        host = `[${ipV6res.escapedHost}]`;
	      } else {
	        host = components.host;
	      }
	    }
	    uriTokens.push(host);
	  }

	  if (typeof components.port === 'number' || typeof components.port === 'string') {
	    uriTokens.push(':');
	    uriTokens.push(String(components.port));
	  }

	  return uriTokens.length ? uriTokens.join('') : undefined
	}
	utils = {
	  recomposeAuthority,
	  normalizeComponentEncoding,
	  removeDotSegments,
	  normalizeIPv4,
	  normalizeIPv6,
	  stringArrayToHexStripped
	};
	return utils;
}

var schemes;
var hasRequiredSchemes;

function requireSchemes () {
	if (hasRequiredSchemes) return schemes;
	hasRequiredSchemes = 1;

	const UUID_REG = /^[\da-f]{8}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{12}$/iu;
	const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;

	function isSecure (wsComponents) {
	  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'
	}

	function httpParse (components) {
	  if (!components.host) {
	    components.error = components.error || 'HTTP URIs must have a host.';
	  }

	  return components
	}

	function httpSerialize (components) {
	  const secure = String(components.scheme).toLowerCase() === 'https';

	  // normalize the default port
	  if (components.port === (secure ? 443 : 80) || components.port === '') {
	    components.port = undefined;
	  }

	  // normalize the empty path
	  if (!components.path) {
	    components.path = '/';
	  }

	  // NOTE: We do not parse query strings for HTTP URIs
	  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,
	  // and not the HTTP spec.

	  return components
	}

	function wsParse (wsComponents) {
	// indicate if the secure flag is set
	  wsComponents.secure = isSecure(wsComponents);

	  // construct resouce name
	  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
	  wsComponents.path = undefined;
	  wsComponents.query = undefined;

	  return wsComponents
	}

	function wsSerialize (wsComponents) {
	// normalize the default port
	  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {
	    wsComponents.port = undefined;
	  }

	  // ensure scheme matches secure flag
	  if (typeof wsComponents.secure === 'boolean') {
	    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws');
	    wsComponents.secure = undefined;
	  }

	  // reconstruct path from resource name
	  if (wsComponents.resourceName) {
	    const [path, query] = wsComponents.resourceName.split('?');
	    wsComponents.path = (path && path !== '/' ? path : undefined);
	    wsComponents.query = query;
	    wsComponents.resourceName = undefined;
	  }

	  // forbid fragment component
	  wsComponents.fragment = undefined;

	  return wsComponents
	}

	function urnParse (urnComponents, options) {
	  if (!urnComponents.path) {
	    urnComponents.error = 'URN can not be parsed';
	    return urnComponents
	  }
	  const matches = urnComponents.path.match(URN_REG);
	  if (matches) {
	    const scheme = options.scheme || urnComponents.scheme || 'urn';
	    urnComponents.nid = matches[1].toLowerCase();
	    urnComponents.nss = matches[2];
	    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
	    const schemeHandler = SCHEMES[urnScheme];
	    urnComponents.path = undefined;

	    if (schemeHandler) {
	      urnComponents = schemeHandler.parse(urnComponents, options);
	    }
	  } else {
	    urnComponents.error = urnComponents.error || 'URN can not be parsed.';
	  }

	  return urnComponents
	}

	function urnSerialize (urnComponents, options) {
	  const scheme = options.scheme || urnComponents.scheme || 'urn';
	  const nid = urnComponents.nid.toLowerCase();
	  const urnScheme = `${scheme}:${options.nid || nid}`;
	  const schemeHandler = SCHEMES[urnScheme];

	  if (schemeHandler) {
	    urnComponents = schemeHandler.serialize(urnComponents, options);
	  }

	  const uriComponents = urnComponents;
	  const nss = urnComponents.nss;
	  uriComponents.path = `${nid || options.nid}:${nss}`;

	  options.skipEscape = true;
	  return uriComponents
	}

	function urnuuidParse (urnComponents, options) {
	  const uuidComponents = urnComponents;
	  uuidComponents.uuid = uuidComponents.nss;
	  uuidComponents.nss = undefined;

	  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
	    uuidComponents.error = uuidComponents.error || 'UUID is not valid.';
	  }

	  return uuidComponents
	}

	function urnuuidSerialize (uuidComponents) {
	  const urnComponents = uuidComponents;
	  // normalize UUID
	  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase();
	  return urnComponents
	}

	const http = {
	  scheme: 'http',
	  domainHost: true,
	  parse: httpParse,
	  serialize: httpSerialize
	};

	const https = {
	  scheme: 'https',
	  domainHost: http.domainHost,
	  parse: httpParse,
	  serialize: httpSerialize
	};

	const ws = {
	  scheme: 'ws',
	  domainHost: true,
	  parse: wsParse,
	  serialize: wsSerialize
	};

	const wss = {
	  scheme: 'wss',
	  domainHost: ws.domainHost,
	  parse: ws.parse,
	  serialize: ws.serialize
	};

	const urn = {
	  scheme: 'urn',
	  parse: urnParse,
	  serialize: urnSerialize,
	  skipNormalize: true
	};

	const urnuuid = {
	  scheme: 'urn:uuid',
	  parse: urnuuidParse,
	  serialize: urnuuidSerialize,
	  skipNormalize: true
	};

	const SCHEMES = {
	  http,
	  https,
	  ws,
	  wss,
	  urn,
	  'urn:uuid': urnuuid
	};

	schemes = SCHEMES;
	return schemes;
}

var hasRequiredFastUri;

function requireFastUri () {
	if (hasRequiredFastUri) return fastUri.exports;
	hasRequiredFastUri = 1;

	const { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = requireUtils();
	const SCHEMES = requireSchemes();

	function normalize (uri, options) {
	  if (typeof uri === 'string') {
	    uri = serialize(parse(uri, options), options);
	  } else if (typeof uri === 'object') {
	    uri = parse(serialize(uri, options), options);
	  }
	  return uri
	}

	function resolve (baseURI, relativeURI, options) {
	  const schemelessOptions = Object.assign({ scheme: 'null' }, options);
	  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
	  return serialize(resolved, { ...schemelessOptions, skipEscape: true })
	}

	function resolveComponents (base, relative, options, skipNormalization) {
	  const target = {};
	  if (!skipNormalization) {
	    base = parse(serialize(base, options), options); // normalize base components
	    relative = parse(serialize(relative, options), options); // normalize relative components
	  }
	  options = options || {};

	  if (!options.tolerant && relative.scheme) {
	    target.scheme = relative.scheme;
	    // target.authority = relative.authority;
	    target.userinfo = relative.userinfo;
	    target.host = relative.host;
	    target.port = relative.port;
	    target.path = removeDotSegments(relative.path || '');
	    target.query = relative.query;
	  } else {
	    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
	      // target.authority = relative.authority;
	      target.userinfo = relative.userinfo;
	      target.host = relative.host;
	      target.port = relative.port;
	      target.path = removeDotSegments(relative.path || '');
	      target.query = relative.query;
	    } else {
	      if (!relative.path) {
	        target.path = base.path;
	        if (relative.query !== undefined) {
	          target.query = relative.query;
	        } else {
	          target.query = base.query;
	        }
	      } else {
	        if (relative.path.charAt(0) === '/') {
	          target.path = removeDotSegments(relative.path);
	        } else {
	          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
	            target.path = '/' + relative.path;
	          } else if (!base.path) {
	            target.path = relative.path;
	          } else {
	            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path;
	          }
	          target.path = removeDotSegments(target.path);
	        }
	        target.query = relative.query;
	      }
	      // target.authority = base.authority;
	      target.userinfo = base.userinfo;
	      target.host = base.host;
	      target.port = base.port;
	    }
	    target.scheme = base.scheme;
	  }

	  target.fragment = relative.fragment;

	  return target
	}

	function equal (uriA, uriB, options) {
	  if (typeof uriA === 'string') {
	    uriA = unescape(uriA);
	    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
	  } else if (typeof uriA === 'object') {
	    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
	  }

	  if (typeof uriB === 'string') {
	    uriB = unescape(uriB);
	    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
	  } else if (typeof uriB === 'object') {
	    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
	  }

	  return uriA.toLowerCase() === uriB.toLowerCase()
	}

	function serialize (cmpts, opts) {
	  const components = {
	    host: cmpts.host,
	    scheme: cmpts.scheme,
	    userinfo: cmpts.userinfo,
	    port: cmpts.port,
	    path: cmpts.path,
	    query: cmpts.query,
	    nid: cmpts.nid,
	    nss: cmpts.nss,
	    uuid: cmpts.uuid,
	    fragment: cmpts.fragment,
	    reference: cmpts.reference,
	    resourceName: cmpts.resourceName,
	    secure: cmpts.secure,
	    error: ''
	  };
	  const options = Object.assign({}, opts);
	  const uriTokens = [];

	  // find scheme handler
	  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()];

	  // perform scheme specific serialization
	  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);

	  if (components.path !== undefined) {
	    if (!options.skipEscape) {
	      components.path = escape(components.path);

	      if (components.scheme !== undefined) {
	        components.path = components.path.split('%3A').join(':');
	      }
	    } else {
	      components.path = unescape(components.path);
	    }
	  }

	  if (options.reference !== 'suffix' && components.scheme) {
	    uriTokens.push(components.scheme, ':');
	  }

	  const authority = recomposeAuthority(components, options);
	  if (authority !== undefined) {
	    if (options.reference !== 'suffix') {
	      uriTokens.push('//');
	    }

	    uriTokens.push(authority);

	    if (components.path && components.path.charAt(0) !== '/') {
	      uriTokens.push('/');
	    }
	  }
	  if (components.path !== undefined) {
	    let s = components.path;

	    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
	      s = removeDotSegments(s);
	    }

	    if (authority === undefined) {
	      s = s.replace(/^\/\//u, '/%2F'); // don't allow the path to start with "//"
	    }

	    uriTokens.push(s);
	  }

	  if (components.query !== undefined) {
	    uriTokens.push('?', components.query);
	  }

	  if (components.fragment !== undefined) {
	    uriTokens.push('#', components.fragment);
	  }
	  return uriTokens.join('')
	}

	const hexLookUp = Array.from({ length: 127 }, (v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));

	function nonSimpleDomain (value) {
	  let code = 0;
	  for (let i = 0, len = value.length; i < len; ++i) {
	    code = value.charCodeAt(i);
	    if (code > 126 || hexLookUp[code]) {
	      return true
	    }
	  }
	  return false
	}

	const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;

	function parse (uri, opts) {
	  const options = Object.assign({}, opts);
	  const parsed = {
	    scheme: undefined,
	    userinfo: undefined,
	    host: '',
	    port: undefined,
	    path: '',
	    query: undefined,
	    fragment: undefined
	  };
	  const gotEncoding = uri.indexOf('%') !== -1;
	  let isIP = false;
	  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri;

	  const matches = uri.match(URI_PARSE);

	  if (matches) {
	    // store each component
	    parsed.scheme = matches[1];
	    parsed.userinfo = matches[3];
	    parsed.host = matches[4];
	    parsed.port = parseInt(matches[5], 10);
	    parsed.path = matches[6] || '';
	    parsed.query = matches[7];
	    parsed.fragment = matches[8];

	    // fix port number
	    if (isNaN(parsed.port)) {
	      parsed.port = matches[5];
	    }
	    if (parsed.host) {
	      const ipv4result = normalizeIPv4(parsed.host);
	      if (ipv4result.isIPV4 === false) {
	        const ipv6result = normalizeIPv6(ipv4result.host, { isIPV4: false });
	        parsed.host = ipv6result.host.toLowerCase();
	        isIP = ipv6result.isIPV6;
	      } else {
	        parsed.host = ipv4result.host;
	        isIP = true;
	      }
	    }
	    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && !parsed.path && parsed.query === undefined) {
	      parsed.reference = 'same-document';
	    } else if (parsed.scheme === undefined) {
	      parsed.reference = 'relative';
	    } else if (parsed.fragment === undefined) {
	      parsed.reference = 'absolute';
	    } else {
	      parsed.reference = 'uri';
	    }

	    // check for reference errors
	    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {
	      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.';
	    }

	    // find scheme handler
	    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()];

	    // check if scheme can't handle IRIs
	    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
	      // if host component is a domain name
	      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {
	        // convert Unicode IDN -> ASCII IDN
	        try {
	          parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
	        } catch (e) {
	          parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
	        }
	      }
	      // convert IRI -> URI
	    }

	    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {
	      if (gotEncoding && parsed.scheme !== undefined) {
	        parsed.scheme = unescape(parsed.scheme);
	      }
	      if (gotEncoding && parsed.host !== undefined) {
	        parsed.host = unescape(parsed.host);
	      }
	      if (parsed.path !== undefined && parsed.path.length) {
	        parsed.path = escape(unescape(parsed.path));
	      }
	      if (parsed.fragment !== undefined && parsed.fragment.length) {
	        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
	      }
	    }

	    // perform scheme specific parsing
	    if (schemeHandler && schemeHandler.parse) {
	      schemeHandler.parse(parsed, options);
	    }
	  } else {
	    parsed.error = parsed.error || 'URI can not be parsed.';
	  }
	  return parsed
	}

	const fastUri$1 = {
	  SCHEMES,
	  normalize,
	  resolve,
	  resolveComponents,
	  equal,
	  serialize,
	  parse
	};

	fastUri.exports = fastUri$1;
	fastUri.exports.default = fastUri$1;
	fastUri.exports.fastUri = fastUri$1;
	return fastUri.exports;
}

var hasRequiredUri;

function requireUri () {
	if (hasRequiredUri) return uri;
	hasRequiredUri = 1;
	Object.defineProperty(uri, "__esModule", { value: true });
	const uri$1 = requireFastUri();
	uri$1.code = 'require("ajv/dist/runtime/uri").default';
	uri.default = uri$1;
	
	return uri;
}

var hasRequiredCore$1;

function requireCore$1 () {
	if (hasRequiredCore$1) return core$1;
	hasRequiredCore$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
		var validate_1 = requireValidate();
		Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
		var codegen_1 = requireCodegen();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
		Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
		const validation_error_1 = requireValidation_error();
		const ref_error_1 = requireRef_error();
		const rules_1 = requireRules();
		const compile_1 = requireCompile();
		const codegen_2 = requireCodegen();
		const resolve_1 = requireResolve();
		const dataType_1 = requireDataType();
		const util_1 = requireUtil$1();
		const $dataRefSchema = require$$9;
		const uri_1 = requireUri();
		const defaultRegExp = (str, flags) => new RegExp(str, flags);
		defaultRegExp.code = "new RegExp";
		const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
		const EXT_SCOPE_NAMES = new Set([
		    "validate",
		    "serialize",
		    "parse",
		    "wrapper",
		    "root",
		    "schema",
		    "keyword",
		    "pattern",
		    "formats",
		    "validate$data",
		    "func",
		    "obj",
		    "Error",
		]);
		const removedOptions = {
		    errorDataPath: "",
		    format: "`validateFormats: false` can be used instead.",
		    nullable: '"nullable" keyword is supported by default.',
		    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
		    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
		    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
		    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
		    sourceCode: "Use option `code: {source: true}`",
		    strictDefaults: "It is default now, see option `strict`.",
		    strictKeywords: "It is default now, see option `strict`.",
		    uniqueItems: '"uniqueItems" keyword is always validated.',
		    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
		    cache: "Map is used as cache, schema object as key.",
		    serialize: "Map is used as cache, schema object as key.",
		    ajvErrors: "It is default now.",
		};
		const deprecatedOptions = {
		    ignoreKeywordsWithRef: "",
		    jsPropertySyntax: "",
		    unicode: '"minLength"/"maxLength" account for unicode characters by default.',
		};
		const MAX_EXPRESSION = 200;
		// eslint-disable-next-line complexity
		function requiredOptions(o) {
		    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
		    const s = o.strict;
		    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
		    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
		    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
		    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
		    return {
		        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
		        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
		        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
		        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
		        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
		        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
		        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
		        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
		        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
		        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
		        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
		        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
		        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
		        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
		        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
		        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
		        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
		        uriResolver: uriResolver,
		    };
		}
		class Ajv {
		    constructor(opts = {}) {
		        this.schemas = {};
		        this.refs = {};
		        this.formats = {};
		        this._compilations = new Set();
		        this._loading = {};
		        this._cache = new Map();
		        opts = this.opts = { ...opts, ...requiredOptions(opts) };
		        const { es5, lines } = this.opts.code;
		        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
		        this.logger = getLogger(opts.logger);
		        const formatOpt = opts.validateFormats;
		        opts.validateFormats = false;
		        this.RULES = (0, rules_1.getRules)();
		        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
		        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
		        this._metaOpts = getMetaSchemaOptions.call(this);
		        if (opts.formats)
		            addInitialFormats.call(this);
		        this._addVocabularies();
		        this._addDefaultMetaSchema();
		        if (opts.keywords)
		            addInitialKeywords.call(this, opts.keywords);
		        if (typeof opts.meta == "object")
		            this.addMetaSchema(opts.meta);
		        addInitialSchemas.call(this);
		        opts.validateFormats = formatOpt;
		    }
		    _addVocabularies() {
		        this.addKeyword("$async");
		    }
		    _addDefaultMetaSchema() {
		        const { $data, meta, schemaId } = this.opts;
		        let _dataRefSchema = $dataRefSchema;
		        if (schemaId === "id") {
		            _dataRefSchema = { ...$dataRefSchema };
		            _dataRefSchema.id = _dataRefSchema.$id;
		            delete _dataRefSchema.$id;
		        }
		        if (meta && $data)
		            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
		    }
		    defaultMeta() {
		        const { meta, schemaId } = this.opts;
		        return (this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined);
		    }
		    validate(schemaKeyRef, // key, ref or schema object
		    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
		    data // to be validated
		    ) {
		        let v;
		        if (typeof schemaKeyRef == "string") {
		            v = this.getSchema(schemaKeyRef);
		            if (!v)
		                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
		        }
		        else {
		            v = this.compile(schemaKeyRef);
		        }
		        const valid = v(data);
		        if (!("$async" in v))
		            this.errors = v.errors;
		        return valid;
		    }
		    compile(schema, _meta) {
		        const sch = this._addSchema(schema, _meta);
		        return (sch.validate || this._compileSchemaEnv(sch));
		    }
		    compileAsync(schema, meta) {
		        if (typeof this.opts.loadSchema != "function") {
		            throw new Error("options.loadSchema should be a function");
		        }
		        const { loadSchema } = this.opts;
		        return runCompileAsync.call(this, schema, meta);
		        async function runCompileAsync(_schema, _meta) {
		            await loadMetaSchema.call(this, _schema.$schema);
		            const sch = this._addSchema(_schema, _meta);
		            return sch.validate || _compileAsync.call(this, sch);
		        }
		        async function loadMetaSchema($ref) {
		            if ($ref && !this.getSchema($ref)) {
		                await runCompileAsync.call(this, { $ref }, true);
		            }
		        }
		        async function _compileAsync(sch) {
		            try {
		                return this._compileSchemaEnv(sch);
		            }
		            catch (e) {
		                if (!(e instanceof ref_error_1.default))
		                    throw e;
		                checkLoaded.call(this, e);
		                await loadMissingSchema.call(this, e.missingSchema);
		                return _compileAsync.call(this, sch);
		            }
		        }
		        function checkLoaded({ missingSchema: ref, missingRef }) {
		            if (this.refs[ref]) {
		                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
		            }
		        }
		        async function loadMissingSchema(ref) {
		            const _schema = await _loadSchema.call(this, ref);
		            if (!this.refs[ref])
		                await loadMetaSchema.call(this, _schema.$schema);
		            if (!this.refs[ref])
		                this.addSchema(_schema, ref, meta);
		        }
		        async function _loadSchema(ref) {
		            const p = this._loading[ref];
		            if (p)
		                return p;
		            try {
		                return await (this._loading[ref] = loadSchema(ref));
		            }
		            finally {
		                delete this._loading[ref];
		            }
		        }
		    }
		    // Adds schema to the instance
		    addSchema(schema, // If array is passed, `key` will be ignored
		    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
		    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
		    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
		    ) {
		        if (Array.isArray(schema)) {
		            for (const sch of schema)
		                this.addSchema(sch, undefined, _meta, _validateSchema);
		            return this;
		        }
		        let id;
		        if (typeof schema === "object") {
		            const { schemaId } = this.opts;
		            id = schema[schemaId];
		            if (id !== undefined && typeof id != "string") {
		                throw new Error(`schema ${schemaId} must be string`);
		            }
		        }
		        key = (0, resolve_1.normalizeId)(key || id);
		        this._checkUnique(key);
		        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
		        return this;
		    }
		    // Add schema that will be used to validate other schemas
		    // options in META_IGNORE_OPTIONS are alway set to false
		    addMetaSchema(schema, key, // schema key
		    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
		    ) {
		        this.addSchema(schema, key, true, _validateSchema);
		        return this;
		    }
		    //  Validate schema against its meta-schema
		    validateSchema(schema, throwOrLogError) {
		        if (typeof schema == "boolean")
		            return true;
		        let $schema;
		        $schema = schema.$schema;
		        if ($schema !== undefined && typeof $schema != "string") {
		            throw new Error("$schema must be a string");
		        }
		        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
		        if (!$schema) {
		            this.logger.warn("meta-schema not available");
		            this.errors = null;
		            return true;
		        }
		        const valid = this.validate($schema, schema);
		        if (!valid && throwOrLogError) {
		            const message = "schema is invalid: " + this.errorsText();
		            if (this.opts.validateSchema === "log")
		                this.logger.error(message);
		            else
		                throw new Error(message);
		        }
		        return valid;
		    }
		    // Get compiled schema by `key` or `ref`.
		    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
		    getSchema(keyRef) {
		        let sch;
		        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
		            keyRef = sch;
		        if (sch === undefined) {
		            const { schemaId } = this.opts;
		            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
		            sch = compile_1.resolveSchema.call(this, root, keyRef);
		            if (!sch)
		                return;
		            this.refs[keyRef] = sch;
		        }
		        return (sch.validate || this._compileSchemaEnv(sch));
		    }
		    // Remove cached schema(s).
		    // If no parameter is passed all schemas but meta-schemas are removed.
		    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
		    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
		    removeSchema(schemaKeyRef) {
		        if (schemaKeyRef instanceof RegExp) {
		            this._removeAllSchemas(this.schemas, schemaKeyRef);
		            this._removeAllSchemas(this.refs, schemaKeyRef);
		            return this;
		        }
		        switch (typeof schemaKeyRef) {
		            case "undefined":
		                this._removeAllSchemas(this.schemas);
		                this._removeAllSchemas(this.refs);
		                this._cache.clear();
		                return this;
		            case "string": {
		                const sch = getSchEnv.call(this, schemaKeyRef);
		                if (typeof sch == "object")
		                    this._cache.delete(sch.schema);
		                delete this.schemas[schemaKeyRef];
		                delete this.refs[schemaKeyRef];
		                return this;
		            }
		            case "object": {
		                const cacheKey = schemaKeyRef;
		                this._cache.delete(cacheKey);
		                let id = schemaKeyRef[this.opts.schemaId];
		                if (id) {
		                    id = (0, resolve_1.normalizeId)(id);
		                    delete this.schemas[id];
		                    delete this.refs[id];
		                }
		                return this;
		            }
		            default:
		                throw new Error("ajv.removeSchema: invalid parameter");
		        }
		    }
		    // add "vocabulary" - a collection of keywords
		    addVocabulary(definitions) {
		        for (const def of definitions)
		            this.addKeyword(def);
		        return this;
		    }
		    addKeyword(kwdOrDef, def // deprecated
		    ) {
		        let keyword;
		        if (typeof kwdOrDef == "string") {
		            keyword = kwdOrDef;
		            if (typeof def == "object") {
		                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
		                def.keyword = keyword;
		            }
		        }
		        else if (typeof kwdOrDef == "object" && def === undefined) {
		            def = kwdOrDef;
		            keyword = def.keyword;
		            if (Array.isArray(keyword) && !keyword.length) {
		                throw new Error("addKeywords: keyword must be string or non-empty array");
		            }
		        }
		        else {
		            throw new Error("invalid addKeywords parameters");
		        }
		        checkKeyword.call(this, keyword, def);
		        if (!def) {
		            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
		            return this;
		        }
		        keywordMetaschema.call(this, def);
		        const definition = {
		            ...def,
		            type: (0, dataType_1.getJSONTypes)(def.type),
		            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),
		        };
		        (0, util_1.eachItem)(keyword, definition.type.length === 0
		            ? (k) => addRule.call(this, k, definition)
		            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
		        return this;
		    }
		    getKeyword(keyword) {
		        const rule = this.RULES.all[keyword];
		        return typeof rule == "object" ? rule.definition : !!rule;
		    }
		    // Remove keyword
		    removeKeyword(keyword) {
		        // TODO return type should be Ajv
		        const { RULES } = this;
		        delete RULES.keywords[keyword];
		        delete RULES.all[keyword];
		        for (const group of RULES.rules) {
		            const i = group.rules.findIndex((rule) => rule.keyword === keyword);
		            if (i >= 0)
		                group.rules.splice(i, 1);
		        }
		        return this;
		    }
		    // Add format
		    addFormat(name, format) {
		        if (typeof format == "string")
		            format = new RegExp(format);
		        this.formats[name] = format;
		        return this;
		    }
		    errorsText(errors = this.errors, // optional array of validation errors
		    { separator = ", ", dataVar = "data" } = {} // optional options with properties `separator` and `dataVar`
		    ) {
		        if (!errors || errors.length === 0)
		            return "No errors";
		        return errors
		            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
		            .reduce((text, msg) => text + separator + msg);
		    }
		    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
		        const rules = this.RULES.all;
		        metaSchema = JSON.parse(JSON.stringify(metaSchema));
		        for (const jsonPointer of keywordsJsonPointers) {
		            const segments = jsonPointer.split("/").slice(1); // first segment is an empty string
		            let keywords = metaSchema;
		            for (const seg of segments)
		                keywords = keywords[seg];
		            for (const key in rules) {
		                const rule = rules[key];
		                if (typeof rule != "object")
		                    continue;
		                const { $data } = rule.definition;
		                const schema = keywords[key];
		                if ($data && schema)
		                    keywords[key] = schemaOrData(schema);
		            }
		        }
		        return metaSchema;
		    }
		    _removeAllSchemas(schemas, regex) {
		        for (const keyRef in schemas) {
		            const sch = schemas[keyRef];
		            if (!regex || regex.test(keyRef)) {
		                if (typeof sch == "string") {
		                    delete schemas[keyRef];
		                }
		                else if (sch && !sch.meta) {
		                    this._cache.delete(sch.schema);
		                    delete schemas[keyRef];
		                }
		            }
		        }
		    }
		    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
		        let id;
		        const { schemaId } = this.opts;
		        if (typeof schema == "object") {
		            id = schema[schemaId];
		        }
		        else {
		            if (this.opts.jtd)
		                throw new Error("schema must be object");
		            else if (typeof schema != "boolean")
		                throw new Error("schema must be object or boolean");
		        }
		        let sch = this._cache.get(schema);
		        if (sch !== undefined)
		            return sch;
		        baseId = (0, resolve_1.normalizeId)(id || baseId);
		        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
		        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
		        this._cache.set(sch.schema, sch);
		        if (addSchema && !baseId.startsWith("#")) {
		            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
		            if (baseId)
		                this._checkUnique(baseId);
		            this.refs[baseId] = sch;
		        }
		        if (validateSchema)
		            this.validateSchema(schema, true);
		        return sch;
		    }
		    _checkUnique(id) {
		        if (this.schemas[id] || this.refs[id]) {
		            throw new Error(`schema with key or id "${id}" already exists`);
		        }
		    }
		    _compileSchemaEnv(sch) {
		        if (sch.meta)
		            this._compileMetaSchema(sch);
		        else
		            compile_1.compileSchema.call(this, sch);
		        /* istanbul ignore if */
		        if (!sch.validate)
		            throw new Error("ajv implementation error");
		        return sch.validate;
		    }
		    _compileMetaSchema(sch) {
		        const currentOpts = this.opts;
		        this.opts = this._metaOpts;
		        try {
		            compile_1.compileSchema.call(this, sch);
		        }
		        finally {
		            this.opts = currentOpts;
		        }
		    }
		}
		Ajv.ValidationError = validation_error_1.default;
		Ajv.MissingRefError = ref_error_1.default;
		exports.default = Ajv;
		function checkOptions(checkOpts, options, msg, log = "error") {
		    for (const key in checkOpts) {
		        const opt = key;
		        if (opt in options)
		            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
		    }
		}
		function getSchEnv(keyRef) {
		    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line
		    return this.schemas[keyRef] || this.refs[keyRef];
		}
		function addInitialSchemas() {
		    const optsSchemas = this.opts.schemas;
		    if (!optsSchemas)
		        return;
		    if (Array.isArray(optsSchemas))
		        this.addSchema(optsSchemas);
		    else
		        for (const key in optsSchemas)
		            this.addSchema(optsSchemas[key], key);
		}
		function addInitialFormats() {
		    for (const name in this.opts.formats) {
		        const format = this.opts.formats[name];
		        if (format)
		            this.addFormat(name, format);
		    }
		}
		function addInitialKeywords(defs) {
		    if (Array.isArray(defs)) {
		        this.addVocabulary(defs);
		        return;
		    }
		    this.logger.warn("keywords option as map is deprecated, pass array");
		    for (const keyword in defs) {
		        const def = defs[keyword];
		        if (!def.keyword)
		            def.keyword = keyword;
		        this.addKeyword(def);
		    }
		}
		function getMetaSchemaOptions() {
		    const metaOpts = { ...this.opts };
		    for (const opt of META_IGNORE_OPTIONS)
		        delete metaOpts[opt];
		    return metaOpts;
		}
		const noLogs = { log() { }, warn() { }, error() { } };
		function getLogger(logger) {
		    if (logger === false)
		        return noLogs;
		    if (logger === undefined)
		        return console;
		    if (logger.log && logger.warn && logger.error)
		        return logger;
		    throw new Error("logger must implement log, warn and error methods");
		}
		const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
		function checkKeyword(keyword, def) {
		    const { RULES } = this;
		    (0, util_1.eachItem)(keyword, (kwd) => {
		        if (RULES.keywords[kwd])
		            throw new Error(`Keyword ${kwd} is already defined`);
		        if (!KEYWORD_NAME.test(kwd))
		            throw new Error(`Keyword ${kwd} has invalid name`);
		    });
		    if (!def)
		        return;
		    if (def.$data && !("code" in def || "validate" in def)) {
		        throw new Error('$data keyword must have "code" or "validate" function');
		    }
		}
		function addRule(keyword, definition, dataType) {
		    var _a;
		    const post = definition === null || definition === void 0 ? void 0 : definition.post;
		    if (dataType && post)
		        throw new Error('keyword with "post" flag cannot have "type"');
		    const { RULES } = this;
		    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
		    if (!ruleGroup) {
		        ruleGroup = { type: dataType, rules: [] };
		        RULES.rules.push(ruleGroup);
		    }
		    RULES.keywords[keyword] = true;
		    if (!definition)
		        return;
		    const rule = {
		        keyword,
		        definition: {
		            ...definition,
		            type: (0, dataType_1.getJSONTypes)(definition.type),
		            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),
		        },
		    };
		    if (definition.before)
		        addBeforeRule.call(this, ruleGroup, rule, definition.before);
		    else
		        ruleGroup.rules.push(rule);
		    RULES.all[keyword] = rule;
		    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
		}
		function addBeforeRule(ruleGroup, rule, before) {
		    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
		    if (i >= 0) {
		        ruleGroup.rules.splice(i, 0, rule);
		    }
		    else {
		        ruleGroup.rules.push(rule);
		        this.logger.warn(`rule ${before} is not defined`);
		    }
		}
		function keywordMetaschema(def) {
		    let { metaSchema } = def;
		    if (metaSchema === undefined)
		        return;
		    if (def.$data && this.opts.$data)
		        metaSchema = schemaOrData(metaSchema);
		    def.validateSchema = this.compile(metaSchema, true);
		}
		const $dataRef = {
		    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
		};
		function schemaOrData(schema) {
		    return { anyOf: [schema, $dataRef] };
		}
		
	} (core$1));
	return core$1;
}

var draft7 = {};

var core = {};

var id = {};

var hasRequiredId;

function requireId () {
	if (hasRequiredId) return id;
	hasRequiredId = 1;
	Object.defineProperty(id, "__esModule", { value: true });
	const def = {
	    keyword: "id",
	    code() {
	        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
	    },
	};
	id.default = def;
	
	return id;
}

var ref = {};

var hasRequiredRef;

function requireRef () {
	if (hasRequiredRef) return ref;
	hasRequiredRef = 1;
	Object.defineProperty(ref, "__esModule", { value: true });
	ref.callRef = ref.getValidate = void 0;
	const ref_error_1 = requireRef_error();
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const compile_1 = requireCompile();
	const util_1 = requireUtil$1();
	const def = {
	    keyword: "$ref",
	    schemaType: "string",
	    code(cxt) {
	        const { gen, schema: $ref, it } = cxt;
	        const { baseId, schemaEnv: env, validateName, opts, self } = it;
	        const { root } = env;
	        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
	            return callRootRef();
	        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
	        if (schOrEnv === undefined)
	            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
	        if (schOrEnv instanceof compile_1.SchemaEnv)
	            return callValidate(schOrEnv);
	        return inlineRefSchema(schOrEnv);
	        function callRootRef() {
	            if (env === root)
	                return callRef(cxt, validateName, env, env.$async);
	            const rootName = gen.scopeValue("root", { ref: root });
	            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);
	        }
	        function callValidate(sch) {
	            const v = getValidate(cxt, sch);
	            callRef(cxt, v, sch, sch.$async);
	        }
	        function inlineRefSchema(sch) {
	            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
	            const valid = gen.name("valid");
	            const schCxt = cxt.subschema({
	                schema: sch,
	                dataTypes: [],
	                schemaPath: codegen_1.nil,
	                topSchemaRef: schName,
	                errSchemaPath: $ref,
	            }, valid);
	            cxt.mergeEvaluated(schCxt);
	            cxt.ok(valid);
	        }
	    },
	};
	function getValidate(cxt, sch) {
	    const { gen } = cxt;
	    return sch.validate
	        ? gen.scopeValue("validate", { ref: sch.validate })
	        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch })}.validate`;
	}
	ref.getValidate = getValidate;
	function callRef(cxt, v, sch, $async) {
	    const { gen, it } = cxt;
	    const { allErrors, schemaEnv: env, opts } = it;
	    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
	    if ($async)
	        callAsyncRef();
	    else
	        callSyncRef();
	    function callAsyncRef() {
	        if (!env.$async)
	            throw new Error("async schema referenced by sync schema");
	        const valid = gen.let("valid");
	        gen.try(() => {
	            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
	            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
	            if (!allErrors)
	                gen.assign(valid, true);
	        }, (e) => {
	            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
	            addErrorsFrom(e);
	            if (!allErrors)
	                gen.assign(valid, false);
	        });
	        cxt.ok(valid);
	    }
	    function callSyncRef() {
	        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
	    }
	    function addErrorsFrom(source) {
	        const errs = (0, codegen_1._) `${source}.errors`;
	        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged
	        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
	    }
	    function addEvaluatedFrom(source) {
	        var _a;
	        if (!it.opts.unevaluated)
	            return;
	        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
	        // TODO refactor
	        if (it.props !== true) {
	            if (schEvaluated && !schEvaluated.dynamicProps) {
	                if (schEvaluated.props !== undefined) {
	                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
	                }
	            }
	            else {
	                const props = gen.var("props", (0, codegen_1._) `${source}.evaluated.props`);
	                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
	            }
	        }
	        if (it.items !== true) {
	            if (schEvaluated && !schEvaluated.dynamicItems) {
	                if (schEvaluated.items !== undefined) {
	                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
	                }
	            }
	            else {
	                const items = gen.var("items", (0, codegen_1._) `${source}.evaluated.items`);
	                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
	            }
	        }
	    }
	}
	ref.callRef = callRef;
	ref.default = def;
	
	return ref;
}

var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core;
	hasRequiredCore = 1;
	Object.defineProperty(core, "__esModule", { value: true });
	const id_1 = requireId();
	const ref_1 = requireRef();
	const core$1 = [
	    "$schema",
	    "$id",
	    "$defs",
	    "$vocabulary",
	    { keyword: "$comment" },
	    "definitions",
	    id_1.default,
	    ref_1.default,
	];
	core.default = core$1;
	
	return core;
}

var validation = {};

var limitNumber = {};

var hasRequiredLimitNumber;

function requireLimitNumber () {
	if (hasRequiredLimitNumber) return limitNumber;
	hasRequiredLimitNumber = 1;
	Object.defineProperty(limitNumber, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const ops = codegen_1.operators;
	const KWDs = {
	    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
	    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
	    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
	    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
	};
	const error = {
	    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,
	    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: Object.keys(KWDs),
	    type: "number",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode } = cxt;
	        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
	    },
	};
	limitNumber.default = def;
	
	return limitNumber;
}

var multipleOf = {};

var hasRequiredMultipleOf;

function requireMultipleOf () {
	if (hasRequiredMultipleOf) return multipleOf;
	hasRequiredMultipleOf = 1;
	Object.defineProperty(multipleOf, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,
	    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,
	};
	const def = {
	    keyword: "multipleOf",
	    type: "number",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, schemaCode, it } = cxt;
	        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
	        const prec = it.opts.multipleOfPrecision;
	        const res = gen.let("res");
	        const invalid = prec
	            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
	            : (0, codegen_1._) `${res} !== parseInt(${res})`;
	        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
	    },
	};
	multipleOf.default = def;
	
	return multipleOf;
}

var limitLength = {};

var ucs2length = {};

var hasRequiredUcs2length;

function requireUcs2length () {
	if (hasRequiredUcs2length) return ucs2length;
	hasRequiredUcs2length = 1;
	Object.defineProperty(ucs2length, "__esModule", { value: true });
	// https://mathiasbynens.be/notes/javascript-encoding
	// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
	function ucs2length$1(str) {
	    const len = str.length;
	    let length = 0;
	    let pos = 0;
	    let value;
	    while (pos < len) {
	        length++;
	        value = str.charCodeAt(pos++);
	        if (value >= 0xd800 && value <= 0xdbff && pos < len) {
	            // high surrogate, and there is a next character
	            value = str.charCodeAt(pos);
	            if ((value & 0xfc00) === 0xdc00)
	                pos++; // low surrogate
	        }
	    }
	    return length;
	}
	ucs2length.default = ucs2length$1;
	ucs2length$1.code = 'require("ajv/dist/runtime/ucs2length").default';
	
	return ucs2length;
}

var hasRequiredLimitLength;

function requireLimitLength () {
	if (hasRequiredLimitLength) return limitLength;
	hasRequiredLimitLength = 1;
	Object.defineProperty(limitLength, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const ucs2length_1 = requireUcs2length();
	const error = {
	    message({ keyword, schemaCode }) {
	        const comp = keyword === "maxLength" ? "more" : "fewer";
	        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;
	    },
	    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: ["maxLength", "minLength"],
	    type: "string",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode, it } = cxt;
	        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
	        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
	        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);
	    },
	};
	limitLength.default = def;
	
	return limitLength;
}

var pattern$1 = {};

var hasRequiredPattern;

function requirePattern () {
	if (hasRequiredPattern) return pattern$1;
	hasRequiredPattern = 1;
	Object.defineProperty(pattern$1, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const error = {
	    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern "${schemaCode}"`,
	    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,
	};
	const def = {
	    keyword: "pattern",
	    type: "string",
	    schemaType: "string",
	    $data: true,
	    error,
	    code(cxt) {
	        const { data, $data, schema, schemaCode, it } = cxt;
	        // TODO regexp should be wrapped in try/catchs
	        const u = it.opts.unicodeRegExp ? "u" : "";
	        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
	        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);
	    },
	};
	pattern$1.default = def;
	
	return pattern$1;
}

var limitProperties = {};

var hasRequiredLimitProperties;

function requireLimitProperties () {
	if (hasRequiredLimitProperties) return limitProperties;
	hasRequiredLimitProperties = 1;
	Object.defineProperty(limitProperties, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message({ keyword, schemaCode }) {
	        const comp = keyword === "maxProperties" ? "more" : "fewer";
	        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} properties`;
	    },
	    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: ["maxProperties", "minProperties"],
	    type: "object",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode } = cxt;
	        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
	        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);
	    },
	};
	limitProperties.default = def;
	
	return limitProperties;
}

var required = {};

var hasRequiredRequired;

function requireRequired () {
	if (hasRequiredRequired) return required;
	hasRequiredRequired = 1;
	Object.defineProperty(required, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,
	    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,
	};
	const def = {
	    keyword: "required",
	    type: "object",
	    schemaType: "array",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, schema, schemaCode, data, $data, it } = cxt;
	        const { opts } = it;
	        if (!$data && schema.length === 0)
	            return;
	        const useLoop = schema.length >= opts.loopRequired;
	        if (it.allErrors)
	            allErrorsMode();
	        else
	            exitOnErrorMode();
	        if (opts.strictRequired) {
	            const props = cxt.parentSchema.properties;
	            const { definedProperties } = cxt.it;
	            for (const requiredKey of schema) {
	                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
	                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
	                    const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
	                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
	                }
	            }
	        }
	        function allErrorsMode() {
	            if (useLoop || $data) {
	                cxt.block$data(codegen_1.nil, loopAllRequired);
	            }
	            else {
	                for (const prop of schema) {
	                    (0, code_1.checkReportMissingProp)(cxt, prop);
	                }
	            }
	        }
	        function exitOnErrorMode() {
	            const missing = gen.let("missing");
	            if (useLoop || $data) {
	                const valid = gen.let("valid", true);
	                cxt.block$data(valid, () => loopUntilMissing(missing, valid));
	                cxt.ok(valid);
	            }
	            else {
	                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
	                (0, code_1.reportMissingProp)(cxt, missing);
	                gen.else();
	            }
	        }
	        function loopAllRequired() {
	            gen.forOf("prop", schemaCode, (prop) => {
	                cxt.setParams({ missingProperty: prop });
	                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
	            });
	        }
	        function loopUntilMissing(missing, valid) {
	            cxt.setParams({ missingProperty: missing });
	            gen.forOf(missing, schemaCode, () => {
	                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
	                gen.if((0, codegen_1.not)(valid), () => {
	                    cxt.error();
	                    gen.break();
	                });
	            }, codegen_1.nil);
	        }
	    },
	};
	required.default = def;
	
	return required;
}

var limitItems = {};

var hasRequiredLimitItems;

function requireLimitItems () {
	if (hasRequiredLimitItems) return limitItems;
	hasRequiredLimitItems = 1;
	Object.defineProperty(limitItems, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message({ keyword, schemaCode }) {
	        const comp = keyword === "maxItems" ? "more" : "fewer";
	        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;
	    },
	    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: ["maxItems", "minItems"],
	    type: "array",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode } = cxt;
	        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
	        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);
	    },
	};
	limitItems.default = def;
	
	return limitItems;
}

var uniqueItems = {};

var equal = {};

var hasRequiredEqual;

function requireEqual () {
	if (hasRequiredEqual) return equal;
	hasRequiredEqual = 1;
	Object.defineProperty(equal, "__esModule", { value: true });
	// https://github.com/ajv-validator/ajv/issues/889
	const equal$1 = requireFastDeepEqual();
	equal$1.code = 'require("ajv/dist/runtime/equal").default';
	equal.default = equal$1;
	
	return equal;
}

var hasRequiredUniqueItems;

function requireUniqueItems () {
	if (hasRequiredUniqueItems) return uniqueItems;
	hasRequiredUniqueItems = 1;
	Object.defineProperty(uniqueItems, "__esModule", { value: true });
	const dataType_1 = requireDataType();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const equal_1 = requireEqual();
	const error = {
	    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
	    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,
	};
	const def = {
	    keyword: "uniqueItems",
	    type: "array",
	    schemaType: "boolean",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
	        if (!$data && !schema)
	            return;
	        const valid = gen.let("valid");
	        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
	        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);
	        cxt.ok(valid);
	        function validateUniqueItems() {
	            const i = gen.let("i", (0, codegen_1._) `${data}.length`);
	            const j = gen.let("j");
	            cxt.setParams({ i, j });
	            gen.assign(valid, true);
	            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
	        }
	        function canOptimize() {
	            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
	        }
	        function loopN(i, j) {
	            const item = gen.name("item");
	            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
	            const indices = gen.const("indices", (0, codegen_1._) `{}`);
	            gen.for((0, codegen_1._) `;${i}--;`, () => {
	                gen.let(item, (0, codegen_1._) `${data}[${i}]`);
	                gen.if(wrongType, (0, codegen_1._) `continue`);
	                if (itemTypes.length > 1)
	                    gen.if((0, codegen_1._) `typeof ${item} == "string"`, (0, codegen_1._) `${item} += "_"`);
	                gen
	                    .if((0, codegen_1._) `typeof ${indices}[${item}] == "number"`, () => {
	                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);
	                    cxt.error();
	                    gen.assign(valid, false).break();
	                })
	                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);
	            });
	        }
	        function loopN2(i, j) {
	            const eql = (0, util_1.useFunc)(gen, equal_1.default);
	            const outer = gen.name("outer");
	            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {
	                cxt.error();
	                gen.assign(valid, false).break(outer);
	            })));
	        }
	    },
	};
	uniqueItems.default = def;
	
	return uniqueItems;
}

var _const = {};

var hasRequired_const;

function require_const () {
	if (hasRequired_const) return _const;
	hasRequired_const = 1;
	Object.defineProperty(_const, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const equal_1 = requireEqual();
	const error = {
	    message: "must be equal to constant",
	    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,
	};
	const def = {
	    keyword: "const",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, $data, schemaCode, schema } = cxt;
	        if ($data || (schema && typeof schema == "object")) {
	            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
	        }
	        else {
	            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);
	        }
	    },
	};
	_const.default = def;
	
	return _const;
}

var _enum = {};

var hasRequired_enum;

function require_enum () {
	if (hasRequired_enum) return _enum;
	hasRequired_enum = 1;
	Object.defineProperty(_enum, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const equal_1 = requireEqual();
	const error = {
	    message: "must be equal to one of the allowed values",
	    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,
	};
	const def = {
	    keyword: "enum",
	    schemaType: "array",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, $data, schema, schemaCode, it } = cxt;
	        if (!$data && schema.length === 0)
	            throw new Error("enum must have non-empty array");
	        const useLoop = schema.length >= it.opts.loopEnum;
	        let eql;
	        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));
	        let valid;
	        if (useLoop || $data) {
	            valid = gen.let("valid");
	            cxt.block$data(valid, loopEnum);
	        }
	        else {
	            /* istanbul ignore if */
	            if (!Array.isArray(schema))
	                throw new Error("ajv implementation error");
	            const vSchema = gen.const("vSchema", schemaCode);
	            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
	        }
	        cxt.pass(valid);
	        function loopEnum() {
	            gen.assign(valid, false);
	            gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
	        }
	        function equalCode(vSchema, i) {
	            const sch = schema[i];
	            return typeof sch === "object" && sch !== null
	                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`
	                : (0, codegen_1._) `${data} === ${sch}`;
	        }
	    },
	};
	_enum.default = def;
	
	return _enum;
}

var hasRequiredValidation;

function requireValidation () {
	if (hasRequiredValidation) return validation;
	hasRequiredValidation = 1;
	Object.defineProperty(validation, "__esModule", { value: true });
	const limitNumber_1 = requireLimitNumber();
	const multipleOf_1 = requireMultipleOf();
	const limitLength_1 = requireLimitLength();
	const pattern_1 = requirePattern();
	const limitProperties_1 = requireLimitProperties();
	const required_1 = requireRequired();
	const limitItems_1 = requireLimitItems();
	const uniqueItems_1 = requireUniqueItems();
	const const_1 = require_const();
	const enum_1 = require_enum();
	const validation$1 = [
	    // number
	    limitNumber_1.default,
	    multipleOf_1.default,
	    // string
	    limitLength_1.default,
	    pattern_1.default,
	    // object
	    limitProperties_1.default,
	    required_1.default,
	    // array
	    limitItems_1.default,
	    uniqueItems_1.default,
	    // any
	    { keyword: "type", schemaType: ["string", "array"] },
	    { keyword: "nullable", schemaType: "boolean" },
	    const_1.default,
	    enum_1.default,
	];
	validation.default = validation$1;
	
	return validation;
}

var applicator = {};

var additionalItems = {};

var hasRequiredAdditionalItems;

function requireAdditionalItems () {
	if (hasRequiredAdditionalItems) return additionalItems;
	hasRequiredAdditionalItems = 1;
	Object.defineProperty(additionalItems, "__esModule", { value: true });
	additionalItems.validateAdditionalItems = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
	    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
	};
	const def = {
	    keyword: "additionalItems",
	    type: "array",
	    schemaType: ["boolean", "object"],
	    before: "uniqueItems",
	    error,
	    code(cxt) {
	        const { parentSchema, it } = cxt;
	        const { items } = parentSchema;
	        if (!Array.isArray(items)) {
	            (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
	            return;
	        }
	        validateAdditionalItems(cxt, items);
	    },
	};
	function validateAdditionalItems(cxt, items) {
	    const { gen, schema, data, keyword, it } = cxt;
	    it.items = true;
	    const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	    if (schema === false) {
	        cxt.setParams({ len: items.length });
	        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);
	    }
	    else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
	        const valid = gen.var("valid", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var
	        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
	        cxt.ok(valid);
	    }
	    function validateItems(valid) {
	        gen.forRange("i", items.length, len, (i) => {
	            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
	            if (!it.allErrors)
	                gen.if((0, codegen_1.not)(valid), () => gen.break());
	        });
	    }
	}
	additionalItems.validateAdditionalItems = validateAdditionalItems;
	additionalItems.default = def;
	
	return additionalItems;
}

var prefixItems = {};

var items = {};

var hasRequiredItems;

function requireItems () {
	if (hasRequiredItems) return items;
	hasRequiredItems = 1;
	Object.defineProperty(items, "__esModule", { value: true });
	items.validateTuple = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const code_1 = requireCode();
	const def = {
	    keyword: "items",
	    type: "array",
	    schemaType: ["object", "array", "boolean"],
	    before: "uniqueItems",
	    code(cxt) {
	        const { schema, it } = cxt;
	        if (Array.isArray(schema))
	            return validateTuple(cxt, "additionalItems", schema);
	        it.items = true;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        cxt.ok((0, code_1.validateArray)(cxt));
	    },
	};
	function validateTuple(cxt, extraItems, schArr = cxt.schema) {
	    const { gen, parentSchema, data, keyword, it } = cxt;
	    checkStrictTuple(parentSchema);
	    if (it.opts.unevaluated && schArr.length && it.items !== true) {
	        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
	    }
	    const valid = gen.name("valid");
	    const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	    schArr.forEach((sch, i) => {
	        if ((0, util_1.alwaysValidSchema)(it, sch))
	            return;
	        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({
	            keyword,
	            schemaProp: i,
	            dataProp: i,
	        }, valid));
	        cxt.ok(valid);
	    });
	    function checkStrictTuple(sch) {
	        const { opts, errSchemaPath } = it;
	        const l = schArr.length;
	        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
	        if (opts.strictTuples && !fullTuple) {
	            const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
	            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
	        }
	    }
	}
	items.validateTuple = validateTuple;
	items.default = def;
	
	return items;
}

var hasRequiredPrefixItems;

function requirePrefixItems () {
	if (hasRequiredPrefixItems) return prefixItems;
	hasRequiredPrefixItems = 1;
	Object.defineProperty(prefixItems, "__esModule", { value: true });
	const items_1 = requireItems();
	const def = {
	    keyword: "prefixItems",
	    type: "array",
	    schemaType: ["array"],
	    before: "uniqueItems",
	    code: (cxt) => (0, items_1.validateTuple)(cxt, "items"),
	};
	prefixItems.default = def;
	
	return prefixItems;
}

var items2020 = {};

var hasRequiredItems2020;

function requireItems2020 () {
	if (hasRequiredItems2020) return items2020;
	hasRequiredItems2020 = 1;
	Object.defineProperty(items2020, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const code_1 = requireCode();
	const additionalItems_1 = requireAdditionalItems();
	const error = {
	    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
	    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
	};
	const def = {
	    keyword: "items",
	    type: "array",
	    schemaType: ["object", "boolean"],
	    before: "uniqueItems",
	    error,
	    code(cxt) {
	        const { schema, parentSchema, it } = cxt;
	        const { prefixItems } = parentSchema;
	        it.items = true;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        if (prefixItems)
	            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
	        else
	            cxt.ok((0, code_1.validateArray)(cxt));
	    },
	};
	items2020.default = def;
	
	return items2020;
}

var contains = {};

var hasRequiredContains;

function requireContains () {
	if (hasRequiredContains) return contains;
	hasRequiredContains = 1;
	Object.defineProperty(contains, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params: { min, max } }) => max === undefined
	        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`
	        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,
	    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,
	};
	const def = {
	    keyword: "contains",
	    type: "array",
	    schemaType: ["object", "boolean"],
	    before: "uniqueItems",
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, schema, parentSchema, data, it } = cxt;
	        let min;
	        let max;
	        const { minContains, maxContains } = parentSchema;
	        if (it.opts.next) {
	            min = minContains === undefined ? 1 : minContains;
	            max = maxContains;
	        }
	        else {
	            min = 1;
	        }
	        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	        cxt.setParams({ min, max });
	        if (max === undefined && min === 0) {
	            (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
	            return;
	        }
	        if (max !== undefined && min > max) {
	            (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
	            cxt.fail();
	            return;
	        }
	        if ((0, util_1.alwaysValidSchema)(it, schema)) {
	            let cond = (0, codegen_1._) `${len} >= ${min}`;
	            if (max !== undefined)
	                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;
	            cxt.pass(cond);
	            return;
	        }
	        it.items = true;
	        const valid = gen.name("valid");
	        if (max === undefined && min === 1) {
	            validateItems(valid, () => gen.if(valid, () => gen.break()));
	        }
	        else if (min === 0) {
	            gen.let(valid, true);
	            if (max !== undefined)
	                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);
	        }
	        else {
	            gen.let(valid, false);
	            validateItemsWithCount();
	        }
	        cxt.result(valid, () => cxt.reset());
	        function validateItemsWithCount() {
	            const schValid = gen.name("_valid");
	            const count = gen.let("count", 0);
	            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
	        }
	        function validateItems(_valid, block) {
	            gen.forRange("i", 0, len, (i) => {
	                cxt.subschema({
	                    keyword: "contains",
	                    dataProp: i,
	                    dataPropType: util_1.Type.Num,
	                    compositeRule: true,
	                }, _valid);
	                block();
	            });
	        }
	        function checkLimits(count) {
	            gen.code((0, codegen_1._) `${count}++`);
	            if (max === undefined) {
	                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());
	            }
	            else {
	                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());
	                if (min === 1)
	                    gen.assign(valid, true);
	                else
	                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));
	            }
	        }
	    },
	};
	contains.default = def;
	
	return contains;
}

var dependencies = {};

var hasRequiredDependencies;

function requireDependencies () {
	if (hasRequiredDependencies) return dependencies;
	hasRequiredDependencies = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
		const codegen_1 = requireCodegen();
		const util_1 = requireUtil$1();
		const code_1 = requireCode();
		exports.error = {
		    message: ({ params: { property, depsCount, deps } }) => {
		        const property_ies = depsCount === 1 ? "property" : "properties";
		        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;
		    },
		    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`, // TODO change to reference
		};
		const def = {
		    keyword: "dependencies",
		    type: "object",
		    schemaType: "object",
		    error: exports.error,
		    code(cxt) {
		        const [propDeps, schDeps] = splitDependencies(cxt);
		        validatePropertyDeps(cxt, propDeps);
		        validateSchemaDeps(cxt, schDeps);
		    },
		};
		function splitDependencies({ schema }) {
		    const propertyDeps = {};
		    const schemaDeps = {};
		    for (const key in schema) {
		        if (key === "__proto__")
		            continue;
		        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
		        deps[key] = schema[key];
		    }
		    return [propertyDeps, schemaDeps];
		}
		function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
		    const { gen, data, it } = cxt;
		    if (Object.keys(propertyDeps).length === 0)
		        return;
		    const missing = gen.let("missing");
		    for (const prop in propertyDeps) {
		        const deps = propertyDeps[prop];
		        if (deps.length === 0)
		            continue;
		        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
		        cxt.setParams({
		            property: prop,
		            depsCount: deps.length,
		            deps: deps.join(", "),
		        });
		        if (it.allErrors) {
		            gen.if(hasProperty, () => {
		                for (const depProp of deps) {
		                    (0, code_1.checkReportMissingProp)(cxt, depProp);
		                }
		            });
		        }
		        else {
		            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
		            (0, code_1.reportMissingProp)(cxt, missing);
		            gen.else();
		        }
		    }
		}
		exports.validatePropertyDeps = validatePropertyDeps;
		function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
		    const { gen, data, keyword, it } = cxt;
		    const valid = gen.name("valid");
		    for (const prop in schemaDeps) {
		        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
		            continue;
		        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
		            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
		            cxt.mergeValidEvaluated(schCxt, valid);
		        }, () => gen.var(valid, true) // TODO var
		        );
		        cxt.ok(valid);
		    }
		}
		exports.validateSchemaDeps = validateSchemaDeps;
		exports.default = def;
		
	} (dependencies));
	return dependencies;
}

var propertyNames = {};

var hasRequiredPropertyNames;

function requirePropertyNames () {
	if (hasRequiredPropertyNames) return propertyNames;
	hasRequiredPropertyNames = 1;
	Object.defineProperty(propertyNames, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const error = {
	    message: "property name must be valid",
	    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,
	};
	const def = {
	    keyword: "propertyNames",
	    type: "object",
	    schemaType: ["object", "boolean"],
	    error,
	    code(cxt) {
	        const { gen, schema, data, it } = cxt;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        const valid = gen.name("valid");
	        gen.forIn("key", data, (key) => {
	            cxt.setParams({ propertyName: key });
	            cxt.subschema({
	                keyword: "propertyNames",
	                data: key,
	                dataTypes: ["string"],
	                propertyName: key,
	                compositeRule: true,
	            }, valid);
	            gen.if((0, codegen_1.not)(valid), () => {
	                cxt.error(true);
	                if (!it.allErrors)
	                    gen.break();
	            });
	        });
	        cxt.ok(valid);
	    },
	};
	propertyNames.default = def;
	
	return propertyNames;
}

var additionalProperties = {};

var hasRequiredAdditionalProperties;

function requireAdditionalProperties () {
	if (hasRequiredAdditionalProperties) return additionalProperties;
	hasRequiredAdditionalProperties = 1;
	Object.defineProperty(additionalProperties, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const util_1 = requireUtil$1();
	const error = {
	    message: "must NOT have additional properties",
	    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,
	};
	const def = {
	    keyword: "additionalProperties",
	    type: ["object"],
	    schemaType: ["boolean", "object"],
	    allowUndefined: true,
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
	        /* istanbul ignore if */
	        if (!errsCount)
	            throw new Error("ajv implementation error");
	        const { allErrors, opts } = it;
	        it.props = true;
	        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
	        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
	        checkAdditionalProperties();
	        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
	        function checkAdditionalProperties() {
	            gen.forIn("key", data, (key) => {
	                if (!props.length && !patProps.length)
	                    additionalPropertyCode(key);
	                else
	                    gen.if(isAdditional(key), () => additionalPropertyCode(key));
	            });
	        }
	        function isAdditional(key) {
	            let definedProp;
	            if (props.length > 8) {
	                // TODO maybe an option instead of hard-coded 8?
	                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
	                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
	            }
	            else if (props.length) {
	                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));
	            }
	            else {
	                definedProp = codegen_1.nil;
	            }
	            if (patProps.length) {
	                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
	            }
	            return (0, codegen_1.not)(definedProp);
	        }
	        function deleteAdditional(key) {
	            gen.code((0, codegen_1._) `delete ${data}[${key}]`);
	        }
	        function additionalPropertyCode(key) {
	            if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
	                deleteAdditional(key);
	                return;
	            }
	            if (schema === false) {
	                cxt.setParams({ additionalProperty: key });
	                cxt.error();
	                if (!allErrors)
	                    gen.break();
	                return;
	            }
	            if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
	                const valid = gen.name("valid");
	                if (opts.removeAdditional === "failing") {
	                    applyAdditionalSchema(key, valid, false);
	                    gen.if((0, codegen_1.not)(valid), () => {
	                        cxt.reset();
	                        deleteAdditional(key);
	                    });
	                }
	                else {
	                    applyAdditionalSchema(key, valid);
	                    if (!allErrors)
	                        gen.if((0, codegen_1.not)(valid), () => gen.break());
	                }
	            }
	        }
	        function applyAdditionalSchema(key, valid, errors) {
	            const subschema = {
	                keyword: "additionalProperties",
	                dataProp: key,
	                dataPropType: util_1.Type.Str,
	            };
	            if (errors === false) {
	                Object.assign(subschema, {
	                    compositeRule: true,
	                    createErrors: false,
	                    allErrors: false,
	                });
	            }
	            cxt.subschema(subschema, valid);
	        }
	    },
	};
	additionalProperties.default = def;
	
	return additionalProperties;
}

var properties$1 = {};

var hasRequiredProperties;

function requireProperties () {
	if (hasRequiredProperties) return properties$1;
	hasRequiredProperties = 1;
	Object.defineProperty(properties$1, "__esModule", { value: true });
	const validate_1 = requireValidate();
	const code_1 = requireCode();
	const util_1 = requireUtil$1();
	const additionalProperties_1 = requireAdditionalProperties();
	const def = {
	    keyword: "properties",
	    type: "object",
	    schemaType: "object",
	    code(cxt) {
	        const { gen, schema, parentSchema, data, it } = cxt;
	        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
	            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
	        }
	        const allProps = (0, code_1.allSchemaProperties)(schema);
	        for (const prop of allProps) {
	            it.definedProperties.add(prop);
	        }
	        if (it.opts.unevaluated && allProps.length && it.props !== true) {
	            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
	        }
	        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
	        if (properties.length === 0)
	            return;
	        const valid = gen.name("valid");
	        for (const prop of properties) {
	            if (hasDefault(prop)) {
	                applyPropertySchema(prop);
	            }
	            else {
	                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
	                applyPropertySchema(prop);
	                if (!it.allErrors)
	                    gen.else().var(valid, true);
	                gen.endIf();
	            }
	            cxt.it.definedProperties.add(prop);
	            cxt.ok(valid);
	        }
	        function hasDefault(prop) {
	            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
	        }
	        function applyPropertySchema(prop) {
	            cxt.subschema({
	                keyword: "properties",
	                schemaProp: prop,
	                dataProp: prop,
	            }, valid);
	        }
	    },
	};
	properties$1.default = def;
	
	return properties$1;
}

var patternProperties = {};

var hasRequiredPatternProperties;

function requirePatternProperties () {
	if (hasRequiredPatternProperties) return patternProperties;
	hasRequiredPatternProperties = 1;
	Object.defineProperty(patternProperties, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const util_2 = requireUtil$1();
	const def = {
	    keyword: "patternProperties",
	    type: "object",
	    schemaType: "object",
	    code(cxt) {
	        const { gen, schema, data, parentSchema, it } = cxt;
	        const { opts } = it;
	        const patterns = (0, code_1.allSchemaProperties)(schema);
	        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
	        if (patterns.length === 0 ||
	            (alwaysValidPatterns.length === patterns.length &&
	                (!it.opts.unevaluated || it.props === true))) {
	            return;
	        }
	        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
	        const valid = gen.name("valid");
	        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
	            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
	        }
	        const { props } = it;
	        validatePatternProperties();
	        function validatePatternProperties() {
	            for (const pat of patterns) {
	                if (checkProperties)
	                    checkMatchingProperties(pat);
	                if (it.allErrors) {
	                    validateProperties(pat);
	                }
	                else {
	                    gen.var(valid, true); // TODO var
	                    validateProperties(pat);
	                    gen.if(valid);
	                }
	            }
	        }
	        function checkMatchingProperties(pat) {
	            for (const prop in checkProperties) {
	                if (new RegExp(pat).test(prop)) {
	                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
	                }
	            }
	        }
	        function validateProperties(pat) {
	            gen.forIn("key", data, (key) => {
	                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
	                    const alwaysValid = alwaysValidPatterns.includes(pat);
	                    if (!alwaysValid) {
	                        cxt.subschema({
	                            keyword: "patternProperties",
	                            schemaProp: pat,
	                            dataProp: key,
	                            dataPropType: util_2.Type.Str,
	                        }, valid);
	                    }
	                    if (it.opts.unevaluated && props !== true) {
	                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);
	                    }
	                    else if (!alwaysValid && !it.allErrors) {
	                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
	                        // or if all properties were evaluated (props === true)
	                        gen.if((0, codegen_1.not)(valid), () => gen.break());
	                    }
	                });
	            });
	        }
	    },
	};
	patternProperties.default = def;
	
	return patternProperties;
}

var not = {};

var hasRequiredNot;

function requireNot () {
	if (hasRequiredNot) return not;
	hasRequiredNot = 1;
	Object.defineProperty(not, "__esModule", { value: true });
	const util_1 = requireUtil$1();
	const def = {
	    keyword: "not",
	    schemaType: ["object", "boolean"],
	    trackErrors: true,
	    code(cxt) {
	        const { gen, schema, it } = cxt;
	        if ((0, util_1.alwaysValidSchema)(it, schema)) {
	            cxt.fail();
	            return;
	        }
	        const valid = gen.name("valid");
	        cxt.subschema({
	            keyword: "not",
	            compositeRule: true,
	            createErrors: false,
	            allErrors: false,
	        }, valid);
	        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
	    },
	    error: { message: "must NOT be valid" },
	};
	not.default = def;
	
	return not;
}

var anyOf = {};

var hasRequiredAnyOf;

function requireAnyOf () {
	if (hasRequiredAnyOf) return anyOf;
	hasRequiredAnyOf = 1;
	Object.defineProperty(anyOf, "__esModule", { value: true });
	const code_1 = requireCode();
	const def = {
	    keyword: "anyOf",
	    schemaType: "array",
	    trackErrors: true,
	    code: code_1.validateUnion,
	    error: { message: "must match a schema in anyOf" },
	};
	anyOf.default = def;
	
	return anyOf;
}

var oneOf = {};

var hasRequiredOneOf;

function requireOneOf () {
	if (hasRequiredOneOf) return oneOf;
	hasRequiredOneOf = 1;
	Object.defineProperty(oneOf, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const error = {
	    message: "must match exactly one schema in oneOf",
	    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,
	};
	const def = {
	    keyword: "oneOf",
	    schemaType: "array",
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, schema, parentSchema, it } = cxt;
	        /* istanbul ignore if */
	        if (!Array.isArray(schema))
	            throw new Error("ajv implementation error");
	        if (it.opts.discriminator && parentSchema.discriminator)
	            return;
	        const schArr = schema;
	        const valid = gen.let("valid", false);
	        const passing = gen.let("passing", null);
	        const schValid = gen.name("_valid");
	        cxt.setParams({ passing });
	        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
	        gen.block(validateOneOf);
	        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	        function validateOneOf() {
	            schArr.forEach((sch, i) => {
	                let schCxt;
	                if ((0, util_1.alwaysValidSchema)(it, sch)) {
	                    gen.var(schValid, true);
	                }
	                else {
	                    schCxt = cxt.subschema({
	                        keyword: "oneOf",
	                        schemaProp: i,
	                        compositeRule: true,
	                    }, schValid);
	                }
	                if (i > 0) {
	                    gen
	                        .if((0, codegen_1._) `${schValid} && ${valid}`)
	                        .assign(valid, false)
	                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)
	                        .else();
	                }
	                gen.if(schValid, () => {
	                    gen.assign(valid, true);
	                    gen.assign(passing, i);
	                    if (schCxt)
	                        cxt.mergeEvaluated(schCxt, codegen_1.Name);
	                });
	            });
	        }
	    },
	};
	oneOf.default = def;
	
	return oneOf;
}

var allOf = {};

var hasRequiredAllOf;

function requireAllOf () {
	if (hasRequiredAllOf) return allOf;
	hasRequiredAllOf = 1;
	Object.defineProperty(allOf, "__esModule", { value: true });
	const util_1 = requireUtil$1();
	const def = {
	    keyword: "allOf",
	    schemaType: "array",
	    code(cxt) {
	        const { gen, schema, it } = cxt;
	        /* istanbul ignore if */
	        if (!Array.isArray(schema))
	            throw new Error("ajv implementation error");
	        const valid = gen.name("valid");
	        schema.forEach((sch, i) => {
	            if ((0, util_1.alwaysValidSchema)(it, sch))
	                return;
	            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
	            cxt.ok(valid);
	            cxt.mergeEvaluated(schCxt);
	        });
	    },
	};
	allOf.default = def;
	
	return allOf;
}

var _if = {};

var hasRequired_if;

function require_if () {
	if (hasRequired_if) return _if;
	hasRequired_if = 1;
	Object.defineProperty(_if, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params }) => (0, codegen_1.str) `must match "${params.ifClause}" schema`,
	    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,
	};
	const def = {
	    keyword: "if",
	    schemaType: ["object", "boolean"],
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, parentSchema, it } = cxt;
	        if (parentSchema.then === undefined && parentSchema.else === undefined) {
	            (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
	        }
	        const hasThen = hasSchema(it, "then");
	        const hasElse = hasSchema(it, "else");
	        if (!hasThen && !hasElse)
	            return;
	        const valid = gen.let("valid", true);
	        const schValid = gen.name("_valid");
	        validateIf();
	        cxt.reset();
	        if (hasThen && hasElse) {
	            const ifClause = gen.let("ifClause");
	            cxt.setParams({ ifClause });
	            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
	        }
	        else if (hasThen) {
	            gen.if(schValid, validateClause("then"));
	        }
	        else {
	            gen.if((0, codegen_1.not)(schValid), validateClause("else"));
	        }
	        cxt.pass(valid, () => cxt.error(true));
	        function validateIf() {
	            const schCxt = cxt.subschema({
	                keyword: "if",
	                compositeRule: true,
	                createErrors: false,
	                allErrors: false,
	            }, schValid);
	            cxt.mergeEvaluated(schCxt);
	        }
	        function validateClause(keyword, ifClause) {
	            return () => {
	                const schCxt = cxt.subschema({ keyword }, schValid);
	                gen.assign(valid, schValid);
	                cxt.mergeValidEvaluated(schCxt, valid);
	                if (ifClause)
	                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);
	                else
	                    cxt.setParams({ ifClause: keyword });
	            };
	        }
	    },
	};
	function hasSchema(it, keyword) {
	    const schema = it.schema[keyword];
	    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);
	}
	_if.default = def;
	
	return _if;
}

var thenElse = {};

var hasRequiredThenElse;

function requireThenElse () {
	if (hasRequiredThenElse) return thenElse;
	hasRequiredThenElse = 1;
	Object.defineProperty(thenElse, "__esModule", { value: true });
	const util_1 = requireUtil$1();
	const def = {
	    keyword: ["then", "else"],
	    schemaType: ["object", "boolean"],
	    code({ keyword, parentSchema, it }) {
	        if (parentSchema.if === undefined)
	            (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
	    },
	};
	thenElse.default = def;
	
	return thenElse;
}

var hasRequiredApplicator;

function requireApplicator () {
	if (hasRequiredApplicator) return applicator;
	hasRequiredApplicator = 1;
	Object.defineProperty(applicator, "__esModule", { value: true });
	const additionalItems_1 = requireAdditionalItems();
	const prefixItems_1 = requirePrefixItems();
	const items_1 = requireItems();
	const items2020_1 = requireItems2020();
	const contains_1 = requireContains();
	const dependencies_1 = requireDependencies();
	const propertyNames_1 = requirePropertyNames();
	const additionalProperties_1 = requireAdditionalProperties();
	const properties_1 = requireProperties();
	const patternProperties_1 = requirePatternProperties();
	const not_1 = requireNot();
	const anyOf_1 = requireAnyOf();
	const oneOf_1 = requireOneOf();
	const allOf_1 = requireAllOf();
	const if_1 = require_if();
	const thenElse_1 = requireThenElse();
	function getApplicator(draft2020 = false) {
	    const applicator = [
	        // any
	        not_1.default,
	        anyOf_1.default,
	        oneOf_1.default,
	        allOf_1.default,
	        if_1.default,
	        thenElse_1.default,
	        // object
	        propertyNames_1.default,
	        additionalProperties_1.default,
	        dependencies_1.default,
	        properties_1.default,
	        patternProperties_1.default,
	    ];
	    // array
	    if (draft2020)
	        applicator.push(prefixItems_1.default, items2020_1.default);
	    else
	        applicator.push(additionalItems_1.default, items_1.default);
	    applicator.push(contains_1.default);
	    return applicator;
	}
	applicator.default = getApplicator;
	
	return applicator;
}

var format$1 = {};

var format = {};

var hasRequiredFormat$1;

function requireFormat$1 () {
	if (hasRequiredFormat$1) return format;
	hasRequiredFormat$1 = 1;
	Object.defineProperty(format, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message: ({ schemaCode }) => (0, codegen_1.str) `must match format "${schemaCode}"`,
	    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,
	};
	const def = {
	    keyword: "format",
	    type: ["number", "string"],
	    schemaType: "string",
	    $data: true,
	    error,
	    code(cxt, ruleType) {
	        const { gen, data, $data, schema, schemaCode, it } = cxt;
	        const { opts, errSchemaPath, schemaEnv, self } = it;
	        if (!opts.validateFormats)
	            return;
	        if ($data)
	            validate$DataFormat();
	        else
	            validateFormat();
	        function validate$DataFormat() {
	            const fmts = gen.scopeValue("formats", {
	                ref: self.formats,
	                code: opts.code.formats,
	            });
	            const fDef = gen.const("fDef", (0, codegen_1._) `${fmts}[${schemaCode}]`);
	            const fType = gen.let("fType");
	            const format = gen.let("format");
	            // TODO simplify
	            gen.if((0, codegen_1._) `typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || "string"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `"string"`).assign(format, fDef));
	            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
	            function unknownFmt() {
	                if (opts.strictSchema === false)
	                    return codegen_1.nil;
	                return (0, codegen_1._) `${schemaCode} && !${format}`;
	            }
	            function invalidFmt() {
	                const callFormat = schemaEnv.$async
	                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
	                    : (0, codegen_1._) `${format}(${data})`;
	                const validData = (0, codegen_1._) `(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
	                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
	            }
	        }
	        function validateFormat() {
	            const formatDef = self.formats[schema];
	            if (!formatDef) {
	                unknownFormat();
	                return;
	            }
	            if (formatDef === true)
	                return;
	            const [fmtType, format, fmtRef] = getFormat(formatDef);
	            if (fmtType === ruleType)
	                cxt.pass(validCondition());
	            function unknownFormat() {
	                if (opts.strictSchema === false) {
	                    self.logger.warn(unknownMsg());
	                    return;
	                }
	                throw new Error(unknownMsg());
	                function unknownMsg() {
	                    return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
	                }
	            }
	            function getFormat(fmtDef) {
	                const code = fmtDef instanceof RegExp
	                    ? (0, codegen_1.regexpCode)(fmtDef)
	                    : opts.code.formats
	                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`
	                        : undefined;
	                const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
	                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
	                    return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];
	                }
	                return ["string", fmtDef, fmt];
	            }
	            function validCondition() {
	                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
	                    if (!schemaEnv.$async)
	                        throw new Error("async format in sync schema");
	                    return (0, codegen_1._) `await ${fmtRef}(${data})`;
	                }
	                return typeof format == "function" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;
	            }
	        }
	    },
	};
	format.default = def;
	
	return format;
}

var hasRequiredFormat;

function requireFormat () {
	if (hasRequiredFormat) return format$1;
	hasRequiredFormat = 1;
	Object.defineProperty(format$1, "__esModule", { value: true });
	const format_1 = requireFormat$1();
	const format = [format_1.default];
	format$1.default = format;
	
	return format$1;
}

var metadata = {};

var hasRequiredMetadata;

function requireMetadata () {
	if (hasRequiredMetadata) return metadata;
	hasRequiredMetadata = 1;
	Object.defineProperty(metadata, "__esModule", { value: true });
	metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
	metadata.metadataVocabulary = [
	    "title",
	    "description",
	    "default",
	    "deprecated",
	    "readOnly",
	    "writeOnly",
	    "examples",
	];
	metadata.contentVocabulary = [
	    "contentMediaType",
	    "contentEncoding",
	    "contentSchema",
	];
	
	return metadata;
}

var hasRequiredDraft7;

function requireDraft7 () {
	if (hasRequiredDraft7) return draft7;
	hasRequiredDraft7 = 1;
	Object.defineProperty(draft7, "__esModule", { value: true });
	const core_1 = requireCore();
	const validation_1 = requireValidation();
	const applicator_1 = requireApplicator();
	const format_1 = requireFormat();
	const metadata_1 = requireMetadata();
	const draft7Vocabularies = [
	    core_1.default,
	    validation_1.default,
	    (0, applicator_1.default)(),
	    format_1.default,
	    metadata_1.metadataVocabulary,
	    metadata_1.contentVocabulary,
	];
	draft7.default = draft7Vocabularies;
	
	return draft7;
}

var discriminator = {};

var types = {};

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;
	Object.defineProperty(types, "__esModule", { value: true });
	types.DiscrError = void 0;
	var DiscrError;
	(function (DiscrError) {
	    DiscrError["Tag"] = "tag";
	    DiscrError["Mapping"] = "mapping";
	})(DiscrError || (types.DiscrError = DiscrError = {}));
	
	return types;
}

var hasRequiredDiscriminator;

function requireDiscriminator () {
	if (hasRequiredDiscriminator) return discriminator;
	hasRequiredDiscriminator = 1;
	Object.defineProperty(discriminator, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const types_1 = requireTypes();
	const compile_1 = requireCompile();
	const ref_error_1 = requireRef_error();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag
	        ? `tag "${tagName}" must be string`
	        : `value of tag "${tagName}" must be in oneOf`,
	    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,
	};
	const def = {
	    keyword: "discriminator",
	    type: "object",
	    schemaType: "object",
	    error,
	    code(cxt) {
	        const { gen, data, schema, parentSchema, it } = cxt;
	        const { oneOf } = parentSchema;
	        if (!it.opts.discriminator) {
	            throw new Error("discriminator: requires discriminator option");
	        }
	        const tagName = schema.propertyName;
	        if (typeof tagName != "string")
	            throw new Error("discriminator: requires propertyName");
	        if (schema.mapping)
	            throw new Error("discriminator: mapping is not supported");
	        if (!oneOf)
	            throw new Error("discriminator: requires oneOf keyword");
	        const valid = gen.let("valid", false);
	        const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);
	        gen.if((0, codegen_1._) `typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
	        cxt.ok(valid);
	        function validateMapping() {
	            const mapping = getMapping();
	            gen.if(false);
	            for (const tagValue in mapping) {
	                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
	                gen.assign(valid, applyTagSchema(mapping[tagValue]));
	            }
	            gen.else();
	            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
	            gen.endIf();
	        }
	        function applyTagSchema(schemaProp) {
	            const _valid = gen.name("valid");
	            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
	            cxt.mergeEvaluated(schCxt, codegen_1.Name);
	            return _valid;
	        }
	        function getMapping() {
	            var _a;
	            const oneOfMapping = {};
	            const topRequired = hasRequired(parentSchema);
	            let tagRequired = true;
	            for (let i = 0; i < oneOf.length; i++) {
	                let sch = oneOf[i];
	                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
	                    const ref = sch.$ref;
	                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
	                    if (sch instanceof compile_1.SchemaEnv)
	                        sch = sch.schema;
	                    if (sch === undefined)
	                        throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
	                }
	                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
	                if (typeof propSch != "object") {
	                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
	                }
	                tagRequired = tagRequired && (topRequired || hasRequired(sch));
	                addMappings(propSch, i);
	            }
	            if (!tagRequired)
	                throw new Error(`discriminator: "${tagName}" must be required`);
	            return oneOfMapping;
	            function hasRequired({ required }) {
	                return Array.isArray(required) && required.includes(tagName);
	            }
	            function addMappings(sch, i) {
	                if (sch.const) {
	                    addMapping(sch.const, i);
	                }
	                else if (sch.enum) {
	                    for (const tagValue of sch.enum) {
	                        addMapping(tagValue, i);
	                    }
	                }
	                else {
	                    throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
	                }
	            }
	            function addMapping(tagValue, i) {
	                if (typeof tagValue != "string" || tagValue in oneOfMapping) {
	                    throw new Error(`discriminator: "${tagName}" values must be unique strings`);
	                }
	                oneOfMapping[tagValue] = i;
	            }
	        }
	    },
	};
	discriminator.default = def;
	
	return discriminator;
}

const $schema = "http://json-schema.org/draft-07/schema#";
const $id = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions = {"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}};
const type = ["object","boolean"];
const properties = {"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}};
const require$$3 = {
  $schema,
  $id,
  title,
  definitions,
  type,
  properties,
  "default": true,
};

var hasRequiredAjv;

function requireAjv () {
	if (hasRequiredAjv) return ajv.exports;
	hasRequiredAjv = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
		const core_1 = requireCore$1();
		const draft7_1 = requireDraft7();
		const discriminator_1 = requireDiscriminator();
		const draft7MetaSchema = require$$3;
		const META_SUPPORT_DATA = ["/properties"];
		const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
		class Ajv extends core_1.default {
		    _addVocabularies() {
		        super._addVocabularies();
		        draft7_1.default.forEach((v) => this.addVocabulary(v));
		        if (this.opts.discriminator)
		            this.addKeyword(discriminator_1.default);
		    }
		    _addDefaultMetaSchema() {
		        super._addDefaultMetaSchema();
		        if (!this.opts.meta)
		            return;
		        const metaSchema = this.opts.$data
		            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
		            : draft7MetaSchema;
		        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
		        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
		    }
		    defaultMeta() {
		        return (this.opts.defaultMeta =
		            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
		    }
		}
		exports.Ajv = Ajv;
		module.exports = exports = Ajv;
		module.exports.Ajv = Ajv;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.default = Ajv;
		var validate_1 = requireValidate();
		Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
		var codegen_1 = requireCodegen();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
		Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
		var validation_error_1 = requireValidation_error();
		Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
		var ref_error_1 = requireRef_error();
		Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
		
	} (ajv, ajv.exports));
	return ajv.exports;
}

var ajvExports = requireAjv();
const Ajv = /*@__PURE__*/getDefaultExportFromCjs(ajvExports);

class OB11Response {
  static createResponse(data, status, retcode, message = "", echo = null) {
    return {
      status,
      retcode,
      data,
      message,
      wording: message,
      echo
    };
  }
  static res(data, status, retcode, message = "") {
    return this.createResponse(data, status, retcode, message);
  }
  static ok(data, echo = null) {
    return this.createResponse(data, "ok", 0, "", echo);
  }
  static error(err, retcode, echo = null) {
    return this.createResponse(null, "failed", retcode, err, echo);
  }
}
class OneBotAction {
  actionName = ActionName.Unknown;
  core;
  validate = void 0;
  payloadSchema = void 0;
  obContext;
  constructor(obContext, core) {
    this.obContext = obContext;
    this.core = core;
  }
  async check(payload) {
    if (this.payloadSchema) {
      this.validate = new Ajv({ allowUnionTypes: true, useDefaults: true }).compile(this.payloadSchema);
    }
    if (this.validate && !this.validate(payload)) {
      const errors = this.validate.errors;
      const errorMessages = errors.map((e) => `Key: ${e.instancePath.split("/").slice(1).join(".")}, Message: ${e.message}`);
      return {
        valid: false,
        message: errorMessages.join("\n") ?? "未知错误"
      };
    }
    return { valid: true };
  }
  async handle(payload, adaptername) {
    const result = await this.check(payload);
    if (!result.valid) {
      return OB11Response.error(result.message, 400);
    }
    try {
      const resData = await this._handle(payload, adaptername);
      return OB11Response.ok(resData);
    } catch (e) {
      this.core.context.logger.logError("发生错误", e);
      return OB11Response.error(e.message.toString() || e?.stack?.toString() || "未知错误，可能操作超时", 200);
    }
  }
  async websocketHandle(payload, echo, adaptername) {
    const result = await this.check(payload);
    if (!result.valid) {
      return OB11Response.error(result.message, 1400, echo);
    }
    try {
      const resData = await this._handle(payload, adaptername);
      return OB11Response.ok(resData, echo);
    } catch (e) {
      this.core.context.logger.logError("发生错误", e);
      return OB11Response.error(e.message.toString() || e.stack?.toString(), 1200, echo);
    }
  }
}

var LifeCycleSubType = /* @__PURE__ */ ((LifeCycleSubType2) => {
  LifeCycleSubType2["ENABLE"] = "enable";
  LifeCycleSubType2["DISABLE"] = "disable";
  LifeCycleSubType2["CONNECT"] = "connect";
  return LifeCycleSubType2;
})(LifeCycleSubType || {});
class OB11LifeCycleEvent extends OB11BaseMetaEvent {
  meta_event_type = "lifecycle";
  sub_type;
  constructor(core, subType) {
    super(core);
    this.sub_type = subType;
  }
}

class OB11ActiveWebSocketAdapter {
  constructor(name, confg, core, actions) {
    this.name = name;
    this.core = core;
    this.actions = actions;
    this.logger = core.context.logger;
    this.config = structuredClone(confg);
  }
  isEnable = false;
  logger;
  connection = null;
  heartbeatRef = null;
  config;
  onEvent(event) {
    if (this.connection && this.connection.readyState === WebSocket.OPEN) {
      this.connection.send(JSON.stringify(event));
    }
  }
  async open() {
    if (this.connection) {
      return;
    }
    if (this.config.heartInterval > 0) {
      this.heartbeatRef = setInterval(() => {
        if (this.connection && this.connection.readyState === WebSocket.OPEN) {
          this.connection.send(JSON.stringify(new OB11HeartbeatEvent(this.core, this.config.heartInterval, this.core.selfInfo.online ?? true, true)));
        }
      }, this.config.heartInterval);
    }
    this.isEnable = true;
    await this.tryConnect();
  }
  close() {
    if (!this.isEnable) {
      this.logger.logDebug("Cannot close a closed WebSocket connection");
      return;
    }
    this.isEnable = false;
    if (this.connection) {
      this.connection.close();
      this.connection = null;
    }
    if (this.heartbeatRef) {
      clearInterval(this.heartbeatRef);
      this.heartbeatRef = null;
    }
  }
  checkStateAndReply(data) {
    if (this.connection && this.connection.readyState === WebSocket.OPEN) {
      this.connection.send(JSON.stringify(data));
    }
  }
  async tryConnect() {
    if (!this.connection && this.isEnable) {
      let isClosedByError = false;
      this.connection = new WebSocket(this.config.url, {
        maxPayload: 1024 * 1024 * 1024,
        handshakeTimeout: 2e3,
        perMessageDeflate: false,
        headers: {
          "X-Self-ID": this.core.selfInfo.uin,
          "Authorization": `Bearer ${this.config.token}`,
          "x-client-role": "Universal",
          // 为koishi adpter适配
          "User-Agent": "OneBot/11"
        }
      });
      this.connection.on("ping", () => {
        this.connection?.pong();
      });
      this.connection.on("pong", () => {
      });
      this.connection.on("open", () => {
        try {
          this.connectEvent(this.core);
        } catch (e) {
          this.logger.logError("[OneBot] [WebSocket Client] 发送连接生命周期失败", e);
        }
      });
      this.connection.on("message", (data) => {
        this.handleMessage(data);
      });
      this.connection.once("close", () => {
        if (!isClosedByError) {
          this.logger.logError(`[OneBot] [WebSocket Client] 反向WebSocket (${this.config.url}) 连接意外关闭`);
          this.logger.logError(`[OneBot] [WebSocket Client] 在 ${Math.floor(this.config.reconnectInterval / 1e3)} 秒后尝试重新连接`);
          if (this.isEnable) {
            this.connection = null;
            setTimeout(() => this.tryConnect(), this.config.reconnectInterval);
          }
        }
      });
      this.connection.on("error", (err) => {
        isClosedByError = true;
        this.logger.logError(`[OneBot] [WebSocket Client] 反向WebSocket (${this.config.url}) 连接错误`, err);
        this.logger.logError(`[OneBot] [WebSocket Client] 在 ${Math.floor(this.config.reconnectInterval / 1e3)} 秒后尝试重新连接`);
        if (this.isEnable) {
          this.connection = null;
          setTimeout(() => this.tryConnect(), this.config.reconnectInterval);
        }
      });
    }
  }
  connectEvent(core) {
    try {
      this.checkStateAndReply(new OB11LifeCycleEvent(core, LifeCycleSubType.CONNECT));
    } catch (e) {
      this.logger.logError("[OneBot] [WebSocket Client] 发送生命周期失败", e);
    }
  }
  async handleMessage(message) {
    let receiveData = { action: ActionName.Unknown, params: {} };
    let echo = void 0;
    try {
      receiveData = JSON.parse(message.toString());
      echo = receiveData.echo;
      this.logger.logDebug("[OneBot] [WebSocket Client] 收到正向Websocket消息", receiveData);
    } catch (e) {
      this.checkStateAndReply(OB11Response.error("json解析失败,请检查数据格式", 1400, echo));
      return;
    }
    receiveData.params = receiveData?.params ? receiveData.params : {};
    const action = this.actions.get(receiveData.action);
    if (!action) {
      this.logger.logError("[OneBot] [WebSocket Client] 发生错误", "不支持的Api " + receiveData.action);
      this.checkStateAndReply(OB11Response.error("不支持的Api " + receiveData.action, 1404, echo));
      return;
    }
    const retdata = await action.websocketHandle(receiveData.params, echo ?? "", this.name);
    this.checkStateAndReply({ ...retdata });
  }
  async reload(newConfig) {
    const wasEnabled = this.isEnable;
    const oldUrl = this.config.url;
    const oldHeartInterval = this.config.heartInterval;
    this.config = newConfig;
    if (newConfig.enable && !wasEnabled) {
      this.open();
      return OB11NetworkReloadType.NetWorkOpen;
    } else if (!newConfig.enable && wasEnabled) {
      this.close();
      return OB11NetworkReloadType.NetWorkClose;
    }
    if (oldUrl !== newConfig.url) {
      this.close();
      if (newConfig.enable) {
        this.open();
      }
      return OB11NetworkReloadType.NetWorkReload;
    }
    if (oldHeartInterval !== newConfig.heartInterval) {
      if (this.heartbeatRef) {
        clearInterval(this.heartbeatRef);
        this.heartbeatRef = null;
      }
      if (newConfig.heartInterval > 0 && this.isEnable) {
        this.heartbeatRef = setInterval(() => {
          if (this.connection && this.connection.readyState === WebSocket.OPEN) {
            this.connection.send(JSON.stringify(new OB11HeartbeatEvent(this.core, newConfig.heartInterval, this.core.selfInfo.online ?? true, true)));
          }
        }, newConfig.heartInterval);
      }
      return OB11NetworkReloadType.NetWorkReload;
    }
    return OB11NetworkReloadType.Normal;
  }
}

var lib = {exports: {}};

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

var objectAssign;
var hasRequiredObjectAssign;

function requireObjectAssign () {
	if (hasRequiredObjectAssign) return objectAssign;
	hasRequiredObjectAssign = 1;
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};
	return objectAssign;
}

var vary = {exports: {}};

/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

var hasRequiredVary;

function requireVary () {
	if (hasRequiredVary) return vary.exports;
	hasRequiredVary = 1;

	/**
	 * Module exports.
	 */

	vary.exports = vary$1;
	vary.exports.append = append;

	/**
	 * RegExp to match field-name in RFC 7230 sec 3.2
	 *
	 * field-name    = token
	 * token         = 1*tchar
	 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	 *               / DIGIT / ALPHA
	 *               ; any VCHAR, except delimiters
	 */

	var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

	/**
	 * Append a field to a vary header.
	 *
	 * @param {String} header
	 * @param {String|Array} field
	 * @return {String}
	 * @public
	 */

	function append (header, field) {
	  if (typeof header !== 'string') {
	    throw new TypeError('header argument is required')
	  }

	  if (!field) {
	    throw new TypeError('field argument is required')
	  }

	  // get fields array
	  var fields = !Array.isArray(field)
	    ? parse(String(field))
	    : field;

	  // assert on invalid field names
	  for (var j = 0; j < fields.length; j++) {
	    if (!FIELD_NAME_REGEXP.test(fields[j])) {
	      throw new TypeError('field argument contains an invalid header name')
	    }
	  }

	  // existing, unspecified vary
	  if (header === '*') {
	    return header
	  }

	  // enumerate current values
	  var val = header;
	  var vals = parse(header.toLowerCase());

	  // unspecified vary
	  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
	    return '*'
	  }

	  for (var i = 0; i < fields.length; i++) {
	    var fld = fields[i].toLowerCase();

	    // append value (case-preserving)
	    if (vals.indexOf(fld) === -1) {
	      vals.push(fld);
	      val = val
	        ? val + ', ' + fields[i]
	        : fields[i];
	    }
	  }

	  return val
	}

	/**
	 * Parse a vary header into an array.
	 *
	 * @param {String} header
	 * @return {Array}
	 * @private
	 */

	function parse (header) {
	  var end = 0;
	  var list = [];
	  var start = 0;

	  // gather tokens
	  for (var i = 0, len = header.length; i < len; i++) {
	    switch (header.charCodeAt(i)) {
	      case 0x20: /*   */
	        if (start === end) {
	          start = end = i + 1;
	        }
	        break
	      case 0x2c: /* , */
	        list.push(header.substring(start, end));
	        start = end = i + 1;
	        break
	      default:
	        end = i + 1;
	        break
	    }
	  }

	  // final token
	  list.push(header.substring(start, end));

	  return list
	}

	/**
	 * Mark that a request is varied on a header field.
	 *
	 * @param {Object} res
	 * @param {String|Array} field
	 * @public
	 */

	function vary$1 (res, field) {
	  if (!res || !res.getHeader || !res.setHeader) {
	    // quack quack
	    throw new TypeError('res argument is required')
	  }

	  // get existing header
	  var val = res.getHeader('Vary') || '';
	  var header = Array.isArray(val)
	    ? val.join(', ')
	    : String(val);

	  // set new header
	  if ((val = append(header, field))) {
	    res.setHeader('Vary', val);
	  }
	}
	return vary.exports;
}

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib.exports;
	hasRequiredLib = 1;
	(function () {

	  var assign = requireObjectAssign();
	  var vary = requireVary();

	  var defaults = {
	    origin: '*',
	    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
	    preflightContinue: false,
	    optionsSuccessStatus: 204
	  };

	  function isString(s) {
	    return typeof s === 'string' || s instanceof String;
	  }

	  function isOriginAllowed(origin, allowedOrigin) {
	    if (Array.isArray(allowedOrigin)) {
	      for (var i = 0; i < allowedOrigin.length; ++i) {
	        if (isOriginAllowed(origin, allowedOrigin[i])) {
	          return true;
	        }
	      }
	      return false;
	    } else if (isString(allowedOrigin)) {
	      return origin === allowedOrigin;
	    } else if (allowedOrigin instanceof RegExp) {
	      return allowedOrigin.test(origin);
	    } else {
	      return !!allowedOrigin;
	    }
	  }

	  function configureOrigin(options, req) {
	    var requestOrigin = req.headers.origin,
	      headers = [],
	      isAllowed;

	    if (!options.origin || options.origin === '*') {
	      // allow any origin
	      headers.push([{
	        key: 'Access-Control-Allow-Origin',
	        value: '*'
	      }]);
	    } else if (isString(options.origin)) {
	      // fixed origin
	      headers.push([{
	        key: 'Access-Control-Allow-Origin',
	        value: options.origin
	      }]);
	      headers.push([{
	        key: 'Vary',
	        value: 'Origin'
	      }]);
	    } else {
	      isAllowed = isOriginAllowed(requestOrigin, options.origin);
	      // reflect origin
	      headers.push([{
	        key: 'Access-Control-Allow-Origin',
	        value: isAllowed ? requestOrigin : false
	      }]);
	      headers.push([{
	        key: 'Vary',
	        value: 'Origin'
	      }]);
	    }

	    return headers;
	  }

	  function configureMethods(options) {
	    var methods = options.methods;
	    if (methods.join) {
	      methods = options.methods.join(','); // .methods is an array, so turn it into a string
	    }
	    return {
	      key: 'Access-Control-Allow-Methods',
	      value: methods
	    };
	  }

	  function configureCredentials(options) {
	    if (options.credentials === true) {
	      return {
	        key: 'Access-Control-Allow-Credentials',
	        value: 'true'
	      };
	    }
	    return null;
	  }

	  function configureAllowedHeaders(options, req) {
	    var allowedHeaders = options.allowedHeaders || options.headers;
	    var headers = [];

	    if (!allowedHeaders) {
	      allowedHeaders = req.headers['access-control-request-headers']; // .headers wasn't specified, so reflect the request headers
	      headers.push([{
	        key: 'Vary',
	        value: 'Access-Control-Request-Headers'
	      }]);
	    } else if (allowedHeaders.join) {
	      allowedHeaders = allowedHeaders.join(','); // .headers is an array, so turn it into a string
	    }
	    if (allowedHeaders && allowedHeaders.length) {
	      headers.push([{
	        key: 'Access-Control-Allow-Headers',
	        value: allowedHeaders
	      }]);
	    }

	    return headers;
	  }

	  function configureExposedHeaders(options) {
	    var headers = options.exposedHeaders;
	    if (!headers) {
	      return null;
	    } else if (headers.join) {
	      headers = headers.join(','); // .headers is an array, so turn it into a string
	    }
	    if (headers && headers.length) {
	      return {
	        key: 'Access-Control-Expose-Headers',
	        value: headers
	      };
	    }
	    return null;
	  }

	  function configureMaxAge(options) {
	    var maxAge = (typeof options.maxAge === 'number' || options.maxAge) && options.maxAge.toString();
	    if (maxAge && maxAge.length) {
	      return {
	        key: 'Access-Control-Max-Age',
	        value: maxAge
	      };
	    }
	    return null;
	  }

	  function applyHeaders(headers, res) {
	    for (var i = 0, n = headers.length; i < n; i++) {
	      var header = headers[i];
	      if (header) {
	        if (Array.isArray(header)) {
	          applyHeaders(header, res);
	        } else if (header.key === 'Vary' && header.value) {
	          vary(res, header.value);
	        } else if (header.value) {
	          res.setHeader(header.key, header.value);
	        }
	      }
	    }
	  }

	  function cors(options, req, res, next) {
	    var headers = [],
	      method = req.method && req.method.toUpperCase && req.method.toUpperCase();

	    if (method === 'OPTIONS') {
	      // preflight
	      headers.push(configureOrigin(options, req));
	      headers.push(configureCredentials(options));
	      headers.push(configureMethods(options));
	      headers.push(configureAllowedHeaders(options, req));
	      headers.push(configureMaxAge(options));
	      headers.push(configureExposedHeaders(options));
	      applyHeaders(headers, res);

	      if (options.preflightContinue) {
	        next();
	      } else {
	        // Safari (and potentially other browsers) need content-length 0,
	        //   for 204 or they just hang waiting for a body
	        res.statusCode = options.optionsSuccessStatus;
	        res.setHeader('Content-Length', '0');
	        res.end();
	      }
	    } else {
	      // actual response
	      headers.push(configureOrigin(options, req));
	      headers.push(configureCredentials(options));
	      headers.push(configureExposedHeaders(options));
	      applyHeaders(headers, res);
	      next();
	    }
	  }

	  function middlewareWrapper(o) {
	    // if options are static (either via defaults or custom options passed in), wrap in a function
	    var optionsCallback = null;
	    if (typeof o === 'function') {
	      optionsCallback = o;
	    } else {
	      optionsCallback = function (req, cb) {
	        cb(null, o);
	      };
	    }

	    return function corsMiddleware(req, res, next) {
	      optionsCallback(req, function (err, options) {
	        if (err) {
	          next(err);
	        } else {
	          var corsOptions = assign({}, defaults, options);
	          var originCallback = null;
	          if (corsOptions.origin && typeof corsOptions.origin === 'function') {
	            originCallback = corsOptions.origin;
	          } else if (corsOptions.origin) {
	            originCallback = function (origin, cb) {
	              cb(null, corsOptions.origin);
	            };
	          }

	          if (originCallback) {
	            originCallback(req.headers.origin, function (err2, origin) {
	              if (err2 || !origin) {
	                next(err2);
	              } else {
	                corsOptions.origin = origin;
	                cors(corsOptions, req, res, next);
	              }
	            });
	          } else {
	            next();
	          }
	        }
	      });
	    };
	  }

	  // can pass either an options hash, an options delegate, or nothing
	  lib.exports = middlewareWrapper;

	}());
	return lib.exports;
}

var libExports = requireLib();
const cors$1 = /*@__PURE__*/getDefaultExportFromCjs(libExports);

class OB11PassiveHttpAdapter {
  constructor(name, config, core, actions) {
    this.name = name;
    this.core = core;
    this.actions = actions;
    this.config = structuredClone(config);
  }
  app;
  server;
  isEnable = false;
  config;
  onEvent() {
  }
  open() {
    try {
      if (this.isEnable) {
        this.core.context.logger.logError("Cannot open a closed HTTP server");
        return;
      }
      if (!this.isEnable) {
        this.initializeServer();
        this.isEnable = true;
      }
    } catch (e) {
      this.core.context.logger.logError(`[OneBot] [HTTP Server Adapter] Boot Error: ${e}`);
    }
  }
  async close() {
    this.isEnable = false;
    this.server?.close();
    this.app = void 0;
  }
  initializeServer() {
    this.app = express();
    this.server = require$$0$4.createServer(this.app);
    this.app.use(cors$1());
    this.app.use(express.urlencoded({ extended: true, limit: "5000mb" }));
    this.app.use((req, res, next) => {
      req.headers["content-type"] = "application/json";
      const originalJson = express.json({ limit: "5000mb" });
      originalJson(req, res, (err) => {
        if (err) {
          return res.status(400).send("Invalid JSON");
        }
        next();
      });
    });
    this.app.use((req, res, next) => this.authorize(this.config.token, req, res, next));
    this.app.use(async (req, res, _) => {
      await this.handleRequest(req, res);
    });
    this.server.listen(this.config.port, () => {
      this.core.context.logger.log(`[OneBot] [HTTP Server Adapter] Start On Port ${this.config.port}`);
    });
  }
  authorize(token, req, res, next) {
    if (!token || token.length == 0) return next();
    const HeaderClientToken = req.headers.authorization?.split("Bearer ").pop() || "";
    const QueryClientToken = req.query.access_token;
    const ClientToken = typeof QueryClientToken === "string" && QueryClientToken !== "" ? QueryClientToken : HeaderClientToken;
    if (ClientToken === token) {
      return next();
    } else {
      return res.status(403).send(JSON.stringify({ message: "token verify failed!" }));
    }
  }
  async handleRequest(req, res) {
    if (!this.isEnable) {
      this.core.context.logger.log(`[OneBot] [HTTP Server Adapter] Server is closed`);
      return res.json(OB11Response.error("Server is closed", 200));
    }
    let payload = req.body;
    if (req.method == "get") {
      payload = req.query;
    } else if (req.query) {
      payload = { ...req.query, ...req.body };
    }
    if (req.path === "" || req.path === "/") {
      const hello = OB11Response.ok({});
      hello.message = "NapCat4 Ss Running";
      return res.json(hello);
    }
    const actionName = req.path.split("/")[1];
    const action = this.actions.get(actionName);
    if (action) {
      try {
        const result = await action.handle(payload, this.name);
        return res.json(result);
      } catch (error) {
        return res.json(OB11Response.error(error?.stack?.toString() || error?.message || "Error Handle", 200));
      }
    } else {
      return res.json(OB11Response.error("不支持的Api " + actionName, 200));
    }
  }
  async reload(newConfig) {
    const wasEnabled = this.isEnable;
    const oldPort = this.config.port;
    this.config = newConfig;
    if (newConfig.enable && !wasEnabled) {
      this.open();
      return OB11NetworkReloadType.NetWorkOpen;
    } else if (!newConfig.enable && wasEnabled) {
      this.close();
      return OB11NetworkReloadType.NetWorkClose;
    }
    if (oldPort !== newConfig.port) {
      this.close();
      if (newConfig.enable) {
        this.open();
      }
      return OB11NetworkReloadType.NetWorkReload;
    }
    return OB11NetworkReloadType.Normal;
  }
}

const E_CANCELED = new Error('request for lock canceled');

var __awaiter$2 = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Semaphore {
    constructor(_value, _cancelError = E_CANCELED) {
        this._value = _value;
        this._cancelError = _cancelError;
        this._queue = [];
        this._weightedWaiters = [];
    }
    acquire(weight = 1, priority = 0) {
        if (weight <= 0)
            throw new Error(`invalid weight ${weight}: must be positive`);
        return new Promise((resolve, reject) => {
            const task = { resolve, reject, weight, priority };
            const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);
            if (i === -1 && weight <= this._value) {
                // Needs immediate dispatch, skip the queue
                this._dispatchItem(task);
            }
            else {
                this._queue.splice(i + 1, 0, task);
            }
        });
    }
    runExclusive(callback_1) {
        return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {
            const [value, release] = yield this.acquire(weight, priority);
            try {
                return yield callback(value);
            }
            finally {
                release();
            }
        });
    }
    waitForUnlock(weight = 1, priority = 0) {
        if (weight <= 0)
            throw new Error(`invalid weight ${weight}: must be positive`);
        if (this._couldLockImmediately(weight, priority)) {
            return Promise.resolve();
        }
        else {
            return new Promise((resolve) => {
                if (!this._weightedWaiters[weight - 1])
                    this._weightedWaiters[weight - 1] = [];
                insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });
            });
        }
    }
    isLocked() {
        return this._value <= 0;
    }
    getValue() {
        return this._value;
    }
    setValue(value) {
        this._value = value;
        this._dispatchQueue();
    }
    release(weight = 1) {
        if (weight <= 0)
            throw new Error(`invalid weight ${weight}: must be positive`);
        this._value += weight;
        this._dispatchQueue();
    }
    cancel() {
        this._queue.forEach((entry) => entry.reject(this._cancelError));
        this._queue = [];
    }
    _dispatchQueue() {
        this._drainUnlockWaiters();
        while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
            this._dispatchItem(this._queue.shift());
            this._drainUnlockWaiters();
        }
    }
    _dispatchItem(item) {
        const previousValue = this._value;
        this._value -= item.weight;
        item.resolve([previousValue, this._newReleaser(item.weight)]);
    }
    _newReleaser(weight) {
        let called = false;
        return () => {
            if (called)
                return;
            called = true;
            this.release(weight);
        };
    }
    _drainUnlockWaiters() {
        if (this._queue.length === 0) {
            for (let weight = this._value; weight > 0; weight--) {
                const waiters = this._weightedWaiters[weight - 1];
                if (!waiters)
                    continue;
                waiters.forEach((waiter) => waiter.resolve());
                this._weightedWaiters[weight - 1] = [];
            }
        }
        else {
            const queuedPriority = this._queue[0].priority;
            for (let weight = this._value; weight > 0; weight--) {
                const waiters = this._weightedWaiters[weight - 1];
                if (!waiters)
                    continue;
                const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);
                (i === -1 ? waiters : waiters.splice(0, i))
                    .forEach((waiter => waiter.resolve()));
            }
        }
    }
    _couldLockImmediately(weight, priority) {
        return (this._queue.length === 0 || this._queue[0].priority < priority) &&
            weight <= this._value;
    }
}
function insertSorted(a, v) {
    const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);
    a.splice(i + 1, 0, v);
}
function findIndexFromEnd(a, predicate) {
    for (let i = a.length - 1; i >= 0; i--) {
        if (predicate(a[i])) {
            return i;
        }
    }
    return -1;
}

var __awaiter$1 = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Mutex {
    constructor(cancelError) {
        this._semaphore = new Semaphore(1, cancelError);
    }
    acquire() {
        return __awaiter$1(this, arguments, void 0, function* (priority = 0) {
            const [, releaser] = yield this._semaphore.acquire(1, priority);
            return releaser;
        });
    }
    runExclusive(callback, priority = 0) {
        return this._semaphore.runExclusive(() => callback(), 1, priority);
    }
    isLocked() {
        return this._semaphore.isLocked();
    }
    waitForUnlock(priority = 0) {
        return this._semaphore.waitForUnlock(1, priority);
    }
    release() {
        if (this._semaphore.isLocked())
            this._semaphore.release();
    }
    cancel() {
        return this._semaphore.cancel();
    }
}

class OB11PassiveWebSocketAdapter {
  constructor(name, config, core, actions) {
    this.name = name;
    this.core = core;
    this.actions = actions;
    this.config = structuredClone(config);
    this.logger = core.context.logger;
    this.wsServer = new WebSocketServer({
      port: this.config.port,
      host: this.config.host === "0.0.0.0" ? "" : this.config.host,
      maxPayload: 1024 * 1024 * 1024
    });
    this.wsServer.on("connection", async (wsClient, wsReq) => {
      if (!this.isEnable) {
        wsClient.close();
        return;
      }
      this.authorize(this.config.token, wsClient, wsReq);
      const paramUrl = wsReq.url?.indexOf("?") !== -1 ? wsReq.url?.substring(0, wsReq.url?.indexOf("?")) : wsReq.url;
      const isApiConnect = paramUrl === "/api" || paramUrl === "/api/";
      if (!isApiConnect) {
        this.connectEvent(core, wsClient);
      }
      wsClient.on("error", (err) => this.logger.log("[OneBot] [WebSocket Server] Client Error:", err.message));
      wsClient.on("message", (message) => {
        this.handleMessage(wsClient, message).then().catch((e) => this.logger.logError(e));
      });
      wsClient.on("ping", () => {
        wsClient.pong();
      });
      wsClient.on("pong", () => {
      });
      wsClient.once("close", () => {
        this.wsClientsMutex.runExclusive(async () => {
          const NormolIndex = this.wsClients.indexOf(wsClient);
          if (NormolIndex !== -1) {
            this.wsClients.splice(NormolIndex, 1);
          }
          const EventIndex = this.wsClientWithEvent.indexOf(wsClient);
          if (EventIndex !== -1) {
            this.wsClientWithEvent.splice(EventIndex, 1);
          }
        });
      });
      await this.wsClientsMutex.runExclusive(async () => {
        if (!isApiConnect) {
          this.wsClientWithEvent.push(wsClient);
        }
        this.wsClients.push(wsClient);
      });
    }).on("error", (err) => this.logger.log("[OneBot] [WebSocket Server] Server Error:", err.message));
  }
  wsServer;
  wsClients = [];
  wsClientsMutex = new Mutex();
  isEnable = false;
  heartbeatInterval = 0;
  logger;
  config;
  heartbeatIntervalId = null;
  wsClientWithEvent = [];
  connectEvent(core, wsClient) {
    try {
      this.checkStateAndReply(new OB11LifeCycleEvent(core, LifeCycleSubType.CONNECT), wsClient);
    } catch (e) {
      this.logger.logError("[OneBot] [WebSocket Server] 发送生命周期失败", e);
    }
  }
  onEvent(event) {
    this.wsClientsMutex.runExclusive(async () => {
      this.wsClientWithEvent.forEach((wsClient) => {
        wsClient.send(JSON.stringify(event));
      });
    });
  }
  open() {
    if (this.isEnable) {
      this.logger.logError("[OneBot] [WebSocket Server] Cannot open a opened WebSocket server");
      return;
    }
    const addressInfo = this.wsServer.address();
    this.logger.log("[OneBot] [WebSocket Server] Server Started", typeof addressInfo === "string" ? addressInfo : addressInfo?.address + ":" + addressInfo?.port);
    this.isEnable = true;
    if (this.heartbeatInterval > 0) {
      this.registerHeartBeat();
    }
  }
  async close() {
    this.isEnable = false;
    this.wsServer.close((err) => {
      if (err) {
        this.logger.logError("[OneBot] [WebSocket Server] Error closing server:", err.message);
      } else {
        this.logger.log("[OneBot] [WebSocket Server] Server Closed");
      }
    });
    if (this.heartbeatIntervalId) {
      clearInterval(this.heartbeatIntervalId);
      this.heartbeatIntervalId = null;
    }
    await this.wsClientsMutex.runExclusive(async () => {
      this.wsClients.forEach((wsClient) => {
        wsClient.close();
      });
      this.wsClients = [];
      this.wsClientWithEvent = [];
    });
  }
  registerHeartBeat() {
    this.heartbeatIntervalId = setInterval(() => {
      this.wsClientsMutex.runExclusive(async () => {
        this.wsClientWithEvent.forEach((wsClient) => {
          if (wsClient.readyState === WebSocket.OPEN) {
            wsClient.send(JSON.stringify(new OB11HeartbeatEvent(this.core, this.heartbeatInterval, this.core.selfInfo.online ?? true, true)));
          }
        });
      });
    }, this.heartbeatInterval);
  }
  authorize(token, wsClient, wsReq) {
    if (!token || token.length == 0) return;
    const QueryClientToken = urlParse.parse(wsReq?.url || "", true).query.access_token;
    const HeaderClientToken = wsReq.headers.authorization?.split("Bearer ").pop() || "";
    const ClientToken = typeof QueryClientToken === "string" && QueryClientToken !== "" ? QueryClientToken : HeaderClientToken;
    if (ClientToken === token) {
      return;
    }
    wsClient.send(JSON.stringify(OB11Response.res(null, "failed", 1403, "token验证失败")));
    wsClient.close();
  }
  checkStateAndReply(data, wsClient) {
    if (wsClient.readyState === WebSocket.OPEN) {
      wsClient.send(JSON.stringify(data));
    }
  }
  async handleMessage(wsClient, message) {
    let receiveData = { action: ActionName.Unknown, params: {} };
    let echo = void 0;
    try {
      receiveData = JSON.parse(message.toString());
      echo = receiveData.echo;
    } catch (e) {
      this.checkStateAndReply(OB11Response.error("json解析失败,请检查数据格式", 1400, echo), wsClient);
      return;
    }
    receiveData.params = receiveData?.params ? receiveData.params : {};
    const action = this.actions.get(receiveData.action);
    if (!action) {
      this.logger.logError("[OneBot] [WebSocket Client] 发生错误", "不支持的API " + receiveData.action);
      this.checkStateAndReply(OB11Response.error("不支持的API " + receiveData.action, 1404, echo), wsClient);
      return;
    }
    const retdata = await action.websocketHandle(receiveData.params, echo ?? "", this.name);
    this.checkStateAndReply({ ...retdata }, wsClient);
  }
  async reload(newConfig) {
    const wasEnabled = this.isEnable;
    const oldPort = this.config.port;
    const oldHost = this.config.host;
    const oldHeartbeatInterval = this.heartbeatInterval;
    this.config = newConfig;
    if (newConfig.enable && !wasEnabled) {
      this.open();
      return OB11NetworkReloadType.NetWorkOpen;
    } else if (!newConfig.enable && wasEnabled) {
      this.close();
      return OB11NetworkReloadType.NetWorkClose;
    }
    if (oldPort !== newConfig.port || oldHost !== newConfig.host) {
      this.close();
      this.wsServer = new WebSocketServer({
        port: newConfig.port,
        host: newConfig.host === "0.0.0.0" ? "" : newConfig.host,
        maxPayload: 1024 * 1024 * 1024
      });
      if (newConfig.enable) {
        this.open();
      }
      return OB11NetworkReloadType.NetWorkReload;
    }
    if (oldHeartbeatInterval !== newConfig.heartInterval) {
      if (this.heartbeatIntervalId) {
        clearInterval(this.heartbeatIntervalId);
        this.heartbeatIntervalId = null;
      }
      this.heartbeatInterval = newConfig.heartInterval;
      if (newConfig.heartInterval > 0 && this.isEnable) {
        this.registerHeartBeat();
      }
      return OB11NetworkReloadType.NetWorkReload;
    }
    return OB11NetworkReloadType.Normal;
  }
}

var OB11NetworkReloadType = /* @__PURE__ */ ((OB11NetworkReloadType2) => {
  OB11NetworkReloadType2[OB11NetworkReloadType2["Normal"] = 0] = "Normal";
  OB11NetworkReloadType2[OB11NetworkReloadType2["ConfigChange"] = 1] = "ConfigChange";
  OB11NetworkReloadType2[OB11NetworkReloadType2["NetWorkReload"] = 2] = "NetWorkReload";
  OB11NetworkReloadType2[OB11NetworkReloadType2["NetWorkClose"] = 3] = "NetWorkClose";
  OB11NetworkReloadType2[OB11NetworkReloadType2["NetWorkOpen"] = 4] = "NetWorkOpen";
  return OB11NetworkReloadType2;
})(OB11NetworkReloadType || {});
class OB11NetworkManager {
  adapters = /* @__PURE__ */ new Map();
  async openAllAdapters() {
    return Promise.all(Array.from(this.adapters.values()).map((adapter) => adapter.open()));
  }
  async emitEvent(event) {
    return Promise.all(Array.from(this.adapters.values()).map((adapter) => adapter.onEvent(event)));
  }
  async emitEvents(events) {
    return Promise.all(events.map((event) => this.emitEvent(event)));
  }
  async emitEventByName(names, event) {
    return Promise.all(names.map((name) => {
      const adapter = this.adapters.get(name);
      if (adapter) {
        return adapter.onEvent(event);
      }
    }));
  }
  async emitEventByNames(map) {
    return Promise.all(Array.from(map.entries()).map(([name, event]) => {
      const adapter = this.adapters.get(name);
      if (adapter) {
        return adapter.onEvent(event);
      }
    }));
  }
  registerAdapter(adapter) {
    this.adapters.set(adapter.name, adapter);
  }
  async registerAdapterAndOpen(adapter) {
    this.registerAdapter(adapter);
    await adapter.open();
  }
  async closeSomeAdapters(adaptersToClose) {
    for (const adapter of adaptersToClose) {
      this.adapters.delete(adapter.name);
      await adapter.close();
    }
  }
  async closeSomeAdaterWhenOpen(adaptersToClose) {
    for (const adapter of adaptersToClose) {
      this.adapters.delete(adapter.name);
      if (adapter.isEnable) {
        await adapter.close();
      }
    }
  }
  findSomeAdapter(name) {
    return this.adapters.get(name);
  }
  async closeAdapterByPredicate(closeFilter) {
    const adaptersToClose = Array.from(this.adapters.values()).filter(closeFilter);
    await this.closeSomeAdapters(adaptersToClose);
  }
  async closeAllAdapters() {
    await Promise.all(Array.from(this.adapters.values()).map((adapter) => adapter.close()));
    this.adapters.clear();
  }
  async readloadAdapter(name, config) {
    const adapter = this.adapters.get(name);
    if (adapter) {
      await adapter.reload(config);
    }
  }
  async readloadSomeAdapters(configMap) {
    await Promise.all(Array.from(configMap.entries()).map(([name, config]) => this.readloadAdapter(name, config)));
  }
}

class OB11BaseNoticeEvent extends OneBotEvent {
  post_type = EventType.NOTICE;
}

class OB11PokeEvent extends OB11BaseNoticeEvent {
  notice_type = "notify";
  sub_type = "poke";
  target_id = 0;
  user_id = 0;
}
class OB11FriendPokeEvent extends OB11PokeEvent {
  raw_info;
  //raw_message nb等框架标准为string
  constructor(core, user_id, target_id, raw_message) {
    super(core);
    this.target_id = target_id;
    this.user_id = user_id;
    this.raw_info = raw_message;
  }
}
class OB11GroupPokeEvent extends OB11PokeEvent {
  group_id;
  raw_info;
  //raw_message nb等框架标准为string
  constructor(core, group_id, user_id, target_id, raw_message) {
    super(core);
    this.group_id = group_id;
    this.target_id = target_id;
    this.user_id = user_id;
    this.raw_info = raw_message;
  }
}

class OneBotFriendApi {
  obContext;
  core;
  friendList = /* @__PURE__ */ new Map();
  //此处作为缓存 uin->info
  constructor(obContext, core) {
    this.obContext = obContext;
    this.core = core;
  }
  //使用前预先判断 busiId 1061
  async parsePrivatePokeEvent(grayTipElement) {
    const json = JSON.parse(grayTipElement.jsonGrayTipElement.jsonStr);
    let pokedetail = json.items;
    pokedetail = pokedetail.filter((item) => item.uid);
    if (pokedetail.length == 2) {
      return new OB11FriendPokeEvent(
        this.core,
        parseInt(await this.core.apis.UserApi.getUinByUidV2(pokedetail[0].uid)),
        parseInt(await this.core.apis.UserApi.getUinByUidV2(pokedetail[1].uid)),
        pokedetail
      );
    }
    return void 0;
  }
}

class OB11GroupNoticeEvent extends OB11BaseNoticeEvent {
  group_id;
  user_id;
  constructor(core, group_id, user_id) {
    super(core);
    this.group_id = group_id;
    this.user_id = user_id;
  }
}

class OB11GroupBanEvent extends OB11GroupNoticeEvent {
  notice_type = "group_ban";
  operator_id;
  duration;
  sub_type;
  constructor(core, groupId, userId, operatorId, duration, sub_type) {
    super(core, groupId, userId);
    this.group_id = groupId;
    this.operator_id = operatorId;
    this.user_id = userId;
    this.duration = duration;
    this.sub_type = sub_type;
  }
}

var validator = {};

var util = {};

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	(function (exports) {

		const nameStartChar = ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
		const nameChar = nameStartChar + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
		const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*';
		const regexName = new RegExp('^' + nameRegexp + '$');

		const getAllMatches = function(string, regex) {
		  const matches = [];
		  let match = regex.exec(string);
		  while (match) {
		    const allmatches = [];
		    allmatches.startIndex = regex.lastIndex - match[0].length;
		    const len = match.length;
		    for (let index = 0; index < len; index++) {
		      allmatches.push(match[index]);
		    }
		    matches.push(allmatches);
		    match = regex.exec(string);
		  }
		  return matches;
		};

		const isName = function(string) {
		  const match = regexName.exec(string);
		  return !(match === null || typeof match === 'undefined');
		};

		exports.isExist = function(v) {
		  return typeof v !== 'undefined';
		};

		exports.isEmptyObject = function(obj) {
		  return Object.keys(obj).length === 0;
		};

		/**
		 * Copy all the properties of a into b.
		 * @param {*} target
		 * @param {*} a
		 */
		exports.merge = function(target, a, arrayMode) {
		  if (a) {
		    const keys = Object.keys(a); // will return an array of own properties
		    const len = keys.length; //don't make it inline
		    for (let i = 0; i < len; i++) {
		      if (arrayMode === 'strict') {
		        target[keys[i]] = [ a[keys[i]] ];
		      } else {
		        target[keys[i]] = a[keys[i]];
		      }
		    }
		  }
		};
		/* exports.merge =function (b,a){
		  return Object.assign(b,a);
		} */

		exports.getValue = function(v) {
		  if (exports.isExist(v)) {
		    return v;
		  } else {
		    return '';
		  }
		};

		// const fakeCall = function(a) {return a;};
		// const fakeCallNoReturn = function() {};

		exports.isName = isName;
		exports.getAllMatches = getAllMatches;
		exports.nameRegexp = nameRegexp; 
	} (util));
	return util;
}

var hasRequiredValidator;

function requireValidator () {
	if (hasRequiredValidator) return validator;
	hasRequiredValidator = 1;

	const util = requireUtil();

	const defaultOptions = {
	  allowBooleanAttributes: false, //A tag can have attributes without any value
	  unpairedTags: []
	};

	//const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
	validator.validate = function (xmlData, options) {
	  options = Object.assign({}, defaultOptions, options);

	  //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
	  //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
	  //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE
	  const tags = [];
	  let tagFound = false;

	  //indicates that the root tag has been closed (aka. depth 0 has been reached)
	  let reachedRoot = false;

	  if (xmlData[0] === '\ufeff') {
	    // check for byte order mark (BOM)
	    xmlData = xmlData.substr(1);
	  }
	  
	  for (let i = 0; i < xmlData.length; i++) {

	    if (xmlData[i] === '<' && xmlData[i+1] === '?') {
	      i+=2;
	      i = readPI(xmlData,i);
	      if (i.err) return i;
	    }else if (xmlData[i] === '<') {
	      //starting of tag
	      //read until you reach to '>' avoiding any '>' in attribute value
	      let tagStartPos = i;
	      i++;
	      
	      if (xmlData[i] === '!') {
	        i = readCommentAndCDATA(xmlData, i);
	        continue;
	      } else {
	        let closingTag = false;
	        if (xmlData[i] === '/') {
	          //closing tag
	          closingTag = true;
	          i++;
	        }
	        //read tagname
	        let tagName = '';
	        for (; i < xmlData.length &&
	          xmlData[i] !== '>' &&
	          xmlData[i] !== ' ' &&
	          xmlData[i] !== '\t' &&
	          xmlData[i] !== '\n' &&
	          xmlData[i] !== '\r'; i++
	        ) {
	          tagName += xmlData[i];
	        }
	        tagName = tagName.trim();
	        //console.log(tagName);

	        if (tagName[tagName.length - 1] === '/') {
	          //self closing tag without attributes
	          tagName = tagName.substring(0, tagName.length - 1);
	          //continue;
	          i--;
	        }
	        if (!validateTagName(tagName)) {
	          let msg;
	          if (tagName.trim().length === 0) {
	            msg = "Invalid space after '<'.";
	          } else {
	            msg = "Tag '"+tagName+"' is an invalid name.";
	          }
	          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));
	        }

	        const result = readAttributeStr(xmlData, i);
	        if (result === false) {
	          return getErrorObject('InvalidAttr', "Attributes for '"+tagName+"' have open quote.", getLineNumberForPosition(xmlData, i));
	        }
	        let attrStr = result.value;
	        i = result.index;

	        if (attrStr[attrStr.length - 1] === '/') {
	          //self closing tag
	          const attrStrStart = i - attrStr.length;
	          attrStr = attrStr.substring(0, attrStr.length - 1);
	          const isValid = validateAttributeString(attrStr, options);
	          if (isValid === true) {
	            tagFound = true;
	            //continue; //text may presents after self closing tag
	          } else {
	            //the result from the nested function returns the position of the error within the attribute
	            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
	            //this gives us the absolute index in the entire xml, which we can use to find the line at last
	            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
	          }
	        } else if (closingTag) {
	          if (!result.tagClosed) {
	            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
	          } else if (attrStr.trim().length > 0) {
	            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
	          } else if (tags.length === 0) {
	            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
	          } else {
	            const otg = tags.pop();
	            if (tagName !== otg.tagName) {
	              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
	              return getErrorObject('InvalidTag',
	                "Expected closing tag '"+otg.tagName+"' (opened in line "+openPos.line+", col "+openPos.col+") instead of closing tag '"+tagName+"'.",
	                getLineNumberForPosition(xmlData, tagStartPos));
	            }

	            //when there are no more tags, we reached the root level.
	            if (tags.length == 0) {
	              reachedRoot = true;
	            }
	          }
	        } else {
	          const isValid = validateAttributeString(attrStr, options);
	          if (isValid !== true) {
	            //the result from the nested function returns the position of the error within the attribute
	            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
	            //this gives us the absolute index in the entire xml, which we can use to find the line at last
	            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
	          }

	          //if the root level has been reached before ...
	          if (reachedRoot === true) {
	            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));
	          } else if(options.unpairedTags.indexOf(tagName) !== -1); else {
	            tags.push({tagName, tagStartPos});
	          }
	          tagFound = true;
	        }

	        //skip tag text value
	        //It may include comments and CDATA value
	        for (i++; i < xmlData.length; i++) {
	          if (xmlData[i] === '<') {
	            if (xmlData[i + 1] === '!') {
	              //comment or CADATA
	              i++;
	              i = readCommentAndCDATA(xmlData, i);
	              continue;
	            } else if (xmlData[i+1] === '?') {
	              i = readPI(xmlData, ++i);
	              if (i.err) return i;
	            } else {
	              break;
	            }
	          } else if (xmlData[i] === '&') {
	            const afterAmp = validateAmpersand(xmlData, i);
	            if (afterAmp == -1)
	              return getErrorObject('InvalidChar', "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
	            i = afterAmp;
	          }else {
	            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
	              return getErrorObject('InvalidXml', "Extra text at the end", getLineNumberForPosition(xmlData, i));
	            }
	          }
	        } //end of reading tag text value
	        if (xmlData[i] === '<') {
	          i--;
	        }
	      }
	    } else {
	      if ( isWhiteSpace(xmlData[i])) {
	        continue;
	      }
	      return getErrorObject('InvalidChar', "char '"+xmlData[i]+"' is not expected.", getLineNumberForPosition(xmlData, i));
	    }
	  }

	  if (!tagFound) {
	    return getErrorObject('InvalidXml', 'Start tag expected.', 1);
	  }else if (tags.length == 1) {
	      return getErrorObject('InvalidTag', "Unclosed tag '"+tags[0].tagName+"'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
	  }else if (tags.length > 0) {
	      return getErrorObject('InvalidXml', "Invalid '"+
	          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\r?\n/g, '')+
	          "' found.", {line: 1, col: 1});
	  }

	  return true;
	};

	function isWhiteSpace(char){
	  return char === ' ' || char === '\t' || char === '\n'  || char === '\r';
	}
	/**
	 * Read Processing insstructions and skip
	 * @param {*} xmlData
	 * @param {*} i
	 */
	function readPI(xmlData, i) {
	  const start = i;
	  for (; i < xmlData.length; i++) {
	    if (xmlData[i] == '?' || xmlData[i] == ' ') {
	      //tagname
	      const tagname = xmlData.substr(start, i - start);
	      if (i > 5 && tagname === 'xml') {
	        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));
	      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
	        //check if valid attribut string
	        i++;
	        break;
	      } else {
	        continue;
	      }
	    }
	  }
	  return i;
	}

	function readCommentAndCDATA(xmlData, i) {
	  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
	    //comment
	    for (i += 3; i < xmlData.length; i++) {
	      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {
	        i += 2;
	        break;
	      }
	    }
	  } else if (
	    xmlData.length > i + 8 &&
	    xmlData[i + 1] === 'D' &&
	    xmlData[i + 2] === 'O' &&
	    xmlData[i + 3] === 'C' &&
	    xmlData[i + 4] === 'T' &&
	    xmlData[i + 5] === 'Y' &&
	    xmlData[i + 6] === 'P' &&
	    xmlData[i + 7] === 'E'
	  ) {
	    let angleBracketsCount = 1;
	    for (i += 8; i < xmlData.length; i++) {
	      if (xmlData[i] === '<') {
	        angleBracketsCount++;
	      } else if (xmlData[i] === '>') {
	        angleBracketsCount--;
	        if (angleBracketsCount === 0) {
	          break;
	        }
	      }
	    }
	  } else if (
	    xmlData.length > i + 9 &&
	    xmlData[i + 1] === '[' &&
	    xmlData[i + 2] === 'C' &&
	    xmlData[i + 3] === 'D' &&
	    xmlData[i + 4] === 'A' &&
	    xmlData[i + 5] === 'T' &&
	    xmlData[i + 6] === 'A' &&
	    xmlData[i + 7] === '['
	  ) {
	    for (i += 8; i < xmlData.length; i++) {
	      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {
	        i += 2;
	        break;
	      }
	    }
	  }

	  return i;
	}

	const doubleQuote = '"';
	const singleQuote = "'";

	/**
	 * Keep reading xmlData until '<' is found outside the attribute value.
	 * @param {string} xmlData
	 * @param {number} i
	 */
	function readAttributeStr(xmlData, i) {
	  let attrStr = '';
	  let startChar = '';
	  let tagClosed = false;
	  for (; i < xmlData.length; i++) {
	    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
	      if (startChar === '') {
	        startChar = xmlData[i];
	      } else if (startChar !== xmlData[i]) ; else {
	        startChar = '';
	      }
	    } else if (xmlData[i] === '>') {
	      if (startChar === '') {
	        tagClosed = true;
	        break;
	      }
	    }
	    attrStr += xmlData[i];
	  }
	  if (startChar !== '') {
	    return false;
	  }

	  return {
	    value: attrStr,
	    index: i,
	    tagClosed: tagClosed
	  };
	}

	/**
	 * Select all the attributes whether valid or invalid.
	 */
	const validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g');

	//attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

	function validateAttributeString(attrStr, options) {
	  //console.log("start:"+attrStr+":end");

	  //if(attrStr.trim().length === 0) return true; //empty string

	  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
	  const attrNames = {};

	  for (let i = 0; i < matches.length; i++) {
	    if (matches[i][1].length === 0) {
	      //nospace before attribute name: a="sd"b="saf"
	      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' has no space in starting.", getPositionFromMatch(matches[i]))
	    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {
	      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' is without value.", getPositionFromMatch(matches[i]));
	    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
	      //independent attribute: ab
	      return getErrorObject('InvalidAttr', "boolean attribute '"+matches[i][2]+"' is not allowed.", getPositionFromMatch(matches[i]));
	    }
	    /* else if(matches[i][6] === undefined){//attribute without value: ab=
	                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
	                } */
	    const attrName = matches[i][2];
	    if (!validateAttrName(attrName)) {
	      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is an invalid name.", getPositionFromMatch(matches[i]));
	    }
	    if (!attrNames.hasOwnProperty(attrName)) {
	      //check for duplicate attribute.
	      attrNames[attrName] = 1;
	    } else {
	      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is repeated.", getPositionFromMatch(matches[i]));
	    }
	  }

	  return true;
	}

	function validateNumberAmpersand(xmlData, i) {
	  let re = /\d/;
	  if (xmlData[i] === 'x') {
	    i++;
	    re = /[\da-fA-F]/;
	  }
	  for (; i < xmlData.length; i++) {
	    if (xmlData[i] === ';')
	      return i;
	    if (!xmlData[i].match(re))
	      break;
	  }
	  return -1;
	}

	function validateAmpersand(xmlData, i) {
	  // https://www.w3.org/TR/xml/#dt-charref
	  i++;
	  if (xmlData[i] === ';')
	    return -1;
	  if (xmlData[i] === '#') {
	    i++;
	    return validateNumberAmpersand(xmlData, i);
	  }
	  let count = 0;
	  for (; i < xmlData.length; i++, count++) {
	    if (xmlData[i].match(/\w/) && count < 20)
	      continue;
	    if (xmlData[i] === ';')
	      break;
	    return -1;
	  }
	  return i;
	}

	function getErrorObject(code, message, lineNumber) {
	  return {
	    err: {
	      code: code,
	      msg: message,
	      line: lineNumber.line || lineNumber,
	      col: lineNumber.col,
	    },
	  };
	}

	function validateAttrName(attrName) {
	  return util.isName(attrName);
	}

	// const startsWithXML = /^xml/i;

	function validateTagName(tagname) {
	  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;
	}

	//this function returns the line number for the character at the given index
	function getLineNumberForPosition(xmlData, index) {
	  const lines = xmlData.substring(0, index).split(/\r?\n/);
	  return {
	    line: lines.length,

	    // column number is last line's length + 1, because column numbering starts at 1:
	    col: lines[lines.length - 1].length + 1
	  };
	}

	//this function returns the position of the first character of match within attrStr
	function getPositionFromMatch(match) {
	  return match.startIndex + match[1].length;
	}
	return validator;
}

var OptionsBuilder = {};

var hasRequiredOptionsBuilder;

function requireOptionsBuilder () {
	if (hasRequiredOptionsBuilder) return OptionsBuilder;
	hasRequiredOptionsBuilder = 1;
	const defaultOptions = {
	    preserveOrder: false,
	    attributeNamePrefix: '@_',
	    attributesGroupName: false,
	    textNodeName: '#text',
	    ignoreAttributes: true,
	    removeNSPrefix: false, // remove NS from tag name or attribute name if true
	    allowBooleanAttributes: false, //a tag can have attributes without any value
	    //ignoreRootElement : false,
	    parseTagValue: true,
	    parseAttributeValue: false,
	    trimValues: true, //Trim string values of tag and attributes
	    cdataPropName: false,
	    numberParseOptions: {
	      hex: true,
	      leadingZeros: true,
	      eNotation: true
	    },
	    tagValueProcessor: function(tagName, val) {
	      return val;
	    },
	    attributeValueProcessor: function(attrName, val) {
	      return val;
	    },
	    stopNodes: [], //nested tags will not be parsed even for errors
	    alwaysCreateTextNode: false,
	    isArray: () => false,
	    commentPropName: false,
	    unpairedTags: [],
	    processEntities: true,
	    htmlEntities: false,
	    ignoreDeclaration: false,
	    ignorePiTags: false,
	    transformTagName: false,
	    transformAttributeName: false,
	    updateTag: function(tagName, jPath, attrs){
	      return tagName
	    },
	    // skipEmptyListItem: false
	};
	   
	const buildOptions = function(options) {
	    return Object.assign({}, defaultOptions, options);
	};

	OptionsBuilder.buildOptions = buildOptions;
	OptionsBuilder.defaultOptions = defaultOptions;
	return OptionsBuilder;
}

var xmlNode;
var hasRequiredXmlNode;

function requireXmlNode () {
	if (hasRequiredXmlNode) return xmlNode;
	hasRequiredXmlNode = 1;

	class XmlNode{
	  constructor(tagname) {
	    this.tagname = tagname;
	    this.child = []; //nested tags, text, cdata, comments in order
	    this[":@"] = {}; //attributes map
	  }
	  add(key,val){
	    // this.child.push( {name : key, val: val, isCdata: isCdata });
	    if(key === "__proto__") key = "#__proto__";
	    this.child.push( {[key]: val });
	  }
	  addChild(node) {
	    if(node.tagname === "__proto__") node.tagname = "#__proto__";
	    if(node[":@"] && Object.keys(node[":@"]).length > 0){
	      this.child.push( { [node.tagname]: node.child, [":@"]: node[":@"] });
	    }else {
	      this.child.push( { [node.tagname]: node.child });
	    }
	  };
	}

	xmlNode = XmlNode;
	return xmlNode;
}

var DocTypeReader;
var hasRequiredDocTypeReader;

function requireDocTypeReader () {
	if (hasRequiredDocTypeReader) return DocTypeReader;
	hasRequiredDocTypeReader = 1;
	const util = requireUtil();

	//TODO: handle comments
	function readDocType(xmlData, i){
	    
	    const entities = {};
	    if( xmlData[i + 3] === 'O' &&
	         xmlData[i + 4] === 'C' &&
	         xmlData[i + 5] === 'T' &&
	         xmlData[i + 6] === 'Y' &&
	         xmlData[i + 7] === 'P' &&
	         xmlData[i + 8] === 'E')
	    {    
	        i = i+9;
	        let angleBracketsCount = 1;
	        let hasBody = false, comment = false;
	        let exp = "";
	        for(;i<xmlData.length;i++){
	            if (xmlData[i] === '<' && !comment) { //Determine the tag type
	                if( hasBody && isEntity(xmlData, i)){
	                    i += 7; 
	                    [entityName, val,i] = readEntityExp(xmlData,i+1);
	                    if(val.indexOf("&") === -1) //Parameter entities are not supported
	                        entities[ validateEntityName(entityName) ] = {
	                            regx : RegExp( `&${entityName};`,"g"),
	                            val: val
	                        };
	                }
	                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported
	                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported
	                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported
	                else if( isComment)                         comment = true;
	                else                                        throw new Error("Invalid DOCTYPE");

	                angleBracketsCount++;
	                exp = "";
	            } else if (xmlData[i] === '>') { //Read tag content
	                if(comment){
	                    if( xmlData[i - 1] === "-" && xmlData[i - 2] === "-"){
	                        comment = false;
	                        angleBracketsCount--;
	                    }
	                }else {
	                    angleBracketsCount--;
	                }
	                if (angleBracketsCount === 0) {
	                  break;
	                }
	            }else if( xmlData[i] === '['){
	                hasBody = true;
	            }else {
	                exp += xmlData[i];
	            }
	        }
	        if(angleBracketsCount !== 0){
	            throw new Error(`Unclosed DOCTYPE`);
	        }
	    }else {
	        throw new Error(`Invalid Tag instead of DOCTYPE`);
	    }
	    return {entities, i};
	}

	function readEntityExp(xmlData,i){
	    //External entities are not supported
	    //    <!ENTITY ext SYSTEM "http://normal-website.com" >

	    //Parameter entities are not supported
	    //    <!ENTITY entityname "&anotherElement;">

	    //Internal entities are supported
	    //    <!ENTITY entityname "replacement text">
	    
	    //read EntityName
	    let entityName = "";
	    for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"' ); i++) {
	        // if(xmlData[i] === " ") continue;
	        // else 
	        entityName += xmlData[i];
	    }
	    entityName = entityName.trim();
	    if(entityName.indexOf(" ") !== -1) throw new Error("External entites are not supported");

	    //read Entity Value
	    const startChar = xmlData[i++];
	    let val = "";
	    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {
	        val += xmlData[i];
	    }
	    return [entityName, val, i];
	}

	function isComment(xmlData, i){
	    if(xmlData[i+1] === '!' &&
	    xmlData[i+2] === '-' &&
	    xmlData[i+3] === '-') return true
	    return false
	}
	function isEntity(xmlData, i){
	    if(xmlData[i+1] === '!' &&
	    xmlData[i+2] === 'E' &&
	    xmlData[i+3] === 'N' &&
	    xmlData[i+4] === 'T' &&
	    xmlData[i+5] === 'I' &&
	    xmlData[i+6] === 'T' &&
	    xmlData[i+7] === 'Y') return true
	    return false
	}
	function isElement(xmlData, i){
	    if(xmlData[i+1] === '!' &&
	    xmlData[i+2] === 'E' &&
	    xmlData[i+3] === 'L' &&
	    xmlData[i+4] === 'E' &&
	    xmlData[i+5] === 'M' &&
	    xmlData[i+6] === 'E' &&
	    xmlData[i+7] === 'N' &&
	    xmlData[i+8] === 'T') return true
	    return false
	}

	function isAttlist(xmlData, i){
	    if(xmlData[i+1] === '!' &&
	    xmlData[i+2] === 'A' &&
	    xmlData[i+3] === 'T' &&
	    xmlData[i+4] === 'T' &&
	    xmlData[i+5] === 'L' &&
	    xmlData[i+6] === 'I' &&
	    xmlData[i+7] === 'S' &&
	    xmlData[i+8] === 'T') return true
	    return false
	}
	function isNotation(xmlData, i){
	    if(xmlData[i+1] === '!' &&
	    xmlData[i+2] === 'N' &&
	    xmlData[i+3] === 'O' &&
	    xmlData[i+4] === 'T' &&
	    xmlData[i+5] === 'A' &&
	    xmlData[i+6] === 'T' &&
	    xmlData[i+7] === 'I' &&
	    xmlData[i+8] === 'O' &&
	    xmlData[i+9] === 'N') return true
	    return false
	}

	function validateEntityName(name){
	    if (util.isName(name))
		return name;
	    else
	        throw new Error(`Invalid entity name ${name}`);
	}

	DocTypeReader = readDocType;
	return DocTypeReader;
}

var strnum;
var hasRequiredStrnum;

function requireStrnum () {
	if (hasRequiredStrnum) return strnum;
	hasRequiredStrnum = 1;
	const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
	const numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
	// const octRegex = /0x[a-z0-9]+/;
	// const binRegex = /0x[a-z0-9]+/;


	//polyfill
	if (!Number.parseInt && window.parseInt) {
	    Number.parseInt = window.parseInt;
	}
	if (!Number.parseFloat && window.parseFloat) {
	    Number.parseFloat = window.parseFloat;
	}

	  
	const consider = {
	    hex :  true,
	    leadingZeros: true,
	    decimalPoint: "\.",
	    eNotation: true
	    //skipLike: /regex/
	};

	function toNumber(str, options = {}){
	    // const options = Object.assign({}, consider);
	    // if(opt.leadingZeros === false){
	    //     options.leadingZeros = false;
	    // }else if(opt.hex === false){
	    //     options.hex = false;
	    // }

	    options = Object.assign({}, consider, options );
	    if(!str || typeof str !== "string" ) return str;
	    
	    let trimmedStr  = str.trim();
	    // if(trimmedStr === "0.0") return 0;
	    // else if(trimmedStr === "+0.0") return 0;
	    // else if(trimmedStr === "-0.0") return -0;

	    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;
	    else if (options.hex && hexRegex.test(trimmedStr)) {
	        return Number.parseInt(trimmedStr, 16);
	    // } else if (options.parseOct && octRegex.test(str)) {
	    //     return Number.parseInt(val, 8);
	    // }else if (options.parseBin && binRegex.test(str)) {
	    //     return Number.parseInt(val, 2);
	    }else {
	        //separate negative sign, leading zeros, and rest number
	        const match = numRegex.exec(trimmedStr);
	        if(match){
	            const sign = match[1];
	            const leadingZeros = match[2];
	            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros
	            //trim ending zeros for floating number
	            
	            const eNotation = match[4] || match[6];
	            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str; //-0123
	            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str; //0123
	            else {//no leading zeros or leading zeros are allowed
	                const num = Number(trimmedStr);
	                const numStr = "" + num;
	                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation
	                    if(options.eNotation) return num;
	                    else return str;
	                }else if(eNotation){ //given number has enotation
	                    if(options.eNotation) return num;
	                    else return str;
	                }else if(trimmedStr.indexOf(".") !== -1){ //floating number
	                    // const decimalPart = match[5].substr(1);
	                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf("."));

	                    
	                    // const p = numStr.indexOf(".");
	                    // const givenIntPart = numStr.substr(0,p);
	                    // const givenDecPart = numStr.substr(p+1);
	                    if(numStr === "0" && (numTrimmedByZeros === "") ) return num; //0.0
	                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000
	                    else if( sign && numStr === "-"+numTrimmedByZeros) return num;
	                    else return str;
	                }
	                
	                if(leadingZeros){
	                    // if(numTrimmedByZeros === numStr){
	                    //     if(options.leadingZeros) return num;
	                    //     else return str;
	                    // }else return str;
	                    if(numTrimmedByZeros === numStr) return num;
	                    else if(sign+numTrimmedByZeros === numStr) return num;
	                    else return str;
	                }

	                if(trimmedStr === numStr) return num;
	                else if(trimmedStr === sign+numStr) return num;
	                // else{
	                //     //number with +/- sign
	                //     trimmedStr.test(/[-+][0-9]);

	                // }
	                return str;
	            }
	            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;
	            
	        }else { //non-numeric string
	            return str;
	        }
	    }
	}

	/**
	 * 
	 * @param {string} numStr without leading zeros
	 * @returns 
	 */
	function trimZeros(numStr){
	    if(numStr && numStr.indexOf(".") !== -1){//float
	        numStr = numStr.replace(/0+$/, ""); //remove ending zeros
	        if(numStr === ".")  numStr = "0";
	        else if(numStr[0] === ".")  numStr = "0"+numStr;
	        else if(numStr[numStr.length-1] === ".")  numStr = numStr.substr(0,numStr.length-1);
	        return numStr;
	    }
	    return numStr;
	}
	strnum = toNumber;
	return strnum;
}

var ignoreAttributes;
var hasRequiredIgnoreAttributes;

function requireIgnoreAttributes () {
	if (hasRequiredIgnoreAttributes) return ignoreAttributes;
	hasRequiredIgnoreAttributes = 1;
	function getIgnoreAttributesFn(ignoreAttributes) {
	    if (typeof ignoreAttributes === 'function') {
	        return ignoreAttributes
	    }
	    if (Array.isArray(ignoreAttributes)) {
	        return (attrName) => {
	            for (const pattern of ignoreAttributes) {
	                if (typeof pattern === 'string' && attrName === pattern) {
	                    return true
	                }
	                if (pattern instanceof RegExp && pattern.test(attrName)) {
	                    return true
	                }
	            }
	        }
	    }
	    return () => false
	}

	ignoreAttributes = getIgnoreAttributesFn;
	return ignoreAttributes;
}

var OrderedObjParser_1;
var hasRequiredOrderedObjParser;

function requireOrderedObjParser () {
	if (hasRequiredOrderedObjParser) return OrderedObjParser_1;
	hasRequiredOrderedObjParser = 1;
	///@ts-check

	const util = requireUtil();
	const xmlNode = requireXmlNode();
	const readDocType = requireDocTypeReader();
	const toNumber = requireStrnum();
	const getIgnoreAttributesFn = requireIgnoreAttributes();

	// const regx =
	//   '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'
	//   .replace(/NAME/g, util.nameRegexp);

	//const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
	//const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");

	class OrderedObjParser{
	  constructor(options){
	    this.options = options;
	    this.currentNode = null;
	    this.tagsNodeStack = [];
	    this.docTypeEntities = {};
	    this.lastEntities = {
	      "apos" : { regex: /&(apos|#39|#x27);/g, val : "'"},
	      "gt" : { regex: /&(gt|#62|#x3E);/g, val : ">"},
	      "lt" : { regex: /&(lt|#60|#x3C);/g, val : "<"},
	      "quot" : { regex: /&(quot|#34|#x22);/g, val : "\""},
	    };
	    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : "&"};
	    this.htmlEntities = {
	      "space": { regex: /&(nbsp|#160);/g, val: " " },
	      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
	      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
	      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
	      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
	      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
	      "cent" : { regex: /&(cent|#162);/g, val: "¢" },
	      "pound" : { regex: /&(pound|#163);/g, val: "£" },
	      "yen" : { regex: /&(yen|#165);/g, val: "¥" },
	      "euro" : { regex: /&(euro|#8364);/g, val: "€" },
	      "copyright" : { regex: /&(copy|#169);/g, val: "©" },
	      "reg" : { regex: /&(reg|#174);/g, val: "®" },
	      "inr" : { regex: /&(inr|#8377);/g, val: "₹" },
	      "num_dec": { regex: /&#([0-9]{1,7});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },
	      "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 16)) },
	    };
	    this.addExternalEntities = addExternalEntities;
	    this.parseXml = parseXml;
	    this.parseTextData = parseTextData;
	    this.resolveNameSpace = resolveNameSpace;
	    this.buildAttributesMap = buildAttributesMap;
	    this.isItStopNode = isItStopNode;
	    this.replaceEntitiesValue = replaceEntitiesValue;
	    this.readStopNodeData = readStopNodeData;
	    this.saveTextToParentTag = saveTextToParentTag;
	    this.addChild = addChild;
	    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
	  }

	}

	function addExternalEntities(externalEntities){
	  const entKeys = Object.keys(externalEntities);
	  for (let i = 0; i < entKeys.length; i++) {
	    const ent = entKeys[i];
	    this.lastEntities[ent] = {
	       regex: new RegExp("&"+ent+";","g"),
	       val : externalEntities[ent]
	    };
	  }
	}

	/**
	 * @param {string} val
	 * @param {string} tagName
	 * @param {string} jPath
	 * @param {boolean} dontTrim
	 * @param {boolean} hasAttributes
	 * @param {boolean} isLeafNode
	 * @param {boolean} escapeEntities
	 */
	function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
	  if (val !== undefined) {
	    if (this.options.trimValues && !dontTrim) {
	      val = val.trim();
	    }
	    if(val.length > 0){
	      if(!escapeEntities) val = this.replaceEntitiesValue(val);
	      
	      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
	      if(newval === null || newval === undefined){
	        //don't parse
	        return val;
	      }else if(typeof newval !== typeof val || newval !== val){
	        //overwrite
	        return newval;
	      }else if(this.options.trimValues){
	        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
	      }else {
	        const trimmedVal = val.trim();
	        if(trimmedVal === val){
	          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
	        }else {
	          return val;
	        }
	      }
	    }
	  }
	}

	function resolveNameSpace(tagname) {
	  if (this.options.removeNSPrefix) {
	    const tags = tagname.split(':');
	    const prefix = tagname.charAt(0) === '/' ? '/' : '';
	    if (tags[0] === 'xmlns') {
	      return '';
	    }
	    if (tags.length === 2) {
	      tagname = prefix + tags[1];
	    }
	  }
	  return tagname;
	}

	//TODO: change regex to capture NS
	//const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
	const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', 'gm');

	function buildAttributesMap(attrStr, jPath, tagName) {
	  if (this.options.ignoreAttributes !== true && typeof attrStr === 'string') {
	    // attrStr = attrStr.replace(/\r?\n/g, ' ');
	    //attrStr = attrStr || attrStr.trim();

	    const matches = util.getAllMatches(attrStr, attrsRegx);
	    const len = matches.length; //don't make it inline
	    const attrs = {};
	    for (let i = 0; i < len; i++) {
	      const attrName = this.resolveNameSpace(matches[i][1]);
	      if (this.ignoreAttributesFn(attrName, jPath)) {
	        continue
	      }
	      let oldVal = matches[i][4];
	      let aName = this.options.attributeNamePrefix + attrName;
	      if (attrName.length) {
	        if (this.options.transformAttributeName) {
	          aName = this.options.transformAttributeName(aName);
	        }
	        if(aName === "__proto__") aName  = "#__proto__";
	        if (oldVal !== undefined) {
	          if (this.options.trimValues) {
	            oldVal = oldVal.trim();
	          }
	          oldVal = this.replaceEntitiesValue(oldVal);
	          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
	          if(newVal === null || newVal === undefined){
	            //don't parse
	            attrs[aName] = oldVal;
	          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){
	            //overwrite
	            attrs[aName] = newVal;
	          }else {
	            //parse
	            attrs[aName] = parseValue(
	              oldVal,
	              this.options.parseAttributeValue,
	              this.options.numberParseOptions
	            );
	          }
	        } else if (this.options.allowBooleanAttributes) {
	          attrs[aName] = true;
	        }
	      }
	    }
	    if (!Object.keys(attrs).length) {
	      return;
	    }
	    if (this.options.attributesGroupName) {
	      const attrCollection = {};
	      attrCollection[this.options.attributesGroupName] = attrs;
	      return attrCollection;
	    }
	    return attrs
	  }
	}

	const parseXml = function(xmlData) {
	  xmlData = xmlData.replace(/\r\n?/g, "\n"); //TODO: remove this line
	  const xmlObj = new xmlNode('!xml');
	  let currentNode = xmlObj;
	  let textData = "";
	  let jPath = "";
	  for(let i=0; i< xmlData.length; i++){//for each char in XML data
	    const ch = xmlData[i];
	    if(ch === '<'){
	      // const nextIndex = i+1;
	      // const _2ndChar = xmlData[nextIndex];
	      if( xmlData[i+1] === '/') {//Closing Tag
	        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
	        let tagName = xmlData.substring(i+2,closeIndex).trim();

	        if(this.options.removeNSPrefix){
	          const colonIndex = tagName.indexOf(":");
	          if(colonIndex !== -1){
	            tagName = tagName.substr(colonIndex+1);
	          }
	        }

	        if(this.options.transformTagName) {
	          tagName = this.options.transformTagName(tagName);
	        }

	        if(currentNode){
	          textData = this.saveTextToParentTag(textData, currentNode, jPath);
	        }

	        //check if last tag of nested tag was unpaired tag
	        const lastTagName = jPath.substring(jPath.lastIndexOf(".")+1);
	        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){
	          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
	        }
	        let propIndex = 0;
	        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){
	          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1);
	          this.tagsNodeStack.pop();
	        }else {
	          propIndex = jPath.lastIndexOf(".");
	        }
	        jPath = jPath.substring(0, propIndex);

	        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope
	        textData = "";
	        i = closeIndex;
	      } else if( xmlData[i+1] === '?') {

	        let tagData = readTagExp(xmlData,i, false, "?>");
	        if(!tagData) throw new Error("Pi Tag is not closed.");

	        textData = this.saveTextToParentTag(textData, currentNode, jPath);
	        if( (this.options.ignoreDeclaration && tagData.tagName === "?xml") || this.options.ignorePiTags);else {
	  
	          const childNode = new xmlNode(tagData.tagName);
	          childNode.add(this.options.textNodeName, "");
	          
	          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){
	            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
	          }
	          this.addChild(currentNode, childNode, jPath);

	        }


	        i = tagData.closeIndex + 1;
	      } else if(xmlData.substr(i + 1, 3) === '!--') {
	        const endIndex = findClosingIndex(xmlData, "-->", i+4, "Comment is not closed.");
	        if(this.options.commentPropName){
	          const comment = xmlData.substring(i + 4, endIndex - 2);

	          textData = this.saveTextToParentTag(textData, currentNode, jPath);

	          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);
	        }
	        i = endIndex;
	      } else if( xmlData.substr(i + 1, 2) === '!D') {
	        const result = readDocType(xmlData, i);
	        this.docTypeEntities = result.entities;
	        i = result.i;
	      }else if(xmlData.substr(i + 1, 2) === '![') {
	        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
	        const tagExp = xmlData.substring(i + 9,closeIndex);

	        textData = this.saveTextToParentTag(textData, currentNode, jPath);

	        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
	        if(val == undefined) val = "";

	        //cdata should be set even if it is 0 length string
	        if(this.options.cdataPropName){
	          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);
	        }else {
	          currentNode.add(this.options.textNodeName, val);
	        }
	        
	        i = closeIndex + 2;
	      }else {//Opening tag
	        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);
	        let tagName= result.tagName;
	        const rawTagName = result.rawTagName;
	        let tagExp = result.tagExp;
	        let attrExpPresent = result.attrExpPresent;
	        let closeIndex = result.closeIndex;

	        if (this.options.transformTagName) {
	          tagName = this.options.transformTagName(tagName);
	        }
	        
	        //save text as child node
	        if (currentNode && textData) {
	          if(currentNode.tagname !== '!xml'){
	            //when nested tag is found
	            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
	          }
	        }

	        //check if last tag was unpaired tag
	        const lastTag = currentNode;
	        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){
	          currentNode = this.tagsNodeStack.pop();
	          jPath = jPath.substring(0, jPath.lastIndexOf("."));
	        }
	        if(tagName !== xmlObj.tagname){
	          jPath += jPath ? "." + tagName : tagName;
	        }
	        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
	          let tagContent = "";
	          //self-closing tag
	          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
	            if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
	              tagName = tagName.substr(0, tagName.length - 1);
	              jPath = jPath.substr(0, jPath.length - 1);
	              tagExp = tagName;
	            }else {
	              tagExp = tagExp.substr(0, tagExp.length - 1);
	            }
	            i = result.closeIndex;
	          }
	          //unpaired tag
	          else if(this.options.unpairedTags.indexOf(tagName) !== -1){
	            
	            i = result.closeIndex;
	          }
	          //normal tag
	          else {
	            //read until closing tag is found
	            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
	            if(!result) throw new Error(`Unexpected end of ${rawTagName}`);
	            i = result.i;
	            tagContent = result.tagContent;
	          }

	          const childNode = new xmlNode(tagName);
	          if(tagName !== tagExp && attrExpPresent){
	            childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
	          }
	          if(tagContent) {
	            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
	          }
	          
	          jPath = jPath.substr(0, jPath.lastIndexOf("."));
	          childNode.add(this.options.textNodeName, tagContent);
	          
	          this.addChild(currentNode, childNode, jPath);
	        }else {
	  //selfClosing tag
	          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
	            if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
	              tagName = tagName.substr(0, tagName.length - 1);
	              jPath = jPath.substr(0, jPath.length - 1);
	              tagExp = tagName;
	            }else {
	              tagExp = tagExp.substr(0, tagExp.length - 1);
	            }
	            
	            if(this.options.transformTagName) {
	              tagName = this.options.transformTagName(tagName);
	            }

	            const childNode = new xmlNode(tagName);
	            if(tagName !== tagExp && attrExpPresent){
	              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
	            }
	            this.addChild(currentNode, childNode, jPath);
	            jPath = jPath.substr(0, jPath.lastIndexOf("."));
	          }
	    //opening tag
	          else {
	            const childNode = new xmlNode( tagName);
	            this.tagsNodeStack.push(currentNode);
	            
	            if(tagName !== tagExp && attrExpPresent){
	              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
	            }
	            this.addChild(currentNode, childNode, jPath);
	            currentNode = childNode;
	          }
	          textData = "";
	          i = closeIndex;
	        }
	      }
	    }else {
	      textData += xmlData[i];
	    }
	  }
	  return xmlObj.child;
	};

	function addChild(currentNode, childNode, jPath){
	  const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
	  if(result === false);else if(typeof result === "string"){
	    childNode.tagname = result;
	    currentNode.addChild(childNode);
	  }else {
	    currentNode.addChild(childNode);
	  }
	}

	const replaceEntitiesValue = function(val){

	  if(this.options.processEntities){
	    for(let entityName in this.docTypeEntities){
	      const entity = this.docTypeEntities[entityName];
	      val = val.replace( entity.regx, entity.val);
	    }
	    for(let entityName in this.lastEntities){
	      const entity = this.lastEntities[entityName];
	      val = val.replace( entity.regex, entity.val);
	    }
	    if(this.options.htmlEntities){
	      for(let entityName in this.htmlEntities){
	        const entity = this.htmlEntities[entityName];
	        val = val.replace( entity.regex, entity.val);
	      }
	    }
	    val = val.replace( this.ampEntity.regex, this.ampEntity.val);
	  }
	  return val;
	};
	function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
	  if (textData) { //store previously collected data as textNode
	    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0;
	    
	    textData = this.parseTextData(textData,
	      currentNode.tagname,
	      jPath,
	      false,
	      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
	      isLeafNode);

	    if (textData !== undefined && textData !== "")
	      currentNode.add(this.options.textNodeName, textData);
	    textData = "";
	  }
	  return textData;
	}

	//TODO: use jPath to simplify the logic
	/**
	 * 
	 * @param {string[]} stopNodes 
	 * @param {string} jPath
	 * @param {string} currentTagName 
	 */
	function isItStopNode(stopNodes, jPath, currentTagName){
	  const allNodesExp = "*." + currentTagName;
	  for (const stopNodePath in stopNodes) {
	    const stopNodeExp = stopNodes[stopNodePath];
	    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;
	  }
	  return false;
	}

	/**
	 * Returns the tag Expression and where it is ending handling single-double quotes situation
	 * @param {string} xmlData 
	 * @param {number} i starting index
	 * @returns 
	 */
	function tagExpWithClosingIndex(xmlData, i, closingChar = ">"){
	  let attrBoundary;
	  let tagExp = "";
	  for (let index = i; index < xmlData.length; index++) {
	    let ch = xmlData[index];
	    if (attrBoundary) {
	        if (ch === attrBoundary) attrBoundary = "";//reset
	    } else if (ch === '"' || ch === "'") {
	        attrBoundary = ch;
	    } else if (ch === closingChar[0]) {
	      if(closingChar[1]){
	        if(xmlData[index + 1] === closingChar[1]){
	          return {
	            data: tagExp,
	            index: index
	          }
	        }
	      }else {
	        return {
	          data: tagExp,
	          index: index
	        }
	      }
	    } else if (ch === '\t') {
	      ch = " ";
	    }
	    tagExp += ch;
	  }
	}

	function findClosingIndex(xmlData, str, i, errMsg){
	  const closingIndex = xmlData.indexOf(str, i);
	  if(closingIndex === -1){
	    throw new Error(errMsg)
	  }else {
	    return closingIndex + str.length - 1;
	  }
	}

	function readTagExp(xmlData,i, removeNSPrefix, closingChar = ">"){
	  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);
	  if(!result) return;
	  let tagExp = result.data;
	  const closeIndex = result.index;
	  const separatorIndex = tagExp.search(/\s/);
	  let tagName = tagExp;
	  let attrExpPresent = true;
	  if(separatorIndex !== -1){//separate tag name and attributes expression
	    tagName = tagExp.substring(0, separatorIndex);
	    tagExp = tagExp.substring(separatorIndex + 1).trimStart();
	  }

	  const rawTagName = tagName;
	  if(removeNSPrefix){
	    const colonIndex = tagName.indexOf(":");
	    if(colonIndex !== -1){
	      tagName = tagName.substr(colonIndex+1);
	      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
	    }
	  }

	  return {
	    tagName: tagName,
	    tagExp: tagExp,
	    closeIndex: closeIndex,
	    attrExpPresent: attrExpPresent,
	    rawTagName: rawTagName,
	  }
	}
	/**
	 * find paired tag for a stop node
	 * @param {string} xmlData 
	 * @param {string} tagName 
	 * @param {number} i 
	 */
	function readStopNodeData(xmlData, tagName, i){
	  const startIndex = i;
	  // Starting at 1 since we already have an open tag
	  let openTagCount = 1;

	  for (; i < xmlData.length; i++) {
	    if( xmlData[i] === "<"){ 
	      if (xmlData[i+1] === "/") {//close tag
	          const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
	          let closeTagName = xmlData.substring(i+2,closeIndex).trim();
	          if(closeTagName === tagName){
	            openTagCount--;
	            if (openTagCount === 0) {
	              return {
	                tagContent: xmlData.substring(startIndex, i),
	                i : closeIndex
	              }
	            }
	          }
	          i=closeIndex;
	        } else if(xmlData[i+1] === '?') { 
	          const closeIndex = findClosingIndex(xmlData, "?>", i+1, "StopNode is not closed.");
	          i=closeIndex;
	        } else if(xmlData.substr(i + 1, 3) === '!--') { 
	          const closeIndex = findClosingIndex(xmlData, "-->", i+3, "StopNode is not closed.");
	          i=closeIndex;
	        } else if(xmlData.substr(i + 1, 2) === '![') { 
	          const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
	          i=closeIndex;
	        } else {
	          const tagData = readTagExp(xmlData, i, '>');

	          if (tagData) {
	            const openTagName = tagData && tagData.tagName;
	            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== "/") {
	              openTagCount++;
	            }
	            i=tagData.closeIndex;
	          }
	        }
	      }
	  }//end for loop
	}

	function parseValue(val, shouldParse, options) {
	  if (shouldParse && typeof val === 'string') {
	    //console.log(options)
	    const newval = val.trim();
	    if(newval === 'true' ) return true;
	    else if(newval === 'false' ) return false;
	    else return toNumber(val, options);
	  } else {
	    if (util.isExist(val)) {
	      return val;
	    } else {
	      return '';
	    }
	  }
	}


	OrderedObjParser_1 = OrderedObjParser;
	return OrderedObjParser_1;
}

var node2json = {};

var hasRequiredNode2json;

function requireNode2json () {
	if (hasRequiredNode2json) return node2json;
	hasRequiredNode2json = 1;

	/**
	 * 
	 * @param {array} node 
	 * @param {any} options 
	 * @returns 
	 */
	function prettify(node, options){
	  return compress( node, options);
	}

	/**
	 * 
	 * @param {array} arr 
	 * @param {object} options 
	 * @param {string} jPath 
	 * @returns object
	 */
	function compress(arr, options, jPath){
	  let text;
	  const compressedObj = {};
	  for (let i = 0; i < arr.length; i++) {
	    const tagObj = arr[i];
	    const property = propName(tagObj);
	    let newJpath = "";
	    if(jPath === undefined) newJpath = property;
	    else newJpath = jPath + "." + property;

	    if(property === options.textNodeName){
	      if(text === undefined) text = tagObj[property];
	      else text += "" + tagObj[property];
	    }else if(property === undefined){
	      continue;
	    }else if(tagObj[property]){
	      
	      let val = compress(tagObj[property], options, newJpath);
	      const isLeaf = isLeafTag(val, options);

	      if(tagObj[":@"]){
	        assignAttributes( val, tagObj[":@"], newJpath, options);
	      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){
	        val = val[options.textNodeName];
	      }else if(Object.keys(val).length === 0){
	        if(options.alwaysCreateTextNode) val[options.textNodeName] = "";
	        else val = "";
	      }

	      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
	        if(!Array.isArray(compressedObj[property])) {
	            compressedObj[property] = [ compressedObj[property] ];
	        }
	        compressedObj[property].push(val);
	      }else {
	        //TODO: if a node is not an array, then check if it should be an array
	        //also determine if it is a leaf node
	        if (options.isArray(property, newJpath, isLeaf )) {
	          compressedObj[property] = [val];
	        }else {
	          compressedObj[property] = val;
	        }
	      }
	    }
	    
	  }
	  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;
	  if(typeof text === "string"){
	    if(text.length > 0) compressedObj[options.textNodeName] = text;
	  }else if(text !== undefined) compressedObj[options.textNodeName] = text;
	  return compressedObj;
	}

	function propName(obj){
	  const keys = Object.keys(obj);
	  for (let i = 0; i < keys.length; i++) {
	    const key = keys[i];
	    if(key !== ":@") return key;
	  }
	}

	function assignAttributes(obj, attrMap, jpath, options){
	  if (attrMap) {
	    const keys = Object.keys(attrMap);
	    const len = keys.length; //don't make it inline
	    for (let i = 0; i < len; i++) {
	      const atrrName = keys[i];
	      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
	        obj[atrrName] = [ attrMap[atrrName] ];
	      } else {
	        obj[atrrName] = attrMap[atrrName];
	      }
	    }
	  }
	}

	function isLeafTag(obj, options){
	  const { textNodeName } = options;
	  const propCount = Object.keys(obj).length;
	  
	  if (propCount === 0) {
	    return true;
	  }

	  if (
	    propCount === 1 &&
	    (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)
	  ) {
	    return true;
	  }

	  return false;
	}
	node2json.prettify = prettify;
	return node2json;
}

var XMLParser_1;
var hasRequiredXMLParser;

function requireXMLParser () {
	if (hasRequiredXMLParser) return XMLParser_1;
	hasRequiredXMLParser = 1;
	const { buildOptions} = requireOptionsBuilder();
	const OrderedObjParser = requireOrderedObjParser();
	const { prettify} = requireNode2json();
	const validator = requireValidator();

	class XMLParser{
	    
	    constructor(options){
	        this.externalEntities = {};
	        this.options = buildOptions(options);
	        
	    }
	    /**
	     * Parse XML dats to JS object 
	     * @param {string|Buffer} xmlData 
	     * @param {boolean|Object} validationOption 
	     */
	    parse(xmlData,validationOption){
	        if(typeof xmlData === "string");else if( xmlData.toString){
	            xmlData = xmlData.toString();
	        }else {
	            throw new Error("XML data is accepted in String or Bytes[] form.")
	        }
	        if( validationOption){
	            if(validationOption === true) validationOption = {}; //validate with default options
	            
	            const result = validator.validate(xmlData, validationOption);
	            if (result !== true) {
	              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )
	            }
	          }
	        const orderedObjParser = new OrderedObjParser(this.options);
	        orderedObjParser.addExternalEntities(this.externalEntities);
	        const orderedResult = orderedObjParser.parseXml(xmlData);
	        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;
	        else return prettify(orderedResult, this.options);
	    }

	    /**
	     * Add Entity which is not by default supported by this library
	     * @param {string} key 
	     * @param {string} value 
	     */
	    addEntity(key, value){
	        if(value.indexOf("&") !== -1){
	            throw new Error("Entity value can't have '&'")
	        }else if(key.indexOf("&") !== -1 || key.indexOf(";") !== -1){
	            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'")
	        }else if(value === "&"){
	            throw new Error("An entity with value '&' is not permitted");
	        }else {
	            this.externalEntities[key] = value;
	        }
	    }
	}

	XMLParser_1 = XMLParser;
	return XMLParser_1;
}

var orderedJs2Xml;
var hasRequiredOrderedJs2Xml;

function requireOrderedJs2Xml () {
	if (hasRequiredOrderedJs2Xml) return orderedJs2Xml;
	hasRequiredOrderedJs2Xml = 1;
	const EOL = "\n";

	/**
	 * 
	 * @param {array} jArray 
	 * @param {any} options 
	 * @returns 
	 */
	function toXml(jArray, options) {
	    let indentation = "";
	    if (options.format && options.indentBy.length > 0) {
	        indentation = EOL;
	    }
	    return arrToStr(jArray, options, "", indentation);
	}

	function arrToStr(arr, options, jPath, indentation) {
	    let xmlStr = "";
	    let isPreviousElementTag = false;

	    for (let i = 0; i < arr.length; i++) {
	        const tagObj = arr[i];
	        const tagName = propName(tagObj);
	        if(tagName === undefined) continue;

	        let newJPath = "";
	        if (jPath.length === 0) newJPath = tagName;
	        else newJPath = `${jPath}.${tagName}`;

	        if (tagName === options.textNodeName) {
	            let tagText = tagObj[tagName];
	            if (!isStopNode(newJPath, options)) {
	                tagText = options.tagValueProcessor(tagName, tagText);
	                tagText = replaceEntitiesValue(tagText, options);
	            }
	            if (isPreviousElementTag) {
	                xmlStr += indentation;
	            }
	            xmlStr += tagText;
	            isPreviousElementTag = false;
	            continue;
	        } else if (tagName === options.cdataPropName) {
	            if (isPreviousElementTag) {
	                xmlStr += indentation;
	            }
	            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
	            isPreviousElementTag = false;
	            continue;
	        } else if (tagName === options.commentPropName) {
	            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
	            isPreviousElementTag = true;
	            continue;
	        } else if (tagName[0] === "?") {
	            const attStr = attr_to_str(tagObj[":@"], options);
	            const tempInd = tagName === "?xml" ? "" : indentation;
	            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
	            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : ""; //remove extra spacing
	            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;
	            isPreviousElementTag = true;
	            continue;
	        }
	        let newIdentation = indentation;
	        if (newIdentation !== "") {
	            newIdentation += options.indentBy;
	        }
	        const attStr = attr_to_str(tagObj[":@"], options);
	        const tagStart = indentation + `<${tagName}${attStr}`;
	        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
	        if (options.unpairedTags.indexOf(tagName) !== -1) {
	            if (options.suppressUnpairedNode) xmlStr += tagStart + ">";
	            else xmlStr += tagStart + "/>";
	        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
	            xmlStr += tagStart + "/>";
	        } else if (tagValue && tagValue.endsWith(">")) {
	            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
	        } else {
	            xmlStr += tagStart + ">";
	            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
	                xmlStr += indentation + options.indentBy + tagValue + indentation;
	            } else {
	                xmlStr += tagValue;
	            }
	            xmlStr += `</${tagName}>`;
	        }
	        isPreviousElementTag = true;
	    }

	    return xmlStr;
	}

	function propName(obj) {
	    const keys = Object.keys(obj);
	    for (let i = 0; i < keys.length; i++) {
	        const key = keys[i];
	        if(!obj.hasOwnProperty(key)) continue;
	        if (key !== ":@") return key;
	    }
	}

	function attr_to_str(attrMap, options) {
	    let attrStr = "";
	    if (attrMap && !options.ignoreAttributes) {
	        for (let attr in attrMap) {
	            if(!attrMap.hasOwnProperty(attr)) continue;
	            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
	            attrVal = replaceEntitiesValue(attrVal, options);
	            if (attrVal === true && options.suppressBooleanAttributes) {
	                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
	            } else {
	                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
	            }
	        }
	    }
	    return attrStr;
	}

	function isStopNode(jPath, options) {
	    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
	    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
	    for (let index in options.stopNodes) {
	        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName) return true;
	    }
	    return false;
	}

	function replaceEntitiesValue(textValue, options) {
	    if (textValue && textValue.length > 0 && options.processEntities) {
	        for (let i = 0; i < options.entities.length; i++) {
	            const entity = options.entities[i];
	            textValue = textValue.replace(entity.regex, entity.val);
	        }
	    }
	    return textValue;
	}
	orderedJs2Xml = toXml;
	return orderedJs2Xml;
}

var json2xml;
var hasRequiredJson2xml;

function requireJson2xml () {
	if (hasRequiredJson2xml) return json2xml;
	hasRequiredJson2xml = 1;
	//parse Empty Node as self closing node
	const buildFromOrderedJs = requireOrderedJs2Xml();
	const getIgnoreAttributesFn = requireIgnoreAttributes();

	const defaultOptions = {
	  attributeNamePrefix: '@_',
	  attributesGroupName: false,
	  textNodeName: '#text',
	  ignoreAttributes: true,
	  cdataPropName: false,
	  format: false,
	  indentBy: '  ',
	  suppressEmptyNode: false,
	  suppressUnpairedNode: true,
	  suppressBooleanAttributes: true,
	  tagValueProcessor: function(key, a) {
	    return a;
	  },
	  attributeValueProcessor: function(attrName, a) {
	    return a;
	  },
	  preserveOrder: false,
	  commentPropName: false,
	  unpairedTags: [],
	  entities: [
	    { regex: new RegExp("&", "g"), val: "&amp;" },//it must be on top
	    { regex: new RegExp(">", "g"), val: "&gt;" },
	    { regex: new RegExp("<", "g"), val: "&lt;" },
	    { regex: new RegExp("\'", "g"), val: "&apos;" },
	    { regex: new RegExp("\"", "g"), val: "&quot;" }
	  ],
	  processEntities: true,
	  stopNodes: [],
	  // transformTagName: false,
	  // transformAttributeName: false,
	  oneListGroup: false
	};

	function Builder(options) {
	  this.options = Object.assign({}, defaultOptions, options);
	  if (this.options.ignoreAttributes === true || this.options.attributesGroupName) {
	    this.isAttribute = function(/*a*/) {
	      return false;
	    };
	  } else {
	    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
	    this.attrPrefixLen = this.options.attributeNamePrefix.length;
	    this.isAttribute = isAttribute;
	  }

	  this.processTextOrObjNode = processTextOrObjNode;

	  if (this.options.format) {
	    this.indentate = indentate;
	    this.tagEndChar = '>\n';
	    this.newLine = '\n';
	  } else {
	    this.indentate = function() {
	      return '';
	    };
	    this.tagEndChar = '>';
	    this.newLine = '';
	  }
	}

	Builder.prototype.build = function(jObj) {
	  if(this.options.preserveOrder){
	    return buildFromOrderedJs(jObj, this.options);
	  }else {
	    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){
	      jObj = {
	        [this.options.arrayNodeName] : jObj
	      };
	    }
	    return this.j2x(jObj, 0, []).val;
	  }
	};

	Builder.prototype.j2x = function(jObj, level, ajPath) {
	  let attrStr = '';
	  let val = '';
	  const jPath = ajPath.join('.');
	  for (let key in jObj) {
	    if(!Object.prototype.hasOwnProperty.call(jObj, key)) continue;
	    if (typeof jObj[key] === 'undefined') {
	      // supress undefined node only if it is not an attribute
	      if (this.isAttribute(key)) {
	        val += '';
	      }
	    } else if (jObj[key] === null) {
	      // null attribute should be ignored by the attribute list, but should not cause the tag closing
	      if (this.isAttribute(key)) {
	        val += '';
	      } else if (key[0] === '?') {
	        val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
	      } else {
	        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
	      }
	      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
	    } else if (jObj[key] instanceof Date) {
	      val += this.buildTextValNode(jObj[key], key, '', level);
	    } else if (typeof jObj[key] !== 'object') {
	      //premitive type
	      const attr = this.isAttribute(key);
	      if (attr && !this.ignoreAttributesFn(attr, jPath)) {
	        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);
	      } else if (!attr) {
	        //tag value
	        if (key === this.options.textNodeName) {
	          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);
	          val += this.replaceEntitiesValue(newval);
	        } else {
	          val += this.buildTextValNode(jObj[key], key, '', level);
	        }
	      }
	    } else if (Array.isArray(jObj[key])) {
	      //repeated nodes
	      const arrLen = jObj[key].length;
	      let listTagVal = "";
	      let listTagAttr = "";
	      for (let j = 0; j < arrLen; j++) {
	        const item = jObj[key][j];
	        if (typeof item === 'undefined') ; else if (item === null) {
	          if(key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
	          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
	          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
	        } else if (typeof item === 'object') {
	          if(this.options.oneListGroup){
	            const result = this.j2x(item, level + 1, ajPath.concat(key));
	            listTagVal += result.val;
	            if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
	              listTagAttr += result.attrStr;
	            }
	          }else {
	            listTagVal += this.processTextOrObjNode(item, key, level, ajPath);
	          }
	        } else {
	          if (this.options.oneListGroup) {
	            let textValue = this.options.tagValueProcessor(key, item);
	            textValue = this.replaceEntitiesValue(textValue);
	            listTagVal += textValue;
	          } else {
	            listTagVal += this.buildTextValNode(item, key, '', level);
	          }
	        }
	      }
	      if(this.options.oneListGroup){
	        listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
	      }
	      val += listTagVal;
	    } else {
	      //nested node
	      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
	        const Ks = Object.keys(jObj[key]);
	        const L = Ks.length;
	        for (let j = 0; j < L; j++) {
	          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);
	        }
	      } else {
	        val += this.processTextOrObjNode(jObj[key], key, level, ajPath);
	      }
	    }
	  }
	  return {attrStr: attrStr, val: val};
	};

	Builder.prototype.buildAttrPairStr = function(attrName, val){
	  val = this.options.attributeValueProcessor(attrName, '' + val);
	  val = this.replaceEntitiesValue(val);
	  if (this.options.suppressBooleanAttributes && val === "true") {
	    return ' ' + attrName;
	  } else return ' ' + attrName + '="' + val + '"';
	};

	function processTextOrObjNode (object, key, level, ajPath) {
	  const result = this.j2x(object, level + 1, ajPath.concat(key));
	  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
	    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
	  } else {
	    return this.buildObjectNode(result.val, key, result.attrStr, level);
	  }
	}

	Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
	  if(val === ""){
	    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;
	    else {
	      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
	    }
	  }else {

	    let tagEndExp = '</' + key + this.tagEndChar;
	    let piClosingChar = "";
	    
	    if(key[0] === "?") {
	      piClosingChar = "?";
	      tagEndExp = "";
	    }
	  
	    // attrStr is an empty string in case the attribute came as undefined or null
	    if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {
	      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );
	    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
	      return this.indentate(level) + `<!--${val}-->` + this.newLine;
	    }else {
	      return (
	        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +
	        val +
	        this.indentate(level) + tagEndExp    );
	    }
	  }
	};

	Builder.prototype.closeTag = function(key){
	  let closeTag = "";
	  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired
	    if(!this.options.suppressUnpairedNode) closeTag = "/";
	  }else if(this.options.suppressEmptyNode){ //empty
	    closeTag = "/";
	  }else {
	    closeTag = `></${key}`;
	  }
	  return closeTag;
	};

	Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
	  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
	    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;
	  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
	    return this.indentate(level) + `<!--${val}-->` +  this.newLine;
	  }else if(key[0] === "?") {//PI tag
	    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; 
	  }else {
	    let textValue = this.options.tagValueProcessor(key, val);
	    textValue = this.replaceEntitiesValue(textValue);
	  
	    if( textValue === ''){
	      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
	    }else {
	      return this.indentate(level) + '<' + key + attrStr + '>' +
	         textValue +
	        '</' + key + this.tagEndChar;
	    }
	  }
	};

	Builder.prototype.replaceEntitiesValue = function(textValue){
	  if(textValue && textValue.length > 0 && this.options.processEntities){
	    for (let i=0; i<this.options.entities.length; i++) {
	      const entity = this.options.entities[i];
	      textValue = textValue.replace(entity.regex, entity.val);
	    }
	  }
	  return textValue;
	};

	function indentate(level) {
	  return this.options.indentBy.repeat(level);
	}

	function isAttribute(name /*, options*/) {
	  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
	    return name.substr(this.attrPrefixLen);
	  } else {
	    return false;
	  }
	}

	json2xml = Builder;
	return json2xml;
}

var fxp;
var hasRequiredFxp;

function requireFxp () {
	if (hasRequiredFxp) return fxp;
	hasRequiredFxp = 1;

	const validator = requireValidator();
	const XMLParser = requireXMLParser();
	const XMLBuilder = requireJson2xml();

	fxp = {
	  XMLParser: XMLParser,
	  XMLValidator: validator,
	  XMLBuilder: XMLBuilder
	};
	return fxp;
}

var fxpExports = requireFxp();
const fastXmlParser = /*@__PURE__*/getDefaultExportFromCjs(fxpExports);

class OB11GroupMsgEmojiLikeEvent extends OB11GroupNoticeEvent {
  notice_type = "group_msg_emoji_like";
  message_id;
  likes;
  constructor(core, groupId, userId, messageId, likes) {
    super(core, groupId, userId);
    this.group_id = groupId;
    this.user_id = userId;
    this.message_id = messageId;
    this.likes = likes;
  }
}

class OB11GroupCardEvent extends OB11GroupNoticeEvent {
  notice_type = "group_card";
  card_new;
  card_old;
  constructor(core, groupId, userId, cardNew, cardOld) {
    super(core, groupId, userId);
    this.group_id = groupId;
    this.user_id = userId;
    this.card_new = cardNew;
    this.card_old = cardOld;
  }
}

class OB11GroupEssenceEvent extends OB11GroupNoticeEvent {
  notice_type = "essence";
  message_id;
  sender_id;
  operator_id;
  sub_type = "add";
  constructor(core, groupId, message_id, sender_id, operator_id) {
    super(core, groupId, sender_id);
    this.group_id = groupId;
    this.operator_id = operator_id;
    this.message_id = message_id;
    this.sender_id = sender_id;
  }
}

class OB11GroupTitleEvent extends OB11GroupNoticeEvent {
  notice_type = "notify";
  sub_type = "title";
  title;
  constructor(core, groupId, userId, title) {
    super(core, groupId, userId);
    this.group_id = groupId;
    this.user_id = userId;
    this.title = title;
  }
}

class OB11GroupUploadNoticeEvent extends OB11GroupNoticeEvent {
  notice_type = "group_upload";
  file;
  constructor(core, groupId, userId, file) {
    super(core, groupId, userId);
    this.group_id = groupId;
    this.user_id = userId;
    this.file = file;
  }
}

class OneBotGroupApi {
  obContext;
  core;
  GroupMemberList = /* @__PURE__ */ new Map();
  //此处作为缓存 group_id->memberUin->info
  constructor(obContext, core) {
    this.obContext = obContext;
    this.core = core;
  }
  async parseGroupBanEvent(GroupCode, grayTipElement) {
    const groupElement = grayTipElement?.groupElement;
    if (!groupElement?.shutUp) return void 0;
    const memberUid = groupElement.shutUp.member.uid;
    const adminUid = groupElement.shutUp.admin.uid;
    let memberUin;
    let duration = parseInt(groupElement.shutUp.duration);
    const subType = duration > 0 ? "ban" : "lift_ban";
    if (memberUid) {
      memberUin = (await this.core.apis.GroupApi.getGroupMember(GroupCode, memberUid))?.uin ?? "";
    } else {
      memberUin = "0";
      if (duration > 0) {
        duration = -1;
      }
    }
    const adminUin = (await this.core.apis.GroupApi.getGroupMember(GroupCode, adminUid))?.uin;
    if (memberUin && adminUin) {
      return new OB11GroupBanEvent(
        this.core,
        parseInt(GroupCode),
        parseInt(memberUin),
        parseInt(adminUin),
        duration,
        subType
      );
    }
    return void 0;
  }
  async parseGroupEmojiLikeEventByGrayTip(groupCode, grayTipElement) {
    const emojiLikeData = new fastXmlParser.XMLParser({
      ignoreAttributes: false,
      attributeNamePrefix: ""
    }).parse(grayTipElement.xmlElement.content);
    this.core.context.logger.logDebug("收到表情回应我的消息", emojiLikeData);
    const senderUin = emojiLikeData.gtip.qq.jp;
    const msgSeq = emojiLikeData.gtip.url.msgseq;
    const emojiId = emojiLikeData.gtip.face.id;
    return await this.createGroupEmojiLikeEvent(groupCode, senderUin, msgSeq, emojiId);
  }
  async createGroupEmojiLikeEvent(groupCode, senderUin, msgSeq, emojiId) {
    const peer = {
      chatType: ChatType.KCHATTYPEGROUP,
      guildId: "",
      peerUid: groupCode
    };
    const replyMsgList = (await this.core.apis.MsgApi.queryFirstMsgBySeq(peer, msgSeq)).msgList;
    if (replyMsgList.length < 1) {
      return;
    }
    const replyMsg = replyMsgList[0];
    if (!replyMsg) {
      this.core.context.logger.logError("解析表情回应消息失败: 未找到回应消息");
      return void 0;
    }
    return new OB11GroupMsgEmojiLikeEvent(
      this.core,
      parseInt(groupCode),
      parseInt(senderUin),
      MessageUnique.getShortIdByMsgId(replyMsg.msgId),
      [{
        emoji_id: emojiId,
        count: 1
      }]
    );
  }
  async parseCardChangedEvent(msg) {
    if (msg.senderUin && msg.senderUin !== "0") {
      const member = await this.core.apis.GroupApi.getGroupMember(msg.peerUid, msg.senderUin);
      if (member && member.cardName !== msg.sendMemberName) {
        const newCardName = msg.sendMemberName ?? "";
        const event = new OB11GroupCardEvent(this.core, parseInt(msg.peerUid), parseInt(msg.senderUin), newCardName, member.cardName);
        member.cardName = newCardName;
        return event;
      }
    }
    return void 0;
  }
  async parsePaiYiPai(msg, jsonStr) {
    const json = JSON.parse(jsonStr);
    const pokedetail = json.items;
    const poke_uid = pokedetail.filter((item) => item.uid);
    if (poke_uid.length == 2) {
      return new OB11GroupPokeEvent(
        this.core,
        parseInt(msg.peerUid),
        +await this.core.apis.UserApi.getUinByUidV2(poke_uid[0].uid),
        +await this.core.apis.UserApi.getUinByUidV2(poke_uid[1].uid),
        pokedetail
      );
    }
    return void 0;
  }
  async parseOtherJsonEvent(msg, jsonStr, context) {
    const json = JSON.parse(jsonStr);
    const type = json.items[json.items.length - 1]?.txt;
    if (type === "头衔") {
      const memberUin = json.items[1].param[0];
      const title = json.items[3].txt;
      context.logger.logDebug("收到群成员新头衔消息", json);
      return new OB11GroupTitleEvent(
        this.core,
        parseInt(msg.peerUid),
        parseInt(memberUin),
        title
      );
    } else if (type === "移出") {
      context.logger.logDebug("收到机器人被踢消息", json);
      return;
    } else {
      context.logger.logWarn("收到未知的灰条消息", json);
    }
  }
  async parseEssenceMsg(msg, jsonStr) {
    const json = JSON.parse(jsonStr);
    const searchParams = new URL(json.items[0].jp).searchParams;
    const msgSeq = searchParams.get("msgSeq");
    const Group = searchParams.get("groupCode");
    if (!Group) return;
    const Peer = {
      guildId: "",
      chatType: ChatType.KCHATTYPEGROUP,
      peerUid: Group
    };
    const msgData = await this.core.apis.MsgApi.getMsgsBySeqAndCount(Peer, msgSeq.toString(), 1, true, true);
    const msgList = (await this.core.apis.WebApi.getGroupEssenceMsgAll(Group)).flatMap((e) => e.data.msg_list);
    const realMsg = msgList.find((e) => e.msg_seq.toString() == msgSeq);
    return new OB11GroupEssenceEvent(
      this.core,
      parseInt(msg.peerUid),
      MessageUnique.getShortIdByMsgId(msgData.msgList[0].msgId),
      parseInt(msgData.msgList[0].senderUin),
      parseInt(realMsg?.add_digest_uin ?? "0")
    );
  }
  async parseGroupUploadFileEvene(msg, element, elementWrapper) {
    return new OB11GroupUploadNoticeEvent(
      this.core,
      parseInt(msg.peerUid),
      parseInt(msg.senderUin || ""),
      {
        id: FileNapCatOneBotUUID.encode({
          chatType: ChatType.KCHATTYPEGROUP,
          peerUid: msg.peerUid
        }, msg.msgId, elementWrapper.elementId, elementWrapper?.fileElement?.fileUuid, "." + element.fileName),
        url: pathToFileURL(element.filePath).href,
        name: element.fileName,
        size: parseInt(element.fileSize),
        busid: element.fileBizId ?? 0
      }
    );
  }
  async parseGrayTipElement(msg, grayTipElement) {
    if (grayTipElement.subElementType === NTGrayTipElementSubTypeV2.GRAYTIP_ELEMENT_SUBTYPE_GROUP) ; else if (grayTipElement.subElementType === NTGrayTipElementSubTypeV2.GRAYTIP_ELEMENT_SUBTYPE_XMLMSG) {
      if (grayTipElement.xmlElement?.templId === "10382") {
        return await this.obContext.apis.GroupApi.parseGroupEmojiLikeEventByGrayTip(msg.peerUid, grayTipElement);
      }
    } else if (grayTipElement.subElementType == NTGrayTipElementSubTypeV2.GRAYTIP_ELEMENT_SUBTYPE_JSON) {
      if (grayTipElement.jsonGrayTipElement.busiId == 1061) {
        return await this.parsePaiYiPai(msg, grayTipElement.jsonGrayTipElement.jsonStr);
      } else if (grayTipElement.jsonGrayTipElement.busiId == JsonGrayBusiId.AIO_GROUP_ESSENCE_MSG_TIP) {
        return await this.parseEssenceMsg(msg, grayTipElement.jsonGrayTipElement.jsonStr);
      } else {
        return await this.parseOtherJsonEvent(msg, grayTipElement.jsonGrayTipElement.jsonStr, this.core.context);
      }
    }
    return void 0;
  }
}

class OB11ProfileLikeEvent extends OB11BaseNoticeEvent {
  notice_type = "notify";
  sub_type = "profile_like";
  operator_id;
  operator_nick;
  times;
  time;
  constructor(core, operatorId, operatorNick, times, time) {
    super(core);
    this.operator_id = operatorId;
    this.operator_nick = operatorNick;
    this.times = times;
    this.time = time;
  }
}

const LikeDetail = {
  txt: ProtoField(1, ScalarType.STRING),
  uin: ProtoField(3, ScalarType.INT64),
  nickname: ProtoField(5, ScalarType.STRING)
};
const LikeMsg = {
  times: ProtoField(1, ScalarType.INT32),
  time: ProtoField(2, ScalarType.INT32),
  detail: ProtoField(3, () => LikeDetail)
};
const ProfileLikeSubTip = {
  msg: ProtoField(14, () => LikeMsg)
};
const ProfileLikeTip = {
  msgType: ProtoField(1, ScalarType.INT32),
  subType: ProtoField(2, ScalarType.INT32),
  content: ProtoField(203, () => ProfileLikeSubTip)
};
({
  PeerNumber: ProtoField(1, ScalarType.UINT32),
  PeerString: ProtoField(2, ScalarType.STRING),
  Uin: ProtoField(5, ScalarType.UINT32),
  Uid: ProtoField(6, ScalarType.STRING, true)
});
({
  msgType: ProtoField(1, ScalarType.UINT32),
  subType: ProtoField(2, ScalarType.UINT32),
  subSubType: ProtoField(3, ScalarType.UINT32),
  msgSeq: ProtoField(5, ScalarType.UINT32),
  time: ProtoField(6, ScalarType.UINT32),
  msgId: ProtoField(12, ScalarType.UINT64),
  other: ProtoField(13, ScalarType.UINT32)
});
({
  wrappedBody: ProtoField(2, ScalarType.BYTES)
});
function decodeProfileLikeTip(buffer) {
  const msg = new NapProtoMsg(ProfileLikeTip);
  return msg.decode(buffer);
}

class OneBotUserApi {
  obContext;
  core;
  constructor(obContext, core) {
    this.obContext = obContext;
    this.core = core;
  }
  async parseLikeEvent(wrappedBody) {
    const likeTip = decodeProfileLikeTip(wrappedBody);
    if (likeTip?.msgType !== 0 || likeTip?.subType !== 203) return;
    this.core.context.logger.logDebug("收到点赞通知消息");
    const likeMsg = likeTip.content.msg;
    if (!likeMsg) return;
    const detail = likeMsg.detail;
    if (!detail) return;
    const times = detail.txt.match(/\d+/) ?? "0";
    return new OB11ProfileLikeEvent(
      this.core,
      Number(detail.uin),
      detail.nickname,
      parseInt(times[0], 10),
      likeMsg.time
    );
  }
}

const sysface = JSON.parse("[{\"QSid\":\"392\",\"QDes\":\"/龙年快乐\",\"IQLid\":\"392\",\"AQLid\":\"392\",\"EMCode\":\"10392\",\"AniStickerType\":3,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"38\"},{\"QSid\":\"393\",\"QDes\":\"/新年中龙\",\"IQLid\":\"393\",\"AQLid\":\"393\",\"EMCode\":\"10393\",\"QHide\":\"1\",\"AniStickerType\":3,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"39\"},{\"QSid\":\"364\",\"QDes\":\"/超级赞\",\"IQLid\":\"364\",\"AQLid\":\"364\",\"EMCode\":\"10364\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"1\",\"AniStickerPackId\":\"2\",\"AniStickerPackName\":\"汪汪\"},{\"QSid\":\"366\",\"QDes\":\"/芒狗\",\"IQLid\":\"366\",\"AQLid\":\"366\",\"EMCode\":\"10366\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"2\",\"AniStickerPackId\":\"2\",\"AniStickerPackName\":\"汪汪\"},{\"QSid\":\"362\",\"QDes\":\"/好兄弟\",\"IQLid\":\"362\",\"AQLid\":\"362\",\"EMCode\":\"10362\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"3\",\"AniStickerPackId\":\"2\",\"AniStickerPackName\":\"汪汪\"},{\"QSid\":\"397\",\"QDes\":\"/抛媚眼\",\"IQLid\":\"397\",\"AQLid\":\"397\",\"EMCode\":\"10397\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"4\",\"AniStickerPackId\":\"2\",\"AniStickerPackName\":\"汪汪\"},{\"QSid\":\"396\",\"QDes\":\"/狼狗\",\"IQLid\":\"396\",\"AQLid\":\"396\",\"EMCode\":\"10396\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"5\",\"AniStickerPackId\":\"2\",\"AniStickerPackName\":\"汪汪\"},{\"QSid\":\"360\",\"QDes\":\"/亲亲\",\"IQLid\":\"360\",\"AQLid\":\"360\",\"EMCode\":\"10360\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"6\",\"AniStickerPackId\":\"2\",\"AniStickerPackName\":\"汪汪\"},{\"QSid\":\"361\",\"QDes\":\"/狗狗笑哭\",\"IQLid\":\"361\",\"AQLid\":\"361\",\"EMCode\":\"10361\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"7\",\"AniStickerPackId\":\"2\",\"AniStickerPackName\":\"汪汪\"},{\"QSid\":\"363\",\"QDes\":\"/狗狗可怜\",\"IQLid\":\"363\",\"AQLid\":\"363\",\"EMCode\":\"10363\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"8\",\"AniStickerPackId\":\"2\",\"AniStickerPackName\":\"汪汪\"},{\"QSid\":\"365\",\"QDes\":\"/狗狗生气\",\"IQLid\":\"365\",\"AQLid\":\"365\",\"EMCode\":\"10365\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"9\",\"AniStickerPackId\":\"2\",\"AniStickerPackName\":\"汪汪\"},{\"QSid\":\"367\",\"QDes\":\"/狗狗疑问\",\"IQLid\":\"367\",\"AQLid\":\"367\",\"EMCode\":\"10367\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"10\",\"AniStickerPackId\":\"2\",\"AniStickerPackName\":\"汪汪\"},{\"QSid\":\"399\",\"QDes\":\"/tui\",\"IQLid\":\"399\",\"AQLid\":\"399\",\"EMCode\":\"10399\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"1\",\"AniStickerPackId\":\"6\",\"AniStickerPackName\":\"噗噗星人\"},{\"QSid\":\"398\",\"QDes\":\"/超级ok\",\"IQLid\":\"398\",\"AQLid\":\"398\",\"EMCode\":\"10398\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"2\",\"AniStickerPackId\":\"6\",\"AniStickerPackName\":\"噗噗星人\"},{\"QSid\":\"373\",\"QDes\":\"/忙\",\"IQLid\":\"373\",\"AQLid\":\"373\",\"EMCode\":\"10373\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"3\",\"AniStickerPackId\":\"6\",\"AniStickerPackName\":\"噗噗星人\"},{\"QSid\":\"370\",\"QDes\":\"/祝贺\",\"IQLid\":\"370\",\"AQLid\":\"370\",\"EMCode\":\"10370\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"4\",\"AniStickerPackId\":\"6\",\"AniStickerPackName\":\"噗噗星人\"},{\"QSid\":\"375\",\"QDes\":\"/超级鼓掌\",\"IQLid\":\"375\",\"AQLid\":\"375\",\"EMCode\":\"10375\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"5\",\"AniStickerPackId\":\"6\",\"AniStickerPackName\":\"噗噗星人\"},{\"QSid\":\"368\",\"QDes\":\"/奥特笑哭\",\"IQLid\":\"368\",\"AQLid\":\"368\",\"EMCode\":\"10368\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"6\",\"AniStickerPackId\":\"6\",\"AniStickerPackName\":\"噗噗星人\"},{\"QSid\":\"369\",\"QDes\":\"/彩虹\",\"IQLid\":\"369\",\"AQLid\":\"369\",\"EMCode\":\"10369\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"7\",\"AniStickerPackId\":\"6\",\"AniStickerPackName\":\"噗噗星人\"},{\"QSid\":\"371\",\"QDes\":\"/冒泡\",\"IQLid\":\"371\",\"AQLid\":\"371\",\"EMCode\":\"10371\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"8\",\"AniStickerPackId\":\"6\",\"AniStickerPackName\":\"噗噗星人\"},{\"QSid\":\"372\",\"QDes\":\"/气呼呼\",\"IQLid\":\"372\",\"AQLid\":\"372\",\"EMCode\":\"10372\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"9\",\"AniStickerPackId\":\"6\",\"AniStickerPackName\":\"噗噗星人\"},{\"QSid\":\"374\",\"QDes\":\"/波波流泪\",\"IQLid\":\"374\",\"AQLid\":\"374\",\"EMCode\":\"10374\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"10\",\"AniStickerPackId\":\"6\",\"AniStickerPackName\":\"噗噗星人\"},{\"QSid\":\"382\",\"QDes\":\"/emo\",\"IQLid\":\"382\",\"AQLid\":\"382\",\"EMCode\":\"10382\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"1\",\"AniStickerPackId\":\"5\",\"AniStickerPackName\":\"企鹅\"},{\"QSid\":\"383\",\"QDes\":\"/企鹅爱心\",\"IQLid\":\"383\",\"AQLid\":\"383\",\"EMCode\":\"10383\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"2\",\"AniStickerPackId\":\"5\",\"AniStickerPackName\":\"企鹅\"},{\"QSid\":\"401\",\"QDes\":\"/超级转圈\",\"IQLid\":\"401\",\"AQLid\":\"401\",\"EMCode\":\"10401\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"3\",\"AniStickerPackId\":\"5\",\"AniStickerPackName\":\"企鹅\"},{\"QSid\":\"400\",\"QDes\":\"/快乐\",\"IQLid\":\"400\",\"AQLid\":\"400\",\"EMCode\":\"10400\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"4\",\"AniStickerPackId\":\"5\",\"AniStickerPackName\":\"企鹅\"},{\"QSid\":\"380\",\"QDes\":\"/真棒\",\"IQLid\":\"380\",\"AQLid\":\"380\",\"EMCode\":\"10380\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"5\",\"AniStickerPackId\":\"5\",\"AniStickerPackName\":\"企鹅\"},{\"QSid\":\"381\",\"QDes\":\"/路过\",\"IQLid\":\"381\",\"AQLid\":\"381\",\"EMCode\":\"10381\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"6\",\"AniStickerPackId\":\"5\",\"AniStickerPackName\":\"企鹅\"},{\"QSid\":\"379\",\"QDes\":\"/企鹅流泪\",\"IQLid\":\"379\",\"AQLid\":\"379\",\"EMCode\":\"10379\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"7\",\"AniStickerPackId\":\"5\",\"AniStickerPackName\":\"企鹅\"},{\"QSid\":\"376\",\"QDes\":\"/跺脚\",\"IQLid\":\"376\",\"AQLid\":\"376\",\"EMCode\":\"10376\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"8\",\"AniStickerPackId\":\"5\",\"AniStickerPackName\":\"企鹅\"},{\"QSid\":\"378\",\"QDes\":\"/企鹅笑哭\",\"IQLid\":\"378\",\"AQLid\":\"378\",\"EMCode\":\"10378\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"9\",\"AniStickerPackId\":\"5\",\"AniStickerPackName\":\"企鹅\"},{\"QSid\":\"377\",\"QDes\":\"/嗨\",\"IQLid\":\"377\",\"AQLid\":\"377\",\"EMCode\":\"10377\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"10\",\"AniStickerPackId\":\"5\",\"AniStickerPackName\":\"企鹅\"},{\"QSid\":\"403\",\"QDes\":\"/出去玩\",\"IQLid\":\"403\",\"AQLid\":\"403\",\"EMCode\":\"10403\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"1\",\"AniStickerPackId\":\"4\",\"AniStickerPackName\":\"QQ黄脸\"},{\"QSid\":\"402\",\"QDes\":\"/别说话\",\"IQLid\":\"402\",\"AQLid\":\"402\",\"EMCode\":\"10402\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"2\",\"AniStickerPackId\":\"4\",\"AniStickerPackName\":\"QQ黄脸\"},{\"QSid\":\"390\",\"QDes\":\"/太头秃\",\"IQLid\":\"390\",\"AQLid\":\"390\",\"EMCode\":\"10390\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"3\",\"AniStickerPackId\":\"4\",\"AniStickerPackName\":\"QQ黄脸\"},{\"QSid\":\"391\",\"QDes\":\"/太沧桑\",\"IQLid\":\"391\",\"AQLid\":\"391\",\"EMCode\":\"10391\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"4\",\"AniStickerPackId\":\"4\",\"AniStickerPackName\":\"QQ黄脸\"},{\"QSid\":\"388\",\"QDes\":\"/太头疼\",\"IQLid\":\"388\",\"AQLid\":\"388\",\"EMCode\":\"10388\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"5\",\"AniStickerPackId\":\"4\",\"AniStickerPackName\":\"QQ黄脸\"},{\"QSid\":\"389\",\"QDes\":\"/太赞了\",\"IQLid\":\"389\",\"AQLid\":\"389\",\"EMCode\":\"10389\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"6\",\"AniStickerPackId\":\"4\",\"AniStickerPackName\":\"QQ黄脸\"},{\"QSid\":\"386\",\"QDes\":\"/呜呜呜\",\"IQLid\":\"386\",\"AQLid\":\"386\",\"EMCode\":\"10386\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"7\",\"AniStickerPackId\":\"4\",\"AniStickerPackName\":\"QQ黄脸\"},{\"QSid\":\"385\",\"QDes\":\"/太气了\",\"IQLid\":\"385\",\"AQLid\":\"385\",\"EMCode\":\"10385\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"8\",\"AniStickerPackId\":\"4\",\"AniStickerPackName\":\"QQ黄脸\"},{\"QSid\":\"384\",\"QDes\":\"/晚安\",\"IQLid\":\"384\",\"AQLid\":\"384\",\"EMCode\":\"10384\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"9\",\"AniStickerPackId\":\"4\",\"AniStickerPackName\":\"QQ黄脸\"},{\"QSid\":\"387\",\"QDes\":\"/太好笑\",\"IQLid\":\"387\",\"AQLid\":\"387\",\"EMCode\":\"10387\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"10\",\"AniStickerPackId\":\"4\",\"AniStickerPackName\":\"QQ黄脸\"},{\"QSid\":\"413\",\"QDes\":\"/摇起来\",\"IQLid\":\"413\",\"AQLid\":\"413\",\"EMCode\":\"10413\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"1\",\"AniStickerPackId\":\"3\",\"AniStickerPackName\":\"喜花妮\"},{\"QSid\":\"405\",\"QDes\":\"/好运来\",\"IQLid\":\"405\",\"AQLid\":\"405\",\"EMCode\":\"10405\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"2\",\"AniStickerPackId\":\"3\",\"AniStickerPackName\":\"喜花妮\"},{\"QSid\":\"404\",\"QDes\":\"/闪亮登场\",\"IQLid\":\"404\",\"AQLid\":\"404\",\"EMCode\":\"10404\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"3\",\"AniStickerPackId\":\"3\",\"AniStickerPackName\":\"喜花妮\"},{\"QSid\":\"406\",\"QDes\":\"/姐是女王\",\"IQLid\":\"406\",\"AQLid\":\"406\",\"EMCode\":\"10406\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"4\",\"AniStickerPackId\":\"3\",\"AniStickerPackName\":\"喜花妮\"},{\"QSid\":\"410\",\"QDes\":\"/么么哒\",\"IQLid\":\"410\",\"AQLid\":\"410\",\"EMCode\":\"10410\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"5\",\"AniStickerPackId\":\"3\",\"AniStickerPackName\":\"喜花妮\"},{\"QSid\":\"411\",\"QDes\":\"/一起嗨\",\"IQLid\":\"411\",\"AQLid\":\"411\",\"EMCode\":\"10411\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"6\",\"AniStickerPackId\":\"3\",\"AniStickerPackName\":\"喜花妮\"},{\"QSid\":\"407\",\"QDes\":\"/我听听\",\"IQLid\":\"407\",\"AQLid\":\"407\",\"EMCode\":\"10407\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"7\",\"AniStickerPackId\":\"3\",\"AniStickerPackName\":\"喜花妮\"},{\"QSid\":\"408\",\"QDes\":\"/臭美\",\"IQLid\":\"408\",\"AQLid\":\"408\",\"EMCode\":\"10408\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"8\",\"AniStickerPackId\":\"3\",\"AniStickerPackName\":\"喜花妮\"},{\"QSid\":\"412\",\"QDes\":\"/开心\",\"IQLid\":\"412\",\"AQLid\":\"412\",\"EMCode\":\"10412\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"9\",\"AniStickerPackId\":\"3\",\"AniStickerPackName\":\"喜花妮\"},{\"QSid\":\"409\",\"QDes\":\"/送你花花\",\"IQLid\":\"409\",\"AQLid\":\"409\",\"EMCode\":\"10409\",\"QHide\":\"1\",\"AniStickerType\":1,\"AniStickerId\":\"10\",\"AniStickerPackId\":\"3\",\"AniStickerPackName\":\"喜花妮\"},{\"QSid\":\"394\",\"QDes\":\"/新年大龙\",\"IQLid\":\"394\",\"AQLid\":\"394\",\"EMCode\":\"10394\",\"QHide\":\"1\",\"AniStickerType\":3,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"40\"},{\"QSid\":\"14\",\"QDes\":\"/微笑\",\"IQLid\":\"23\",\"AQLid\":\"23\",\"EMCode\":\"100\"},{\"QSid\":\"1\",\"QDes\":\"/撇嘴\",\"IQLid\":\"40\",\"AQLid\":\"40\",\"EMCode\":\"101\"},{\"QSid\":\"2\",\"QDes\":\"/色\",\"IQLid\":\"19\",\"AQLid\":\"19\",\"EMCode\":\"102\"},{\"QSid\":\"3\",\"QDes\":\"/发呆\",\"IQLid\":\"43\",\"AQLid\":\"43\",\"EMCode\":\"103\"},{\"QSid\":\"4\",\"QDes\":\"/得意\",\"IQLid\":\"21\",\"AQLid\":\"21\",\"EMCode\":\"104\"},{\"QSid\":\"6\",\"QDes\":\"/害羞\",\"IQLid\":\"20\",\"AQLid\":\"20\",\"EMCode\":\"106\"},{\"QSid\":\"7\",\"QDes\":\"/闭嘴\",\"IQLid\":\"104\",\"AQLid\":\"106\",\"EMCode\":\"107\"},{\"QSid\":\"8\",\"QDes\":\"/睡\",\"IQLid\":\"35\",\"AQLid\":\"35\",\"EMCode\":\"108\"},{\"QSid\":\"9\",\"QDes\":\"/大哭\",\"IQLid\":\"10\",\"AQLid\":\"10\",\"EMCode\":\"109\"},{\"QSid\":\"5\",\"QDes\":\"/流泪\",\"IQLid\":\"9\",\"AQLid\":\"9\",\"EMCode\":\"105\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"16\"},{\"QSid\":\"10\",\"QDes\":\"/尴尬\",\"IQLid\":\"25\",\"AQLid\":\"25\",\"EMCode\":\"110\"},{\"QSid\":\"11\",\"QDes\":\"/发怒\",\"IQLid\":\"24\",\"AQLid\":\"24\",\"EMCode\":\"111\"},{\"QSid\":\"12\",\"QDes\":\"/调皮\",\"IQLid\":\"1\",\"AQLid\":\"1\",\"EMCode\":\"112\"},{\"QSid\":\"13\",\"QDes\":\"/呲牙\",\"IQLid\":\"0\",\"AQLid\":\"0\",\"EMCode\":\"113\"},{\"QSid\":\"0\",\"QDes\":\"/惊讶\",\"IQLid\":\"33\",\"AQLid\":\"33\",\"EMCode\":\"114\"},{\"QSid\":\"15\",\"QDes\":\"/难过\",\"IQLid\":\"32\",\"AQLid\":\"32\",\"EMCode\":\"115\"},{\"QSid\":\"16\",\"QDes\":\"/酷\",\"IQLid\":\"12\",\"AQLid\":\"12\",\"EMCode\":\"116\"},{\"QSid\":\"96\",\"QDes\":\"/冷汗\",\"IQLid\":\"27\",\"AQLid\":\"27\",\"EMCode\":\"117\"},{\"QSid\":\"18\",\"QDes\":\"/抓狂\",\"IQLid\":\"13\",\"AQLid\":\"13\",\"EMCode\":\"118\"},{\"QSid\":\"19\",\"QDes\":\"/吐\",\"IQLid\":\"22\",\"AQLid\":\"22\",\"EMCode\":\"119\"},{\"QSid\":\"20\",\"QDes\":\"/偷笑\",\"IQLid\":\"3\",\"AQLid\":\"3\",\"EMCode\":\"120\"},{\"QSid\":\"21\",\"QDes\":\"/可爱\",\"IQLid\":\"18\",\"AQLid\":\"18\",\"EMCode\":\"121\"},{\"QSid\":\"22\",\"QDes\":\"/白眼\",\"IQLid\":\"30\",\"AQLid\":\"30\",\"EMCode\":\"122\"},{\"QSid\":\"23\",\"QDes\":\"/傲慢\",\"IQLid\":\"31\",\"AQLid\":\"31\",\"EMCode\":\"123\"},{\"QSid\":\"24\",\"QDes\":\"/饥饿\",\"IQLid\":\"79\",\"AQLid\":\"81\",\"EMCode\":\"124\"},{\"QSid\":\"25\",\"QDes\":\"/困\",\"IQLid\":\"80\",\"AQLid\":\"82\",\"EMCode\":\"125\"},{\"QSid\":\"26\",\"QDes\":\"/惊恐\",\"IQLid\":\"26\",\"AQLid\":\"26\",\"EMCode\":\"126\"},{\"QSid\":\"27\",\"QDes\":\"/流汗\",\"IQLid\":\"2\",\"AQLid\":\"2\",\"EMCode\":\"127\"},{\"QSid\":\"28\",\"QDes\":\"/憨笑\",\"IQLid\":\"37\",\"AQLid\":\"37\",\"EMCode\":\"128\"},{\"QSid\":\"29\",\"QDes\":\"/悠闲\",\"IQLid\":\"50\",\"AQLid\":\"50\",\"EMCode\":\"129\"},{\"QSid\":\"30\",\"QDes\":\"/奋斗\",\"IQLid\":\"42\",\"AQLid\":\"42\",\"EMCode\":\"130\"},{\"QSid\":\"31\",\"QDes\":\"/咒骂\",\"IQLid\":\"81\",\"AQLid\":\"83\",\"EMCode\":\"131\"},{\"QSid\":\"32\",\"QDes\":\"/疑问\",\"IQLid\":\"34\",\"AQLid\":\"34\",\"EMCode\":\"132\"},{\"QSid\":\"33\",\"QDes\":\"/嘘\",\"IQLid\":\"11\",\"AQLid\":\"11\",\"EMCode\":\"133\"},{\"QSid\":\"34\",\"QDes\":\"/晕\",\"IQLid\":\"49\",\"AQLid\":\"49\",\"EMCode\":\"134\"},{\"QSid\":\"35\",\"QDes\":\"/折磨\",\"IQLid\":\"82\",\"AQLid\":\"84\",\"EMCode\":\"135\"},{\"QSid\":\"36\",\"QDes\":\"/衰\",\"IQLid\":\"39\",\"AQLid\":\"39\",\"EMCode\":\"136\"},{\"QSid\":\"37\",\"QDes\":\"/骷髅\",\"isStatic\":\"1\",\"IQLid\":\"76\",\"AQLid\":\"78\",\"EMCode\":\"137\"},{\"QSid\":\"38\",\"QDes\":\"/敲打\",\"IQLid\":\"5\",\"AQLid\":\"5\",\"EMCode\":\"138\"},{\"QSid\":\"39\",\"QDes\":\"/再见\",\"IQLid\":\"4\",\"AQLid\":\"4\",\"EMCode\":\"139\"},{\"QSid\":\"97\",\"QDes\":\"/擦汗\",\"IQLid\":\"6\",\"AQLid\":\"6\",\"EMCode\":\"140\"},{\"QSid\":\"98\",\"QDes\":\"/抠鼻\",\"IQLid\":\"83\",\"AQLid\":\"85\",\"EMCode\":\"141\"},{\"QSid\":\"99\",\"QDes\":\"/鼓掌\",\"IQLid\":\"84\",\"AQLid\":\"86\",\"EMCode\":\"142\"},{\"QSid\":\"100\",\"QDes\":\"/糗大了\",\"IQLid\":\"85\",\"AQLid\":\"87\",\"EMCode\":\"143\"},{\"QSid\":\"101\",\"QDes\":\"/坏笑\",\"IQLid\":\"46\",\"AQLid\":\"46\",\"EMCode\":\"144\"},{\"QSid\":\"102\",\"QDes\":\"/左哼哼\",\"IQLid\":\"86\",\"AQLid\":\"88\",\"EMCode\":\"145\"},{\"QSid\":\"103\",\"QDes\":\"/右哼哼\",\"IQLid\":\"44\",\"AQLid\":\"44\",\"EMCode\":\"146\"},{\"QSid\":\"104\",\"QDes\":\"/哈欠\",\"IQLid\":\"87\",\"AQLid\":\"89\",\"EMCode\":\"147\"},{\"QSid\":\"105\",\"QDes\":\"/鄙视\",\"IQLid\":\"48\",\"AQLid\":\"48\",\"EMCode\":\"148\"},{\"QSid\":\"106\",\"QDes\":\"/委屈\",\"IQLid\":\"14\",\"AQLid\":\"14\",\"EMCode\":\"149\"},{\"QSid\":\"107\",\"QDes\":\"/快哭了\",\"IQLid\":\"88\",\"AQLid\":\"90\",\"EMCode\":\"150\"},{\"QSid\":\"108\",\"QDes\":\"/阴险\",\"IQLid\":\"41\",\"AQLid\":\"41\",\"EMCode\":\"151\"},{\"QSid\":\"305\",\"QDes\":\"/右亲亲\",\"IQLid\":\"305\",\"AQLid\":\"305\",\"EMCode\":\"10305\"},{\"QSid\":\"109\",\"QDes\":\"/左亲亲\",\"IQLid\":\"36\",\"AQLid\":\"36\",\"EMCode\":\"152\"},{\"QSid\":\"110\",\"QDes\":\"/吓\",\"IQLid\":\"89\",\"AQLid\":\"91\",\"EMCode\":\"153\"},{\"QSid\":\"111\",\"QDes\":\"/可怜\",\"IQLid\":\"51\",\"AQLid\":\"51\",\"EMCode\":\"154\"},{\"QSid\":\"172\",\"QDes\":\"/眨眼睛\",\"IQLid\":\"142\",\"AQLid\":\"164\",\"EMCode\":\"242\"},{\"QSid\":\"182\",\"QDes\":\"/笑哭\",\"IQLid\":\"152\",\"AQLid\":\"174\",\"EMCode\":\"252\"},{\"QSid\":\"179\",\"QDes\":\"/doge\",\"IQLid\":\"149\",\"AQLid\":\"171\",\"EMCode\":\"249\"},{\"QSid\":\"173\",\"QDes\":\"/泪奔\",\"IQLid\":\"143\",\"AQLid\":\"165\",\"EMCode\":\"243\"},{\"QSid\":\"174\",\"QDes\":\"/无奈\",\"IQLid\":\"144\",\"AQLid\":\"166\",\"EMCode\":\"244\"},{\"QSid\":\"212\",\"QDes\":\"/托腮\",\"IQLid\":\"182\",\"AQLid\":\"161\",\"EMCode\":\"282\"},{\"QSid\":\"175\",\"QDes\":\"/卖萌\",\"IQLid\":\"145\",\"AQLid\":\"167\",\"EMCode\":\"245\"},{\"QSid\":\"178\",\"QDes\":\"/斜眼笑\",\"IQLid\":\"148\",\"AQLid\":\"170\",\"EMCode\":\"248\"},{\"QSid\":\"177\",\"QDes\":\"/喷血\",\"IQLid\":\"147\",\"AQLid\":\"169\",\"EMCode\":\"247\"},{\"QSid\":\"176\",\"QDes\":\"/小纠结\",\"IQLid\":\"146\",\"AQLid\":\"168\",\"EMCode\":\"246\"},{\"QSid\":\"183\",\"QDes\":\"/我最美\",\"IQLid\":\"153\",\"AQLid\":\"175\",\"EMCode\":\"253\"},{\"QSid\":\"262\",\"QDes\":\"/脑阔疼\",\"IQLid\":\"262\",\"AQLid\":\"262\",\"EMCode\":\"10262\"},{\"QSid\":\"263\",\"QDes\":\"/沧桑\",\"IQLid\":\"263\",\"AQLid\":\"263\",\"EMCode\":\"10263\"},{\"QSid\":\"264\",\"QDes\":\"/捂脸\",\"IQLid\":\"264\",\"AQLid\":\"264\",\"EMCode\":\"10264\"},{\"QSid\":\"265\",\"QDes\":\"/辣眼睛\",\"IQLid\":\"265\",\"AQLid\":\"265\",\"EMCode\":\"10265\"},{\"QSid\":\"266\",\"QDes\":\"/哦哟\",\"IQLid\":\"266\",\"AQLid\":\"266\",\"EMCode\":\"10266\"},{\"QSid\":\"267\",\"QDes\":\"/头秃\",\"IQLid\":\"267\",\"AQLid\":\"267\",\"EMCode\":\"10267\"},{\"QSid\":\"268\",\"QDes\":\"/问号脸\",\"IQLid\":\"268\",\"AQLid\":\"268\",\"EMCode\":\"10268\"},{\"QSid\":\"269\",\"QDes\":\"/暗中观察\",\"IQLid\":\"269\",\"AQLid\":\"269\",\"EMCode\":\"10269\"},{\"QSid\":\"270\",\"QDes\":\"/emm\",\"IQLid\":\"270\",\"AQLid\":\"270\",\"EMCode\":\"10270\"},{\"QSid\":\"271\",\"QDes\":\"/吃瓜\",\"IQLid\":\"271\",\"AQLid\":\"271\",\"EMCode\":\"10271\"},{\"QSid\":\"272\",\"QDes\":\"/呵呵哒\",\"IQLid\":\"272\",\"AQLid\":\"272\",\"EMCode\":\"10272\"},{\"QSid\":\"277\",\"QDes\":\"/汪汪\",\"IQLid\":\"277\",\"AQLid\":\"277\",\"EMCode\":\"10277\"},{\"QSid\":\"307\",\"QDes\":\"/喵喵\",\"IQLid\":\"307\",\"AQLid\":\"307\",\"EMCode\":\"10307\"},{\"QSid\":\"306\",\"QDes\":\"/牛气冲天\",\"isStatic\":\"1\",\"IQLid\":\"306\",\"AQLid\":\"306\",\"EMCode\":\"10306\"},{\"QSid\":\"281\",\"QDes\":\"/无眼笑\",\"IQLid\":\"281\",\"AQLid\":\"281\",\"EMCode\":\"10281\"},{\"QSid\":\"282\",\"QDes\":\"/敬礼\",\"IQLid\":\"282\",\"AQLid\":\"282\",\"EMCode\":\"10282\"},{\"QSid\":\"283\",\"QDes\":\"/狂笑\",\"IQLid\":\"283\",\"AQLid\":\"283\",\"EMCode\":\"10283\"},{\"QSid\":\"284\",\"QDes\":\"/面无表情\",\"IQLid\":\"284\",\"AQLid\":\"284\",\"EMCode\":\"10284\"},{\"QSid\":\"285\",\"QDes\":\"/摸鱼\",\"IQLid\":\"285\",\"AQLid\":\"285\",\"EMCode\":\"10285\"},{\"QSid\":\"293\",\"QDes\":\"/摸锦鲤\",\"IQLid\":\"293\",\"AQLid\":\"293\",\"EMCode\":\"10293\"},{\"QSid\":\"286\",\"QDes\":\"/魔鬼笑\",\"IQLid\":\"286\",\"AQLid\":\"286\",\"EMCode\":\"10286\"},{\"QSid\":\"287\",\"QDes\":\"/哦\",\"IQLid\":\"287\",\"AQLid\":\"287\",\"EMCode\":\"10287\"},{\"QSid\":\"289\",\"QDes\":\"/睁眼\",\"IQLid\":\"289\",\"AQLid\":\"289\",\"EMCode\":\"10289\"},{\"QSid\":\"294\",\"QDes\":\"/期待\",\"IQLid\":\"294\",\"AQLid\":\"294\",\"EMCode\":\"10294\"},{\"QSid\":\"297\",\"QDes\":\"/拜谢\",\"IQLid\":\"297\",\"AQLid\":\"297\",\"EMCode\":\"10297\"},{\"QSid\":\"298\",\"QDes\":\"/元宝\",\"IQLid\":\"298\",\"AQLid\":\"298\",\"EMCode\":\"10298\"},{\"QSid\":\"299\",\"QDes\":\"/牛啊\",\"IQLid\":\"299\",\"AQLid\":\"299\",\"EMCode\":\"10299\"},{\"QSid\":\"300\",\"QDes\":\"/胖三斤\",\"IQLid\":\"300\",\"AQLid\":\"300\",\"EMCode\":\"10300\"},{\"QSid\":\"323\",\"QDes\":\"/嫌弃\",\"IQLid\":\"323\",\"AQLid\":\"323\",\"EMCode\":\"10323\"},{\"QSid\":\"332\",\"QDes\":\"/举牌牌\",\"IQLid\":\"332\",\"AQLid\":\"332\",\"EMCode\":\"10332\"},{\"QSid\":\"336\",\"QDes\":\"/豹富\",\"IQLid\":\"336\",\"AQLid\":\"336\",\"EMCode\":\"10336\"},{\"QSid\":\"353\",\"QDes\":\"/拜托\",\"IQLid\":\"353\",\"AQLid\":\"353\",\"EMCode\":\"10353\"},{\"QSid\":\"355\",\"QDes\":\"/耶\",\"IQLid\":\"355\",\"AQLid\":\"355\",\"EMCode\":\"10355\"},{\"QSid\":\"356\",\"QDes\":\"/666\",\"IQLid\":\"356\",\"AQLid\":\"356\",\"EMCode\":\"10356\"},{\"QSid\":\"354\",\"QDes\":\"/尊嘟假嘟\",\"IQLid\":\"354\",\"AQLid\":\"354\",\"EMCode\":\"10354\"},{\"QSid\":\"352\",\"QDes\":\"/咦\",\"IQLid\":\"352\",\"AQLid\":\"352\",\"EMCode\":\"10352\"},{\"QSid\":\"357\",\"QDes\":\"/裂开\",\"IQLid\":\"357\",\"AQLid\":\"357\",\"EMCode\":\"10357\"},{\"QSid\":\"334\",\"QDes\":\"/虎虎生威\",\"IQLid\":\"334\",\"AQLid\":\"334\",\"EMCode\":\"10334\"},{\"QSid\":\"347\",\"QDes\":\"/大展宏兔\",\"IQLid\":\"347\",\"AQLid\":\"347\",\"EMCode\":\"10347\"},{\"QSid\":\"303\",\"QDes\":\"/右拜年\",\"IQLid\":\"303\",\"AQLid\":\"303\",\"EMCode\":\"10303\"},{\"QSid\":\"302\",\"QDes\":\"/左拜年\",\"IQLid\":\"302\",\"AQLid\":\"302\",\"EMCode\":\"10302\"},{\"QSid\":\"295\",\"QDes\":\"/拿到红包\",\"IQLid\":\"295\",\"AQLid\":\"295\",\"EMCode\":\"10295\"},{\"QSid\":\"311\",\"QDes\":\"/打call\",\"IQLid\":\"311\",\"AQLid\":\"311\",\"EMCode\":\"10311\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"1\"},{\"QSid\":\"312\",\"QDes\":\"/变形\",\"IQLid\":\"312\",\"AQLid\":\"312\",\"EMCode\":\"10312\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"2\"},{\"QSid\":\"314\",\"QDes\":\"/仔细分析\",\"IQLid\":\"314\",\"AQLid\":\"314\",\"EMCode\":\"10314\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"4\"},{\"QSid\":\"317\",\"QDes\":\"/菜汪\",\"IQLid\":\"317\",\"AQLid\":\"317\",\"EMCode\":\"10317\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"7\"},{\"QSid\":\"318\",\"QDes\":\"/崇拜\",\"IQLid\":\"318\",\"AQLid\":\"318\",\"EMCode\":\"10318\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"8\"},{\"QSid\":\"319\",\"QDes\":\"/比心\",\"IQLid\":\"319\",\"AQLid\":\"319\",\"EMCode\":\"10319\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"9\"},{\"QSid\":\"320\",\"QDes\":\"/庆祝\",\"IQLid\":\"320\",\"AQLid\":\"320\",\"EMCode\":\"10320\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"10\"},{\"QSid\":\"324\",\"QDes\":\"/吃糖\",\"IQLid\":\"324\",\"AQLid\":\"324\",\"EMCode\":\"10324\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"12\"},{\"QSid\":\"325\",\"QDes\":\"/惊吓\",\"IQLid\":\"325\",\"AQLid\":\"325\",\"EMCode\":\"10325\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"14\"},{\"QSid\":\"337\",\"QDes\":\"/花朵脸\",\"IQLid\":\"337\",\"AQLid\":\"337\",\"EMCode\":\"10337\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"22\"},{\"QSid\":\"338\",\"QDes\":\"/我想开了\",\"IQLid\":\"338\",\"AQLid\":\"338\",\"EMCode\":\"10338\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"20\"},{\"QSid\":\"339\",\"QDes\":\"/舔屏\",\"IQLid\":\"339\",\"AQLid\":\"339\",\"EMCode\":\"10339\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"21\"},{\"QSid\":\"341\",\"QDes\":\"/打招呼\",\"IQLid\":\"341\",\"AQLid\":\"341\",\"EMCode\":\"10341\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"24\"},{\"QSid\":\"342\",\"QDes\":\"/酸Q\",\"IQLid\":\"342\",\"AQLid\":\"342\",\"EMCode\":\"10342\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"26\"},{\"QSid\":\"343\",\"QDes\":\"/我方了\",\"IQLid\":\"343\",\"AQLid\":\"343\",\"EMCode\":\"10343\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"27\"},{\"QSid\":\"344\",\"QDes\":\"/大怨种\",\"IQLid\":\"344\",\"AQLid\":\"344\",\"EMCode\":\"10344\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"28\"},{\"QSid\":\"345\",\"QDes\":\"/红包多多\",\"IQLid\":\"345\",\"AQLid\":\"345\",\"EMCode\":\"10345\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"29\"},{\"QSid\":\"346\",\"QDes\":\"/你真棒棒\",\"IQLid\":\"346\",\"AQLid\":\"346\",\"EMCode\":\"10346\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"25\"},{\"QSid\":\"181\",\"QDes\":\"/戳一戳\",\"IQLid\":\"151\",\"AQLid\":\"173\",\"EMCode\":\"251\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"37\"},{\"QSid\":\"74\",\"QDes\":\"/太阳\",\"isStatic\":\"1\",\"IQLid\":\"73\",\"AQLid\":\"75\",\"EMCode\":\"176\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"35\"},{\"QSid\":\"75\",\"QDes\":\"/月亮\",\"isStatic\":\"1\",\"IQLid\":\"67\",\"AQLid\":\"68\",\"EMCode\":\"175\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"36\"},{\"QSid\":\"351\",\"QDes\":\"/敲敲\",\"IQLid\":\"351\",\"AQLid\":\"351\",\"EMCode\":\"10351\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"30\"},{\"QSid\":\"349\",\"QDes\":\"/坚强\",\"IQLid\":\"349\",\"AQLid\":\"349\",\"EMCode\":\"10349\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"32\"},{\"QSid\":\"350\",\"QDes\":\"/贴贴\",\"IQLid\":\"350\",\"AQLid\":\"350\",\"EMCode\":\"10350\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"31\"},{\"QSid\":\"395\",\"QDes\":\"/略略略\",\"IQLid\":\"395\",\"AQLid\":\"395\",\"EMCode\":\"10395\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"41\"},{\"QSid\":\"114\",\"QDes\":\"/篮球\",\"IQLid\":\"90\",\"AQLid\":\"92\",\"EMCode\":\"158\",\"AniStickerType\":2,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"13\"},{\"QSid\":\"358\",\"QDes\":\"/骰子\",\"IQLid\":\"358\",\"AQLid\":\"358\",\"QHide\":\"1\",\"EMCode\":\"10358\",\"AniStickerType\":2,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"33\"},{\"QSid\":\"359\",\"QDes\":\"/包剪锤\",\"IQLid\":\"359\",\"AQLid\":\"359\",\"QHide\":\"1\",\"EMCode\":\"10359\",\"AniStickerType\":2,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"34\"},{\"QSid\":\"326\",\"QDes\":\"/生气\",\"IQLid\":\"326\",\"AQLid\":\"326\",\"EMCode\":\"10326\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"15\"},{\"QSid\":\"53\",\"QDes\":\"/蛋糕\",\"IQLid\":\"59\",\"AQLid\":\"59\",\"EMCode\":\"168\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"17\"},{\"QSid\":\"49\",\"QDes\":\"/拥抱\",\"IQLid\":\"45\",\"AQLid\":\"45\",\"EMCode\":\"178\"},{\"QSid\":\"66\",\"QDes\":\"/爱心\",\"IQLid\":\"28\",\"AQLid\":\"28\",\"EMCode\":\"166\"},{\"QSid\":\"63\",\"QDes\":\"/玫瑰\",\"IQLid\":\"8\",\"AQLid\":\"8\",\"EMCode\":\"163\"},{\"QSid\":\"64\",\"QDes\":\"/凋谢\",\"IQLid\":\"57\",\"AQLid\":\"57\",\"EMCode\":\"164\"},{\"QSid\":\"187\",\"QDes\":\"/幽灵\",\"IQLid\":\"157\",\"AQLid\":\"179\",\"EMCode\":\"257\"},{\"QSid\":\"146\",\"QDes\":\"/爆筋\",\"IQLid\":\"116\",\"AQLid\":\"118\",\"EMCode\":\"121011\"},{\"QSid\":\"116\",\"QDes\":\"/示爱\",\"IQLid\":\"29\",\"AQLid\":\"29\",\"EMCode\":\"165\"},{\"QSid\":\"67\",\"QDes\":\"/心碎\",\"IQLid\":\"72\",\"AQLid\":\"74\",\"EMCode\":\"167\"},{\"QSid\":\"60\",\"QDes\":\"/咖啡\",\"IQLid\":\"66\",\"AQLid\":\"66\",\"EMCode\":\"160\"},{\"QSid\":\"185\",\"QDes\":\"/羊驼\",\"IQLid\":\"155\",\"AQLid\":\"177\",\"EMCode\":\"255\"},{\"QSid\":\"137\",\"QDes\":\"/鞭炮\",\"isStatic\":\"1\",\"IQLid\":\"107\",\"AQLid\":\"109\",\"EMCode\":\"121002\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"18\"},{\"QSid\":\"333\",\"QDes\":\"/烟花\",\"isStatic\":\"1\",\"IQLid\":\"333\",\"AQLid\":\"333\",\"EMCode\":\"10333\",\"AniStickerType\":1,\"AniStickerPackId\":\"1\",\"AniStickerId\":\"19\"},{\"QSid\":\"76\",\"QDes\":\"/赞\",\"IQLid\":\"52\",\"AQLid\":\"52\",\"EMCode\":\"179\"},{\"QSid\":\"124\",\"QDes\":\"/OK\",\"IQLid\":\"64\",\"AQLid\":\"64\",\"EMCode\":\"189\"},{\"QSid\":\"118\",\"QDes\":\"/抱拳\",\"IQLid\":\"56\",\"AQLid\":\"56\",\"EMCode\":\"183\"},{\"QSid\":\"78\",\"QDes\":\"/握手\",\"IQLid\":\"54\",\"AQLid\":\"54\",\"EMCode\":\"181\"},{\"QSid\":\"119\",\"QDes\":\"/勾引\",\"IQLid\":\"63\",\"AQLid\":\"63\",\"EMCode\":\"184\"},{\"QSid\":\"79\",\"QDes\":\"/胜利\",\"IQLid\":\"55\",\"AQLid\":\"55\",\"EMCode\":\"182\"},{\"QSid\":\"120\",\"QDes\":\"/拳头\",\"IQLid\":\"71\",\"AQLid\":\"73\",\"EMCode\":\"185\"},{\"QSid\":\"121\",\"QDes\":\"/差劲\",\"IQLid\":\"70\",\"AQLid\":\"72\",\"EMCode\":\"186\"},{\"QSid\":\"77\",\"QDes\":\"/踩\",\"IQLid\":\"53\",\"AQLid\":\"53\",\"EMCode\":\"180\"},{\"QSid\":\"123\",\"QDes\":\"/NO\",\"IQLid\":\"92\",\"AQLid\":\"94\",\"EMCode\":\"188\"},{\"QSid\":\"201\",\"QDes\":\"/点赞\",\"IQLid\":\"171\",\"AQLid\":\"150\",\"EMCode\":\"271\"},{\"QSid\":\"273\",\"QDes\":\"/我酸了\",\"isStatic\":\"1\",\"IQLid\":\"273\",\"AQLid\":\"273\",\"EMCode\":\"10273\"},{\"QSid\":\"46\",\"QDes\":\"/猪头\",\"isStatic\":\"1\",\"IQLid\":\"7\",\"AQLid\":\"7\",\"EMCode\":\"162\"},{\"QSid\":\"112\",\"QDes\":\"/菜刀\",\"IQLid\":\"17\",\"AQLid\":\"17\",\"EMCode\":\"155\"},{\"QSid\":\"56\",\"QDes\":\"/刀\",\"IQLid\":\"68\",\"AQLid\":\"70\",\"EMCode\":\"171\"},{\"QSid\":\"169\",\"QDes\":\"/手枪\",\"isStatic\":\"1\",\"IQLid\":\"139\",\"AQLid\":\"141\",\"EMCode\":\"121034\"},{\"QSid\":\"171\",\"QDes\":\"/茶\",\"IQLid\":\"141\",\"AQLid\":\"163\",\"EMCode\":\"241\"},{\"QSid\":\"59\",\"QDes\":\"/便便\",\"IQLid\":\"15\",\"AQLid\":\"15\",\"EMCode\":\"174\"},{\"QSid\":\"144\",\"QDes\":\"/喝彩\",\"isStatic\":\"1\",\"IQLid\":\"114\",\"AQLid\":\"116\",\"EMCode\":\"121009\"},{\"QSid\":\"147\",\"QDes\":\"/棒棒糖\",\"isStatic\":\"1\",\"IQLid\":\"117\",\"AQLid\":\"119\",\"EMCode\":\"121012\"},{\"QSid\":\"89\",\"QDes\":\"/西瓜\",\"isStatic\":\"1\",\"IQLid\":\"60\",\"AQLid\":\"60\",\"EMCode\":\"156\"},{\"QSid\":\"148\",\"QDes\":\"/喝奶\",\"isStatic\":\"1\",\"IQLid\":\"118\",\"AQLid\":\"120\",\"QHide\":\"1\",\"EMCode\":\"121013\"},{\"QSid\":\"55\",\"QDes\":\"/炸弹\",\"isStatic\":\"1\",\"IQLid\":\"16\",\"AQLid\":\"16\",\"QHide\":\"1\",\"EMCode\":\"170\"},{\"QSid\":\"41\",\"QDes\":\"/发抖\",\"isStatic\":\"1\",\"IQLid\":\"69\",\"AQLid\":\"71\",\"EMCode\":\"193\"},{\"QSid\":\"125\",\"QDes\":\"/转圈\",\"IQLid\":\"95\",\"AQLid\":\"97\",\"EMCode\":\"195\"},{\"QSid\":\"42\",\"QDes\":\"/爱情\",\"IQLid\":\"38\",\"AQLid\":\"38\",\"EMCode\":\"190\"},{\"QSid\":\"43\",\"QDes\":\"/跳跳\",\"IQLid\":\"93\",\"AQLid\":\"95\",\"EMCode\":\"192\"},{\"QSid\":\"86\",\"QDes\":\"/怄火\",\"IQLid\":\"94\",\"AQLid\":\"96\",\"EMCode\":\"194\"},{\"QSid\":\"129\",\"QDes\":\"/挥手\",\"IQLid\":\"77\",\"AQLid\":\"79\",\"EMCode\":\"199\"},{\"QSid\":\"226\",\"QDes\":\"/拍桌\",\"IQLid\":\"196\",\"isCMEmoji\":\"1\",\"AQLid\":\"198\",\"QHide\":\"1\",\"EMCode\":\"297\"},{\"QSid\":\"85\",\"QDes\":\"/飞吻\",\"isStatic\":\"1\",\"IQLid\":\"47\",\"AQLid\":\"47\",\"EMCode\":\"191\"},{\"QSid\":\"215\",\"QDes\":\"/糊脸\",\"IQLid\":\"185\",\"isCMEmoji\":\"1\",\"AQLid\":\"187\",\"QHide\":\"1\",\"EMCode\":\"285\"},{\"QSid\":\"214\",\"QDes\":\"/啵啵\",\"IQLid\":\"184\",\"isCMEmoji\":\"1\",\"AQLid\":\"186\",\"QHide\":\"1\",\"EMCode\":\"284\"},{\"QSid\":\"222\",\"QDes\":\"/抱抱\",\"IQLid\":\"192\",\"isCMEmoji\":\"1\",\"AQLid\":\"194\",\"QHide\":\"1\",\"EMCode\":\"292\"},{\"QSid\":\"203\",\"QDes\":\"/托脸\",\"IQLid\":\"173\",\"AQLid\":\"152\",\"QHide\":\"1\",\"EMCode\":\"273\"},{\"QSid\":\"235\",\"QDes\":\"/颤抖\",\"IQLid\":\"205\",\"isCMEmoji\":\"1\",\"AQLid\":\"207\",\"QHide\":\"1\",\"EMCode\":\"305\"},{\"QSid\":\"241\",\"QDes\":\"/生日快乐\",\"IQLid\":\"211\",\"isCMEmoji\":\"1\",\"AQLid\":\"213\",\"QHide\":\"1\",\"EMCode\":\"311\"},{\"QSid\":\"237\",\"QDes\":\"/偷看\",\"IQLid\":\"207\",\"isCMEmoji\":\"1\",\"AQLid\":\"209\",\"QHide\":\"1\",\"EMCode\":\"307\"},{\"QSid\":\"218\",\"QDes\":\"/舔一舔\",\"IQLid\":\"188\",\"isCMEmoji\":\"1\",\"AQLid\":\"190\",\"QHide\":\"1\",\"EMCode\":\"288\"},{\"QSid\":\"233\",\"QDes\":\"/掐一掐\",\"IQLid\":\"203\",\"isCMEmoji\":\"1\",\"AQLid\":\"205\",\"QHide\":\"1\",\"EMCode\":\"303\"},{\"QSid\":\"232\",\"QDes\":\"/佛系\",\"IQLid\":\"202\",\"isCMEmoji\":\"1\",\"AQLid\":\"204\",\"QHide\":\"1\",\"EMCode\":\"302\"},{\"QSid\":\"238\",\"QDes\":\"/扇脸\",\"IQLid\":\"208\",\"isCMEmoji\":\"1\",\"AQLid\":\"210\",\"QHide\":\"1\",\"EMCode\":\"308\"},{\"QSid\":\"217\",\"QDes\":\"/扯一扯\",\"IQLid\":\"187\",\"isCMEmoji\":\"1\",\"AQLid\":\"189\",\"QHide\":\"1\",\"EMCode\":\"287\"},{\"QSid\":\"225\",\"QDes\":\"/撩一撩\",\"IQLid\":\"195\",\"isCMEmoji\":\"1\",\"AQLid\":\"197\",\"QHide\":\"1\",\"EMCode\":\"296\"},{\"QSid\":\"230\",\"QDes\":\"/嘲讽\",\"IQLid\":\"200\",\"isCMEmoji\":\"1\",\"AQLid\":\"202\",\"QHide\":\"1\",\"EMCode\":\"300\"},{\"QSid\":\"194\",\"QDes\":\"/不开心\",\"IQLid\":\"164\",\"AQLid\":\"143\",\"QHide\":\"1\",\"EMCode\":\"264\"},{\"QSid\":\"210\",\"QDes\":\"/飙泪\",\"IQLid\":\"180\",\"AQLid\":\"159\",\"QHide\":\"1\",\"EMCode\":\"280\"},{\"QSid\":\"193\",\"QDes\":\"/大笑\",\"IQLid\":\"163\",\"AQLid\":\"185\",\"QHide\":\"1\",\"EMCode\":\"263\"},{\"QSid\":\"204\",\"QDes\":\"/吃\",\"IQLid\":\"174\",\"AQLid\":\"153\",\"QHide\":\"1\",\"EMCode\":\"274\"},{\"QSid\":\"200\",\"QDes\":\"/求求\",\"IQLid\":\"170\",\"AQLid\":\"149\",\"QHide\":\"1\",\"EMCode\":\"270\"},{\"QSid\":\"290\",\"QDes\":\"/敲开心\",\"IQLid\":\"290\",\"isCMEmoji\":\"1\",\"AQLid\":\"290\",\"QHide\":\"1\",\"EMCode\":\"20240\"},{\"QSid\":\"224\",\"QDes\":\"/开枪\",\"IQLid\":\"194\",\"isCMEmoji\":\"1\",\"AQLid\":\"196\",\"QHide\":\"1\",\"EMCode\":\"295\"},{\"QSid\":\"229\",\"QDes\":\"/干杯\",\"IQLid\":\"199\",\"isCMEmoji\":\"1\",\"AQLid\":\"201\",\"QHide\":\"1\",\"EMCode\":\"299\"},{\"QSid\":\"221\",\"QDes\":\"/顶呱呱\",\"IQLid\":\"191\",\"isCMEmoji\":\"1\",\"AQLid\":\"193\",\"QHide\":\"1\",\"EMCode\":\"291\"},{\"QSid\":\"219\",\"QDes\":\"/蹭一蹭\",\"IQLid\":\"189\",\"isCMEmoji\":\"1\",\"AQLid\":\"191\",\"QHide\":\"1\",\"EMCode\":\"289\"},{\"QSid\":\"227\",\"QDes\":\"/拍手\",\"IQLid\":\"197\",\"isCMEmoji\":\"1\",\"AQLid\":\"199\",\"QHide\":\"1\",\"EMCode\":\"294\"},{\"QSid\":\"216\",\"QDes\":\"/拍头\",\"IQLid\":\"186\",\"isCMEmoji\":\"1\",\"AQLid\":\"188\",\"QHide\":\"1\",\"EMCode\":\"286\"},{\"QSid\":\"231\",\"QDes\":\"/哼\",\"IQLid\":\"201\",\"isCMEmoji\":\"1\",\"AQLid\":\"203\",\"QHide\":\"1\",\"EMCode\":\"301\"},{\"QSid\":\"244\",\"QDes\":\"/扔狗\",\"IQLid\":\"214\",\"isCMEmoji\":\"1\",\"AQLid\":\"216\",\"QHide\":\"1\",\"EMCode\":\"312\"},{\"QSid\":\"223\",\"QDes\":\"/暴击\",\"IQLid\":\"193\",\"isCMEmoji\":\"1\",\"AQLid\":\"195\",\"QHide\":\"1\",\"EMCode\":\"293\"},{\"QSid\":\"243\",\"QDes\":\"/甩头\",\"IQLid\":\"213\",\"isCMEmoji\":\"1\",\"AQLid\":\"215\",\"QHide\":\"1\",\"EMCode\":\"313\"},{\"QSid\":\"211\",\"QDes\":\"/我不看\",\"IQLid\":\"181\",\"AQLid\":\"160\",\"QHide\":\"1\",\"EMCode\":\"281\"},{\"QSid\":\"292\",\"QDes\":\"/让我康康\",\"IQLid\":\"292\",\"isCMEmoji\":\"1\",\"AQLid\":\"292\",\"QHide\":\"1\",\"EMCode\":\"20242\"},{\"QSid\":\"240\",\"QDes\":\"/喷脸\",\"IQLid\":\"210\",\"isCMEmoji\":\"1\",\"AQLid\":\"212\",\"QHide\":\"1\",\"EMCode\":\"310\"},{\"QSid\":\"180\",\"QDes\":\"/惊喜\",\"IQLid\":\"150\",\"AQLid\":\"172\",\"QHide\":\"1\",\"EMCode\":\"250\"},{\"QSid\":\"122\",\"QDes\":\"/爱你\",\"IQLid\":\"65\",\"AQLid\":\"65\",\"QHide\":\"1\",\"EMCode\":\"187\"},{\"QSid\":\"202\",\"QDes\":\"/无聊\",\"IQLid\":\"172\",\"AQLid\":\"151\",\"QHide\":\"1\",\"EMCode\":\"272\"},{\"QSid\":\"278\",\"QDes\":\"/汗\",\"IQLid\":\"278\",\"isCMEmoji\":\"1\",\"AQLid\":\"278\",\"QHide\":\"1\",\"EMCode\":\"20237\"},{\"QSid\":\"301\",\"QDes\":\"/好闪\",\"IQLid\":\"301\",\"AQLid\":\"301\",\"QHide\":\"1\",\"EMCode\":\"10301\"},{\"QSid\":\"288\",\"QDes\":\"/请\",\"IQLid\":\"288\",\"AQLid\":\"288\",\"QHide\":\"1\",\"EMCode\":\"10288\"},{\"QSid\":\"322\",\"QDes\":\"/拒绝\",\"IQLid\":\"322\",\"AQLid\":\"322\",\"QHide\":\"1\",\"EMCode\":\"10322\"},{\"QSid\":\"198\",\"QDes\":\"/呃\",\"IQLid\":\"168\",\"AQLid\":\"147\",\"QHide\":\"1\",\"EMCode\":\"268\"},{\"QSid\":\"348\",\"QDes\":\"/福萝卜\",\"IQLid\":\"348\",\"AQLid\":\"348\",\"QHide\":\"1\",\"EMCode\":\"10348\"},{\"QSid\":\"206\",\"QDes\":\"/害怕\",\"IQLid\":\"176\",\"AQLid\":\"155\",\"QHide\":\"1\",\"EMCode\":\"276\"},{\"QSid\":\"239\",\"QDes\":\"/原谅\",\"IQLid\":\"209\",\"isCMEmoji\":\"1\",\"AQLid\":\"211\",\"QHide\":\"1\",\"EMCode\":\"309\"}]");
const emoji = JSON.parse("[{\"QSid\":\"😊\",\"QCid\":\"128522\",\"AQLid\":\"0\",\"QDes\":\"/嘿嘿\",\"EMCode\":\"400832\"},{\"QSid\":\"😌\",\"QCid\":\"128524\",\"AQLid\":\"1\",\"QDes\":\"/羞涩\",\"EMCode\":\"400834\"},{\"QSid\":\"😚\",\"QCid\":\"128538\",\"AQLid\":\"2\",\"QDes\":\"/亲亲\",\"EMCode\":\"400848\"},{\"QSid\":\"😓\",\"QCid\":\"128531\",\"AQLid\":\"3\",\"QDes\":\"/汗\",\"EMCode\":\"400841\"},{\"QSid\":\"😰\",\"QCid\":\"128560\",\"AQLid\":\"4\",\"QDes\":\"/紧张\",\"EMCode\":\"400870\"},{\"QSid\":\"😝\",\"QCid\":\"128541\",\"AQLid\":\"5\",\"QDes\":\"/吐舌\",\"EMCode\":\"400851\"},{\"QSid\":\"😁\",\"QCid\":\"128513\",\"AQLid\":\"6\",\"QDes\":\"/呲牙\",\"EMCode\":\"400823\"},{\"QSid\":\"😜\",\"QCid\":\"128540\",\"AQLid\":\"7\",\"QDes\":\"/淘气\",\"EMCode\":\"400850\"},{\"QSid\":\"☺\",\"QCid\":\"9786\",\"AQLid\":\"8\",\"QDes\":\"/可爱\",\"EMCode\":\"401181\"},{\"QSid\":\"😉\",\"QCid\":\"128521\",\"AQLid\":\"9\",\"QDes\":\"/媚眼\",\"QHide\":\"1\",\"EMCode\":\"400831\"},{\"QSid\":\"😍\",\"QCid\":\"128525\",\"AQLid\":\"10\",\"QDes\":\"/花痴\",\"EMCode\":\"400835\"},{\"QSid\":\"😔\",\"QCid\":\"128532\",\"AQLid\":\"11\",\"QDes\":\"/失落\",\"EMCode\":\"400842\"},{\"QSid\":\"😄\",\"QCid\":\"128516\",\"AQLid\":\"12\",\"QDes\":\"/高兴\",\"EMCode\":\"400826\"},{\"QSid\":\"😏\",\"QCid\":\"128527\",\"AQLid\":\"13\",\"QDes\":\"/哼哼\",\"EMCode\":\"400837\"},{\"QSid\":\"😒\",\"QCid\":\"128530\",\"AQLid\":\"14\",\"QDes\":\"/不屑\",\"EMCode\":\"400840\"},{\"QSid\":\"😳\",\"QCid\":\"128563\",\"AQLid\":\"15\",\"QDes\":\"/瞪眼\",\"EMCode\":\"400873\"},{\"QSid\":\"😘\",\"QCid\":\"128536\",\"AQLid\":\"16\",\"QDes\":\"/飞吻\",\"EMCode\":\"400846\"},{\"QSid\":\"😭\",\"QCid\":\"128557\",\"AQLid\":\"17\",\"QDes\":\"/大哭\",\"EMCode\":\"400867\"},{\"QSid\":\"😱\",\"QCid\":\"128561\",\"AQLid\":\"18\",\"QDes\":\"/害怕\",\"EMCode\":\"400871\"},{\"QSid\":\"😂\",\"QCid\":\"128514\",\"AQLid\":\"19\",\"QDes\":\"/激动\",\"EMCode\":\"400824\"},{\"QSid\":\"💪\",\"QCid\":\"128170\",\"AQLid\":\"20\",\"QDes\":\"/肌肉\",\"EMCode\":\"400644\"},{\"QSid\":\"👊\",\"QCid\":\"128074\",\"AQLid\":\"21\",\"QDes\":\"/拳头\",\"EMCode\":\"400390\"},{\"QSid\":\"👍\",\"QCid\":\"128077\",\"AQLid\":\"22\",\"QDes\":\"/厉害\",\"EMCode\":\"400408\"},{\"QSid\":\"☝\",\"QCid\":\"9757\",\"AQLid\":\"23\",\"QDes\":\"/向上\",\"QHide\":\"1\",\"EMCode\":\"401203\"},{\"QSid\":\"👏\",\"QCid\":\"128079\",\"AQLid\":\"24\",\"QDes\":\"/鼓掌\",\"EMCode\":\"400420\"},{\"QSid\":\"✌\",\"QCid\":\"9996\",\"AQLid\":\"25\",\"QDes\":\"/胜利\",\"QHide\":\"1\",\"EMCode\":\"401210\"},{\"QSid\":\"👎\",\"QCid\":\"128078\",\"AQLid\":\"26\",\"QDes\":\"/鄙视\",\"EMCode\":\"400414\"},{\"QSid\":\"🙏\",\"QCid\":\"128591\",\"AQLid\":\"27\",\"QDes\":\"/合十\",\"EMCode\":\"400396\"},{\"QSid\":\"👌\",\"QCid\":\"128076\",\"AQLid\":\"28\",\"QDes\":\"/好的\",\"EMCode\":\"400402\"},{\"QSid\":\"👈\",\"QCid\":\"128072\",\"AQLid\":\"29\",\"QDes\":\"/向左\",\"QHide\":\"1\",\"EMCode\":\"400378\"},{\"QSid\":\"👉\",\"QCid\":\"128073\",\"AQLid\":\"30\",\"QDes\":\"/向右\",\"QHide\":\"1\",\"EMCode\":\"400384\"},{\"QSid\":\"👆\",\"QCid\":\"128070\",\"AQLid\":\"31\",\"QDes\":\"/向上\",\"EMCode\":\"400366\"},{\"QSid\":\"👇\",\"QCid\":\"128071\",\"AQLid\":\"32\",\"QDes\":\"/向下\",\"QHide\":\"1\",\"EMCode\":\"400372\"},{\"QSid\":\"👀\",\"QCid\":\"128064\",\"AQLid\":\"33\",\"QDes\":\"/眼睛\",\"EMCode\":\"400351\"},{\"QSid\":\"👃\",\"QCid\":\"128067\",\"AQLid\":\"34\",\"QDes\":\"/鼻子\",\"QHide\":\"1\",\"EMCode\":\"400358\"},{\"QSid\":\"👄\",\"QCid\":\"128068\",\"AQLid\":\"35\",\"QDes\":\"/嘴唇\",\"QHide\":\"1\",\"EMCode\":\"400364\"},{\"QSid\":\"👂\",\"QCid\":\"128066\",\"AQLid\":\"36\",\"QDes\":\"/耳朵\",\"QHide\":\"1\",\"EMCode\":\"400352\"},{\"QSid\":\"🍚\",\"QCid\":\"127834\",\"AQLid\":\"37\",\"QDes\":\"/米饭\",\"QHide\":\"1\",\"EMCode\":\"400149\"},{\"QSid\":\"🍝\",\"QCid\":\"127837\",\"AQLid\":\"38\",\"QDes\":\"/意面\",\"QHide\":\"1\",\"EMCode\":\"400152\"},{\"QSid\":\"🍜\",\"QCid\":\"127836\",\"AQLid\":\"39\",\"QDes\":\"/拉面\",\"EMCode\":\"400151\"},{\"QSid\":\"🍙\",\"QCid\":\"127833\",\"AQLid\":\"40\",\"QDes\":\"/饭团\",\"QHide\":\"1\",\"EMCode\":\"400148\"},{\"QSid\":\"🍧\",\"QCid\":\"127847\",\"AQLid\":\"41\",\"QDes\":\"/刨冰\",\"EMCode\":\"400162\"},{\"QSid\":\"🍣\",\"QCid\":\"127843\",\"AQLid\":\"42\",\"QDes\":\"/寿司\",\"QHide\":\"1\",\"EMCode\":\"400158\"},{\"QSid\":\"🎂\",\"QCid\":\"127874\",\"AQLid\":\"43\",\"QDes\":\"/蛋糕\",\"QHide\":\"1\",\"EMCode\":\"400186\"},{\"QSid\":\"🍞\",\"QCid\":\"127838\",\"AQLid\":\"44\",\"QDes\":\"/面包\",\"EMCode\":\"400153\"},{\"QSid\":\"🍔\",\"QCid\":\"127828\",\"AQLid\":\"45\",\"QDes\":\"/汉堡\",\"QHide\":\"1\",\"EMCode\":\"400143\"},{\"QSid\":\"🍳\",\"QCid\":\"127859\",\"AQLid\":\"46\",\"QDes\":\"/煎蛋\",\"QHide\":\"1\",\"EMCode\":\"400174\"},{\"QSid\":\"🍟\",\"QCid\":\"127839\",\"AQLid\":\"47\",\"QDes\":\"/薯条\",\"QHide\":\"1\",\"EMCode\":\"400154\"},{\"QSid\":\"🍺\",\"QCid\":\"127866\",\"AQLid\":\"48\",\"QDes\":\"/啤酒\",\"EMCode\":\"400181\"},{\"QSid\":\"🍻\",\"QCid\":\"127867\",\"AQLid\":\"49\",\"QDes\":\"/干杯\",\"EMCode\":\"400182\"},{\"QSid\":\"🍸\",\"QCid\":\"127864\",\"AQLid\":\"50\",\"QDes\":\"/高脚杯\",\"QHide\":\"1\",\"EMCode\":\"400179\"},{\"QSid\":\"☕\",\"QCid\":\"9749\",\"AQLid\":\"51\",\"QDes\":\"/咖啡\",\"EMCode\":\"401262\"},{\"QSid\":\"🍎\",\"QCid\":\"127822\",\"AQLid\":\"52\",\"QDes\":\"/苹果\",\"EMCode\":\"400137\"},{\"QSid\":\"🍊\",\"QCid\":\"127818\",\"AQLid\":\"53\",\"QDes\":\"/橙子\",\"QHide\":\"1\",\"EMCode\":\"400133\"},{\"QSid\":\"🍓\",\"QCid\":\"127827\",\"AQLid\":\"54\",\"QDes\":\"/草莓\",\"EMCode\":\"400142\"},{\"QSid\":\"🍉\",\"QCid\":\"127817\",\"AQLid\":\"55\",\"QDes\":\"/西瓜\",\"EMCode\":\"400132\"},{\"QSid\":\"💊\",\"QCid\":\"128138\",\"AQLid\":\"56\",\"QDes\":\"/药丸\",\"QHide\":\"1\",\"EMCode\":\"400612\"},{\"QSid\":\"🚬\",\"QCid\":\"128684\",\"AQLid\":\"57\",\"QDes\":\"/吸烟\",\"EMCode\":\"400987\"},{\"QSid\":\"🎄\",\"QCid\":\"127876\",\"AQLid\":\"58\",\"QDes\":\"/圣诞树\",\"QHide\":\"1\",\"EMCode\":\"400188\"},{\"QSid\":\"🌹\",\"QCid\":\"127801\",\"AQLid\":\"59\",\"QDes\":\"/玫瑰\",\"EMCode\":\"400116\"},{\"QSid\":\"🎉\",\"QCid\":\"127881\",\"AQLid\":\"60\",\"QDes\":\"/庆祝\",\"EMCode\":\"400198\"},{\"QSid\":\"🌴\",\"QCid\":\"127796\",\"AQLid\":\"61\",\"QDes\":\"/椰子树\",\"QHide\":\"1\",\"EMCode\":\"400112\"},{\"QSid\":\"💝\",\"QCid\":\"128157\",\"AQLid\":\"62\",\"QDes\":\"/礼物\",\"EMCode\":\"400631\"},{\"QSid\":\"🎀\",\"QCid\":\"127872\",\"AQLid\":\"63\",\"QDes\":\"/蝴蝶结\",\"QHide\":\"1\",\"EMCode\":\"400184\"},{\"QSid\":\"🎈\",\"QCid\":\"127880\",\"AQLid\":\"64\",\"QDes\":\"/气球\",\"QHide\":\"1\",\"EMCode\":\"400197\"},{\"QSid\":\"🐚\",\"QCid\":\"128026\",\"AQLid\":\"65\",\"QDes\":\"/海螺\",\"QHide\":\"1\",\"EMCode\":\"400314\"},{\"QSid\":\"💍\",\"QCid\":\"128141\",\"AQLid\":\"66\",\"QDes\":\"/戒指\",\"QHide\":\"1\",\"EMCode\":\"400615\"},{\"QSid\":\"💣\",\"QCid\":\"128163\",\"AQLid\":\"67\",\"QDes\":\"/炸弹\",\"EMCode\":\"400637\"},{\"QSid\":\"👑\",\"QCid\":\"128081\",\"AQLid\":\"68\",\"QDes\":\"/皇冠\",\"QHide\":\"1\",\"EMCode\":\"400432\"},{\"QSid\":\"🔔\",\"QCid\":\"128276\",\"AQLid\":\"69\",\"QDes\":\"/铃铛\",\"QHide\":\"1\",\"EMCode\":\"400751\"},{\"QSid\":\"⭐\",\"QCid\":\"11088\",\"AQLid\":\"70\",\"QDes\":\"/星星\",\"QHide\":\"1\",\"EMCode\":\"401686\"},{\"QSid\":\"✨\",\"QCid\":\"10024\",\"AQLid\":\"71\",\"QDes\":\"/闪光\",\"EMCode\":\"401137\"},{\"QSid\":\"💨\",\"QCid\":\"128168\",\"AQLid\":\"72\",\"QDes\":\"/吹气\",\"EMCode\":\"400642\"},{\"QSid\":\"💦\",\"QCid\":\"128166\",\"AQLid\":\"73\",\"QDes\":\"/水\",\"EMCode\":\"400640\"},{\"QSid\":\"🔥\",\"QCid\":\"128293\",\"AQLid\":\"74\",\"QDes\":\"/火\",\"EMCode\":\"400768\"},{\"QSid\":\"🏆\",\"QCid\":\"127942\",\"AQLid\":\"75\",\"QDes\":\"/奖杯\",\"QHide\":\"1\",\"EMCode\":\"400256\"},{\"QSid\":\"💰\",\"QCid\":\"128176\",\"AQLid\":\"76\",\"QDes\":\"/钱\",\"QHide\":\"1\",\"EMCode\":\"400655\"},{\"QSid\":\"💤\",\"QCid\":\"128164\",\"AQLid\":\"77\",\"QDes\":\"/睡觉\",\"EMCode\":\"400638\"},{\"QSid\":\"⚡\",\"QCid\":\"9889\",\"AQLid\":\"78\",\"QDes\":\"/闪电\",\"QHide\":\"1\",\"EMCode\":\"401685\"},{\"QSid\":\"👣\",\"QCid\":\"128099\",\"AQLid\":\"79\",\"QDes\":\"/脚印\",\"QHide\":\"1\",\"EMCode\":\"400450\"},{\"QSid\":\"💩\",\"QCid\":\"128169\",\"AQLid\":\"80\",\"QDes\":\"/便便\",\"EMCode\":\"400643\"},{\"QSid\":\"💉\",\"QCid\":\"128137\",\"AQLid\":\"81\",\"QDes\":\"/打针\",\"EMCode\":\"400611\"},{\"QSid\":\"♨\",\"QCid\":\"9832\",\"AQLid\":\"82\",\"QDes\":\"/热\",\"QHide\":\"1\",\"EMCode\":\"401287\"},{\"QSid\":\"📫\",\"QCid\":\"128235\",\"AQLid\":\"83\",\"QDes\":\"/邮箱\",\"EMCode\":\"400714\"},{\"QSid\":\"🔑\",\"QCid\":\"128273\",\"AQLid\":\"84\",\"QDes\":\"/钥匙\",\"QHide\":\"1\",\"EMCode\":\"400748\"},{\"QSid\":\"🔒\",\"QCid\":\"128274\",\"AQLid\":\"85\",\"QDes\":\"/锁\",\"QHide\":\"1\",\"EMCode\":\"400749\"},{\"QSid\":\"✈\",\"QCid\":\"9992\",\"AQLid\":\"86\",\"QDes\":\"/飞机\",\"QHide\":\"1\",\"EMCode\":\"401298\"},{\"QSid\":\"🚄\",\"QCid\":\"128644\",\"AQLid\":\"87\",\"QDes\":\"/列车\",\"QHide\":\"1\",\"EMCode\":\"400942\"},{\"QSid\":\"🚗\",\"QCid\":\"128663\",\"AQLid\":\"88\",\"QDes\":\"/汽车\",\"QHide\":\"1\",\"EMCode\":\"400961\"},{\"QSid\":\"🚤\",\"QCid\":\"128676\",\"AQLid\":\"89\",\"QDes\":\"/快艇\",\"QHide\":\"1\",\"EMCode\":\"400979\"},{\"QSid\":\"🚲\",\"QCid\":\"128690\",\"AQLid\":\"90\",\"QDes\":\"/自行车\",\"QHide\":\"1\",\"EMCode\":\"400993\"},{\"QSid\":\"🐎\",\"QCid\":\"128014\",\"AQLid\":\"91\",\"QDes\":\"/骑马\",\"EMCode\":\"400302\"},{\"QSid\":\"🚀\",\"QCid\":\"128640\",\"AQLid\":\"92\",\"QDes\":\"/火箭\",\"QHide\":\"1\",\"EMCode\":\"400938\"},{\"QSid\":\"🚌\",\"QCid\":\"128652\",\"AQLid\":\"93\",\"QDes\":\"/公交\",\"QHide\":\"1\",\"EMCode\":\"400950\"},{\"QSid\":\"⛵\",\"QCid\":\"9973\",\"AQLid\":\"94\",\"QDes\":\"/船\",\"QHide\":\"1\",\"EMCode\":\"401294\"},{\"QSid\":\"👩\",\"QCid\":\"128105\",\"AQLid\":\"95\",\"QDes\":\"/妈妈\",\"QHide\":\"1\",\"EMCode\":\"400482\"},{\"QSid\":\"👨\",\"QCid\":\"128104\",\"AQLid\":\"96\",\"QDes\":\"/爸爸\",\"QHide\":\"1\",\"EMCode\":\"400465\"},{\"QSid\":\"👧\",\"QCid\":\"128103\",\"AQLid\":\"97\",\"QDes\":\"/女孩\",\"EMCode\":\"400459\"},{\"QSid\":\"👦\",\"QCid\":\"128102\",\"AQLid\":\"98\",\"QDes\":\"/男孩\",\"EMCode\":\"400453\"},{\"QSid\":\"🐵\",\"QCid\":\"128053\",\"AQLid\":\"99\",\"QDes\":\"/猴\",\"EMCode\":\"400341\"},{\"QSid\":\"🐙\",\"QCid\":\"128025\",\"AQLid\":\"100\",\"QDes\":\"/章鱼\",\"QHide\":\"1\",\"EMCode\":\"400313\"},{\"QSid\":\"🐷\",\"QCid\":\"128055\",\"AQLid\":\"101\",\"QDes\":\"/猪\",\"EMCode\":\"400343\"},{\"QSid\":\"💀\",\"QCid\":\"128128\",\"AQLid\":\"102\",\"QDes\":\"/骷髅\",\"QHide\":\"1\",\"EMCode\":\"400572\"},{\"QSid\":\"🐤\",\"QCid\":\"128036\",\"AQLid\":\"103\",\"QDes\":\"/小鸡\",\"QHide\":\"1\",\"EMCode\":\"400324\"},{\"QSid\":\"🐨\",\"QCid\":\"128040\",\"AQLid\":\"104\",\"QDes\":\"/树懒\",\"QHide\":\"1\",\"EMCode\":\"400328\"},{\"QSid\":\"🐮\",\"QCid\":\"128046\",\"AQLid\":\"105\",\"QDes\":\"/牛\",\"EMCode\":\"400334\"},{\"QSid\":\"🐔\",\"QCid\":\"128020\",\"AQLid\":\"106\",\"QDes\":\"/公鸡\",\"EMCode\":\"400308\"},{\"QSid\":\"🐸\",\"QCid\":\"128056\",\"AQLid\":\"107\",\"QDes\":\"/青蛙\",\"EMCode\":\"400344\"},{\"QSid\":\"👻\",\"QCid\":\"128123\",\"AQLid\":\"108\",\"QDes\":\"/幽灵\",\"EMCode\":\"400562\"},{\"QSid\":\"🐛\",\"QCid\":\"128027\",\"AQLid\":\"109\",\"QDes\":\"/虫\",\"EMCode\":\"400315\"},{\"QSid\":\"🐠\",\"QCid\":\"128032\",\"AQLid\":\"110\",\"QDes\":\"/鱼\",\"QHide\":\"1\",\"EMCode\":\"400320\"},{\"QSid\":\"🐶\",\"QCid\":\"128054\",\"AQLid\":\"111\",\"QDes\":\"/狗\",\"EMCode\":\"400342\"},{\"QSid\":\"🐯\",\"QCid\":\"128047\",\"AQLid\":\"112\",\"QDes\":\"/老虎\",\"QHide\":\"1\",\"EMCode\":\"400335\"},{\"QSid\":\"👼\",\"QCid\":\"128124\",\"AQLid\":\"113\",\"QDes\":\"/天使\",\"QHide\":\"1\",\"EMCode\":\"400563\"},{\"QSid\":\"🐧\",\"QCid\":\"128039\",\"AQLid\":\"114\",\"QDes\":\"/企鹅\",\"QHide\":\"1\",\"EMCode\":\"400327\"},{\"QSid\":\"🐳\",\"QCid\":\"128051\",\"AQLid\":\"115\",\"QDes\":\"/鲸鱼\",\"EMCode\":\"400339\"},{\"QSid\":\"🐭\",\"QCid\":\"128045\",\"AQLid\":\"116\",\"QDes\":\"/老鼠\",\"QHide\":\"1\",\"EMCode\":\"400333\"},{\"QSid\":\"👒\",\"QCid\":\"128082\",\"AQLid\":\"117\",\"QDes\":\"/帽子\",\"QHide\":\"1\",\"EMCode\":\"400433\"},{\"QSid\":\"👗\",\"QCid\":\"128087\",\"AQLid\":\"118\",\"QDes\":\"/连衣裙\",\"QHide\":\"1\",\"EMCode\":\"400438\"},{\"QSid\":\"💄\",\"QCid\":\"128132\",\"AQLid\":\"119\",\"QDes\":\"/口红\",\"QHide\":\"1\",\"EMCode\":\"400591\"},{\"QSid\":\"👠\",\"QCid\":\"128096\",\"AQLid\":\"120\",\"QDes\":\"/高跟鞋\",\"QHide\":\"1\",\"EMCode\":\"400447\"},{\"QSid\":\"👢\",\"QCid\":\"128098\",\"AQLid\":\"121\",\"QDes\":\"/靴子\",\"EMCode\":\"400449\"},{\"QSid\":\"🌂\",\"QCid\":\"127746\",\"AQLid\":\"122\",\"QDes\":\"/雨伞\",\"QHide\":\"1\",\"EMCode\":\"400077\"},{\"QSid\":\"👜\",\"QCid\":\"128092\",\"AQLid\":\"123\",\"QDes\":\"/包\",\"QHide\":\"1\",\"EMCode\":\"400443\"},{\"QSid\":\"👙\",\"QCid\":\"128089\",\"AQLid\":\"124\",\"QDes\":\"/内衣\",\"QHide\":\"1\",\"EMCode\":\"400440\"},{\"QSid\":\"👕\",\"QCid\":\"128085\",\"AQLid\":\"125\",\"QDes\":\"/衣服\",\"QHide\":\"1\",\"EMCode\":\"400436\"},{\"QSid\":\"👟\",\"QCid\":\"128095\",\"AQLid\":\"126\",\"QDes\":\"/鞋子\",\"QHide\":\"1\",\"EMCode\":\"400446\"},{\"QSid\":\"☁\",\"QCid\":\"9729\",\"AQLid\":\"127\",\"QDes\":\"/云朵\",\"QHide\":\"1\",\"EMCode\":\"401329\"},{\"QSid\":\"☀\",\"QCid\":\"9728\",\"AQLid\":\"128\",\"QDes\":\"/晴天\",\"EMCode\":\"401328\"},{\"QSid\":\"☔\",\"QCid\":\"9748\",\"AQLid\":\"129\",\"QDes\":\"/雨天\",\"QHide\":\"1\",\"EMCode\":\"401342\"},{\"QSid\":\"🌙\",\"QCid\":\"127769\",\"AQLid\":\"130\",\"QDes\":\"/月亮\",\"QHide\":\"1\",\"EMCode\":\"400100\"},{\"QSid\":\"⛄\",\"QCid\":\"9924\",\"AQLid\":\"131\",\"QDes\":\"/雪人\",\"QHide\":\"1\",\"EMCode\":\"401346\"},{\"QSid\":\"⭕\",\"QCid\":\"11093\",\"AQLid\":\"132\",\"QDes\":\"/正确\",\"QHide\":\"1\",\"EMCode\":\"401687\"},{\"QSid\":\"❌\",\"QCid\":\"10060\",\"AQLid\":\"133\",\"QDes\":\"/错误\",\"QHide\":\"1\",\"EMCode\":\"401142\"},{\"QSid\":\"❔\",\"QCid\":\"10068\",\"AQLid\":\"134\",\"QDes\":\"/问号\",\"EMCode\":\"401145\"},{\"QSid\":\"❕\",\"QCid\":\"10069\",\"AQLid\":\"135\",\"QDes\":\"/叹号\",\"QHide\":\"1\",\"EMCode\":\"401146\"},{\"QSid\":\"☎\",\"QCid\":\"9742\",\"AQLid\":\"136\",\"QDes\":\"/电话\",\"QHide\":\"1\",\"EMCode\":\"401398\"},{\"QSid\":\"📷\",\"QCid\":\"128247\",\"AQLid\":\"137\",\"QDes\":\"/相机\",\"QHide\":\"1\",\"EMCode\":\"400726\"},{\"QSid\":\"📱\",\"QCid\":\"128241\",\"AQLid\":\"138\",\"QDes\":\"/手机\",\"QHide\":\"1\",\"EMCode\":\"400720\"},{\"QSid\":\"📠\",\"QCid\":\"128224\",\"AQLid\":\"139\",\"QDes\":\"/传真\",\"QHide\":\"1\",\"EMCode\":\"400703\"},{\"QSid\":\"💻\",\"QCid\":\"128187\",\"AQLid\":\"140\",\"QDes\":\"/电脑\",\"QHide\":\"1\",\"EMCode\":\"400666\"},{\"QSid\":\"🎥\",\"QCid\":\"127909\",\"AQLid\":\"141\",\"QDes\":\"/摄影机\",\"QHide\":\"1\",\"EMCode\":\"400214\"},{\"QSid\":\"🎤\",\"QCid\":\"127908\",\"AQLid\":\"142\",\"QDes\":\"/话筒\",\"QHide\":\"1\",\"EMCode\":\"400213\"},{\"QSid\":\"🔫\",\"QCid\":\"128299\",\"AQLid\":\"143\",\"QDes\":\"/手枪\",\"EMCode\":\"400774\"},{\"QSid\":\"💿\",\"QCid\":\"128191\",\"AQLid\":\"144\",\"QDes\":\"/光碟\",\"QHide\":\"1\",\"EMCode\":\"400670\"},{\"QSid\":\"💓\",\"QCid\":\"128147\",\"AQLid\":\"145\",\"QDes\":\"/爱心\",\"EMCode\":\"400621\"},{\"QSid\":\"♣\",\"QCid\":\"9827\",\"AQLid\":\"146\",\"QDes\":\"/扑克\",\"QHide\":\"1\",\"EMCode\":\"401385\"},{\"QSid\":\"🀄\",\"QCid\":\"126980\",\"AQLid\":\"147\",\"QDes\":\"/麻将\",\"QHide\":\"1\",\"EMCode\":\"401386\"},{\"QSid\":\"〽\",\"QCid\":\"12349\",\"AQLid\":\"148\",\"QDes\":\"/股票\",\"QHide\":\"1\",\"EMCode\":\"401691\"},{\"QSid\":\"🎰\",\"QCid\":\"127920\",\"AQLid\":\"149\",\"QDes\":\"/老虎机\",\"QHide\":\"1\",\"EMCode\":\"400225\"},{\"QSid\":\"🚥\",\"QCid\":\"128677\",\"AQLid\":\"150\",\"QDes\":\"/信号灯\",\"QHide\":\"1\",\"EMCode\":\"400980\"},{\"QSid\":\"🚧\",\"QCid\":\"128679\",\"AQLid\":\"151\",\"QDes\":\"/路障\",\"QHide\":\"1\",\"EMCode\":\"400982\"},{\"QSid\":\"🎸\",\"QCid\":\"127928\",\"AQLid\":\"152\",\"QDes\":\"/吉他\",\"QHide\":\"1\",\"EMCode\":\"400233\"},{\"QSid\":\"💈\",\"QCid\":\"128136\",\"AQLid\":\"153\",\"QDes\":\"/理发厅\",\"QHide\":\"1\",\"EMCode\":\"400610\"},{\"QSid\":\"🛀\",\"QCid\":\"128704\",\"AQLid\":\"154\",\"QDes\":\"/浴缸\",\"QHide\":\"1\",\"EMCode\":\"401022\"},{\"QSid\":\"🚽\",\"QCid\":\"128701\",\"AQLid\":\"155\",\"QDes\":\"/马桶\",\"QHide\":\"1\",\"EMCode\":\"401019\"},{\"QSid\":\"🏠\",\"QCid\":\"127968\",\"AQLid\":\"156\",\"QDes\":\"/家\",\"QHide\":\"1\",\"EMCode\":\"400271\"},{\"QSid\":\"⛪\",\"QCid\":\"9962\",\"AQLid\":\"157\",\"QDes\":\"/教堂\",\"QHide\":\"1\",\"EMCode\":\"401281\"},{\"QSid\":\"🏦\",\"QCid\":\"127974\",\"AQLid\":\"158\",\"QDes\":\"/银行\",\"QHide\":\"1\",\"EMCode\":\"400277\"},{\"QSid\":\"🏥\",\"QCid\":\"127973\",\"AQLid\":\"159\",\"QDes\":\"/医院\",\"QHide\":\"1\",\"EMCode\":\"400276\"},{\"QSid\":\"🏨\",\"QCid\":\"127976\",\"AQLid\":\"160\",\"QDes\":\"/酒店\",\"QHide\":\"1\",\"EMCode\":\"400279\"},{\"QSid\":\"🏧\",\"QCid\":\"127975\",\"AQLid\":\"161\",\"QDes\":\"/取款机\",\"QHide\":\"1\",\"EMCode\":\"400278\"},{\"QSid\":\"🏪\",\"QCid\":\"127978\",\"AQLid\":\"162\",\"QDes\":\"/便利店\",\"EMCode\":\"400281\"},{\"QSid\":\"🚹\",\"QCid\":\"128697\",\"AQLid\":\"163\",\"QDes\":\"/男性\",\"QHide\":\"1\",\"EMCode\":\"401015\"},{\"QSid\":\"🚺\",\"QCid\":\"128698\",\"AQLid\":\"164\",\"QDes\":\"/女性\",\"QHide\":\"1\",\"EMCode\":\"401016\"}]");
const faceConfig = {
  sysface,
  emoji,
};

var OB11UserSex = /* @__PURE__ */ ((OB11UserSex2) => {
  OB11UserSex2["male"] = "male";
  OB11UserSex2["female"] = "female";
  OB11UserSex2["unknown"] = "unknown";
  return OB11UserSex2;
})(OB11UserSex || {});
var OB11GroupMemberRole = /* @__PURE__ */ ((OB11GroupMemberRole2) => {
  OB11GroupMemberRole2["owner"] = "owner";
  OB11GroupMemberRole2["admin"] = "admin";
  OB11GroupMemberRole2["member"] = "member";
  return OB11GroupMemberRole2;
})(OB11GroupMemberRole || {});

var OB11MessageDataType = /* @__PURE__ */ ((OB11MessageDataType2) => {
  OB11MessageDataType2["text"] = "text";
  OB11MessageDataType2["image"] = "image";
  OB11MessageDataType2["music"] = "music";
  OB11MessageDataType2["video"] = "video";
  OB11MessageDataType2["voice"] = "record";
  OB11MessageDataType2["file"] = "file";
  OB11MessageDataType2["at"] = "at";
  OB11MessageDataType2["reply"] = "reply";
  OB11MessageDataType2["json"] = "json";
  OB11MessageDataType2["face"] = "face";
  OB11MessageDataType2["mface"] = "mface";
  OB11MessageDataType2["markdown"] = "markdown";
  OB11MessageDataType2["node"] = "node";
  OB11MessageDataType2["forward"] = "forward";
  OB11MessageDataType2["xml"] = "xml";
  OB11MessageDataType2["poke"] = "poke";
  OB11MessageDataType2["dice"] = "dice";
  OB11MessageDataType2["rps"] = "rps";
  OB11MessageDataType2["miniapp"] = "miniapp";
  OB11MessageDataType2["contact"] = "contact";
  OB11MessageDataType2["location"] = "location";
  return OB11MessageDataType2;
})(OB11MessageDataType || {});

class OB11Construct {
  static selfInfo(selfInfo) {
    return {
      user_id: +selfInfo.uin,
      nickname: selfInfo.nick
    };
  }
  static friends(friends) {
    return friends.map((rawFriend) => ({
      ...rawFriend.baseInfo,
      ...rawFriend.coreInfo,
      user_id: parseInt(rawFriend.coreInfo.uin),
      nickname: rawFriend.coreInfo.nick,
      remark: rawFriend.coreInfo.remark ?? rawFriend.coreInfo.nick,
      sex: this.sex(rawFriend.baseInfo.sex),
      level: 0
    }));
  }
  static groupMemberRole(role) {
    return {
      4: OB11GroupMemberRole.owner,
      3: OB11GroupMemberRole.admin,
      2: OB11GroupMemberRole.member
    }[role];
  }
  static sex(sex) {
    if (!sex) return OB11UserSex.unknown;
    return {
      [NTSex.GENDER_MALE]: OB11UserSex.male,
      [NTSex.GENDER_FEMALE]: OB11UserSex.female,
      [NTSex.GENDER_UNKOWN]: OB11UserSex.unknown,
      [NTSex.GENDER_PRIVACY]: OB11UserSex.unknown
    }[sex] || OB11UserSex.unknown;
  }
  static groupMember(group_id, member) {
    return {
      group_id: +group_id,
      user_id: +member.uin,
      nickname: member.nick,
      card: member.cardName,
      sex: this.sex(member.sex),
      age: member.age ?? 0,
      area: "",
      level: member.memberRealLevel?.toString() ?? "0",
      qq_level: member.qqLevel && calcQQLevel(member.qqLevel) || 0,
      join_time: +member.joinTime,
      last_sent_time: +member.lastSpeakTime,
      title_expire_time: 0,
      unfriendly: false,
      card_changeable: true,
      is_robot: member.isRobot,
      shut_up_timestamp: member.shutUpTime,
      role: this.groupMemberRole(member.role),
      title: member.memberSpecialTitle ?? ""
    };
  }
  static group(group) {
    return {
      group_id: +group.groupCode,
      group_name: group.groupName,
      member_count: group.memberCount,
      max_member_count: group.maxMember
    };
  }
  static groups(groups) {
    return groups.map(this.group);
  }
  static file(peerId, file) {
    return {
      group_id: +peerId,
      file_id: FileNapCatOneBotUUID.encodeModelId({ chatType: 2, peerUid: peerId }, file.fileModelId, file.fileId, file.fileId ?? ""),
      file_name: file.fileName,
      busid: file.busId,
      size: +file.fileSize,
      upload_time: file.uploadTime,
      dead_time: file.deadTime,
      modify_time: file.modifyTime,
      download_times: file.downloadTimes,
      uploader: +file.uploaderUin,
      uploader_name: file.uploaderName
    };
  }
  static folder(peerId, folder) {
    return {
      group_id: +peerId,
      folder_id: folder.folderId,
      folder: folder.folderId,
      folder_name: folder.folderName,
      create_time: folder.createTime,
      creator: +folder.createUin,
      creator_name: folder.creatorName,
      total_file_count: folder.totalFileCount
    };
  }
}

const pattern = /\[CQ:(\w+)((,\w+=[^,\]]*)*)]/;
function unescape$1(source) {
  return String(source).replace(/&#91;/g, "[").replace(/&#93;/g, "]").replace(/&#44;/g, ",").replace(/&amp;/g, "&");
}
function from(source) {
  const capture = pattern.exec(source);
  if (!capture) return null;
  const [, type, attrs] = capture;
  const data = {};
  if (attrs) {
    attrs.slice(1).split(",").forEach((str) => {
      const index = str.indexOf("=");
      data[str.slice(0, index)] = unescape$1(str.slice(index + 1));
    });
  }
  return { type, data, capture };
}
function convert(type, data) {
  return {
    type,
    data
  };
}
function decodeCQCode(source) {
  const elements = [];
  let result;
  while (result = from(source)) {
    const { type, data, capture } = result;
    if (capture.index) {
      elements.push(convert("text", { text: unescape$1(source.slice(0, capture.index)) }));
    }
    elements.push(convert(type, data));
    source = source.slice(capture.index + capture[0].length);
  }
  if (source) elements.push(convert("text", { text: unescape$1(source) }));
  return elements;
}
function CQCodeEscapeText(text) {
  return text.replace(/&/g, "&amp;").replace(/\[/g, "&#91;").replace(/]/g, "&#93;");
}
function CQCodeEscape(text) {
  return text.replace(/&/g, "&amp;").replace(/\[/g, "&#91;").replace(/]/g, "&#93;").replace(/,/g, "&#44;");
}
function encodeCQCode(data) {
  if (data.type === "text") {
    return CQCodeEscapeText(data.data.text);
  }
  let result = "[CQ:" + data.type;
  for (const name in data.data) {
    const value = data.data[name];
    if (value === void 0) {
      continue;
    }
    try {
      const text = value?.toString();
      if (text) {
        result += `,${name}=${CQCodeEscape(text)}`;
      }
    } catch (error) {
      console.error(`Error encoding CQCode for ${name}:`, error);
    }
  }
  result += "]";
  return result;
}

class OB11FriendAddNoticeEvent extends OB11BaseNoticeEvent {
  notice_type = "friend_add";
  user_id;
  constructor(core, userId) {
    super(core);
    this.user_id = userId;
  }
}

class OB11GroupIncreaseEvent extends OB11GroupNoticeEvent {
  notice_type = "group_increase";
  operator_id;
  sub_type;
  constructor(core, groupId, userId, operatorId, subType = "approve") {
    super(core, groupId, userId);
    this.group_id = groupId;
    this.operator_id = operatorId;
    this.user_id = userId;
    this.sub_type = subType;
  }
}

class OB11GroupDecreaseEvent extends OB11GroupNoticeEvent {
  notice_type = "group_decrease";
  sub_type = "leave";
  operator_id;
  constructor(core, groupId, userId, operatorId, subType = "leave") {
    super(core, groupId, userId);
    this.group_id = groupId;
    this.operator_id = operatorId;
    this.user_id = userId;
    this.sub_type = subType;
  }
}

const GroupAdminExtra = {
  adminUid: ProtoField(1, ScalarType.STRING),
  isPromote: ProtoField(2, ScalarType.BOOL)
};
const GroupAdminBody = {
  extraDisable: ProtoField(1, () => GroupAdminExtra),
  extraEnable: ProtoField(2, () => GroupAdminExtra)
};
const GroupAdmin = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  flag: ProtoField(2, ScalarType.UINT32),
  isPromote: ProtoField(3, ScalarType.BOOL),
  body: ProtoField(4, () => GroupAdminBody)
};

class OB11GroupAdminNoticeEvent extends OB11GroupNoticeEvent {
  notice_type = "group_admin";
  sub_type;
  constructor(core, group_id, user_id, sub_type) {
    super(core, group_id, user_id);
    this.sub_type = sub_type;
  }
}

function keyCanBeParsed(key, parser) {
  return key in parser;
}
class OneBotMsgApi {
  obContext;
  core;
  rawToOb11Converters = {
    textElement: async (element) => {
      if (element.atType === NTMsgAtType.ATTYPEUNKNOWN) {
        let text = element.content;
        if (!text.trim()) {
          return null;
        }
        if (text.indexOf("\n") === -1 && text.indexOf("\r\n") === -1) {
          text = text.replace(/\r/g, "\n");
        }
        return {
          type: OB11MessageDataType.text,
          data: { text }
        };
      } else {
        let qq = "all";
        if (element.atType !== NTMsgAtType.ATTYPEALL) {
          const {
            atNtUid
            /* content */
          } = element;
          let atQQ = element.atUid;
          if (!atQQ || atQQ === "0") {
            atQQ = await this.core.apis.UserApi.getUinByUidV2(atNtUid);
          }
          if (atQQ) {
            qq = atQQ;
          }
        }
        return {
          type: OB11MessageDataType.at,
          data: {
            qq
            // name: content.slice(1);
          }
        };
      }
    },
    picElement: async (element, msg, elementWrapper) => {
      try {
        const peer = {
          chatType: msg.chatType,
          peerUid: msg.peerUid,
          guildId: ""
        };
        const encodedFileId = FileNapCatOneBotUUID.encode(peer, msg.msgId, elementWrapper.elementId, element.fileUuid, "." + element.fileName);
        return {
          type: OB11MessageDataType.image,
          data: {
            summary: element.summary,
            file: encodedFileId,
            sub_type: element.picSubType,
            file_id: encodedFileId,
            url: await this.core.apis.FileApi.getImageUrl(element),
            path: element.filePath,
            file_size: element.fileSize,
            file_unique: element.md5HexStr ?? element.fileName
          }
        };
      } catch (e) {
        this.core.context.logger.logError("获取图片url失败", e.stack);
        return null;
      }
    },
    fileElement: async (element, msg, elementWrapper) => {
      const peer = {
        chatType: msg.chatType,
        peerUid: msg.peerUid,
        guildId: ""
      };
      return {
        type: OB11MessageDataType.file,
        data: {
          file: element.fileName,
          path: element.filePath,
          url: pathToFileURL(element.filePath).href,
          file_id: FileNapCatOneBotUUID.encode(peer, msg.msgId, elementWrapper.elementId, element.fileUuid, "." + element.fileName),
          file_size: element.fileSize,
          file_unique: element.fileMd5 ?? element.fileSha ?? element.fileName
        }
      };
    },
    faceElement: async (element) => {
      const faceIndex = element.faceIndex;
      if (element.faceType == FaceType.Poke) {
        return {
          type: OB11MessageDataType.poke,
          data: {
            type: element?.pokeType?.toString() ?? "0",
            id: faceIndex.toString()
          }
        };
      }
      if (faceIndex === FaceIndex.DICE) {
        return {
          type: OB11MessageDataType.dice,
          data: {
            result: element.resultId
          }
        };
      } else if (faceIndex === FaceIndex.RPS) {
        return {
          type: OB11MessageDataType.rps,
          data: {
            result: element.resultId
          }
        };
      } else {
        return {
          type: OB11MessageDataType.face,
          data: {
            id: element.faceIndex.toString()
          }
        };
      }
    },
    marketFaceElement: async (_, msg, elementWrapper) => {
      const peer = {
        chatType: msg.chatType,
        peerUid: msg.peerUid,
        guildId: ""
      };
      const { emojiId } = _;
      const dir = emojiId.substring(0, 2);
      const url = `https://gxh.vip.qq.com/club/item/parcel/item/${dir}/${emojiId}/raw300.gif`;
      return {
        type: OB11MessageDataType.image,
        data: {
          summary: _.faceName,
          // 商城表情名称
          file: "marketface",
          file_id: FileNapCatOneBotUUID.encode(peer, msg.msgId, elementWrapper.elementId, "", "." + _.key + ".jpg"),
          path: url,
          url,
          key: _.key,
          emoji_id: _.emojiId,
          emoji_package_id: _.emojiPackageId,
          file_unique: _.key
        }
      };
    },
    replyElement: async (element, msg) => {
      const records = msg.records.find((msgRecord) => msgRecord.msgId === element?.sourceMsgIdInRecords);
      const peer = {
        chatType: msg.chatType,
        peerUid: msg.peerUid,
        guildId: ""
      };
      if (!records || !element.replyMsgTime || !element.senderUidStr) {
        this.core.context.logger.logError("似乎是旧版客户端,获取不到引用的消息", element.replayMsgSeq);
        return null;
      }
      const createReplyData = (msgId) => ({
        type: OB11MessageDataType.reply,
        data: {
          id: MessageUnique.createUniqueMsgId(peer, msgId).toString()
        }
      });
      if (records.peerUin === "284840486" || records.peerUin === "1094950020") {
        return createReplyData(records.msgId);
      }
      let replyMsgList = (await this.core.apis.MsgApi.queryMsgsWithFilterExWithSeqV2(peer, element.replayMsgSeq, records.msgTime, [element.senderUidStr])).msgList;
      let replyMsg = replyMsgList.find((msg2) => msg2.msgRandom === records.msgRandom);
      if (!replyMsg || records.msgRandom !== replyMsg.msgRandom) {
        this.core.context.logger.logError(
          "筛选结果,筛选消息失败,将使用Fallback-1 Seq: ",
          element.replayMsgSeq,
          ",消息长度:",
          replyMsgList.length
        );
        replyMsgList = (await this.core.apis.MsgApi.getMsgsBySeqAndCount(peer, element.replayMsgSeq, 1, true, true)).msgList;
        replyMsg = replyMsgList.find((msg2) => msg2.msgRandom === records.msgRandom);
      }
      if (!replyMsg || records.msgRandom !== replyMsg.msgRandom) {
        this.core.context.logger.logWarn(
          "筛选消息失败,将使用Fallback-2 Seq:",
          element.replayMsgSeq,
          ",消息长度:",
          replyMsgList.length
        );
        replyMsgList = (await this.core.apis.MsgApi.queryMsgsWithFilterExWithSeqV3(peer, element.replayMsgSeq, [element.senderUidStr])).msgList;
        replyMsg = replyMsgList.find((msg2) => msg2.msgRandom === records.msgRandom);
      }
      if (!replyMsg || records.msgRandom !== replyMsg.msgRandom) {
        this.core.context.logger.logError(
          "最终筛选结果,筛选消息失败,获取不到引用的消息 Seq: ",
          element.replayMsgSeq,
          ",消息长度:",
          replyMsgList.length
        );
        return null;
      }
      return createReplyData(replyMsg.msgId);
    },
    videoElement: async (element, msg, elementWrapper) => {
      const peer = {
        chatType: msg.chatType,
        peerUid: msg.peerUid,
        guildId: ""
      };
      let videoUrlWrappers;
      if (msg.peerUin === "284840486" || msg.peerUin === "1094950020") {
        try {
          videoUrlWrappers = await this.core.apis.FileApi.getVideoUrl({
            chatType: msg.chatType,
            peerUid: msg.peerUid,
            guildId: "0"
          }, msg.parentMsgIdList[0] ?? msg.msgId, elementWrapper.elementId);
        } catch (error) {
          this.core.context.logger.logWarn("合并获取视频 URL 失败");
        }
      } else {
        try {
          videoUrlWrappers = await this.core.apis.FileApi.getVideoUrl({
            chatType: msg.chatType,
            peerUid: msg.peerUid,
            guildId: "0"
          }, msg.msgId, elementWrapper.elementId);
        } catch (error) {
          this.core.context.logger.logWarn("获取视频 URL 失败");
        }
      }
      let videoDownUrl;
      if (videoUrlWrappers) {
        const videoDownUrlTemp = videoUrlWrappers.find((urlWrapper) => {
          return !!urlWrapper.url;
        });
        if (videoDownUrlTemp) {
          videoDownUrl = videoDownUrlTemp.url;
        }
      }
      if (!videoDownUrl) {
        videoDownUrl = element.filePath;
      }
      const fileCode = FileNapCatOneBotUUID.encode(peer, msg.msgId, elementWrapper.elementId, "", "." + element.fileName);
      return {
        type: OB11MessageDataType.video,
        data: {
          file: fileCode,
          path: videoDownUrl,
          url: videoDownUrl ?? pathToFileURL(element.filePath).href,
          file_id: fileCode,
          file_size: element.fileSize,
          file_unique: element.videoMd5 ?? element.thumbMd5 ?? element.fileName
        }
      };
    },
    pttElement: async (element, msg, elementWrapper) => {
      const peer = {
        chatType: msg.chatType,
        peerUid: msg.peerUid,
        guildId: ""
      };
      const fileCode = FileNapCatOneBotUUID.encode(peer, msg.msgId, elementWrapper.elementId, "", "." + element.fileName);
      return {
        type: OB11MessageDataType.voice,
        data: {
          file: fileCode,
          path: element.filePath,
          url: pathToFileURL(element.filePath).href,
          file_id: fileCode,
          file_size: element.fileSize,
          file_unique: element.fileUuid
        }
      };
    },
    multiForwardMsgElement: async (_, msg, wrapper, context) => {
      const parentMsgPeer = msg.parentMsgPeer ?? {
        chatType: msg.chatType,
        guildId: "",
        peerUid: msg.peerUid
      };
      const multiMsgs = await this.getMultiMessages(msg, parentMsgPeer);
      if (!multiMsgs) return null;
      const forward = {
        type: OB11MessageDataType.forward,
        data: { id: msg.msgId }
      };
      if (!context.parseMultMsg) return forward;
      forward.data.content = await this.parseMultiMessageContent(
        multiMsgs,
        parentMsgPeer,
        msg.parentMsgIdList
      );
      return forward;
    },
    arkElement: async (element) => {
      return {
        type: OB11MessageDataType.json,
        data: {
          data: element.bytesData
        }
      };
    },
    markdownElement: async (element) => {
      return {
        type: OB11MessageDataType.markdown,
        data: {
          content: element.content
        }
      };
    }
  };
  ob11ToRawConverters = {
    [OB11MessageDataType.text]: async ({ data: { text } }) => ({
      elementType: ElementType.TEXT,
      elementId: "",
      textElement: {
        content: text,
        atType: NTMsgAtType.ATTYPEUNKNOWN,
        atUid: "",
        atTinyId: "",
        atNtUid: ""
      }
    }),
    [OB11MessageDataType.at]: async ({ data: { qq: atQQ } }, context) => {
      function at(atUid, atNtUid, atType, atName) {
        return {
          elementType: ElementType.TEXT,
          elementId: "",
          textElement: {
            content: `@${atName}`,
            atType,
            atUid,
            atTinyId: "",
            atNtUid
          }
        };
      }
      if (!context.peer || context.peer.chatType == ChatType.KCHATTYPEC2C) return void 0;
      if (atQQ === "all") return at(atQQ, atQQ, NTMsgAtType.ATTYPEALL, "全体成员");
      const atMember = await this.core.apis.GroupApi.getGroupMember(context.peer.peerUid, atQQ);
      if (atMember) {
        return at(atQQ, atMember.uid, NTMsgAtType.ATTYPEONE, atMember.nick || atMember.cardName);
      }
      const uid = await this.core.apis.UserApi.getUidByUinV2(`${atQQ}`);
      if (!uid) throw new Error("Get Uid Error");
      const info = await this.core.apis.UserApi.getUserDetailInfo(uid);
      return at(atQQ, uid, NTMsgAtType.ATTYPEONE, info.nick || "");
    },
    [OB11MessageDataType.reply]: async ({ data: { id } }) => {
      const replyMsgM = MessageUnique.getMsgIdAndPeerByShortId(parseInt(id));
      if (!replyMsgM) {
        this.core.context.logger.logWarn("回复消息不存在", id);
        return void 0;
      }
      const replyMsg = (await this.core.apis.MsgApi.getMsgsByMsgId(
        replyMsgM.Peer,
        [replyMsgM.MsgId]
      )).msgList[0];
      return replyMsg ? {
        elementType: ElementType.REPLY,
        elementId: "",
        replyElement: {
          replayMsgSeq: replyMsg.msgSeq,
          // raw.msgSeq
          replayMsgId: replyMsg.msgId,
          // raw.msgId
          senderUin: replyMsg.senderUin,
          senderUinStr: replyMsg.senderUin
        }
      } : void 0;
    },
    [OB11MessageDataType.face]: async ({ data: { id } }) => {
      const parsedFaceId = +id;
      const sysFaces = faceConfig.sysface;
      const face = sysFaces.find((systemFace) => systemFace.QSid === parsedFaceId.toString());
      if (!face) {
        this.core.context.logger.logError("不支持的ID", id);
        return void 0;
      }
      let faceType = 1;
      if (parsedFaceId >= 222) {
        faceType = 2;
      }
      if (face.AniStickerType) {
        faceType = 3;
      }
      return {
        elementType: ElementType.FACE,
        elementId: "",
        faceElement: {
          faceIndex: parsedFaceId,
          faceType,
          faceText: face.QDes,
          stickerId: face.AniStickerId,
          stickerType: face.AniStickerType,
          packId: face.AniStickerPackId,
          sourceType: 1
        }
      };
    },
    [OB11MessageDataType.mface]: async ({
      data: {
        emoji_package_id,
        emoji_id,
        key,
        summary
      }
    }) => ({
      elementType: ElementType.MFACE,
      elementId: "",
      marketFaceElement: {
        emojiPackageId: emoji_package_id,
        emojiId: emoji_id,
        key,
        faceName: summary || "[商城表情]"
      }
    }),
    // File service
    [OB11MessageDataType.image]: async (sendMsg, context) => {
      return await this.core.apis.FileApi.createValidSendPicElement(
        context,
        (await this.handleOb11FileLikeMessage(sendMsg, context)).path,
        sendMsg.data.summary,
        sendMsg.data.sub_type
      );
    },
    [OB11MessageDataType.file]: async (sendMsg, context) => {
      const { path, fileName } = await this.handleOb11FileLikeMessage(sendMsg, context);
      return await this.core.apis.FileApi.createValidSendFileElement(context, path, fileName);
    },
    [OB11MessageDataType.video]: async (sendMsg, context) => {
      const { path, fileName } = await this.handleOb11FileLikeMessage(sendMsg, context);
      let thumb = sendMsg.data.thumb;
      if (thumb) {
        const uri2LocalRes = await uriToLocalFile(this.core.NapCatTempPath, thumb);
        if (uri2LocalRes.success) thumb = uri2LocalRes.path;
      }
      return await this.core.apis.FileApi.createValidSendVideoElement(context, path, fileName, thumb);
    },
    [OB11MessageDataType.voice]: async (sendMsg, context) => this.core.apis.FileApi.createValidSendPttElement(
      (await this.handleOb11FileLikeMessage(sendMsg, context)).path
    ),
    [OB11MessageDataType.json]: async ({ data: { data } }) => ({
      elementType: ElementType.ARK,
      elementId: "",
      arkElement: {
        bytesData: typeof data === "string" ? data : JSON.stringify(data),
        linkInfo: null,
        subElementType: null
      }
    }),
    [OB11MessageDataType.dice]: async () => ({
      elementType: ElementType.FACE,
      elementId: "",
      faceElement: {
        faceIndex: FaceIndex.DICE,
        faceType: FaceType.AniSticke,
        faceText: "[骰子]",
        packId: "1",
        stickerId: "33",
        sourceType: 1,
        stickerType: 2,
        surpriseId: ""
        // "randomType": 1,
      }
    }),
    [OB11MessageDataType.rps]: async () => ({
      elementType: ElementType.FACE,
      elementId: "",
      faceElement: {
        faceIndex: FaceIndex.RPS,
        faceText: "[包剪锤]",
        faceType: FaceType.AniSticke,
        packId: "1",
        stickerId: "34",
        sourceType: 1,
        stickerType: 2,
        surpriseId: ""
        // "randomType": 1,
      }
    }),
    // Need signing
    [OB11MessageDataType.markdown]: async ({ data: { content } }) => ({
      elementType: ElementType.MARKDOWN,
      elementId: "",
      markdownElement: { content }
    }),
    [OB11MessageDataType.music]: async ({ data }, context) => {
      if (data.id !== void 0) {
        if (!["qq", "163", "kugou", "kuwo", "migu"].includes(data.type)) {
          this.core.context.logger.logError("音乐卡片type错误, 只支持qq、163、kugou、kuwo、migu，当前type:", data.type);
          return void 0;
        }
      } else {
        if (!["qq", "163", "kugou", "kuwo", "migu", "custom"].includes(data.type)) {
          this.core.context.logger.logError("音乐卡片type错误, 只支持qq、163、kugou、kuwo、migu、custom，当前type:", data.type);
          return void 0;
        }
        if (!data.url) {
          this.core.context.logger.logError("自定义音卡缺少参数url");
          return void 0;
        }
        if (!data.image) {
          this.core.context.logger.logError("自定义音卡缺少参数image");
          return void 0;
        }
      }
      let postData;
      if (data.id === void 0 && data.content) {
        const { content, ...others } = data;
        postData = { singer: content, ...others };
      } else {
        postData = data;
      }
      let signUrl = this.obContext.configLoader.configData.musicSignUrl;
      if (!signUrl) {
        signUrl = "https://ss.xingzhige.com/music_card/card";
      }
      try {
        const musicJson = await RequestUtil.HttpGetJson(signUrl, "POST", postData);
        return this.ob11ToRawConverters.json({
          data: { data: musicJson },
          type: OB11MessageDataType.json
        }, context);
      } catch (e) {
        this.core.context.logger.logError("生成音乐消息失败", e);
      }
    },
    [OB11MessageDataType.node]: async () => void 0,
    [OB11MessageDataType.forward]: async ({ data }, context) => {
      const jsonData = ForwardMsgBuilder.fromResId(data.id);
      return this.ob11ToRawConverters.json({
        data: { data: JSON.stringify(jsonData) },
        type: OB11MessageDataType.json
      }, context);
    },
    [OB11MessageDataType.xml]: async () => void 0,
    [OB11MessageDataType.poke]: async () => void 0,
    [OB11MessageDataType.location]: async () => ({
      elementType: ElementType.SHARELOCATION,
      elementId: "",
      shareLocationElement: {
        text: "测试",
        ext: ""
      }
    }),
    [OB11MessageDataType.miniapp]: async () => void 0,
    [OB11MessageDataType.contact]: async ({ data: { type = "qq", id } }, context) => {
      if (type === "qq") {
        const arkJson = await this.core.apis.UserApi.getBuddyRecommendContactArkJson(id.toString(), "");
        return this.ob11ToRawConverters.json({
          data: { data: arkJson.arkMsg },
          type: OB11MessageDataType.json
        }, context);
      } else if (type === "group") {
        const arkJson = await this.core.apis.GroupApi.getGroupRecommendContactArkJson(id.toString());
        return this.ob11ToRawConverters.json({
          data: { data: arkJson.arkJson },
          type: OB11MessageDataType.json
        }, context);
      }
    }
  };
  constructor(obContext, core) {
    this.obContext = obContext;
    this.core = core;
  }
  async parsePrivateMsgEvent(msg, grayTipElement) {
    if (grayTipElement.subElementType == NTGrayTipElementSubTypeV2.GRAYTIP_ELEMENT_SUBTYPE_JSON) {
      if (grayTipElement.jsonGrayTipElement.busiId == 1061) {
        const PokeEvent = await this.obContext.apis.FriendApi.parsePrivatePokeEvent(grayTipElement);
        if (PokeEvent) {
          return PokeEvent;
        }
      } else if (grayTipElement.jsonGrayTipElement.busiId == 19324 && msg.peerUid !== "") {
        return new OB11FriendAddNoticeEvent(this.core, Number(await this.core.apis.UserApi.getUinByUidV2(msg.peerUid)));
      }
    }
  }
  async getMultiMessages(msg, parentMsgPeer) {
    msg.parentMsgIdList = msg.parentMsgIdList ?? [];
    msg.parentMsgIdList.push(msg.msgId);
    return (await this.core.apis.MsgApi.getMultiMsg(
      parentMsgPeer,
      msg.parentMsgIdList[0],
      msg.msgId
    ))?.msgList;
  }
  async parseMultiMessageContent(multiMsgs, parentMsgPeer, parentMsgIdList) {
    const parsed = await Promise.all(multiMsgs.map(async (msg) => {
      msg.parentMsgPeer = parentMsgPeer;
      msg.parentMsgIdList = parentMsgIdList;
      msg.id = MessageUnique.createUniqueMsgId(parentMsgPeer, msg.msgId);
      return await this.parseMessage(msg, "array", true);
    }));
    return parsed.filter((item) => item !== void 0);
  }
  async parseMessage(msg, messagePostFormat, parseMultMsg = true) {
    if (messagePostFormat === "string") {
      return (await this.parseMessageV2(msg, parseMultMsg))?.stringMsg;
    }
    return (await this.parseMessageV2(msg, parseMultMsg))?.arrayMsg;
  }
  async parseMessageV2(msg, parseMultMsg = true) {
    if (msg.senderUin == "0" || msg.senderUin == "") return;
    if (msg.peerUin == "0" || msg.peerUin == "") return;
    const resMsg = this.initializeMessage(msg);
    if (this.core.selfInfo.uin == msg.senderUin) {
      resMsg.message_sent_type = "self";
    }
    if (msg.chatType == ChatType.KCHATTYPEGROUP) {
      await this.handleGroupMessage(resMsg, msg);
    } else if (msg.chatType == ChatType.KCHATTYPEC2C) {
      await this.handlePrivateMessage(resMsg, msg);
    } else if (msg.chatType == ChatType.KCHATTYPETEMPC2CFROMGROUP) {
      await this.handleTempGroupMessage(resMsg, msg);
    } else {
      return void 0;
    }
    const validSegments = await this.parseMessageSegments(msg, parseMultMsg);
    resMsg.message = validSegments;
    resMsg.raw_message = validSegments.map((msg2) => encodeCQCode(msg2)).join("").trim();
    const stringMsg = await this.convertArrayToStringMessage(resMsg);
    return { stringMsg, arrayMsg: resMsg };
  }
  initializeMessage(msg) {
    return {
      self_id: parseInt(this.core.selfInfo.uin),
      user_id: parseInt(msg.senderUin),
      time: parseInt(msg.msgTime) || Date.now(),
      message_id: msg.id,
      message_seq: msg.id,
      real_id: msg.id,
      message_type: msg.chatType == ChatType.KCHATTYPEGROUP ? "group" : "private",
      sender: {
        user_id: +(msg.senderUin ?? 0),
        nickname: msg.sendNickName,
        card: msg.sendMemberName ?? ""
      },
      raw_message: "",
      font: 14,
      sub_type: "friend",
      message: [],
      message_format: "array",
      post_type: this.core.selfInfo.uin == msg.senderUin ? EventType.MESSAGE_SENT : EventType.MESSAGE
    };
  }
  async handleGroupMessage(resMsg, msg) {
    resMsg.sub_type = "normal";
    resMsg.group_id = parseInt(msg.peerUin);
    let member = await this.core.apis.GroupApi.getGroupMember(msg.peerUin, msg.senderUin);
    if (!member) member = await this.core.apis.GroupApi.getGroupMember(msg.peerUin, msg.senderUin);
    if (member) {
      resMsg.sender.role = OB11Construct.groupMemberRole(member.role);
      resMsg.sender.nickname = member.nick;
    }
  }
  async handlePrivateMessage(resMsg, msg) {
    resMsg.sub_type = "friend";
    resMsg.sender.nickname = (await this.core.apis.UserApi.getUserDetailInfo(msg.senderUid)).nick;
  }
  async handleTempGroupMessage(resMsg, msg) {
    resMsg.sub_type = "group";
    const ret = await this.core.apis.MsgApi.getTempChatInfo(ChatType.KCHATTYPETEMPC2CFROMGROUP, msg.senderUid);
    if (ret.result === 0) {
      const member = await this.core.apis.GroupApi.getGroupMember(msg.peerUin, msg.senderUin);
      resMsg.group_id = parseInt(ret.tmpChatInfo.groupCode);
      resMsg.sender.nickname = member?.nick ?? member?.cardName ?? "临时会话";
      resMsg.temp_source = resMsg.group_id;
    } else {
      resMsg.group_id = 284840486;
      resMsg.temp_source = resMsg.group_id;
      resMsg.sender.nickname = "临时会话";
    }
  }
  async parseMessageSegments(msg, parseMultMsg) {
    const msgSegments = await Promise.allSettled(msg.elements.map(
      async (element) => {
        for (const key in element) {
          if (keyCanBeParsed(key, this.rawToOb11Converters) && element[key]) {
            const converters = this.rawToOb11Converters[key];
            const parsedElement = await converters?.(
              element[key],
              msg,
              element,
              { parseMultMsg }
            );
            if (key === "faceElement" && !parsedElement) {
              return null;
            }
            return parsedElement;
          }
        }
      }
    ));
    return msgSegments.filter((entry) => {
      if (entry.status === "fulfilled") {
        return !!entry.value;
      } else {
        this.core.context.logger.logError("消息段解析失败", entry.reason);
        return false;
      }
    }).map((entry) => entry.value).filter((value) => value != null);
  }
  async convertArrayToStringMessage(originMsg) {
    const msg = structuredClone(originMsg);
    msg.message_format = "string";
    msg.message = msg.raw_message;
    return msg;
  }
  async importArrayTostringMsg(originMsg) {
    const msg = structuredClone(originMsg);
    msg.message_format = "string";
    msg.message = msg.raw_message;
    return msg;
  }
  async createSendElements(messageData, peer, ignoreTypes = []) {
    const deleteAfterSentFiles = [];
    const callResultList = [];
    for (const sendMsg of messageData) {
      if (ignoreTypes.includes(sendMsg.type)) {
        continue;
      }
      const converter = this.ob11ToRawConverters[sendMsg.type];
      const callResult = converter(
        sendMsg,
        { peer, deleteAfterSentFiles }
      )?.catch(void 0);
      callResultList.push(callResult);
    }
    const ret = await Promise.all(callResultList);
    const sendElements = ret.filter((ele) => !!ele);
    return { sendElements, deleteAfterSentFiles };
  }
  async sendMsgWithOb11UniqueId(peer, sendElements, deleteAfterSentFiles, waitComplete = true) {
    if (!sendElements.length) {
      throw new Error("消息体无法解析, 请检查是否发送了不支持的消息类型");
    }
    const calculateTotalSize = async (elements) => {
      const sizePromises = elements.map(async (element) => {
        switch (element.elementType) {
          case ElementType.PTT:
            return (await fs$2.stat(element.pttElement.filePath)).size;
          case ElementType.FILE:
            return (await fs$2.stat(element.fileElement.filePath)).size;
          case ElementType.VIDEO:
            return (await fs$2.stat(element.videoElement.filePath)).size;
          case ElementType.PIC:
            return (await fs$2.stat(element.picElement.sourcePath)).size;
          default:
            return 0;
        }
      });
      const sizes = await Promise.all(sizePromises);
      return sizes.reduce((total, size) => total + size, 0);
    };
    const totalSize = await calculateTotalSize(sendElements).catch((e) => {
      this.core.context.logger.logError("发送消息计算预计时间异常", e);
      return 0;
    });
    const timeout = 1e4 + totalSize / 1024 / 256 * 1e3;
    const returnMsg = await this.core.apis.MsgApi.sendMsg(peer, sendElements, waitComplete, timeout);
    if (!returnMsg) throw new Error("发送消息失败");
    returnMsg.id = MessageUnique.createUniqueMsgId({
      chatType: peer.chatType,
      guildId: "",
      peerUid: peer.peerUid
    }, returnMsg.msgId);
    setTimeout(async () => {
      const deletePromises = deleteAfterSentFiles.map(async (file) => {
        try {
          if (await fs$2.access(file, constants$1.W_OK).then(() => true).catch(() => false)) {
            await fs$2.unlink(file);
          }
        } catch (e) {
          this.core.context.logger.logError("发送消息删除文件失败", e);
        }
      });
      await Promise.all(deletePromises);
    }, 6e4);
    return returnMsg;
  }
  async handleOb11FileLikeMessage({ data: inputdata }, { deleteAfterSentFiles }) {
    const realUri = inputdata.url ?? inputdata.file ?? inputdata.path ?? "";
    if (realUri.length === 0) {
      this.core.context.logger.logError("文件消息缺少参数", inputdata);
      throw Error("文件消息缺少参数");
    }
    const {
      path,
      fileName,
      errMsg,
      success
    } = await uriToLocalFile(this.core.NapCatTempPath, realUri);
    if (!success) {
      this.core.context.logger.logError("文件下载失败", errMsg);
      throw Error("文件下载失败" + errMsg);
    }
    deleteAfterSentFiles.push(path);
    return { path, fileName: inputdata.name ?? fileName };
  }
  groupChangDecreseType2String(type) {
    switch (type) {
      case 130:
        return "leave";
      case 131:
        return "kick";
      case 3:
        return "kick_me";
      default:
        return "kick";
    }
  }
  async parseSysMessage(msg) {
    const SysMessage = new NapProtoMsg(PushMsgBody).decode(Uint8Array.from(msg));
    if (SysMessage.contentHead.type == 33 && SysMessage.body?.msgContent) {
      const groupChange = new NapProtoMsg(GroupChange).decode(SysMessage.body.msgContent);
      this.core.apis.GroupApi.refreshGroupMemberCache(groupChange.groupUin.toString()).then().catch();
      const operatorUid = groupChange.operatorInfo?.toString();
      return new OB11GroupIncreaseEvent(
        this.core,
        groupChange.groupUin,
        groupChange.memberUid ? +await this.core.apis.UserApi.getUinByUidV2(groupChange.memberUid) : 0,
        operatorUid ? +await this.core.apis.UserApi.getUinByUidV2(operatorUid) : 0,
        groupChange.decreaseType == 131 ? "invite" : "approve"
      );
    } else if (SysMessage.contentHead.type == 34 && SysMessage.body?.msgContent) {
      const groupChange = new NapProtoMsg(GroupChange).decode(SysMessage.body.msgContent);
      const operatorUid = groupChange.decreaseType === 3 && groupChange.operatorInfo ? new NapProtoMsg(GroupChangeInfo).decode(groupChange.operatorInfo).operator?.operatorUid : groupChange.operatorInfo?.toString();
      if (groupChange.memberUid === this.core.selfInfo.uid) {
        setTimeout(() => {
          this.core.apis.GroupApi.groupMemberCache.delete(groupChange.groupUin.toString());
        }, 5e3);
      } else {
        this.core.apis.GroupApi.refreshGroupMemberCache(groupChange.groupUin.toString()).then().catch();
      }
      return new OB11GroupDecreaseEvent(
        this.core,
        groupChange.groupUin,
        groupChange.memberUid ? +await this.core.apis.UserApi.getUinByUidV2(groupChange.memberUid) : 0,
        operatorUid ? +await this.core.apis.UserApi.getUinByUidV2(operatorUid) : 0,
        this.groupChangDecreseType2String(groupChange.decreaseType)
      );
    } else if (SysMessage.contentHead.type == 44 && SysMessage.body?.msgContent) {
      const groupAmin = new NapProtoMsg(GroupAdmin).decode(SysMessage.body.msgContent);
      this.core.apis.GroupApi.refreshGroupMemberCache(groupAmin.groupUin.toString()).then().catch();
      let enabled = false;
      let uid = "";
      if (groupAmin.body.extraEnable != null) {
        uid = groupAmin.body.extraEnable.adminUid;
        enabled = true;
      } else if (groupAmin.body.extraDisable != null) {
        uid = groupAmin.body.extraDisable.adminUid;
        enabled = false;
      }
      return new OB11GroupAdminNoticeEvent(
        this.core,
        groupAmin.groupUin,
        +await this.core.apis.UserApi.getUinByUidV2(uid),
        enabled ? "set" : "unset"
      );
    } else if (SysMessage.contentHead.type == 528 && SysMessage.contentHead.subType == 39 && SysMessage.body?.msgContent) {
      return await this.obContext.apis.UserApi.parseLikeEvent(SysMessage.body?.msgContent);
    }
  }
}

var ContextMode = /* @__PURE__ */ ((ContextMode2) => {
  ContextMode2[ContextMode2["Normal"] = 0] = "Normal";
  ContextMode2[ContextMode2["Private"] = 1] = "Private";
  ContextMode2[ContextMode2["Group"] = 2] = "Group";
  return ContextMode2;
})(ContextMode || {});
function normalize(message, autoEscape = false) {
  return typeof message === "string" ? autoEscape ? [{ type: OB11MessageDataType.text, data: { text: message } }] : decodeCQCode(message) : Array.isArray(message) ? message : [message];
}
async function createContext(core, payload, contextMode) {
  if ((contextMode === 2 /* Group */ || contextMode === 0 /* Normal */) && payload.group_id) {
    return {
      chatType: ChatType.KCHATTYPEGROUP,
      peerUid: payload.group_id.toString()
    };
  }
  if ((contextMode === 1 /* Private */ || contextMode === 0 /* Normal */) && payload.user_id) {
    const Uid = await core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
    if (!Uid) throw new Error("无法获取用户信息");
    const isBuddy = await core.apis.FriendApi.isBuddy(Uid);
    if (!isBuddy) {
      const ret = await core.apis.MsgApi.getTempChatInfo(ChatType.KCHATTYPETEMPC2CFROMGROUP, Uid);
      if (ret.tmpChatInfo?.groupCode) {
        return {
          chatType: ChatType.KCHATTYPETEMPC2CFROMGROUP,
          peerUid: Uid,
          guildId: ""
        };
      }
      if (payload.group_id) {
        return {
          chatType: ChatType.KCHATTYPETEMPC2CFROMGROUP,
          peerUid: Uid,
          guildId: payload.group_id.toString()
        };
      }
      return {
        chatType: ChatType.KCHATTYPEC2C,
        peerUid: Uid,
        guildId: ""
      };
    }
    return {
      chatType: ChatType.KCHATTYPEC2C,
      peerUid: Uid,
      guildId: ""
    };
  }
  throw new Error("请指定 group_id 或 user_id");
}
function getSpecialMsgNum(payload, msgType) {
  if (Array.isArray(payload.message)) {
    return payload.message.filter((msg) => msg.type == msgType).length;
  }
  return 0;
}
class SendMsg extends OneBotAction {
  actionName = ActionName.SendMsg;
  contextMode = 0 /* Normal */;
  async check(payload) {
    const messages = normalize(payload.message);
    const nodeElementLength = getSpecialMsgNum(payload, OB11MessageDataType.node);
    if (nodeElementLength > 0 && nodeElementLength != messages.length) {
      return {
        valid: false,
        message: "转发消息不能和普通消息混在一起发送,转发需要保证message只有type为node的元素"
      };
    }
    return { valid: true };
  }
  async _handle(payload) {
    this.contextMode = 0 /* Normal */;
    if (payload.message_type === "group") this.contextMode = 2 /* Group */;
    if (payload.message_type === "private") this.contextMode = 1 /* Private */;
    const peer = await createContext(this.core, payload, this.contextMode);
    const messages = normalize(
      payload.message,
      typeof payload.auto_escape === "string" ? payload.auto_escape === "true" : !!payload.auto_escape
    );
    if (getSpecialMsgNum(payload, OB11MessageDataType.node)) {
      const packetMode = this.core.apis.PacketApi.available;
      let returnMsgAndResId;
      try {
        returnMsgAndResId = packetMode ? await this.handleForwardedNodesPacket(peer, messages, payload.source, payload.news, payload.summary, payload.prompt) : await this.handleForwardedNodes(peer, messages);
      } catch (e) {
        throw Error(packetMode ? `发送伪造合并转发消息失败: ${e?.stack}` : `发送合并转发消息失败: ${e?.stack}`);
      }
      if (!returnMsgAndResId) {
        throw Error("发送合并转发消息失败：returnMsgAndResId 为空！");
      }
      if (returnMsgAndResId.message) {
        const msgShortId = MessageUnique.createUniqueMsgId({
          guildId: "",
          peerUid: peer.peerUid,
          chatType: peer.chatType
        }, returnMsgAndResId.message.msgId);
        return { message_id: msgShortId, res_id: returnMsgAndResId.res_id };
      } else if (returnMsgAndResId.res_id && !returnMsgAndResId.message) {
        throw Error(`发送转发消息（res_id：${returnMsgAndResId.res_id} 失败`);
      }
    }
    const { sendElements, deleteAfterSentFiles } = await this.obContext.apis.MsgApi.createSendElements(messages, peer);
    const returnMsg = await this.obContext.apis.MsgApi.sendMsgWithOb11UniqueId(peer, sendElements, deleteAfterSentFiles);
    return { message_id: returnMsg.id };
  }
  async uploadForwardedNodesPacket(msgPeer, messageNodes, source, news, summary, prompt, parentMeta, dp = 0) {
    const packetMsg = [];
    for (const node of messageNodes) {
      if (dp >= 3) {
        this.core.context.logger.logWarn("转发消息深度超过3层，将停止解析！");
        break;
      }
      if (!node.data.id) {
        const OB11Data = normalize(node.type === OB11MessageDataType.node ? node.data.content : node);
        let sendElements;
        if (getSpecialMsgNum({ message: OB11Data }, OB11MessageDataType.node)) {
          const uploadReturnData = await this.uploadForwardedNodesPacket(msgPeer, OB11Data, node.data.source, node.data.news, node.data.summary, node.data.prompt, {
            user_id: (node.data.user_id ?? node.data.uin)?.toString() ?? parentMeta?.user_id ?? this.core.selfInfo.uin,
            nickname: (node.data.nickname || node.data.name) ?? parentMeta?.nickname ?? "QQ用户"
          }, dp + 1);
          sendElements = uploadReturnData?.finallySendElements ? [uploadReturnData.finallySendElements] : [];
        } else {
          const sendElementsCreateReturn = await this.obContext.apis.MsgApi.createSendElements(OB11Data, msgPeer);
          sendElements = sendElementsCreateReturn.sendElements;
        }
        const packetMsgElements = {
          senderUin: Number(node.data.user_id ?? node.data.uin ?? parentMeta?.user_id) || +this.core.selfInfo.uin,
          senderName: (node.data.nickname || node.data.name) ?? parentMeta?.nickname ?? "QQ用户",
          groupId: msgPeer.chatType === ChatType.KCHATTYPEGROUP ? +msgPeer.peerUid : void 0,
          time: Number(node.data.time) || Date.now(),
          msg: sendElements
        };
        this.core.context.logger.logDebug(`handleForwardedNodesPacket[SendRaw] 开始转换 ${stringifyWithBigInt(packetMsgElements)}`);
        const transformedMsg = this.core.apis.PacketApi.pkt.msgConverter.rawMsgWithSendMsgToPacketMsg(packetMsgElements);
        this.core.context.logger.logDebug(`handleForwardedNodesPacket[SendRaw] 转换为 ${stringifyWithBigInt(transformedMsg)}`);
        packetMsg.push(transformedMsg);
      } else if (node.data.id) {
        const id = node.data.id;
        const nodeMsg = MessageUnique.getMsgIdAndPeerByShortId(+id) || MessageUnique.getPeerByMsgId(id);
        if (!nodeMsg) {
          this.core.context.logger.logError("转发消息失败，未找到消息", id);
          continue;
        }
        const msg = (await this.core.apis.MsgApi.getMsgsByMsgId(nodeMsg.Peer, [nodeMsg.MsgId])).msgList[0];
        this.core.context.logger.logDebug(`handleForwardedNodesPacket[PureRaw] 开始转换 ${stringifyWithBigInt(msg)}`);
        await this.core.apis.FileApi.downloadRawMsgMedia([msg]);
        const transformedMsg = this.core.apis.PacketApi.pkt.msgConverter.rawMsgToPacketMsg(msg, msgPeer);
        this.core.context.logger.logDebug(`handleForwardedNodesPacket[PureRaw] 转换为 ${stringifyWithBigInt(transformedMsg)}`);
        packetMsg.push(transformedMsg);
      } else {
        this.core.context.logger.logDebug(`handleForwardedNodesPacket 跳过元素 ${stringifyWithBigInt(node)}`);
      }
    }
    if (packetMsg.length === 0) {
      this.core.context.logger.logWarn("handleForwardedNodesPacket 元素为空！");
      return null;
    }
    const resid = await this.core.apis.PacketApi.pkt.operation.UploadForwardMsg(packetMsg, msgPeer.chatType === ChatType.KCHATTYPEGROUP ? +msgPeer.peerUid : 0);
    const forwardJson = ForwardMsgBuilder.fromPacketMsg(resid, packetMsg, source, news, summary, prompt);
    return {
      finallySendElements: {
        elementType: ElementType.ARK,
        elementId: "",
        arkElement: {
          bytesData: JSON.stringify(forwardJson)
        }
      },
      res_id: resid
    };
  }
  async handleForwardedNodesPacket(msgPeer, messageNodes, source, news, summary, prompt) {
    const uploadReturnData = await this.uploadForwardedNodesPacket(msgPeer, messageNodes, source, news, summary, prompt);
    const res_id = uploadReturnData?.res_id;
    const finallySendElements = uploadReturnData?.finallySendElements;
    if (!finallySendElements) throw Error("转发消息失败，生成节点为空");
    const returnMsg = await this.obContext.apis.MsgApi.sendMsgWithOb11UniqueId(msgPeer, [finallySendElements], [], true).catch((_) => void 0);
    return { message: returnMsg ?? null, res_id };
  }
  async handleForwardedNodes(destPeer, messageNodes) {
    const selfPeer = {
      chatType: ChatType.KCHATTYPEC2C,
      peerUid: this.core.selfInfo.uid
    };
    let nodeMsgIds = [];
    for (const messageNode of messageNodes) {
      const nodeId = messageNode.data.id;
      if (nodeId) {
        const nodeMsg = MessageUnique.getMsgIdAndPeerByShortId(parseInt(nodeId)) || MessageUnique.getPeerByMsgId(nodeId);
        if (!nodeMsg) {
          this.core.context.logger.logError("转发消息失败，未找到消息", nodeId);
          continue;
        }
        nodeMsgIds.push(nodeMsg.MsgId);
      } else {
        try {
          const OB11Data = normalize(messageNode.data.content);
          const isNodeMsg = OB11Data.filter((e) => e.type === OB11MessageDataType.node).length;
          if (isNodeMsg !== 0) {
            if (isNodeMsg !== OB11Data.length) {
              this.core.context.logger.logError("子消息中包含非node消息 跳过不合法部分");
              continue;
            }
            const nodeMsg = await this.handleForwardedNodes(selfPeer, OB11Data.filter((e) => e.type === OB11MessageDataType.node));
            if (nodeMsg) {
              nodeMsgIds.push(nodeMsg.message.msgId);
              MessageUnique.createUniqueMsgId(selfPeer, nodeMsg.message.msgId);
            }
            continue;
          }
          const { sendElements } = await this.obContext.apis.MsgApi.createSendElements(OB11Data, destPeer);
          const MixElement = sendElements.filter(
            (element) => element.elementType !== ElementType.FILE && element.elementType !== ElementType.VIDEO && element.elementType !== ElementType.ARK
          );
          const SingleElement = sendElements.filter(
            (element) => element.elementType === ElementType.FILE || element.elementType === ElementType.VIDEO || element.elementType === ElementType.ARK
          ).map((e) => [e]);
          const AllElement = [MixElement, ...SingleElement].filter((e) => e !== void 0 && e.length !== 0);
          const MsgNodeList = [];
          for (const sendElementsSplitElement of AllElement) {
            MsgNodeList.push(this.obContext.apis.MsgApi.sendMsgWithOb11UniqueId(selfPeer, sendElementsSplitElement, [], true).catch((_) => void 0));
          }
          (await Promise.allSettled(MsgNodeList)).map((result) => {
            if (result.status === "fulfilled" && result.value) {
              nodeMsgIds.push(result.value.msgId);
              MessageUnique.createUniqueMsgId(selfPeer, result.value.msgId);
            }
          });
        } catch (e) {
          this.core.context.logger.logDebug("生成转发消息节点失败", e?.stack);
        }
      }
    }
    const nodeMsgArray = [];
    let srcPeer = void 0;
    let needSendSelf = false;
    for (const msgId of nodeMsgIds) {
      const nodeMsgPeer = MessageUnique.getPeerByMsgId(msgId);
      if (!nodeMsgPeer) {
        this.core.context.logger.logError("转发消息失败，未找到消息", msgId);
        continue;
      }
      const nodeMsg = (await this.core.apis.MsgApi.getMsgsByMsgId(nodeMsgPeer.Peer, [msgId])).msgList[0];
      srcPeer = srcPeer ?? { chatType: nodeMsg.chatType, peerUid: nodeMsg.peerUid };
      if (srcPeer.peerUid !== nodeMsg.peerUid) {
        needSendSelf = true;
      }
      nodeMsgArray.push(nodeMsg);
    }
    nodeMsgIds = nodeMsgArray.map((msg) => msg.msgId);
    let retMsgIds = [];
    if (needSendSelf) {
      for (const [, msg] of nodeMsgArray.entries()) {
        if (msg.peerUid === this.core.selfInfo.uid) {
          retMsgIds.push(msg.msgId);
          continue;
        }
        const ClonedMsg = await this.cloneMsg(msg);
        if (ClonedMsg) retMsgIds.push(ClonedMsg.msgId);
      }
    } else {
      retMsgIds = nodeMsgIds;
    }
    if (retMsgIds.length === 0) throw Error("转发消息失败，生成节点为空");
    try {
      this.core.context.logger.logDebug("开发转发", srcPeer, destPeer, retMsgIds);
      return {
        message: await this.core.apis.MsgApi.multiForwardMsg(srcPeer, destPeer, retMsgIds)
      };
    } catch (e) {
      this.core.context.logger.logError("forward failed", e?.stack);
      return {
        message: null
      };
    }
  }
  async cloneMsg(msg) {
    const selfPeer = {
      chatType: ChatType.KCHATTYPEC2C,
      peerUid: this.core.selfInfo.uid
    };
    const sendElements = [];
    for (const element of msg.elements) {
      sendElements.push(element);
    }
    if (sendElements.length === 0) {
      this.core.context.logger.logDebug("需要clone的消息无法解析，将会忽略掉", msg);
    }
    try {
      return await this.core.apis.MsgApi.sendMsg(selfPeer, sendElements, true);
    } catch (e) {
      this.core.context.logger.logError(e?.stack, "克隆转发消息失败,将忽略本条消息", msg);
    }
  }
}

class OneBotQuickActionApi {
  obContext;
  core;
  constructor(obContext, core) {
    this.obContext = obContext;
    this.core = core;
  }
  async handleQuickOperation(eventContext, quickAction) {
    if (eventContext.post_type === "message") {
      await this.handleMsg(eventContext, quickAction).catch((e) => this.core.context.logger.logError(e));
    }
    if (eventContext.post_type === "request") {
      const friendRequest = eventContext;
      const groupRequest = eventContext;
      if (friendRequest.request_type === "friend") {
        await this.handleFriendRequest(friendRequest, quickAction).catch((e) => this.core.context.logger.logError(e));
      } else if (groupRequest.request_type === "group") {
        await this.handleGroupRequest(groupRequest, quickAction).catch((e) => this.core.context.logger.logError(e));
      }
    }
  }
  async handleMsg(msg, quickAction) {
    const reply = quickAction.reply;
    const peerContextMode = msg.message_type == "private" ? ContextMode.Private : ContextMode.Group;
    const peer = await createContext(this.core, {
      message_type: void 0,
      group_id: msg.group_id?.toString(),
      user_id: msg.user_id?.toString()
    }, peerContextMode);
    if (reply) {
      let replyMessage = [];
      if (msg.message_type == "group") {
        replyMessage.push({
          type: "reply",
          data: {
            id: msg.message_id.toString()
          }
        });
        if (quickAction.at_sender) {
          replyMessage.push({
            type: "at",
            data: {
              qq: msg.user_id.toString()
            }
          });
        }
      }
      replyMessage = replyMessage.concat(normalize(reply, quickAction.auto_escape));
      const {
        sendElements,
        deleteAfterSentFiles
      } = await this.obContext.apis.MsgApi.createSendElements(replyMessage, peer);
      this.obContext.apis.MsgApi.sendMsgWithOb11UniqueId(peer, sendElements, deleteAfterSentFiles, false).then().catch((e) => this.core.context.logger.logError(e));
    }
  }
  async handleGroupRequest(request, quickAction) {
    if (!isNull(quickAction.approve)) {
      this.core.apis.GroupApi.handleGroupRequest(
        request.flag,
        quickAction.approve ? NTGroupRequestOperateTypes.KAGREE : NTGroupRequestOperateTypes.KREFUSE,
        quickAction.reason
      ).catch((e) => this.core.context.logger.logError(e));
    }
  }
  async handleFriendRequest(request, quickAction) {
    if (!isNull(quickAction.approve)) {
      this.core.apis.FriendApi.handleFriendRequest(request.flag, !!quickAction.approve).then().catch((e) => this.core.context.logger.logError(e));
    }
  }
}

// --------------------------------------------------------------------------
// PropertyKey
// --------------------------------------------------------------------------
/** Returns true if this value has this property key */
// --------------------------------------------------------------------------
// Object Instances
// --------------------------------------------------------------------------
/** Returns true if this value is an async iterator */
function IsAsyncIterator$2(value) {
    return IsObject$3(value) && !IsArray$3(value) && !IsUint8Array$2(value) && Symbol.asyncIterator in value;
}
/** Returns true if this value is an array */
function IsArray$3(value) {
    return Array.isArray(value);
}
/** Returns true if this value is bigint */
function IsBigInt$2(value) {
    return typeof value === 'bigint';
}
/** Returns true if this value is a boolean */
function IsBoolean$2(value) {
    return typeof value === 'boolean';
}
/** Returns true if this value is a Date object */
function IsDate$2(value) {
    return value instanceof globalThis.Date;
}
/** Returns true if this value is a function */
function IsFunction$2(value) {
    return typeof value === 'function';
}
/** Returns true if this value is an iterator */
function IsIterator$2(value) {
    return IsObject$3(value) && !IsArray$3(value) && !IsUint8Array$2(value) && Symbol.iterator in value;
}
/** Returns true if this value is null */
function IsNull$2(value) {
    return value === null;
}
/** Returns true if this value is number */
function IsNumber$3(value) {
    return typeof value === 'number';
}
/** Returns true if this value is an object */
function IsObject$3(value) {
    return typeof value === 'object' && value !== null;
}
/** Returns true if this value is RegExp */
function IsRegExp$2(value) {
    return value instanceof globalThis.RegExp;
}
/** Returns true if this value is string */
function IsString$2(value) {
    return typeof value === 'string';
}
/** Returns true if this value is symbol */
function IsSymbol$2(value) {
    return typeof value === 'symbol';
}
/** Returns true if this value is a Uint8Array */
function IsUint8Array$2(value) {
    return value instanceof globalThis.Uint8Array;
}
/** Returns true if this value is undefined */
function IsUndefined$3(value) {
    return value === undefined;
}

function ArrayType(value) {
    return value.map((value) => Visit$2(value));
}
function DateType(value) {
    return new Date(value.getTime());
}
function Uint8ArrayType(value) {
    return new Uint8Array(value);
}
function RegExpType(value) {
    return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
    const result = {};
    for (const key of Object.getOwnPropertyNames(value)) {
        result[key] = Visit$2(value[key]);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
        result[key] = Visit$2(value[key]);
    }
    return result;
}
// prettier-ignore
function Visit$2(value) {
    return (IsArray$3(value) ? ArrayType(value) :
        IsDate$2(value) ? DateType(value) :
            IsUint8Array$2(value) ? Uint8ArrayType(value) :
                IsRegExp$2(value) ? RegExpType(value) :
                    IsObject$3(value) ? ObjectType(value) :
                        value);
}
/** Clones a value */
function Clone(value) {
    return Visit$2(value);
}

/** Clones a Type */
function CloneType(schema, options) {
    return Clone(schema) ;
}

// --------------------------------------------------------------------------
// Iterators
// --------------------------------------------------------------------------
/** Returns true if this value is an async iterator */
// --------------------------------------------------------------------------
// Standard
// --------------------------------------------------------------------------
/** Returns true of this value is an object type */
function IsObject$2(value) {
    return value !== null && typeof value === 'object';
}
/** Returns true if this value is an array, but not a typed array */
function IsArray$2(value) {
    return Array.isArray(value) && !ArrayBuffer.isView(value);
}
/** Returns true if this value is an undefined */
function IsUndefined$2(value) {
    return value === undefined;
}
/** Returns true if this value is an number */
function IsNumber$2(value) {
    return typeof value === 'number';
}

var TypeSystemPolicy;
(function (TypeSystemPolicy) {
    // ------------------------------------------------------------------
    // TypeSystemPolicy: Instancing
    // ------------------------------------------------------------------
    /**
     * Configures the instantiation behavior of TypeBox types. The `default` option assigns raw JavaScript
     * references for embedded types, which may cause side effects if type properties are explicitly updated
     * outside the TypeBox type builder. The `clone` option creates copies of any shared types upon creation,
     * preventing unintended side effects. The `freeze` option applies `Object.freeze()` to the type, making
     * it fully readonly and immutable. Implementations should use `default` whenever possible, as it is the
     * fastest way to instantiate types. The default setting is `default`.
     */
    TypeSystemPolicy.InstanceMode = 'default';
    // ------------------------------------------------------------------
    // TypeSystemPolicy: Checking
    // ------------------------------------------------------------------
    /** Sets whether TypeBox should assert optional properties using the TypeScript `exactOptionalPropertyTypes` assertion policy. The default is `false` */
    TypeSystemPolicy.ExactOptionalPropertyTypes = false;
    /** Sets whether arrays should be treated as a kind of objects. The default is `false` */
    TypeSystemPolicy.AllowArrayObject = false;
    /** Sets whether `NaN` or `Infinity` should be treated as valid numeric values. The default is `false` */
    TypeSystemPolicy.AllowNaN = false;
    /** Sets whether `null` should validate for void types. The default is `false` */
    TypeSystemPolicy.AllowNullVoid = false;
    /** Checks this value using the ExactOptionalPropertyTypes policy */
    function IsExactOptionalProperty(value, key) {
        return TypeSystemPolicy.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
    }
    TypeSystemPolicy.IsExactOptionalProperty = IsExactOptionalProperty;
    /** Checks this value using the AllowArrayObjects policy */
    function IsObjectLike(value) {
        const isObject = IsObject$2(value);
        return TypeSystemPolicy.AllowArrayObject ? isObject : isObject && !IsArray$2(value);
    }
    TypeSystemPolicy.IsObjectLike = IsObjectLike;
    /** Checks this value as a record using the AllowArrayObjects policy */
    function IsRecordLike(value) {
        return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
    }
    TypeSystemPolicy.IsRecordLike = IsRecordLike;
    /** Checks this value using the AllowNaN policy */
    function IsNumberLike(value) {
        return TypeSystemPolicy.AllowNaN ? IsNumber$2(value) : Number.isFinite(value);
    }
    TypeSystemPolicy.IsNumberLike = IsNumberLike;
    /** Checks this value using the AllowVoidNull policy */
    function IsVoidLike(value) {
        const isUndefined = IsUndefined$2(value);
        return TypeSystemPolicy.AllowNullVoid ? isUndefined || value === null : isUndefined;
    }
    TypeSystemPolicy.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));

function ImmutableArray(value) {
    return globalThis.Object.freeze(value).map((value) => Immutable(value));
}
function ImmutableDate(value) {
    return value;
}
function ImmutableUint8Array(value) {
    return value;
}
function ImmutableRegExp(value) {
    return value;
}
function ImmutableObject(value) {
    const result = {};
    for (const key of Object.getOwnPropertyNames(value)) {
        result[key] = Immutable(value[key]);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
        result[key] = Immutable(value[key]);
    }
    return globalThis.Object.freeze(result);
}
/** Specialized deep immutable value. Applies freeze recursively to the given value */
// prettier-ignore
function Immutable(value) {
    return (IsArray$3(value) ? ImmutableArray(value) :
        IsDate$2(value) ? ImmutableDate(value) :
            IsUint8Array$2(value) ? ImmutableUint8Array(value) :
                IsRegExp$2(value) ? ImmutableRegExp(value) :
                    IsObject$3(value) ? ImmutableObject(value) :
                        value);
}

/** Creates TypeBox schematics using the configured InstanceMode */
function CreateType(schema, options) {
    const result = options !== undefined ? { ...options, ...schema } : schema;
    switch (TypeSystemPolicy.InstanceMode) {
        case 'freeze':
            return Immutable(result);
        case 'clone':
            return Clone(result);
        default:
            return result;
    }
}

/** The base Error type thrown for all TypeBox exceptions  */
class TypeBoxError extends Error {
    constructor(message) {
        super(message);
    }
}

/** Symbol key applied to transform types */
const TransformKind = Symbol.for('TypeBox.Transform');
/** Symbol key applied to readonly types */
const ReadonlyKind = Symbol.for('TypeBox.Readonly');
/** Symbol key applied to optional types */
const OptionalKind = Symbol.for('TypeBox.Optional');
/** Symbol key applied to types */
const Hint = Symbol.for('TypeBox.Hint');
/** Symbol key applied to types */
const Kind = Symbol.for('TypeBox.Kind');

/** `[Kind-Only]` Returns true if this value has a Readonly symbol */
function IsReadonly(value) {
    return IsObject$3(value) && value[ReadonlyKind] === 'Readonly';
}
/** `[Kind-Only]` Returns true if this value has a Optional symbol */
function IsOptional$1(value) {
    return IsObject$3(value) && value[OptionalKind] === 'Optional';
}
/** `[Kind-Only]` Returns true if the given value is TAny */
function IsAny$1(value) {
    return IsKindOf$1(value, 'Any');
}
/** `[Kind-Only]` Returns true if the given value is TArray */
function IsArray$1(value) {
    return IsKindOf$1(value, 'Array');
}
/** `[Kind-Only]` Returns true if the given value is TAsyncIterator */
function IsAsyncIterator$1(value) {
    return IsKindOf$1(value, 'AsyncIterator');
}
/** `[Kind-Only]` Returns true if the given value is TBigInt */
function IsBigInt$1(value) {
    return IsKindOf$1(value, 'BigInt');
}
/** `[Kind-Only]` Returns true if the given value is TBoolean */
function IsBoolean$1(value) {
    return IsKindOf$1(value, 'Boolean');
}
/** `[Kind-Only]` Returns true if the given value is TComputed */
function IsComputed$1(value) {
    return IsKindOf$1(value, 'Computed');
}
/** `[Kind-Only]` Returns true if the given value is TConstructor */
function IsConstructor$1(value) {
    return IsKindOf$1(value, 'Constructor');
}
/** `[Kind-Only]` Returns true if the given value is TDate */
function IsDate$1(value) {
    return IsKindOf$1(value, 'Date');
}
/** `[Kind-Only]` Returns true if the given value is TFunction */
function IsFunction$1(value) {
    return IsKindOf$1(value, 'Function');
}
/** `[Kind-Only]` Returns true if the given value is TInteger */
function IsInteger$1(value) {
    return IsKindOf$1(value, 'Integer');
}
/** `[Kind-Only]` Returns true if the given value is TIntersect */
function IsIntersect$1(value) {
    return IsKindOf$1(value, 'Intersect');
}
/** `[Kind-Only]` Returns true if the given value is TIterator */
function IsIterator$1(value) {
    return IsKindOf$1(value, 'Iterator');
}
/** `[Kind-Only]` Returns true if the given value is a TKind with the given name. */
function IsKindOf$1(value, kind) {
    return IsObject$3(value) && Kind in value && value[Kind] === kind;
}
/** `[Kind-Only]` Returns true if the given value is TLiteralValue */
function IsLiteralValue$1(value) {
    return IsBoolean$2(value) || IsNumber$3(value) || IsString$2(value);
}
/** `[Kind-Only]` Returns true if the given value is TLiteral */
function IsLiteral$1(value) {
    return IsKindOf$1(value, 'Literal');
}
/** `[Kind-Only]` Returns true if the given value is a TMappedKey */
function IsMappedKey$1(value) {
    return IsKindOf$1(value, 'MappedKey');
}
/** `[Kind-Only]` Returns true if the given value is TMappedResult */
function IsMappedResult$1(value) {
    return IsKindOf$1(value, 'MappedResult');
}
/** `[Kind-Only]` Returns true if the given value is TNever */
function IsNever$1(value) {
    return IsKindOf$1(value, 'Never');
}
/** `[Kind-Only]` Returns true if the given value is TNot */
function IsNot$1(value) {
    return IsKindOf$1(value, 'Not');
}
/** `[Kind-Only]` Returns true if the given value is TNull */
function IsNull$1(value) {
    return IsKindOf$1(value, 'Null');
}
/** `[Kind-Only]` Returns true if the given value is TNumber */
function IsNumber$1(value) {
    return IsKindOf$1(value, 'Number');
}
/** `[Kind-Only]` Returns true if the given value is TObject */
function IsObject$1(value) {
    return IsKindOf$1(value, 'Object');
}
/** `[Kind-Only]` Returns true if the given value is TPromise */
function IsPromise$1(value) {
    return IsKindOf$1(value, 'Promise');
}
/** `[Kind-Only]` Returns true if the given value is TRecord */
function IsRecord$1(value) {
    return IsKindOf$1(value, 'Record');
}
/** `[Kind-Only]` Returns true if the given value is TRef */
function IsRef$1(value) {
    return IsKindOf$1(value, 'Ref');
}
/** `[Kind-Only]` Returns true if the given value is TRegExp */
function IsRegExp$1(value) {
    return IsKindOf$1(value, 'RegExp');
}
/** `[Kind-Only]` Returns true if the given value is TString */
function IsString$1(value) {
    return IsKindOf$1(value, 'String');
}
/** `[Kind-Only]` Returns true if the given value is TSymbol */
function IsSymbol$1(value) {
    return IsKindOf$1(value, 'Symbol');
}
/** `[Kind-Only]` Returns true if the given value is TTemplateLiteral */
function IsTemplateLiteral$1(value) {
    return IsKindOf$1(value, 'TemplateLiteral');
}
/** `[Kind-Only]` Returns true if the given value is TThis */
function IsThis$1(value) {
    return IsKindOf$1(value, 'This');
}
/** `[Kind-Only]` Returns true of this value is TTransform */
function IsTransform$1(value) {
    return IsObject$3(value) && TransformKind in value;
}
/** `[Kind-Only]` Returns true if the given value is TTuple */
function IsTuple$1(value) {
    return IsKindOf$1(value, 'Tuple');
}
/** `[Kind-Only]` Returns true if the given value is TUndefined */
function IsUndefined$1(value) {
    return IsKindOf$1(value, 'Undefined');
}
/** `[Kind-Only]` Returns true if the given value is TUnion */
function IsUnion$1(value) {
    return IsKindOf$1(value, 'Union');
}
/** `[Kind-Only]` Returns true if the given value is TUint8Array */
function IsUint8Array$1(value) {
    return IsKindOf$1(value, 'Uint8Array');
}
/** `[Kind-Only]` Returns true if the given value is TUnknown */
function IsUnknown$1(value) {
    return IsKindOf$1(value, 'Unknown');
}
/** `[Kind-Only]` Returns true if the given value is a raw TUnsafe */
function IsUnsafe$1(value) {
    return IsKindOf$1(value, 'Unsafe');
}
/** `[Kind-Only]` Returns true if the given value is TVoid */
function IsVoid$1(value) {
    return IsKindOf$1(value, 'Void');
}
/** `[Kind-Only]` Returns true if the given value is TKind */
function IsKind$1(value) {
    return IsObject$3(value) && Kind in value && IsString$2(value[Kind]);
}
/** `[Kind-Only]` Returns true if the given value is TSchema */
function IsSchema$1(value) {
    // prettier-ignore
    return (IsAny$1(value) ||
        IsArray$1(value) ||
        IsBoolean$1(value) ||
        IsBigInt$1(value) ||
        IsAsyncIterator$1(value) ||
        IsComputed$1(value) ||
        IsConstructor$1(value) ||
        IsDate$1(value) ||
        IsFunction$1(value) ||
        IsInteger$1(value) ||
        IsIntersect$1(value) ||
        IsIterator$1(value) ||
        IsLiteral$1(value) ||
        IsMappedKey$1(value) ||
        IsMappedResult$1(value) ||
        IsNever$1(value) ||
        IsNot$1(value) ||
        IsNull$1(value) ||
        IsNumber$1(value) ||
        IsObject$1(value) ||
        IsPromise$1(value) ||
        IsRecord$1(value) ||
        IsRef$1(value) ||
        IsRegExp$1(value) ||
        IsString$1(value) ||
        IsSymbol$1(value) ||
        IsTemplateLiteral$1(value) ||
        IsThis$1(value) ||
        IsTuple$1(value) ||
        IsUndefined$1(value) ||
        IsUnion$1(value) ||
        IsUint8Array$1(value) ||
        IsUnknown$1(value) ||
        IsUnsafe$1(value) ||
        IsVoid$1(value) ||
        IsKind$1(value));
}

const KnownTypes = [
    'Any',
    'Array',
    'AsyncIterator',
    'BigInt',
    'Boolean',
    'Computed',
    'Constructor',
    'Date',
    'Enum',
    'Function',
    'Integer',
    'Intersect',
    'Iterator',
    'Literal',
    'MappedKey',
    'MappedResult',
    'Not',
    'Null',
    'Number',
    'Object',
    'Promise',
    'Record',
    'Ref',
    'RegExp',
    'String',
    'Symbol',
    'TemplateLiteral',
    'This',
    'Tuple',
    'Undefined',
    'Union',
    'Uint8Array',
    'Unknown',
    'Void',
];
function IsPattern(value) {
    try {
        new RegExp(value);
        return true;
    }
    catch {
        return false;
    }
}
function IsControlCharacterFree(value) {
    if (!IsString$2(value))
        return false;
    for (let i = 0; i < value.length; i++) {
        const code = value.charCodeAt(i);
        if ((code >= 7 && code <= 13) || code === 27 || code === 127) {
            return false;
        }
    }
    return true;
}
function IsAdditionalProperties(value) {
    return IsOptionalBoolean(value) || IsSchema(value);
}
function IsOptionalBigInt(value) {
    return IsUndefined$3(value) || IsBigInt$2(value);
}
function IsOptionalNumber(value) {
    return IsUndefined$3(value) || IsNumber$3(value);
}
function IsOptionalBoolean(value) {
    return IsUndefined$3(value) || IsBoolean$2(value);
}
function IsOptionalString(value) {
    return IsUndefined$3(value) || IsString$2(value);
}
function IsOptionalPattern(value) {
    return IsUndefined$3(value) || (IsString$2(value) && IsControlCharacterFree(value) && IsPattern(value));
}
function IsOptionalFormat(value) {
    return IsUndefined$3(value) || (IsString$2(value) && IsControlCharacterFree(value));
}
function IsOptionalSchema(value) {
    return IsUndefined$3(value) || IsSchema(value);
}
/** Returns true if this value has a Optional symbol */
function IsOptional(value) {
    return IsObject$3(value) && value[OptionalKind] === 'Optional';
}
// ------------------------------------------------------------------
// Types
// ------------------------------------------------------------------
/** Returns true if the given value is TAny */
function IsAny(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Any') &&
        IsOptionalString(value.$id));
}
/** Returns true if the given value is TArray */
function IsArray(value) {
    return (IsKindOf(value, 'Array') &&
        value.type === 'array' &&
        IsOptionalString(value.$id) &&
        IsSchema(value.items) &&
        IsOptionalNumber(value.minItems) &&
        IsOptionalNumber(value.maxItems) &&
        IsOptionalBoolean(value.uniqueItems) &&
        IsOptionalSchema(value.contains) &&
        IsOptionalNumber(value.minContains) &&
        IsOptionalNumber(value.maxContains));
}
/** Returns true if the given value is TAsyncIterator */
function IsAsyncIterator(value) {
    // prettier-ignore
    return (IsKindOf(value, 'AsyncIterator') &&
        value.type === 'AsyncIterator' &&
        IsOptionalString(value.$id) &&
        IsSchema(value.items));
}
/** Returns true if the given value is TBigInt */
function IsBigInt(value) {
    // prettier-ignore
    return (IsKindOf(value, 'BigInt') &&
        value.type === 'bigint' &&
        IsOptionalString(value.$id) &&
        IsOptionalBigInt(value.exclusiveMaximum) &&
        IsOptionalBigInt(value.exclusiveMinimum) &&
        IsOptionalBigInt(value.maximum) &&
        IsOptionalBigInt(value.minimum) &&
        IsOptionalBigInt(value.multipleOf));
}
/** Returns true if the given value is TBoolean */
function IsBoolean(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Boolean') &&
        value.type === 'boolean' &&
        IsOptionalString(value.$id));
}
/** Returns true if the given value is TComputed */
function IsComputed(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Computed') &&
        IsString$2(value.target) &&
        IsArray$3(value.parameters) &&
        value.parameters.every((schema) => IsSchema(schema)));
}
/** Returns true if the given value is TConstructor */
function IsConstructor(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Constructor') &&
        value.type === 'Constructor' &&
        IsOptionalString(value.$id) &&
        IsArray$3(value.parameters) &&
        value.parameters.every(schema => IsSchema(schema)) &&
        IsSchema(value.returns));
}
/** Returns true if the given value is TDate */
function IsDate(value) {
    return (IsKindOf(value, 'Date') &&
        value.type === 'Date' &&
        IsOptionalString(value.$id) &&
        IsOptionalNumber(value.exclusiveMaximumTimestamp) &&
        IsOptionalNumber(value.exclusiveMinimumTimestamp) &&
        IsOptionalNumber(value.maximumTimestamp) &&
        IsOptionalNumber(value.minimumTimestamp) &&
        IsOptionalNumber(value.multipleOfTimestamp));
}
/** Returns true if the given value is TFunction */
function IsFunction(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Function') &&
        value.type === 'Function' &&
        IsOptionalString(value.$id) &&
        IsArray$3(value.parameters) &&
        value.parameters.every(schema => IsSchema(schema)) &&
        IsSchema(value.returns));
}
/** Returns true if the given value is TInteger */
function IsInteger(value) {
    return (IsKindOf(value, 'Integer') &&
        value.type === 'integer' &&
        IsOptionalString(value.$id) &&
        IsOptionalNumber(value.exclusiveMaximum) &&
        IsOptionalNumber(value.exclusiveMinimum) &&
        IsOptionalNumber(value.maximum) &&
        IsOptionalNumber(value.minimum) &&
        IsOptionalNumber(value.multipleOf));
}
/** Returns true if the given schema is TProperties */
function IsProperties(value) {
    // prettier-ignore
    return (IsObject$3(value) &&
        Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema(schema)));
}
/** Returns true if the given value is TIntersect */
function IsIntersect(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Intersect') &&
        (IsString$2(value.type) && value.type !== 'object' ? false : true) &&
        IsArray$3(value.allOf) &&
        value.allOf.every(schema => IsSchema(schema) && !IsTransform(schema)) &&
        IsOptionalString(value.type) &&
        (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) &&
        IsOptionalString(value.$id));
}
/** Returns true if the given value is TIterator */
function IsIterator(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Iterator') &&
        value.type === 'Iterator' &&
        IsOptionalString(value.$id) &&
        IsSchema(value.items));
}
/** Returns true if the given value is a TKind with the given name. */
function IsKindOf(value, kind) {
    return IsObject$3(value) && Kind in value && value[Kind] === kind;
}
/** Returns true if the given value is TLiteral<string> */
function IsLiteralString(value) {
    return IsLiteral(value) && IsString$2(value.const);
}
/** Returns true if the given value is TLiteral<number> */
function IsLiteralNumber(value) {
    return IsLiteral(value) && IsNumber$3(value.const);
}
/** Returns true if the given value is TLiteral<boolean> */
function IsLiteralBoolean(value) {
    return IsLiteral(value) && IsBoolean$2(value.const);
}
/** Returns true if the given value is TLiteral */
function IsLiteral(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Literal') &&
        IsOptionalString(value.$id) && IsLiteralValue(value.const));
}
/** Returns true if the given value is a TLiteralValue */
function IsLiteralValue(value) {
    return IsBoolean$2(value) || IsNumber$3(value) || IsString$2(value);
}
/** Returns true if the given value is a TMappedKey */
function IsMappedKey(value) {
    // prettier-ignore
    return (IsKindOf(value, 'MappedKey') &&
        IsArray$3(value.keys) &&
        value.keys.every(key => IsNumber$3(key) || IsString$2(key)));
}
/** Returns true if the given value is TMappedResult */
function IsMappedResult(value) {
    // prettier-ignore
    return (IsKindOf(value, 'MappedResult') &&
        IsProperties(value.properties));
}
/** Returns true if the given value is TNever */
function IsNever(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Never') &&
        IsObject$3(value.not) &&
        Object.getOwnPropertyNames(value.not).length === 0);
}
/** Returns true if the given value is TNot */
function IsNot(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Not') &&
        IsSchema(value.not));
}
/** Returns true if the given value is TNull */
function IsNull(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Null') &&
        value.type === 'null' &&
        IsOptionalString(value.$id));
}
/** Returns true if the given value is TNumber */
function IsNumber(value) {
    return (IsKindOf(value, 'Number') &&
        value.type === 'number' &&
        IsOptionalString(value.$id) &&
        IsOptionalNumber(value.exclusiveMaximum) &&
        IsOptionalNumber(value.exclusiveMinimum) &&
        IsOptionalNumber(value.maximum) &&
        IsOptionalNumber(value.minimum) &&
        IsOptionalNumber(value.multipleOf));
}
/** Returns true if the given value is TObject */
function IsObject(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Object') &&
        value.type === 'object' &&
        IsOptionalString(value.$id) &&
        IsProperties(value.properties) &&
        IsAdditionalProperties(value.additionalProperties) &&
        IsOptionalNumber(value.minProperties) &&
        IsOptionalNumber(value.maxProperties));
}
/** Returns true if the given value is TPromise */
function IsPromise(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Promise') &&
        value.type === 'Promise' &&
        IsOptionalString(value.$id) &&
        IsSchema(value.item));
}
/** Returns true if the given value is TRecord */
function IsRecord(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Record') &&
        value.type === 'object' &&
        IsOptionalString(value.$id) &&
        IsAdditionalProperties(value.additionalProperties) &&
        IsObject$3(value.patternProperties) &&
        ((schema) => {
            const keys = Object.getOwnPropertyNames(schema.patternProperties);
            return (keys.length === 1 &&
                IsPattern(keys[0]) &&
                IsObject$3(schema.patternProperties) &&
                IsSchema(schema.patternProperties[keys[0]]));
        })(value));
}
/** Returns true if the given value is TRef */
function IsRef(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Ref') &&
        IsOptionalString(value.$id) &&
        IsString$2(value.$ref));
}
/** Returns true if the given value is TRegExp */
function IsRegExp(value) {
    // prettier-ignore
    return (IsKindOf(value, 'RegExp') &&
        IsOptionalString(value.$id) &&
        IsString$2(value.source) &&
        IsString$2(value.flags) &&
        IsOptionalNumber(value.maxLength) &&
        IsOptionalNumber(value.minLength));
}
/** Returns true if the given value is TString */
function IsString(value) {
    // prettier-ignore
    return (IsKindOf(value, 'String') &&
        value.type === 'string' &&
        IsOptionalString(value.$id) &&
        IsOptionalNumber(value.minLength) &&
        IsOptionalNumber(value.maxLength) &&
        IsOptionalPattern(value.pattern) &&
        IsOptionalFormat(value.format));
}
/** Returns true if the given value is TSymbol */
function IsSymbol(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Symbol') &&
        value.type === 'symbol' &&
        IsOptionalString(value.$id));
}
/** Returns true if the given value is TTemplateLiteral */
function IsTemplateLiteral(value) {
    // prettier-ignore
    return (IsKindOf(value, 'TemplateLiteral') &&
        value.type === 'string' &&
        IsString$2(value.pattern) &&
        value.pattern[0] === '^' &&
        value.pattern[value.pattern.length - 1] === '$');
}
/** Returns true if the given value is TThis */
function IsThis(value) {
    // prettier-ignore
    return (IsKindOf(value, 'This') &&
        IsOptionalString(value.$id) &&
        IsString$2(value.$ref));
}
/** Returns true of this value is TTransform */
function IsTransform(value) {
    return IsObject$3(value) && TransformKind in value;
}
/** Returns true if the given value is TTuple */
function IsTuple(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Tuple') &&
        value.type === 'array' &&
        IsOptionalString(value.$id) &&
        IsNumber$3(value.minItems) &&
        IsNumber$3(value.maxItems) &&
        value.minItems === value.maxItems &&
        (( // empty
        IsUndefined$3(value.items) &&
            IsUndefined$3(value.additionalItems) &&
            value.minItems === 0) || (IsArray$3(value.items) &&
            value.items.every(schema => IsSchema(schema)))));
}
/** Returns true if the given value is TUndefined */
function IsUndefined(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Undefined') &&
        value.type === 'undefined' &&
        IsOptionalString(value.$id));
}
/** Returns true if the given value is TUnion */
function IsUnion(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Union') &&
        IsOptionalString(value.$id) &&
        IsObject$3(value) &&
        IsArray$3(value.anyOf) &&
        value.anyOf.every(schema => IsSchema(schema)));
}
/** Returns true if the given value is TUint8Array */
function IsUint8Array(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Uint8Array') &&
        value.type === 'Uint8Array' &&
        IsOptionalString(value.$id) &&
        IsOptionalNumber(value.minByteLength) &&
        IsOptionalNumber(value.maxByteLength));
}
/** Returns true if the given value is TUnknown */
function IsUnknown(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Unknown') &&
        IsOptionalString(value.$id));
}
/** Returns true if the given value is a raw TUnsafe */
function IsUnsafe(value) {
    return IsKindOf(value, 'Unsafe');
}
/** Returns true if the given value is TVoid */
function IsVoid(value) {
    // prettier-ignore
    return (IsKindOf(value, 'Void') &&
        value.type === 'void' &&
        IsOptionalString(value.$id));
}
/** Returns true if the given value is TKind */
function IsKind(value) {
    return IsObject$3(value) && Kind in value && IsString$2(value[Kind]) && !KnownTypes.includes(value[Kind]);
}
/** Returns true if the given value is TSchema */
function IsSchema(value) {
    // prettier-ignore
    return (IsObject$3(value)) && (IsAny(value) ||
        IsArray(value) ||
        IsBoolean(value) ||
        IsBigInt(value) ||
        IsAsyncIterator(value) ||
        IsComputed(value) ||
        IsConstructor(value) ||
        IsDate(value) ||
        IsFunction(value) ||
        IsInteger(value) ||
        IsIntersect(value) ||
        IsIterator(value) ||
        IsLiteral(value) ||
        IsMappedKey(value) ||
        IsMappedResult(value) ||
        IsNever(value) ||
        IsNot(value) ||
        IsNull(value) ||
        IsNumber(value) ||
        IsObject(value) ||
        IsPromise(value) ||
        IsRecord(value) ||
        IsRef(value) ||
        IsRegExp(value) ||
        IsString(value) ||
        IsSymbol(value) ||
        IsTemplateLiteral(value) ||
        IsThis(value) ||
        IsTuple(value) ||
        IsUndefined(value) ||
        IsUnion(value) ||
        IsUint8Array(value) ||
        IsUnknown(value) ||
        IsUnsafe(value) ||
        IsVoid(value) ||
        IsKind(value));
}

const PatternBoolean = '(true|false)';
const PatternNumber = '(0|[1-9][0-9]*)';
const PatternString = '(.*)';
const PatternNever = '(?!.*)';
const PatternNumberExact = `^${PatternNumber}$`;
const PatternStringExact = `^${PatternString}$`;
const PatternNeverExact = `^${PatternNever}$`;

/** Returns true if element right is in the set of left */
// prettier-ignore
function SetIncludes(T, S) {
    return T.includes(S);
}
/** Returns a distinct set of elements */
function SetDistinct(T) {
    return [...new Set(T)];
}
/** Returns the Intersect of the given sets */
function SetIntersect(T, S) {
    return T.filter((L) => S.includes(L));
}
// prettier-ignore
function SetIntersectManyResolve(T, Init) {
    return T.reduce((Acc, L) => {
        return SetIntersect(Acc, L);
    }, Init);
}
// prettier-ignore
function SetIntersectMany(T) {
    return (T.length === 1
        ? T[0]
        // Use left to initialize the accumulator for resolve
        : T.length > 1
            ? SetIntersectManyResolve(T.slice(1), T[0])
            : []);
}
/** Returns the Union of multiple sets */
function SetUnionMany(T) {
    const Acc = [];
    for (const L of T)
        Acc.push(...L);
    return Acc;
}

/** `[Json]` Creates an Any type */
function Any(options) {
    return CreateType({ [Kind]: 'Any' }, options);
}

/** `[Json]` Creates an Array type */
function Array$1(items, options) {
    return CreateType({ [Kind]: 'Array', type: 'array', items }, options);
}

/** `[JavaScript]` Creates a AsyncIterator type */
function AsyncIterator(items, options) {
    return CreateType({ [Kind]: 'AsyncIterator', type: 'AsyncIterator', items }, options);
}

/** `[Internal]` Creates a deferred computed type. This type is used exclusively in modules to defer resolution of computable types that contain interior references  */
function Computed(target, parameters, options) {
    return CreateType({ [Kind]: 'Computed', target, parameters }, options);
}

function DiscardKey(value, key) {
    const { [key]: _, ...rest } = value;
    return rest;
}
/** Discards property keys from the given value. This function returns a shallow Clone. */
function Discard(value, keys) {
    return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}

/** `[Json]` Creates a Never type */
function Never(options) {
    return CreateType({ [Kind]: 'Never', not: {} }, options);
}

// prettier-ignore
function MappedResult(properties) {
    return CreateType({
        [Kind]: 'MappedResult',
        properties
    });
}

/** `[JavaScript]` Creates a Constructor type */
function Constructor(parameters, returns, options) {
    return CreateType({ [Kind]: 'Constructor', type: 'Constructor', parameters, returns }, options);
}

/** `[JavaScript]` Creates a Function type */
function Function$1(parameters, returns, options) {
    return CreateType({ [Kind]: 'Function', type: 'Function', parameters, returns }, options);
}

function UnionCreate(T, options) {
    return CreateType({ [Kind]: 'Union', anyOf: T }, options);
}

// prettier-ignore
function IsUnionOptional(types) {
    return types.some(type => IsOptional$1(type));
}
// prettier-ignore
function RemoveOptionalFromRest$1(types) {
    return types.map(left => IsOptional$1(left) ? RemoveOptionalFromType$1(left) : left);
}
// prettier-ignore
function RemoveOptionalFromType$1(T) {
    return (Discard(T, [OptionalKind]));
}
// prettier-ignore
function ResolveUnion(types, options) {
    const isOptional = IsUnionOptional(types);
    return (isOptional
        ? Optional(UnionCreate(RemoveOptionalFromRest$1(types), options))
        : UnionCreate(RemoveOptionalFromRest$1(types), options));
}
/** `[Json]` Creates an evaluated Union type */
function UnionEvaluated(T, options) {
    // prettier-ignore
    return (T.length === 1 ? CreateType(T[0], options) :
        T.length === 0 ? Never(options) :
            ResolveUnion(T, options));
}

/** `[Json]` Creates a Union type */
function Union(types, options) {
    // prettier-ignore
    return (types.length === 0 ? Never(options) :
        types.length === 1 ? CreateType(types[0], options) :
            UnionCreate(types, options));
}

// ------------------------------------------------------------------
// TemplateLiteralParserError
// ------------------------------------------------------------------
class TemplateLiteralParserError extends TypeBoxError {
}
// -------------------------------------------------------------------
// Unescape
//
// Unescape for these control characters specifically. Note that this
// function is only called on non union group content, and where we
// still want to allow the user to embed control characters in that
// content. For review.
// -------------------------------------------------------------------
// prettier-ignore
function Unescape(pattern) {
    return pattern
        .replace(/\\\$/g, '$')
        .replace(/\\\*/g, '*')
        .replace(/\\\^/g, '^')
        .replace(/\\\|/g, '|')
        .replace(/\\\(/g, '(')
        .replace(/\\\)/g, ')');
}
// -------------------------------------------------------------------
// Control Characters
// -------------------------------------------------------------------
function IsNonEscaped(pattern, index, char) {
    return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
    return IsNonEscaped(pattern, index, '(');
}
function IsCloseParen(pattern, index) {
    return IsNonEscaped(pattern, index, ')');
}
function IsSeparator(pattern, index) {
    return IsNonEscaped(pattern, index, '|');
}
// -------------------------------------------------------------------
// Control Groups
// -------------------------------------------------------------------
function IsGroup(pattern) {
    if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
        return false;
    let count = 0;
    for (let index = 0; index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
            count += 1;
        if (IsCloseParen(pattern, index))
            count -= 1;
        if (count === 0 && index !== pattern.length - 1)
            return false;
    }
    return true;
}
// prettier-ignore
function InGroup(pattern) {
    return pattern.slice(1, pattern.length - 1);
}
// prettier-ignore
function IsPrecedenceOr(pattern) {
    let count = 0;
    for (let index = 0; index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
            count += 1;
        if (IsCloseParen(pattern, index))
            count -= 1;
        if (IsSeparator(pattern, index) && count === 0)
            return true;
    }
    return false;
}
// prettier-ignore
function IsPrecedenceAnd(pattern) {
    for (let index = 0; index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
            return true;
    }
    return false;
}
// prettier-ignore
function Or(pattern) {
    let [count, start] = [0, 0];
    const expressions = [];
    for (let index = 0; index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
            count += 1;
        if (IsCloseParen(pattern, index))
            count -= 1;
        if (IsSeparator(pattern, index) && count === 0) {
            const range = pattern.slice(start, index);
            if (range.length > 0)
                expressions.push(TemplateLiteralParse(range));
            start = index + 1;
        }
    }
    const range = pattern.slice(start);
    if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
    if (expressions.length === 0)
        return { type: 'const', const: '' };
    if (expressions.length === 1)
        return expressions[0];
    return { type: 'or', expr: expressions };
}
// prettier-ignore
function And(pattern) {
    function Group(value, index) {
        if (!IsOpenParen(value, index))
            throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
        let count = 0;
        for (let scan = index; scan < value.length; scan++) {
            if (IsOpenParen(value, scan))
                count += 1;
            if (IsCloseParen(value, scan))
                count -= 1;
            if (count === 0)
                return [index, scan];
        }
        throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
    }
    function Range(pattern, index) {
        for (let scan = index; scan < pattern.length; scan++) {
            if (IsOpenParen(pattern, scan))
                return [index, scan];
        }
        return [index, pattern.length];
    }
    const expressions = [];
    for (let index = 0; index < pattern.length; index++) {
        if (IsOpenParen(pattern, index)) {
            const [start, end] = Group(pattern, index);
            const range = pattern.slice(start, end + 1);
            expressions.push(TemplateLiteralParse(range));
            index = end;
        }
        else {
            const [start, end] = Range(pattern, index);
            const range = pattern.slice(start, end);
            if (range.length > 0)
                expressions.push(TemplateLiteralParse(range));
            index = end - 1;
        }
    }
    return ((expressions.length === 0) ? { type: 'const', const: '' } :
        (expressions.length === 1) ? expressions[0] :
            { type: 'and', expr: expressions });
}
// ------------------------------------------------------------------
// TemplateLiteralParse
// ------------------------------------------------------------------
/** Parses a pattern and returns an expression tree */
function TemplateLiteralParse(pattern) {
    // prettier-ignore
    return (IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) :
        IsPrecedenceOr(pattern) ? Or(pattern) :
            IsPrecedenceAnd(pattern) ? And(pattern) :
                { type: 'const', const: Unescape(pattern) });
}
// ------------------------------------------------------------------
// TemplateLiteralParseExact
// ------------------------------------------------------------------
/** Parses a pattern and strips forward and trailing ^ and $ */
function TemplateLiteralParseExact(pattern) {
    return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

// ------------------------------------------------------------------
// TemplateLiteralFiniteError
// ------------------------------------------------------------------
class TemplateLiteralFiniteError extends TypeBoxError {
}
// ------------------------------------------------------------------
// IsTemplateLiteralFiniteCheck
// ------------------------------------------------------------------
// prettier-ignore
function IsNumberExpression(expression) {
    return (expression.type === 'or' &&
        expression.expr.length === 2 &&
        expression.expr[0].type === 'const' &&
        expression.expr[0].const === '0' &&
        expression.expr[1].type === 'const' &&
        expression.expr[1].const === '[1-9][0-9]*');
}
// prettier-ignore
function IsBooleanExpression(expression) {
    return (expression.type === 'or' &&
        expression.expr.length === 2 &&
        expression.expr[0].type === 'const' &&
        expression.expr[0].const === 'true' &&
        expression.expr[1].type === 'const' &&
        expression.expr[1].const === 'false');
}
// prettier-ignore
function IsStringExpression(expression) {
    return expression.type === 'const' && expression.const === '.*';
}
// ------------------------------------------------------------------
// IsTemplateLiteralExpressionFinite
// ------------------------------------------------------------------
// prettier-ignore
function IsTemplateLiteralExpressionFinite(expression) {
    return (IsNumberExpression(expression) || IsStringExpression(expression) ? false :
        IsBooleanExpression(expression) ? true :
            (expression.type === 'and') ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) :
                (expression.type === 'or') ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) :
                    (expression.type === 'const') ? true :
                        (() => { throw new TemplateLiteralFiniteError(`Unknown expression type`); })());
}
/** Returns true if this TemplateLiteral resolves to a finite set of values */
function IsTemplateLiteralFinite(schema) {
    const expression = TemplateLiteralParseExact(schema.pattern);
    return IsTemplateLiteralExpressionFinite(expression);
}

// ------------------------------------------------------------------
// TemplateLiteralGenerateError
// ------------------------------------------------------------------
class TemplateLiteralGenerateError extends TypeBoxError {
}
// ------------------------------------------------------------------
// TemplateLiteralExpressionGenerate
// ------------------------------------------------------------------
// prettier-ignore
function* GenerateReduce(buffer) {
    if (buffer.length === 1)
        return yield* buffer[0];
    for (const left of buffer[0]) {
        for (const right of GenerateReduce(buffer.slice(1))) {
            yield `${left}${right}`;
        }
    }
}
// prettier-ignore
function* GenerateAnd(expression) {
    return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
// prettier-ignore
function* GenerateOr(expression) {
    for (const expr of expression.expr)
        yield* TemplateLiteralExpressionGenerate(expr);
}
// prettier-ignore
function* GenerateConst(expression) {
    return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
    return expression.type === 'and'
        ? yield* GenerateAnd(expression)
        : expression.type === 'or'
            ? yield* GenerateOr(expression)
            : expression.type === 'const'
                ? yield* GenerateConst(expression)
                : (() => {
                    throw new TemplateLiteralGenerateError('Unknown expression');
                })();
}
/** Generates a tuple of strings from the given TemplateLiteral. Returns an empty tuple if infinite. */
function TemplateLiteralGenerate(schema) {
    const expression = TemplateLiteralParseExact(schema.pattern);
    // prettier-ignore
    return (IsTemplateLiteralExpressionFinite(expression)
        ? [...TemplateLiteralExpressionGenerate(expression)]
        : []);
}

/** `[Json]` Creates a Literal type */
function Literal(value, options) {
    return CreateType({
        [Kind]: 'Literal',
        const: value,
        type: typeof value,
    }, options);
}

/** `[Json]` Creates a Boolean type */
function Boolean$1(options) {
    return CreateType({ [Kind]: 'Boolean', type: 'boolean' }, options);
}

/** `[JavaScript]` Creates a BigInt type */
function BigInt$1(options) {
    return CreateType({ [Kind]: 'BigInt', type: 'bigint' }, options);
}

/** `[Json]` Creates a Number type */
function Number$1(options) {
    return CreateType({ [Kind]: 'Number', type: 'number' }, options);
}

/** `[Json]` Creates a String type */
function String$1(options) {
    return CreateType({ [Kind]: 'String', type: 'string' }, options);
}

// ------------------------------------------------------------------
// SyntaxParsers
// ------------------------------------------------------------------
// prettier-ignore
function* FromUnion$8(syntax) {
    const trim = syntax.trim().replace(/"|'/g, '');
    return (trim === 'boolean' ? yield Boolean$1() :
        trim === 'number' ? yield Number$1() :
            trim === 'bigint' ? yield BigInt$1() :
                trim === 'string' ? yield String$1() :
                    yield (() => {
                        const literals = trim.split('|').map((literal) => Literal(literal.trim()));
                        return (literals.length === 0 ? Never() :
                            literals.length === 1 ? literals[0] :
                                UnionEvaluated(literals));
                    })());
}
// prettier-ignore
function* FromTerminal(syntax) {
    if (syntax[1] !== '{') {
        const L = Literal('$');
        const R = FromSyntax(syntax.slice(1));
        return yield* [L, ...R];
    }
    for (let i = 2; i < syntax.length; i++) {
        if (syntax[i] === '}') {
            const L = FromUnion$8(syntax.slice(2, i));
            const R = FromSyntax(syntax.slice(i + 1));
            return yield* [...L, ...R];
        }
    }
    yield Literal(syntax);
}
// prettier-ignore
function* FromSyntax(syntax) {
    for (let i = 0; i < syntax.length; i++) {
        if (syntax[i] === '$') {
            const L = Literal(syntax.slice(0, i));
            const R = FromTerminal(syntax.slice(i));
            return yield* [L, ...R];
        }
    }
    yield Literal(syntax);
}
/** Parses TemplateLiteralSyntax and returns a tuple of TemplateLiteralKinds */
function TemplateLiteralSyntax(syntax) {
    return [...FromSyntax(syntax)];
}

// ------------------------------------------------------------------
// TemplateLiteralPatternError
// ------------------------------------------------------------------
class TemplateLiteralPatternError extends TypeBoxError {
}
// ------------------------------------------------------------------
// TemplateLiteralPattern
// ------------------------------------------------------------------
function Escape(value) {
    return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
// prettier-ignore
function Visit$1(schema, acc) {
    return (IsTemplateLiteral$1(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) :
        IsUnion$1(schema) ? `(${schema.anyOf.map((schema) => Visit$1(schema, acc)).join('|')})` :
            IsNumber$1(schema) ? `${acc}${PatternNumber}` :
                IsInteger$1(schema) ? `${acc}${PatternNumber}` :
                    IsBigInt$1(schema) ? `${acc}${PatternNumber}` :
                        IsString$1(schema) ? `${acc}${PatternString}` :
                            IsLiteral$1(schema) ? `${acc}${Escape(schema.const.toString())}` :
                                IsBoolean$1(schema) ? `${acc}${PatternBoolean}` :
                                    (() => { throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`); })());
}
function TemplateLiteralPattern(kinds) {
    return `^${kinds.map((schema) => Visit$1(schema, '')).join('')}\$`;
}

/** Returns a Union from the given TemplateLiteral */
function TemplateLiteralToUnion(schema) {
    const R = TemplateLiteralGenerate(schema);
    const L = R.map((S) => Literal(S));
    return UnionEvaluated(L);
}

/** `[Json]` Creates a TemplateLiteral type */
// prettier-ignore
function TemplateLiteral(unresolved, options) {
    const pattern = IsString$2(unresolved)
        ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved))
        : TemplateLiteralPattern(unresolved);
    return CreateType({ [Kind]: 'TemplateLiteral', type: 'string', pattern }, options);
}

// prettier-ignore
function FromTemplateLiteral$2(templateLiteral) {
    const keys = TemplateLiteralGenerate(templateLiteral);
    return keys.map(key => key.toString());
}
// prettier-ignore
function FromUnion$7(types) {
    const result = [];
    for (const type of types)
        result.push(...IndexPropertyKeys(type));
    return result;
}
// prettier-ignore
function FromLiteral$1(literalValue) {
    return ([literalValue.toString()] // TS 5.4 observes TLiteralValue as not having a toString()
    );
}
/** Returns a tuple of PropertyKeys derived from the given TSchema */
// prettier-ignore
function IndexPropertyKeys(type) {
    return [...new Set((IsTemplateLiteral$1(type) ? FromTemplateLiteral$2(type) :
            IsUnion$1(type) ? FromUnion$7(type.anyOf) :
                IsLiteral$1(type) ? FromLiteral$1(type.const) :
                    IsNumber$1(type) ? ['[number]'] :
                        IsInteger$1(type) ? ['[number]'] :
                            []))];
}

// prettier-ignore
function FromProperties$h(type, properties, options) {
    const result = {};
    for (const K2 of Object.getOwnPropertyNames(properties)) {
        result[K2] = Index(type, IndexPropertyKeys(properties[K2]), options);
    }
    return result;
}
// prettier-ignore
function FromMappedResult$b(type, mappedResult, options) {
    return FromProperties$h(type, mappedResult.properties, options);
}
// prettier-ignore
function IndexFromMappedResult(type, mappedResult, options) {
    const properties = FromMappedResult$b(type, mappedResult, options);
    return MappedResult(properties);
}

// prettier-ignore
function FromRest$7(types, key) {
    return types.map(type => IndexFromPropertyKey(type, key));
}
// prettier-ignore
function FromIntersectRest(types) {
    return types.filter(type => !IsNever$1(type));
}
// prettier-ignore
function FromIntersect$6(types, key) {
    return (IntersectEvaluated(FromIntersectRest(FromRest$7(types, key))));
}
// prettier-ignore
function FromUnionRest(types) {
    return (types.some(L => IsNever$1(L))
        ? []
        : types);
}
// prettier-ignore
function FromUnion$6(types, key) {
    return (UnionEvaluated(FromUnionRest(FromRest$7(types, key))));
}
// prettier-ignore
function FromTuple$3(types, key) {
    return (key in types ? types[key] :
        key === '[number]' ? UnionEvaluated(types) :
            Never());
}
// prettier-ignore
function FromArray$4(type, key) {
    return (key === '[number]'
        ? type
        : Never());
}
// prettier-ignore
function FromProperty$1(properties, propertyKey) {
    return (propertyKey in properties ? properties[propertyKey] : Never());
}
// prettier-ignore
function IndexFromPropertyKey(type, propertyKey) {
    return (IsIntersect$1(type) ? FromIntersect$6(type.allOf, propertyKey) :
        IsUnion$1(type) ? FromUnion$6(type.anyOf, propertyKey) :
            IsTuple$1(type) ? FromTuple$3(type.items ?? [], propertyKey) :
                IsArray$1(type) ? FromArray$4(type.items, propertyKey) :
                    IsObject$1(type) ? FromProperty$1(type.properties, propertyKey) :
                        Never());
}
// prettier-ignore
function IndexFromPropertyKeys(type, propertyKeys) {
    return propertyKeys.map(propertyKey => IndexFromPropertyKey(type, propertyKey));
}
// prettier-ignore
function FromSchema(type, propertyKeys) {
    return (UnionEvaluated(IndexFromPropertyKeys(type, propertyKeys)));
}
/** `[Json]` Returns an Indexed property type for the given keys */
function Index(type, key, options) {
    // computed-type
    if (IsRef$1(type) || IsRef$1(key)) {
        const error = `Index types using Ref parameters require both Type and Key to be of TSchema`;
        if (!IsSchema$1(type) || !IsSchema$1(key))
            throw new TypeBoxError(error);
        return Computed('Index', [type, key]);
    }
    // mapped-types
    if (IsMappedResult$1(key))
        return IndexFromMappedResult(type, key, options);
    if (IsMappedKey$1(key))
        return IndexFromMappedKey(type, key, options);
    // prettier-ignore
    return CreateType(IsSchema$1(key)
        ? FromSchema(type, IndexPropertyKeys(key))
        : FromSchema(type, key), options);
}

// prettier-ignore
function MappedIndexPropertyKey(type, key, options) {
    return { [key]: Index(type, [key], Clone(options)) };
}
// prettier-ignore
function MappedIndexPropertyKeys(type, propertyKeys, options) {
    return propertyKeys.reduce((result, left) => {
        return { ...result, ...MappedIndexPropertyKey(type, left, options) };
    }, {});
}
// prettier-ignore
function MappedIndexProperties(type, mappedKey, options) {
    return MappedIndexPropertyKeys(type, mappedKey.keys, options);
}
// prettier-ignore
function IndexFromMappedKey(type, mappedKey, options) {
    const properties = MappedIndexProperties(type, mappedKey, options);
    return MappedResult(properties);
}

/** `[JavaScript]` Creates an Iterator type */
function Iterator(items, options) {
    return CreateType({ [Kind]: 'Iterator', type: 'Iterator', items }, options);
}

function RequiredKeys(properties) {
    const keys = [];
    for (let key in properties) {
        if (!IsOptional$1(properties[key]))
            keys.push(key);
    }
    return keys;
}
/** `[Json]` Creates an Object type */
function _Object(properties, options) {
    const required = RequiredKeys(properties);
    const schematic = required.length > 0 ? { [Kind]: 'Object', type: 'object', properties, required } : { [Kind]: 'Object', type: 'object', properties };
    return CreateType(schematic, options);
}
/** `[Json]` Creates an Object type */
var Object$1 = _Object;

/** `[JavaScript]` Creates a Promise type */
function Promise$1(item, options) {
    return CreateType({ [Kind]: 'Promise', type: 'Promise', item }, options);
}

function RemoveReadonly(schema) {
    return CreateType(Discard(schema, [ReadonlyKind]));
}
function AddReadonly(schema) {
    return CreateType({ ...schema, [ReadonlyKind]: 'Readonly' });
}
// prettier-ignore
function ReadonlyWithFlag(schema, F) {
    return (F === false
        ? RemoveReadonly(schema)
        : AddReadonly(schema));
}
/** `[Json]` Creates a Readonly property */
function Readonly(schema, enable) {
    const F = enable ?? true;
    return IsMappedResult$1(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// prettier-ignore
function FromProperties$g(K, F) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(K))
        Acc[K2] = Readonly(K[K2], F);
    return Acc;
}
// prettier-ignore
function FromMappedResult$a(R, F) {
    return FromProperties$g(R.properties, F);
}
// prettier-ignore
function ReadonlyFromMappedResult(R, F) {
    const P = FromMappedResult$a(R, F);
    return MappedResult(P);
}

/** `[Json]` Creates a Tuple type */
function Tuple(types, options) {
    // prettier-ignore
    return CreateType(types.length > 0 ?
        { [Kind]: 'Tuple', type: 'array', items: types, additionalItems: false, minItems: types.length, maxItems: types.length } :
        { [Kind]: 'Tuple', type: 'array', minItems: types.length, maxItems: types.length }, options);
}

// prettier-ignore
function FromMappedResult$9(K, P) {
    return (K in P
        ? FromSchemaType(K, P[K])
        : MappedResult(P));
}
// prettier-ignore
function MappedKeyToKnownMappedResultProperties(K) {
    return { [K]: Literal(K) };
}
// prettier-ignore
function MappedKeyToUnknownMappedResultProperties(P) {
    const Acc = {};
    for (const L of P)
        Acc[L] = Literal(L);
    return Acc;
}
// prettier-ignore
function MappedKeyToMappedResultProperties(K, P) {
    return (SetIncludes(P, K)
        ? MappedKeyToKnownMappedResultProperties(K)
        : MappedKeyToUnknownMappedResultProperties(P));
}
// prettier-ignore
function FromMappedKey$3(K, P) {
    const R = MappedKeyToMappedResultProperties(K, P);
    return FromMappedResult$9(K, R);
}
// prettier-ignore
function FromRest$6(K, T) {
    return T.map(L => FromSchemaType(K, L));
}
// prettier-ignore
function FromProperties$f(K, T) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(T))
        Acc[K2] = FromSchemaType(K, T[K2]);
    return Acc;
}
// prettier-ignore
function FromSchemaType(K, T) {
    // required to retain user defined options for mapped type
    const options = { ...T };
    return (
    // unevaluated modifier types
    IsOptional$1(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) :
        IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) :
            // unevaluated mapped types
            IsMappedResult$1(T) ? FromMappedResult$9(K, T.properties) :
                IsMappedKey$1(T) ? FromMappedKey$3(K, T.keys) :
                    // unevaluated types
                    IsConstructor$1(T) ? Constructor(FromRest$6(K, T.parameters), FromSchemaType(K, T.returns), options) :
                        IsFunction$1(T) ? Function$1(FromRest$6(K, T.parameters), FromSchemaType(K, T.returns), options) :
                            IsAsyncIterator$1(T) ? AsyncIterator(FromSchemaType(K, T.items), options) :
                                IsIterator$1(T) ? Iterator(FromSchemaType(K, T.items), options) :
                                    IsIntersect$1(T) ? Intersect(FromRest$6(K, T.allOf), options) :
                                        IsUnion$1(T) ? Union(FromRest$6(K, T.anyOf), options) :
                                            IsTuple$1(T) ? Tuple(FromRest$6(K, T.items ?? []), options) :
                                                IsObject$1(T) ? Object$1(FromProperties$f(K, T.properties), options) :
                                                    IsArray$1(T) ? Array$1(FromSchemaType(K, T.items), options) :
                                                        IsPromise$1(T) ? Promise$1(FromSchemaType(K, T.item), options) :
                                                            T);
}
// prettier-ignore
function MappedFunctionReturnType(K, T) {
    const Acc = {};
    for (const L of K)
        Acc[L] = FromSchemaType(L, T);
    return Acc;
}
/** `[Json]` Creates a Mapped object type */
function Mapped(key, map, options) {
    const K = IsSchema$1(key) ? IndexPropertyKeys(key) : key;
    const RT = map({ [Kind]: 'MappedKey', keys: K });
    const R = MappedFunctionReturnType(K, RT);
    return Object$1(R, options);
}

function RemoveOptional(schema) {
    return CreateType(Discard(schema, [OptionalKind]));
}
function AddOptional(schema) {
    return CreateType({ ...schema, [OptionalKind]: 'Optional' });
}
// prettier-ignore
function OptionalWithFlag(schema, F) {
    return (F === false
        ? RemoveOptional(schema)
        : AddOptional(schema));
}
/** `[Json]` Creates a Optional property */
function Optional(schema, enable) {
    const F = enable ?? true;
    return IsMappedResult$1(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// prettier-ignore
function FromProperties$e(P, F) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
        Acc[K2] = Optional(P[K2], F);
    return Acc;
}
// prettier-ignore
function FromMappedResult$8(R, F) {
    return FromProperties$e(R.properties, F);
}
// prettier-ignore
function OptionalFromMappedResult(R, F) {
    const P = FromMappedResult$8(R, F);
    return MappedResult(P);
}

// ------------------------------------------------------------------
// IntersectCreate
// ------------------------------------------------------------------
// prettier-ignore
function IntersectCreate(T, options = {}) {
    const allObjects = T.every((schema) => IsObject$1(schema));
    const clonedUnevaluatedProperties = IsSchema$1(options.unevaluatedProperties)
        ? { unevaluatedProperties: options.unevaluatedProperties }
        : {};
    return CreateType((options.unevaluatedProperties === false || IsSchema$1(options.unevaluatedProperties) || allObjects
        ? { ...clonedUnevaluatedProperties, [Kind]: 'Intersect', type: 'object', allOf: T }
        : { ...clonedUnevaluatedProperties, [Kind]: 'Intersect', allOf: T }), options);
}

// prettier-ignore
function IsIntersectOptional(types) {
    return types.every(left => IsOptional$1(left));
}
// prettier-ignore
function RemoveOptionalFromType(type) {
    return (Discard(type, [OptionalKind]));
}
// prettier-ignore
function RemoveOptionalFromRest(types) {
    return types.map(left => IsOptional$1(left) ? RemoveOptionalFromType(left) : left);
}
// prettier-ignore
function ResolveIntersect(types, options) {
    return (IsIntersectOptional(types)
        ? Optional(IntersectCreate(RemoveOptionalFromRest(types), options))
        : IntersectCreate(RemoveOptionalFromRest(types), options));
}
/** `[Json]` Creates an evaluated Intersect type */
function IntersectEvaluated(types, options = {}) {
    if (types.length === 1)
        return CreateType(types[0], options);
    if (types.length === 0)
        return Never(options);
    if (types.some((schema) => IsTransform$1(schema)))
        throw new Error('Cannot intersect transform types');
    return ResolveIntersect(types, options);
}

/** `[Json]` Creates an evaluated Intersect type */
function Intersect(types, options) {
    if (types.length === 1)
        return CreateType(types[0], options);
    if (types.length === 0)
        return Never(options);
    if (types.some((schema) => IsTransform$1(schema)))
        throw new Error('Cannot intersect transform types');
    return IntersectCreate(types, options);
}

/** `[Json]` Creates a Ref type. The referenced type must contain a $id */
function Ref(...args) {
    const [$ref, options] = typeof args[0] === 'string' ? [args[0], args[1]] : [args[0].$id, args[1]];
    if (typeof $ref !== 'string')
        throw new TypeBoxError('Ref: $ref must be a string');
    return CreateType({ [Kind]: 'Ref', $ref }, options);
}

// prettier-ignore
function FromComputed$4(target, parameters) {
    return Computed('Awaited', [Computed(target, parameters)]);
}
// prettier-ignore
function FromRef$3($ref) {
    return Computed('Awaited', [Ref($ref)]);
}
// prettier-ignore
function FromIntersect$5(types) {
    return Intersect(FromRest$5(types));
}
// prettier-ignore
function FromUnion$5(types) {
    return Union(FromRest$5(types));
}
// prettier-ignore
function FromPromise$1(type) {
    return Awaited(type);
}
// prettier-ignore
function FromRest$5(types) {
    return types.map(type => Awaited(type));
}
/** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
function Awaited(type, options) {
    return CreateType(IsComputed$1(type) ? FromComputed$4(type.target, type.parameters) : IsIntersect$1(type) ? FromIntersect$5(type.allOf) : IsUnion$1(type) ? FromUnion$5(type.anyOf) : IsPromise$1(type) ? FromPromise$1(type.item) : IsRef$1(type) ? FromRef$3(type.$ref) : type, options);
}

// prettier-ignore
function FromRest$4(types) {
    const result = [];
    for (const L of types)
        result.push(KeyOfPropertyKeys(L));
    return result;
}
// prettier-ignore
function FromIntersect$4(types) {
    const propertyKeysArray = FromRest$4(types);
    const propertyKeys = SetUnionMany(propertyKeysArray);
    return propertyKeys;
}
// prettier-ignore
function FromUnion$4(types) {
    const propertyKeysArray = FromRest$4(types);
    const propertyKeys = SetIntersectMany(propertyKeysArray);
    return propertyKeys;
}
// prettier-ignore
function FromTuple$2(types) {
    return types.map((_, indexer) => indexer.toString());
}
// prettier-ignore
function FromArray$3(_) {
    return (['[number]']);
}
// prettier-ignore
function FromProperties$d(T) {
    return (globalThis.Object.getOwnPropertyNames(T));
}
// ------------------------------------------------------------------
// FromPatternProperties
// ------------------------------------------------------------------
// prettier-ignore
function FromPatternProperties(patternProperties) {
    return [];
}
/** Returns a tuple of PropertyKeys derived from the given TSchema. */
// prettier-ignore
function KeyOfPropertyKeys(type) {
    return (IsIntersect$1(type) ? FromIntersect$4(type.allOf) :
        IsUnion$1(type) ? FromUnion$4(type.anyOf) :
            IsTuple$1(type) ? FromTuple$2(type.items ?? []) :
                IsArray$1(type) ? FromArray$3(type.items) :
                    IsObject$1(type) ? FromProperties$d(type.properties) :
                        IsRecord$1(type) ? FromPatternProperties(type.patternProperties) :
                            []);
}

// prettier-ignore
function FromComputed$3(target, parameters) {
    return Computed('KeyOf', [Computed(target, parameters)]);
}
// prettier-ignore
function FromRef$2($ref) {
    return Computed('KeyOf', [Ref($ref)]);
}
// prettier-ignore
function KeyOfFromType(type, options) {
    const propertyKeys = KeyOfPropertyKeys(type);
    const propertyKeyTypes = KeyOfPropertyKeysToRest(propertyKeys);
    const result = UnionEvaluated(propertyKeyTypes);
    return CreateType(result, options);
}
// prettier-ignore
function KeyOfPropertyKeysToRest(propertyKeys) {
    return propertyKeys.map(L => L === '[number]' ? Number$1() : Literal(L));
}
/** `[Json]` Creates a KeyOf type */
function KeyOf(type, options) {
    return (IsComputed$1(type) ? FromComputed$3(type.target, type.parameters) : IsRef$1(type) ? FromRef$2(type.$ref) : IsMappedResult$1(type) ? KeyOfFromMappedResult(type, options) : KeyOfFromType(type, options));
}

// prettier-ignore
function FromProperties$c(properties, options) {
    const result = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
        result[K2] = KeyOf(properties[K2], Clone(options));
    return result;
}
// prettier-ignore
function FromMappedResult$7(mappedResult, options) {
    return FromProperties$c(mappedResult.properties, options);
}
// prettier-ignore
function KeyOfFromMappedResult(mappedResult, options) {
    const properties = FromMappedResult$7(mappedResult, options);
    return MappedResult(properties);
}

// prettier-ignore
function CompositeKeys(T) {
    const Acc = [];
    for (const L of T)
        Acc.push(...KeyOfPropertyKeys(L));
    return SetDistinct(Acc);
}
// prettier-ignore
function FilterNever(T) {
    return T.filter(L => !IsNever$1(L));
}
// prettier-ignore
function CompositeProperty(T, K) {
    const Acc = [];
    for (const L of T)
        Acc.push(...IndexFromPropertyKeys(L, [K]));
    return FilterNever(Acc);
}
// prettier-ignore
function CompositeProperties(T, K) {
    const Acc = {};
    for (const L of K) {
        Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
    }
    return Acc;
}
// prettier-ignore
function Composite(T, options) {
    const K = CompositeKeys(T);
    const P = CompositeProperties(T, K);
    const R = Object$1(P, options);
    return R;
}

/** `[JavaScript]` Creates a Date type */
function Date$1(options) {
    return CreateType({ [Kind]: 'Date', type: 'Date' }, options);
}

/** `[Json]` Creates a Null type */
function Null(options) {
    return CreateType({ [Kind]: 'Null', type: 'null' }, options);
}

/** `[JavaScript]` Creates a Symbol type */
function Symbol$1(options) {
    return CreateType({ [Kind]: 'Symbol', type: 'symbol' }, options);
}

/** `[JavaScript]` Creates a Undefined type */
function Undefined(options) {
    return CreateType({ [Kind]: 'Undefined', type: 'undefined' }, options);
}

/** `[JavaScript]` Creates a Uint8Array type */
function Uint8Array$1(options) {
    return CreateType({ [Kind]: 'Uint8Array', type: 'Uint8Array' }, options);
}

/** `[Json]` Creates an Unknown type */
function Unknown(options) {
    return CreateType({ [Kind]: 'Unknown' }, options);
}

// prettier-ignore
function FromArray$2(T) {
    return T.map(L => FromValue(L, false));
}
// prettier-ignore
function FromProperties$b(value) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(value))
        Acc[K] = Readonly(FromValue(value[K], false));
    return Acc;
}
function ConditionalReadonly(T, root) {
    return (root === true ? T : Readonly(T));
}
// prettier-ignore
function FromValue(value, root) {
    return (IsAsyncIterator$2(value) ? ConditionalReadonly(Any(), root) :
        IsIterator$2(value) ? ConditionalReadonly(Any(), root) :
            IsArray$3(value) ? Readonly(Tuple(FromArray$2(value))) :
                IsUint8Array$2(value) ? Uint8Array$1() :
                    IsDate$2(value) ? Date$1() :
                        IsObject$3(value) ? ConditionalReadonly(Object$1(FromProperties$b(value)), root) :
                            IsFunction$2(value) ? ConditionalReadonly(Function$1([], Unknown()), root) :
                                IsUndefined$3(value) ? Undefined() :
                                    IsNull$2(value) ? Null() :
                                        IsSymbol$2(value) ? Symbol$1() :
                                            IsBigInt$2(value) ? BigInt$1() :
                                                IsNumber$3(value) ? Literal(value) :
                                                    IsBoolean$2(value) ? Literal(value) :
                                                        IsString$2(value) ? Literal(value) :
                                                            Object$1({}));
}
/** `[JavaScript]` Creates a readonly const type from the given value. */
function Const(T, options) {
    return CreateType(FromValue(T, true), options);
}

/** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
function ConstructorParameters(schema, options) {
    return Tuple(schema.parameters, options);
}

/** `[Json]` Creates a Enum type */
function Enum(item, options) {
    if (IsUndefined$3(item))
        throw new Error('Enum undefined or empty');
    const values1 = globalThis.Object.getOwnPropertyNames(item)
        .filter((key) => isNaN(key))
        .map((key) => item[key]);
    const values2 = [...new Set(values1)];
    const anyOf = values2.map((value) => Literal(value));
    return Union(anyOf, { ...options, [Hint]: 'Enum' });
}

class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function (ExtendsResult) {
    ExtendsResult[ExtendsResult["Union"] = 0] = "Union";
    ExtendsResult[ExtendsResult["True"] = 1] = "True";
    ExtendsResult[ExtendsResult["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
// ------------------------------------------------------------------
// IntoBooleanResult
// ------------------------------------------------------------------
// prettier-ignore
function IntoBooleanResult(result) {
    return result === ExtendsResult.False ? result : ExtendsResult.True;
}
// ------------------------------------------------------------------
// Throw
// ------------------------------------------------------------------
// prettier-ignore
function Throw(message) {
    throw new ExtendsResolverError(message);
}
// ------------------------------------------------------------------
// StructuralRight
// ------------------------------------------------------------------
// prettier-ignore
function IsStructuralRight(right) {
    return (IsNever(right) ||
        IsIntersect(right) ||
        IsUnion(right) ||
        IsUnknown(right) ||
        IsAny(right));
}
// prettier-ignore
function StructuralRight(left, right) {
    return (IsNever(right) ? FromNeverRight() :
        IsIntersect(right) ? FromIntersectRight(left, right) :
            IsUnion(right) ? FromUnionRight(left, right) :
                IsUnknown(right) ? FromUnknownRight() :
                    IsAny(right) ? FromAnyRight() :
                        Throw('StructuralRight'));
}
// ------------------------------------------------------------------
// Any
// ------------------------------------------------------------------
// prettier-ignore
function FromAnyRight(left, right) {
    return ExtendsResult.True;
}
// prettier-ignore
function FromAny(left, right) {
    return (IsIntersect(right) ? FromIntersectRight(left, right) :
        (IsUnion(right) && right.anyOf.some((schema) => IsAny(schema) || IsUnknown(schema))) ? ExtendsResult.True :
            IsUnion(right) ? ExtendsResult.Union :
                IsUnknown(right) ? ExtendsResult.True :
                    IsAny(right) ? ExtendsResult.True :
                        ExtendsResult.Union);
}
// ------------------------------------------------------------------
// Array
// ------------------------------------------------------------------
// prettier-ignore
function FromArrayRight(left, right) {
    return (IsUnknown(left) ? ExtendsResult.False :
        IsAny(left) ? ExtendsResult.Union :
            IsNever(left) ? ExtendsResult.True :
                ExtendsResult.False);
}
// prettier-ignore
function FromArray$1(left, right) {
    return (IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True :
        IsStructuralRight(right) ? StructuralRight(left, right) :
            !IsArray(right) ? ExtendsResult.False :
                IntoBooleanResult(Visit(left.items, right.items)));
}
// ------------------------------------------------------------------
// AsyncIterator
// ------------------------------------------------------------------
// prettier-ignore
function FromAsyncIterator$1(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        !IsAsyncIterator(right) ? ExtendsResult.False :
            IntoBooleanResult(Visit(left.items, right.items)));
}
// ------------------------------------------------------------------
// BigInt
// ------------------------------------------------------------------
// prettier-ignore
function FromBigInt(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        IsObject(right) ? FromObjectRight(left, right) :
            IsRecord(right) ? FromRecordRight(left, right) :
                IsBigInt(right) ? ExtendsResult.True :
                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Boolean
// ------------------------------------------------------------------
// prettier-ignore
function FromBooleanRight(left, right) {
    return (IsLiteralBoolean(left) ? ExtendsResult.True :
        IsBoolean(left) ? ExtendsResult.True :
            ExtendsResult.False);
}
// prettier-ignore
function FromBoolean(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        IsObject(right) ? FromObjectRight(left, right) :
            IsRecord(right) ? FromRecordRight(left, right) :
                IsBoolean(right) ? ExtendsResult.True :
                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Constructor
// ------------------------------------------------------------------
// prettier-ignore
function FromConstructor$1(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        IsObject(right) ? FromObjectRight(left, right) :
            !IsConstructor(right) ? ExtendsResult.False :
                left.parameters.length > right.parameters.length ? ExtendsResult.False :
                    (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True)) ? ExtendsResult.False :
                        IntoBooleanResult(Visit(left.returns, right.returns)));
}
// ------------------------------------------------------------------
// Date
// ------------------------------------------------------------------
// prettier-ignore
function FromDate(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        IsObject(right) ? FromObjectRight(left, right) :
            IsRecord(right) ? FromRecordRight(left, right) :
                IsDate(right) ? ExtendsResult.True :
                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Function
// ------------------------------------------------------------------
// prettier-ignore
function FromFunction$1(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        IsObject(right) ? FromObjectRight(left, right) :
            !IsFunction(right) ? ExtendsResult.False :
                left.parameters.length > right.parameters.length ? ExtendsResult.False :
                    (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True)) ? ExtendsResult.False :
                        IntoBooleanResult(Visit(left.returns, right.returns)));
}
// ------------------------------------------------------------------
// Integer
// ------------------------------------------------------------------
// prettier-ignore
function FromIntegerRight(left, right) {
    return (IsLiteral(left) && IsNumber$3(left.const) ? ExtendsResult.True :
        IsNumber(left) || IsInteger(left) ? ExtendsResult.True :
            ExtendsResult.False);
}
// prettier-ignore
function FromInteger(left, right) {
    return (IsInteger(right) || IsNumber(right) ? ExtendsResult.True :
        IsStructuralRight(right) ? StructuralRight(left, right) :
            IsObject(right) ? FromObjectRight(left, right) :
                IsRecord(right) ? FromRecordRight(left, right) :
                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Intersect
// ------------------------------------------------------------------
// prettier-ignore
function FromIntersectRight(left, right) {
    return right.allOf.every((schema) => Visit(left, schema) === ExtendsResult.True)
        ? ExtendsResult.True
        : ExtendsResult.False;
}
// prettier-ignore
function FromIntersect$3(left, right) {
    return left.allOf.some((schema) => Visit(schema, right) === ExtendsResult.True)
        ? ExtendsResult.True
        : ExtendsResult.False;
}
// ------------------------------------------------------------------
// Iterator
// ------------------------------------------------------------------
// prettier-ignore
function FromIterator$1(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        !IsIterator(right) ? ExtendsResult.False :
            IntoBooleanResult(Visit(left.items, right.items)));
}
// ------------------------------------------------------------------
// Literal
// ------------------------------------------------------------------
// prettier-ignore
function FromLiteral(left, right) {
    return (IsLiteral(right) && right.const === left.const ? ExtendsResult.True :
        IsStructuralRight(right) ? StructuralRight(left, right) :
            IsObject(right) ? FromObjectRight(left, right) :
                IsRecord(right) ? FromRecordRight(left, right) :
                    IsString(right) ? FromStringRight(left) :
                        IsNumber(right) ? FromNumberRight(left) :
                            IsInteger(right) ? FromIntegerRight(left) :
                                IsBoolean(right) ? FromBooleanRight(left) :
                                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Never
// ------------------------------------------------------------------
// prettier-ignore
function FromNeverRight(left, right) {
    return ExtendsResult.False;
}
// prettier-ignore
function FromNever(left, right) {
    return ExtendsResult.True;
}
// ------------------------------------------------------------------
// Not
// ------------------------------------------------------------------
// prettier-ignore
function UnwrapTNot(schema) {
    let [current, depth] = [schema, 0];
    while (true) {
        if (!IsNot(current))
            break;
        current = current.not;
        depth += 1;
    }
    return depth % 2 === 0 ? current : Unknown();
}
// prettier-ignore
function FromNot(left, right) {
    // TypeScript has no concept of negated types, and attempts to correctly check the negated
    // type at runtime would put TypeBox at odds with TypeScripts ability to statically infer
    // the type. Instead we unwrap to either unknown or T and continue evaluating.
    // prettier-ignore
    return (IsNot(left) ? Visit(UnwrapTNot(left), right) :
        IsNot(right) ? Visit(left, UnwrapTNot(right)) :
            Throw('Invalid fallthrough for Not'));
}
// ------------------------------------------------------------------
// Null
// ------------------------------------------------------------------
// prettier-ignore
function FromNull(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        IsObject(right) ? FromObjectRight(left, right) :
            IsRecord(right) ? FromRecordRight(left, right) :
                IsNull(right) ? ExtendsResult.True :
                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Number
// ------------------------------------------------------------------
// prettier-ignore
function FromNumberRight(left, right) {
    return (IsLiteralNumber(left) ? ExtendsResult.True :
        IsNumber(left) || IsInteger(left) ? ExtendsResult.True :
            ExtendsResult.False);
}
// prettier-ignore
function FromNumber(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        IsObject(right) ? FromObjectRight(left, right) :
            IsRecord(right) ? FromRecordRight(left, right) :
                IsInteger(right) || IsNumber(right) ? ExtendsResult.True :
                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Object
// ------------------------------------------------------------------
// prettier-ignore
function IsObjectPropertyCount(schema, count) {
    return Object.getOwnPropertyNames(schema.properties).length === count;
}
// prettier-ignore
function IsObjectStringLike(schema) {
    return IsObjectArrayLike(schema);
}
// prettier-ignore
function IsObjectSymbolLike(schema) {
    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'description' in schema.properties && IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && ((IsString(schema.properties.description.anyOf[0]) &&
        IsUndefined(schema.properties.description.anyOf[1])) || (IsString(schema.properties.description.anyOf[1]) &&
        IsUndefined(schema.properties.description.anyOf[0]))));
}
// prettier-ignore
function IsObjectNumberLike(schema) {
    return IsObjectPropertyCount(schema, 0);
}
// prettier-ignore
function IsObjectBooleanLike(schema) {
    return IsObjectPropertyCount(schema, 0);
}
// prettier-ignore
function IsObjectBigIntLike(schema) {
    return IsObjectPropertyCount(schema, 0);
}
// prettier-ignore
function IsObjectDateLike(schema) {
    return IsObjectPropertyCount(schema, 0);
}
// prettier-ignore
function IsObjectUint8ArrayLike(schema) {
    return IsObjectArrayLike(schema);
}
// prettier-ignore
function IsObjectFunctionLike(schema) {
    const length = Number$1();
    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === ExtendsResult.True);
}
// prettier-ignore
function IsObjectConstructorLike(schema) {
    return IsObjectPropertyCount(schema, 0);
}
// prettier-ignore
function IsObjectArrayLike(schema) {
    const length = Number$1();
    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === ExtendsResult.True);
}
// prettier-ignore
function IsObjectPromiseLike(schema) {
    const then = Function$1([Any()], Any());
    return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'then' in schema.properties && IntoBooleanResult(Visit(schema.properties['then'], then)) === ExtendsResult.True);
}
// ------------------------------------------------------------------
// Property
// ------------------------------------------------------------------
// prettier-ignore
function Property(left, right) {
    return (Visit(left, right) === ExtendsResult.False ? ExtendsResult.False :
        IsOptional(left) && !IsOptional(right) ? ExtendsResult.False :
            ExtendsResult.True);
}
// prettier-ignore
function FromObjectRight(left, right) {
    return (IsUnknown(left) ? ExtendsResult.False :
        IsAny(left) ? ExtendsResult.Union : (IsNever(left) ||
            (IsLiteralString(left) && IsObjectStringLike(right)) ||
            (IsLiteralNumber(left) && IsObjectNumberLike(right)) ||
            (IsLiteralBoolean(left) && IsObjectBooleanLike(right)) ||
            (IsSymbol(left) && IsObjectSymbolLike(right)) ||
            (IsBigInt(left) && IsObjectBigIntLike(right)) ||
            (IsString(left) && IsObjectStringLike(right)) ||
            (IsSymbol(left) && IsObjectSymbolLike(right)) ||
            (IsNumber(left) && IsObjectNumberLike(right)) ||
            (IsInteger(left) && IsObjectNumberLike(right)) ||
            (IsBoolean(left) && IsObjectBooleanLike(right)) ||
            (IsUint8Array(left) && IsObjectUint8ArrayLike(right)) ||
            (IsDate(left) && IsObjectDateLike(right)) ||
            (IsConstructor(left) && IsObjectConstructorLike(right)) ||
            (IsFunction(left) && IsObjectFunctionLike(right))) ? ExtendsResult.True :
            (IsRecord(left) && IsString(RecordKey(left))) ? (() => {
                // When expressing a Record with literal key values, the Record is converted into a Object with
                // the Hint assigned as `Record`. This is used to invert the extends logic.
                return right[Hint] === 'Record' ? ExtendsResult.True : ExtendsResult.False;
            })() :
                (IsRecord(left) && IsNumber(RecordKey(left))) ? (() => {
                    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
                })() :
                    ExtendsResult.False);
}
// prettier-ignore
function FromObject$5(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        IsRecord(right) ? FromRecordRight(left, right) :
            !IsObject(right) ? ExtendsResult.False :
                (() => {
                    for (const key of Object.getOwnPropertyNames(right.properties)) {
                        if (!(key in left.properties) && !IsOptional(right.properties[key])) {
                            return ExtendsResult.False;
                        }
                        if (IsOptional(right.properties[key])) {
                            return ExtendsResult.True;
                        }
                        if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
                            return ExtendsResult.False;
                        }
                    }
                    return ExtendsResult.True;
                })());
}
// ------------------------------------------------------------------
// Promise
// ------------------------------------------------------------------
// prettier-ignore
function FromPromise(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True :
            !IsPromise(right) ? ExtendsResult.False :
                IntoBooleanResult(Visit(left.item, right.item)));
}
// ------------------------------------------------------------------
// Record
// ------------------------------------------------------------------
// prettier-ignore
function RecordKey(schema) {
    return (PatternNumberExact in schema.patternProperties ? Number$1() :
        PatternStringExact in schema.patternProperties ? String$1() :
            Throw('Unknown record key pattern'));
}
// prettier-ignore
function RecordValue(schema) {
    return (PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] :
        PatternStringExact in schema.patternProperties ? schema.patternProperties[PatternStringExact] :
            Throw('Unable to get record value schema'));
}
// prettier-ignore
function FromRecordRight(left, right) {
    const [Key, Value] = [RecordKey(right), RecordValue(right)];
    return ((IsLiteralString(left) && IsNumber(Key) && IntoBooleanResult(Visit(left, Value)) === ExtendsResult.True) ? ExtendsResult.True :
        IsUint8Array(left) && IsNumber(Key) ? Visit(left, Value) :
            IsString(left) && IsNumber(Key) ? Visit(left, Value) :
                IsArray(left) && IsNumber(Key) ? Visit(left, Value) :
                    IsObject(left) ? (() => {
                        for (const key of Object.getOwnPropertyNames(left.properties)) {
                            if (Property(Value, left.properties[key]) === ExtendsResult.False) {
                                return ExtendsResult.False;
                            }
                        }
                        return ExtendsResult.True;
                    })() :
                        ExtendsResult.False);
}
// prettier-ignore
function FromRecord$1(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        IsObject(right) ? FromObjectRight(left, right) :
            !IsRecord(right) ? ExtendsResult.False :
                Visit(RecordValue(left), RecordValue(right)));
}
// ------------------------------------------------------------------
// RegExp
// ------------------------------------------------------------------
// prettier-ignore
function FromRegExp(left, right) {
    // Note: RegExp types evaluate as strings, not RegExp objects.
    // Here we remap either into string and continue evaluating.
    const L = IsRegExp(left) ? String$1() : left;
    const R = IsRegExp(right) ? String$1() : right;
    return Visit(L, R);
}
// ------------------------------------------------------------------
// String
// ------------------------------------------------------------------
// prettier-ignore
function FromStringRight(left, right) {
    return (IsLiteral(left) && IsString$2(left.const) ? ExtendsResult.True :
        IsString(left) ? ExtendsResult.True :
            ExtendsResult.False);
}
// prettier-ignore
function FromString(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        IsObject(right) ? FromObjectRight(left, right) :
            IsRecord(right) ? FromRecordRight(left, right) :
                IsString(right) ? ExtendsResult.True :
                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Symbol
// ------------------------------------------------------------------
// prettier-ignore
function FromSymbol(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        IsObject(right) ? FromObjectRight(left, right) :
            IsRecord(right) ? FromRecordRight(left, right) :
                IsSymbol(right) ? ExtendsResult.True :
                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// TemplateLiteral
// ------------------------------------------------------------------
// prettier-ignore
function FromTemplateLiteral$1(left, right) {
    // TemplateLiteral types are resolved to either unions for finite expressions or string
    // for infinite expressions. Here we call to TemplateLiteralResolver to resolve for
    // either type and continue evaluating.
    return (IsTemplateLiteral(left) ? Visit(TemplateLiteralToUnion(left), right) :
        IsTemplateLiteral(right) ? Visit(left, TemplateLiteralToUnion(right)) :
            Throw('Invalid fallthrough for TemplateLiteral'));
}
// ------------------------------------------------------------------
// Tuple
// ------------------------------------------------------------------
// prettier-ignore
function IsArrayOfTuple(left, right) {
    return (IsArray(right) &&
        left.items !== undefined &&
        left.items.every((schema) => Visit(schema, right.items) === ExtendsResult.True));
}
// prettier-ignore
function FromTupleRight(left, right) {
    return (IsNever(left) ? ExtendsResult.True :
        IsUnknown(left) ? ExtendsResult.False :
            IsAny(left) ? ExtendsResult.Union :
                ExtendsResult.False);
}
// prettier-ignore
function FromTuple$1(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True :
            IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True :
                !IsTuple(right) ? ExtendsResult.False :
                    (IsUndefined$3(left.items) && !IsUndefined$3(right.items)) || (!IsUndefined$3(left.items) && IsUndefined$3(right.items)) ? ExtendsResult.False :
                        (IsUndefined$3(left.items) && !IsUndefined$3(right.items)) ? ExtendsResult.True :
                            left.items.every((schema, index) => Visit(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True :
                                ExtendsResult.False);
}
// ------------------------------------------------------------------
// Uint8Array
// ------------------------------------------------------------------
// prettier-ignore
function FromUint8Array(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        IsObject(right) ? FromObjectRight(left, right) :
            IsRecord(right) ? FromRecordRight(left, right) :
                IsUint8Array(right) ? ExtendsResult.True :
                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Undefined
// ------------------------------------------------------------------
// prettier-ignore
function FromUndefined(left, right) {
    return (IsStructuralRight(right) ? StructuralRight(left, right) :
        IsObject(right) ? FromObjectRight(left, right) :
            IsRecord(right) ? FromRecordRight(left, right) :
                IsVoid(right) ? FromVoidRight(left) :
                    IsUndefined(right) ? ExtendsResult.True :
                        ExtendsResult.False);
}
// ------------------------------------------------------------------
// Union
// ------------------------------------------------------------------
// prettier-ignore
function FromUnionRight(left, right) {
    return right.anyOf.some((schema) => Visit(left, schema) === ExtendsResult.True)
        ? ExtendsResult.True
        : ExtendsResult.False;
}
// prettier-ignore
function FromUnion$3(left, right) {
    return left.anyOf.every((schema) => Visit(schema, right) === ExtendsResult.True)
        ? ExtendsResult.True
        : ExtendsResult.False;
}
// ------------------------------------------------------------------
// Unknown
// ------------------------------------------------------------------
// prettier-ignore
function FromUnknownRight(left, right) {
    return ExtendsResult.True;
}
// prettier-ignore
function FromUnknown(left, right) {
    return (IsNever(right) ? FromNeverRight() :
        IsIntersect(right) ? FromIntersectRight(left, right) :
            IsUnion(right) ? FromUnionRight(left, right) :
                IsAny(right) ? FromAnyRight() :
                    IsString(right) ? FromStringRight(left) :
                        IsNumber(right) ? FromNumberRight(left) :
                            IsInteger(right) ? FromIntegerRight(left) :
                                IsBoolean(right) ? FromBooleanRight(left) :
                                    IsArray(right) ? FromArrayRight(left) :
                                        IsTuple(right) ? FromTupleRight(left) :
                                            IsObject(right) ? FromObjectRight(left, right) :
                                                IsUnknown(right) ? ExtendsResult.True :
                                                    ExtendsResult.False);
}
// ------------------------------------------------------------------
// Void
// ------------------------------------------------------------------
// prettier-ignore
function FromVoidRight(left, right) {
    return (IsUndefined(left) ? ExtendsResult.True :
        IsUndefined(left) ? ExtendsResult.True :
            ExtendsResult.False);
}
// prettier-ignore
function FromVoid(left, right) {
    return (IsIntersect(right) ? FromIntersectRight(left, right) :
        IsUnion(right) ? FromUnionRight(left, right) :
            IsUnknown(right) ? FromUnknownRight() :
                IsAny(right) ? FromAnyRight() :
                    IsObject(right) ? FromObjectRight(left, right) :
                        IsVoid(right) ? ExtendsResult.True :
                            ExtendsResult.False);
}
// prettier-ignore
function Visit(left, right) {
    return (
    // resolvable
    (IsTemplateLiteral(left) || IsTemplateLiteral(right)) ? FromTemplateLiteral$1(left, right) :
        (IsRegExp(left) || IsRegExp(right)) ? FromRegExp(left, right) :
            (IsNot(left) || IsNot(right)) ? FromNot(left, right) :
                // standard
                IsAny(left) ? FromAny(left, right) :
                    IsArray(left) ? FromArray$1(left, right) :
                        IsBigInt(left) ? FromBigInt(left, right) :
                            IsBoolean(left) ? FromBoolean(left, right) :
                                IsAsyncIterator(left) ? FromAsyncIterator$1(left, right) :
                                    IsConstructor(left) ? FromConstructor$1(left, right) :
                                        IsDate(left) ? FromDate(left, right) :
                                            IsFunction(left) ? FromFunction$1(left, right) :
                                                IsInteger(left) ? FromInteger(left, right) :
                                                    IsIntersect(left) ? FromIntersect$3(left, right) :
                                                        IsIterator(left) ? FromIterator$1(left, right) :
                                                            IsLiteral(left) ? FromLiteral(left, right) :
                                                                IsNever(left) ? FromNever() :
                                                                    IsNull(left) ? FromNull(left, right) :
                                                                        IsNumber(left) ? FromNumber(left, right) :
                                                                            IsObject(left) ? FromObject$5(left, right) :
                                                                                IsRecord(left) ? FromRecord$1(left, right) :
                                                                                    IsString(left) ? FromString(left, right) :
                                                                                        IsSymbol(left) ? FromSymbol(left, right) :
                                                                                            IsTuple(left) ? FromTuple$1(left, right) :
                                                                                                IsPromise(left) ? FromPromise(left, right) :
                                                                                                    IsUint8Array(left) ? FromUint8Array(left, right) :
                                                                                                        IsUndefined(left) ? FromUndefined(left, right) :
                                                                                                            IsUnion(left) ? FromUnion$3(left, right) :
                                                                                                                IsUnknown(left) ? FromUnknown(left, right) :
                                                                                                                    IsVoid(left) ? FromVoid(left, right) :
                                                                                                                        Throw(`Unknown left type operand '${left[Kind]}'`));
}
function ExtendsCheck(left, right) {
    return Visit(left, right);
}

// prettier-ignore
function FromProperties$a(P, Right, True, False, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
        Acc[K2] = Extends(P[K2], Right, True, False, Clone(options));
    return Acc;
}
// prettier-ignore
function FromMappedResult$6(Left, Right, True, False, options) {
    return FromProperties$a(Left.properties, Right, True, False, options);
}
// prettier-ignore
function ExtendsFromMappedResult(Left, Right, True, False, options) {
    const P = FromMappedResult$6(Left, Right, True, False, options);
    return MappedResult(P);
}

// prettier-ignore
function ExtendsResolve(left, right, trueType, falseType) {
    const R = ExtendsCheck(left, right);
    return (R === ExtendsResult.Union ? Union([trueType, falseType]) :
        R === ExtendsResult.True ? trueType :
            falseType);
}
/** `[Json]` Creates a Conditional type */
function Extends(L, R, T, F, options) {
    // prettier-ignore
    return (IsMappedResult$1(L) ? ExtendsFromMappedResult(L, R, T, F, options) :
        IsMappedKey$1(L) ? CreateType(ExtendsFromMappedKey(L, R, T, F, options)) :
            CreateType(ExtendsResolve(L, R, T, F), options));
}

// prettier-ignore
function FromPropertyKey$2(K, U, L, R, options) {
    return {
        [K]: Extends(Literal(K), U, L, R, Clone(options))
    };
}
// prettier-ignore
function FromPropertyKeys$2(K, U, L, R, options) {
    return K.reduce((Acc, LK) => {
        return { ...Acc, ...FromPropertyKey$2(LK, U, L, R, options) };
    }, {});
}
// prettier-ignore
function FromMappedKey$2(K, U, L, R, options) {
    return FromPropertyKeys$2(K.keys, U, L, R, options);
}
// prettier-ignore
function ExtendsFromMappedKey(T, U, L, R, options) {
    const P = FromMappedKey$2(T, U, L, R, options);
    return MappedResult(P);
}

function ExcludeFromTemplateLiteral(L, R) {
    return Exclude(TemplateLiteralToUnion(L), R);
}

function ExcludeRest(L, R) {
    const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
    return excluded.length === 1 ? excluded[0] : Union(excluded);
}
/** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
function Exclude(L, R, options = {}) {
    // overloads
    if (IsTemplateLiteral$1(L))
        return CreateType(ExcludeFromTemplateLiteral(L, R), options);
    if (IsMappedResult$1(L))
        return CreateType(ExcludeFromMappedResult(L, R), options);
    // prettier-ignore
    return CreateType(IsUnion$1(L) ? ExcludeRest(L.anyOf, R) :
        ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// prettier-ignore
function FromProperties$9(P, U) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
        Acc[K2] = Exclude(P[K2], U);
    return Acc;
}
// prettier-ignore
function FromMappedResult$5(R, T) {
    return FromProperties$9(R.properties, T);
}
// prettier-ignore
function ExcludeFromMappedResult(R, T) {
    const P = FromMappedResult$5(R, T);
    return MappedResult(P);
}

function ExtractFromTemplateLiteral(L, R) {
    return Extract(TemplateLiteralToUnion(L), R);
}

function ExtractRest(L, R) {
    const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
    return extracted.length === 1 ? extracted[0] : Union(extracted);
}
/** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
function Extract(L, R, options) {
    // overloads
    if (IsTemplateLiteral$1(L))
        return CreateType(ExtractFromTemplateLiteral(L, R), options);
    if (IsMappedResult$1(L))
        return CreateType(ExtractFromMappedResult(L, R), options);
    // prettier-ignore
    return CreateType(IsUnion$1(L) ? ExtractRest(L.anyOf, R) :
        ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// prettier-ignore
function FromProperties$8(P, T) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
        Acc[K2] = Extract(P[K2], T);
    return Acc;
}
// prettier-ignore
function FromMappedResult$4(R, T) {
    return FromProperties$8(R.properties, T);
}
// prettier-ignore
function ExtractFromMappedResult(R, T) {
    const P = FromMappedResult$4(R, T);
    return MappedResult(P);
}

/** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
function InstanceType(schema, options) {
    return CreateType(schema.returns, options);
}

/** `[Json]` Creates an Integer type */
function Integer(options) {
    return CreateType({ [Kind]: 'Integer', type: 'integer' }, options);
}

// prettier-ignore
function MappedIntrinsicPropertyKey(K, M, options) {
    return {
        [K]: Intrinsic(Literal(K), M, Clone(options))
    };
}
// prettier-ignore
function MappedIntrinsicPropertyKeys(K, M, options) {
    const result = K.reduce((Acc, L) => {
        return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
    }, {});
    return result;
}
// prettier-ignore
function MappedIntrinsicProperties(T, M, options) {
    return MappedIntrinsicPropertyKeys(T['keys'], M, options);
}
// prettier-ignore
function IntrinsicFromMappedKey(T, M, options) {
    const P = MappedIntrinsicProperties(T, M, options);
    return MappedResult(P);
}

// ------------------------------------------------------------------
// Apply
// ------------------------------------------------------------------
function ApplyUncapitalize(value) {
    const [first, rest] = [value.slice(0, 1), value.slice(1)];
    return [first.toLowerCase(), rest].join('');
}
function ApplyCapitalize(value) {
    const [first, rest] = [value.slice(0, 1), value.slice(1)];
    return [first.toUpperCase(), rest].join('');
}
function ApplyUppercase(value) {
    return value.toUpperCase();
}
function ApplyLowercase(value) {
    return value.toLowerCase();
}
function FromTemplateLiteral(schema, mode, options) {
    // note: template literals require special runtime handling as they are encoded in string patterns.
    // This diverges from the mapped type which would otherwise map on the template literal kind.
    const expression = TemplateLiteralParseExact(schema.pattern);
    const finite = IsTemplateLiteralExpressionFinite(expression);
    if (!finite)
        return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
    const strings = [...TemplateLiteralExpressionGenerate(expression)];
    const literals = strings.map((value) => Literal(value));
    const mapped = FromRest$3(literals, mode);
    const union = Union(mapped);
    return TemplateLiteral([union], options);
}
// prettier-ignore
function FromLiteralValue(value, mode) {
    return (typeof value === 'string' ? (mode === 'Uncapitalize' ? ApplyUncapitalize(value) :
        mode === 'Capitalize' ? ApplyCapitalize(value) :
            mode === 'Uppercase' ? ApplyUppercase(value) :
                mode === 'Lowercase' ? ApplyLowercase(value) :
                    value) : value.toString());
}
// prettier-ignore
function FromRest$3(T, M) {
    return T.map(L => Intrinsic(L, M));
}
/** Applies an intrinsic string manipulation to the given type. */
function Intrinsic(schema, mode, options = {}) {
    // prettier-ignore
    return (
    // Intrinsic-Mapped-Inference
    IsMappedKey$1(schema) ? IntrinsicFromMappedKey(schema, mode, options) :
        // Standard-Inference
        IsTemplateLiteral$1(schema) ? FromTemplateLiteral(schema, mode, options) :
            IsUnion$1(schema) ? Union(FromRest$3(schema.anyOf, mode), options) :
                IsLiteral$1(schema) ? Literal(FromLiteralValue(schema.const, mode), options) :
                    // Default Type
                    CreateType(schema, options));
}

/** `[Json]` Intrinsic function to Capitalize LiteralString types */
function Capitalize(T, options = {}) {
    return Intrinsic(T, 'Capitalize', options);
}

/** `[Json]` Intrinsic function to Lowercase LiteralString types */
function Lowercase(T, options = {}) {
    return Intrinsic(T, 'Lowercase', options);
}

/** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
function Uncapitalize(T, options = {}) {
    return Intrinsic(T, 'Uncapitalize', options);
}

/** `[Json]` Intrinsic function to Uppercase LiteralString types */
function Uppercase(T, options = {}) {
    return Intrinsic(T, 'Uppercase', options);
}

// prettier-ignore
function FromProperties$7(properties, propertyKeys, options) {
    const result = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
        result[K2] = Omit(properties[K2], propertyKeys, Clone(options));
    return result;
}
// prettier-ignore
function FromMappedResult$3(mappedResult, propertyKeys, options) {
    return FromProperties$7(mappedResult.properties, propertyKeys, options);
}
// prettier-ignore
function OmitFromMappedResult(mappedResult, propertyKeys, options) {
    const properties = FromMappedResult$3(mappedResult, propertyKeys, options);
    return MappedResult(properties);
}

// prettier-ignore
function FromIntersect$2(types, propertyKeys) {
    return types.map((type) => OmitResolve(type, propertyKeys));
}
// prettier-ignore
function FromUnion$2(types, propertyKeys) {
    return types.map((type) => OmitResolve(type, propertyKeys));
}
// ------------------------------------------------------------------
// FromProperty
// ------------------------------------------------------------------
// prettier-ignore
function FromProperty(properties, key) {
    const { [key]: _, ...R } = properties;
    return R;
}
// prettier-ignore
function FromProperties$6(properties, propertyKeys) {
    return propertyKeys.reduce((T, K2) => FromProperty(T, K2), properties);
}
// prettier-ignore
function FromObject$4(properties, propertyKeys) {
    const options = Discard(properties, [TransformKind, '$id', 'required', 'properties']);
    const omittedProperties = FromProperties$6(properties['properties'], propertyKeys);
    return Object$1(omittedProperties, options);
}
// prettier-ignore
function UnionFromPropertyKeys$1(propertyKeys) {
    const result = propertyKeys.reduce((result, key) => IsLiteralValue$1(key) ? [...result, Literal(key)] : result, []);
    return Union(result);
}
// prettier-ignore
function OmitResolve(properties, propertyKeys) {
    return (IsIntersect$1(properties) ? Intersect(FromIntersect$2(properties.allOf, propertyKeys)) :
        IsUnion$1(properties) ? Union(FromUnion$2(properties.anyOf, propertyKeys)) :
            IsObject$1(properties) ? FromObject$4(properties, propertyKeys) :
                Object$1({}));
}
/** `[Json]` Constructs a type whose keys are picked from the given type */
// prettier-ignore
function Omit(type, key, options) {
    const typeKey = IsArray$3(key) ? UnionFromPropertyKeys$1(key) : key;
    const propertyKeys = IsSchema$1(key) ? IndexPropertyKeys(key) : key;
    const isTypeRef = IsRef$1(type);
    const isKeyRef = IsRef$1(key);
    return (IsMappedResult$1(type) ? OmitFromMappedResult(type, propertyKeys, options) :
        IsMappedKey$1(key) ? OmitFromMappedKey(type, key, options) :
            (isTypeRef && isKeyRef) ? Computed('Omit', [type, typeKey], options) :
                (!isTypeRef && isKeyRef) ? Computed('Omit', [type, typeKey], options) :
                    (isTypeRef && !isKeyRef) ? Computed('Omit', [type, typeKey], options) :
                        CreateType({ ...OmitResolve(type, propertyKeys), ...options }));
}

// prettier-ignore
function FromPropertyKey$1(type, key, options) {
    return { [key]: Omit(type, [key], Clone(options)) };
}
// prettier-ignore
function FromPropertyKeys$1(type, propertyKeys, options) {
    return propertyKeys.reduce((Acc, LK) => {
        return { ...Acc, ...FromPropertyKey$1(type, LK, options) };
    }, {});
}
// prettier-ignore
function FromMappedKey$1(type, mappedKey, options) {
    return FromPropertyKeys$1(type, mappedKey.keys, options);
}
// prettier-ignore
function OmitFromMappedKey(type, mappedKey, options) {
    const properties = FromMappedKey$1(type, mappedKey, options);
    return MappedResult(properties);
}

// prettier-ignore
function FromProperties$5(properties, propertyKeys, options) {
    const result = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
        result[K2] = Pick(properties[K2], propertyKeys, Clone(options));
    return result;
}
// prettier-ignore
function FromMappedResult$2(mappedResult, propertyKeys, options) {
    return FromProperties$5(mappedResult.properties, propertyKeys, options);
}
// prettier-ignore
function PickFromMappedResult(mappedResult, propertyKeys, options) {
    const properties = FromMappedResult$2(mappedResult, propertyKeys, options);
    return MappedResult(properties);
}

function FromIntersect$1(types, propertyKeys) {
    return types.map((type) => PickResolve(type, propertyKeys));
}
// prettier-ignore
function FromUnion$1(types, propertyKeys) {
    return types.map((type) => PickResolve(type, propertyKeys));
}
// prettier-ignore
function FromProperties$4(properties, propertyKeys) {
    const result = {};
    for (const K2 of propertyKeys)
        if (K2 in properties)
            result[K2] = properties[K2];
    return result;
}
// prettier-ignore
function FromObject$3(T, K) {
    const options = Discard(T, [TransformKind, '$id', 'required', 'properties']);
    const properties = FromProperties$4(T['properties'], K);
    return Object$1(properties, options);
}
// prettier-ignore
function UnionFromPropertyKeys(propertyKeys) {
    const result = propertyKeys.reduce((result, key) => IsLiteralValue$1(key) ? [...result, Literal(key)] : result, []);
    return Union(result);
}
// prettier-ignore
function PickResolve(properties, propertyKeys) {
    return (IsIntersect$1(properties) ? Intersect(FromIntersect$1(properties.allOf, propertyKeys)) :
        IsUnion$1(properties) ? Union(FromUnion$1(properties.anyOf, propertyKeys)) :
            IsObject$1(properties) ? FromObject$3(properties, propertyKeys) :
                Object$1({}));
}
/** `[Json]` Constructs a type whose keys are picked from the given type */
// prettier-ignore
function Pick(type, key, options) {
    const typeKey = IsArray$3(key) ? UnionFromPropertyKeys(key) : key;
    const propertyKeys = IsSchema$1(key) ? IndexPropertyKeys(key) : key;
    const isTypeRef = IsRef$1(type);
    const isKeyRef = IsRef$1(key);
    return (IsMappedResult$1(type) ? PickFromMappedResult(type, propertyKeys, options) :
        IsMappedKey$1(key) ? PickFromMappedKey(type, key, options) :
            (isTypeRef && isKeyRef) ? Computed('Pick', [type, typeKey], options) :
                (!isTypeRef && isKeyRef) ? Computed('Pick', [type, typeKey], options) :
                    (isTypeRef && !isKeyRef) ? Computed('Pick', [type, typeKey], options) :
                        CreateType({ ...PickResolve(type, propertyKeys), ...options }));
}

// prettier-ignore
function FromPropertyKey(type, key, options) {
    return {
        [key]: Pick(type, [key], Clone(options))
    };
}
// prettier-ignore
function FromPropertyKeys(type, propertyKeys, options) {
    return propertyKeys.reduce((result, leftKey) => {
        return { ...result, ...FromPropertyKey(type, leftKey, options) };
    }, {});
}
// prettier-ignore
function FromMappedKey(type, mappedKey, options) {
    return FromPropertyKeys(type, mappedKey.keys, options);
}
// prettier-ignore
function PickFromMappedKey(type, mappedKey, options) {
    const properties = FromMappedKey(type, mappedKey, options);
    return MappedResult(properties);
}

// prettier-ignore
function FromComputed$2(target, parameters) {
    return Computed('Partial', [Computed(target, parameters)]);
}
// prettier-ignore
function FromRef$1($ref) {
    return Computed('Partial', [Ref($ref)]);
}
// prettier-ignore
function FromProperties$3(properties) {
    const partialProperties = {};
    for (const K of globalThis.Object.getOwnPropertyNames(properties))
        partialProperties[K] = Optional(properties[K]);
    return partialProperties;
}
// prettier-ignore
function FromObject$2(T) {
    const options = Discard(T, [TransformKind, '$id', 'required', 'properties']);
    const properties = FromProperties$3(T['properties']);
    return Object$1(properties, options);
}
// prettier-ignore
function FromRest$2(types) {
    return types.map(type => PartialResolve(type));
}
// ------------------------------------------------------------------
// PartialResolve
// ------------------------------------------------------------------
// prettier-ignore
function PartialResolve(type) {
    return (IsComputed$1(type) ? FromComputed$2(type.target, type.parameters) :
        IsRef$1(type) ? FromRef$1(type.$ref) :
            IsIntersect$1(type) ? Intersect(FromRest$2(type.allOf)) :
                IsUnion$1(type) ? Union(FromRest$2(type.anyOf)) :
                    IsObject$1(type) ? FromObject$2(type) :
                        Object$1({}));
}
/** `[Json]` Constructs a type where all properties are optional */
function Partial(type, options) {
    if (IsMappedResult$1(type)) {
        return PartialFromMappedResult(type, options);
    }
    else {
        // special: mapping types require overridable options
        return CreateType({ ...PartialResolve(type), ...options });
    }
}

// prettier-ignore
function FromProperties$2(K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(K))
        Acc[K2] = Partial(K[K2], Clone(options));
    return Acc;
}
// prettier-ignore
function FromMappedResult$1(R, options) {
    return FromProperties$2(R.properties, options);
}
// prettier-ignore
function PartialFromMappedResult(R, options) {
    const P = FromMappedResult$1(R, options);
    return MappedResult(P);
}

// ------------------------------------------------------------------
// RecordCreateFromPattern
// ------------------------------------------------------------------
// prettier-ignore
function RecordCreateFromPattern(pattern, T, options) {
    return CreateType({ [Kind]: 'Record', type: 'object', patternProperties: { [pattern]: T } }, options);
}
// ------------------------------------------------------------------
// RecordCreateFromKeys
// ------------------------------------------------------------------
// prettier-ignore
function RecordCreateFromKeys(K, T, options) {
    const result = {};
    for (const K2 of K)
        result[K2] = T;
    return Object$1(result, { ...options, [Hint]: 'Record' });
}
// prettier-ignore
function FromTemplateLiteralKey(K, T, options) {
    return (IsTemplateLiteralFinite(K)
        ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options)
        : RecordCreateFromPattern(K.pattern, T, options));
}
// prettier-ignore
function FromUnionKey(key, type, options) {
    return RecordCreateFromKeys(IndexPropertyKeys(Union(key)), type, options);
}
// prettier-ignore
function FromLiteralKey(key, type, options) {
    return RecordCreateFromKeys([key.toString()], type, options);
}
// prettier-ignore
function FromRegExpKey(key, type, options) {
    return RecordCreateFromPattern(key.source, type, options);
}
// prettier-ignore
function FromStringKey(key, type, options) {
    const pattern = IsUndefined$3(key.pattern) ? PatternStringExact : key.pattern;
    return RecordCreateFromPattern(pattern, type, options);
}
// prettier-ignore
function FromAnyKey(_, type, options) {
    return RecordCreateFromPattern(PatternStringExact, type, options);
}
// prettier-ignore
function FromNeverKey(_key, type, options) {
    return RecordCreateFromPattern(PatternNeverExact, type, options);
}
// prettier-ignore
function FromIntegerKey(_key, type, options) {
    return RecordCreateFromPattern(PatternNumberExact, type, options);
}
// prettier-ignore
function FromNumberKey(_, type, options) {
    return RecordCreateFromPattern(PatternNumberExact, type, options);
}
// ------------------------------------------------------------------
// TRecordOrObject
// ------------------------------------------------------------------
/** `[Json]` Creates a Record type */
function Record(key, type, options = {}) {
    // prettier-ignore
    return (IsComputed$1(type) ? Computed('Record', [key, Computed(type.target, type.parameters)], options) :
        IsComputed$1(key) ? Computed('Record', [Computed(type.target, type.parameters), type], options) :
            IsRef$1(key) ? Computed('Record', [Ref(key.$ref), type]) :
                IsUnion$1(key) ? FromUnionKey(key.anyOf, type, options) :
                    IsTemplateLiteral$1(key) ? FromTemplateLiteralKey(key, type, options) :
                        IsLiteral$1(key) ? FromLiteralKey(key.const, type, options) :
                            IsInteger$1(key) ? FromIntegerKey(key, type, options) :
                                IsNumber$1(key) ? FromNumberKey(key, type, options) :
                                    IsRegExp$1(key) ? FromRegExpKey(key, type, options) :
                                        IsString$1(key) ? FromStringKey(key, type, options) :
                                            IsAny$1(key) ? FromAnyKey(key, type, options) :
                                                IsNever$1(key) ? FromNeverKey(key, type, options) :
                                                    Never(options));
}

// prettier-ignore
function FromComputed$1(target, parameters) {
    return Computed('Required', [Computed(target, parameters)]);
}
// prettier-ignore
function FromRef($ref) {
    return Computed('Required', [Ref($ref)]);
}
// prettier-ignore
function FromProperties$1(properties) {
    const requiredProperties = {};
    for (const K of globalThis.Object.getOwnPropertyNames(properties))
        requiredProperties[K] = Discard(properties[K], [OptionalKind]);
    return requiredProperties;
}
// prettier-ignore
function FromObject$1(type) {
    const options = Discard(type, [TransformKind, '$id', 'required', 'properties']);
    const properties = FromProperties$1(type['properties']);
    return Object$1(properties, options);
}
// prettier-ignore
function FromRest$1(types) {
    return types.map(type => RequiredResolve(type));
}
// ------------------------------------------------------------------
// RequiredResolve
// ------------------------------------------------------------------
// prettier-ignore
function RequiredResolve(type) {
    return (IsComputed$1(type) ? FromComputed$1(type.target, type.parameters) :
        IsRef$1(type) ? FromRef(type.$ref) :
            IsIntersect$1(type) ? Intersect(FromRest$1(type.allOf)) :
                IsUnion$1(type) ? Union(FromRest$1(type.anyOf)) :
                    IsObject$1(type) ? FromObject$1(type) :
                        Object$1({}));
}
/** `[Json]` Constructs a type where all properties are required */
function Required(type, options) {
    if (IsMappedResult$1(type)) {
        return RequiredFromMappedResult(type, options);
    }
    else {
        // special: mapping types require overridable options
        return CreateType({ ...RequiredResolve(type), ...options });
    }
}

// prettier-ignore
function FromProperties(P, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
        Acc[K2] = Required(P[K2], options);
    return Acc;
}
// prettier-ignore
function FromMappedResult(R, options) {
    return FromProperties(R.properties, options);
}
// prettier-ignore
function RequiredFromMappedResult(R, options) {
    const P = FromMappedResult(R, options);
    return MappedResult(P);
}

// prettier-ignore
function DerefParameters(moduleProperties, types) {
    return types.map((type) => {
        return IsRef$1(type)
            ? Deref(moduleProperties, type.$ref)
            : FromType(moduleProperties, type);
    });
}
// prettier-ignore
function Deref(moduleProperties, ref) {
    return (ref in moduleProperties
        ? IsRef$1(moduleProperties[ref])
            ? Deref(moduleProperties, moduleProperties[ref].$ref)
            : FromType(moduleProperties, moduleProperties[ref])
        : Never());
}
// prettier-ignore
function FromAwaited(parameters) {
    return Awaited(parameters[0]);
}
// prettier-ignore
function FromIndex(parameters) {
    return Index(parameters[0], parameters[1]);
}
// prettier-ignore
function FromKeyOf(parameters) {
    return KeyOf(parameters[0]);
}
// prettier-ignore
function FromPartial(parameters) {
    return Partial(parameters[0]);
}
// prettier-ignore
function FromOmit(parameters) {
    return Omit(parameters[0], parameters[1]);
}
// prettier-ignore
function FromPick(parameters) {
    return Pick(parameters[0], parameters[1]);
}
// prettier-ignore
function FromRecord(parameters) {
    return Record(parameters[0], parameters[1]);
}
// prettier-ignore
function FromRequired(parameters) {
    return Required(parameters[0]);
}
// prettier-ignore
function FromComputed(moduleProperties, target, parameters) {
    const dereferenced = DerefParameters(moduleProperties, parameters);
    return (target === 'Awaited' ? FromAwaited(dereferenced) :
        target === 'Index' ? FromIndex(dereferenced) :
            target === 'KeyOf' ? FromKeyOf(dereferenced) :
                target === 'Partial' ? FromPartial(dereferenced) :
                    target === 'Omit' ? FromOmit(dereferenced) :
                        target === 'Pick' ? FromPick(dereferenced) :
                            target === 'Record' ? FromRecord(dereferenced) :
                                target === 'Required' ? FromRequired(dereferenced) :
                                    Never());
}
function FromObject(moduleProperties, properties) {
    return Object$1(globalThis.Object.keys(properties).reduce((result, key) => {
        return { ...result, [key]: FromType(moduleProperties, properties[key]) };
    }, {}));
}
// prettier-ignore
function FromConstructor(moduleProperties, parameters, instanceType) {
    return Constructor(FromRest(moduleProperties, parameters), FromType(moduleProperties, instanceType));
}
// prettier-ignore
function FromFunction(moduleProperties, parameters, returnType) {
    return Function$1(FromRest(moduleProperties, parameters), FromType(moduleProperties, returnType));
}
function FromTuple(moduleProperties, types) {
    return Tuple(FromRest(moduleProperties, types));
}
function FromIntersect(moduleProperties, types) {
    return Intersect(FromRest(moduleProperties, types));
}
function FromUnion(moduleProperties, types) {
    return Union(FromRest(moduleProperties, types));
}
function FromArray(moduleProperties, type) {
    return Array$1(FromType(moduleProperties, type));
}
function FromAsyncIterator(moduleProperties, type) {
    return AsyncIterator(FromType(moduleProperties, type));
}
function FromIterator(moduleProperties, type) {
    return Iterator(FromType(moduleProperties, type));
}
function FromRest(moduleProperties, types) {
    return types.map((type) => FromType(moduleProperties, type));
}
// prettier-ignore
function FromType(moduleProperties, type) {
    return (
    // Modifier Unwrap - Reapplied via CreateType Options
    IsOptional$1(type) ? CreateType(FromType(moduleProperties, Discard(type, [OptionalKind])), type) :
        IsReadonly(type) ? CreateType(FromType(moduleProperties, Discard(type, [ReadonlyKind])), type) :
            // Traveral
            IsArray$1(type) ? CreateType(FromArray(moduleProperties, type.items), type) :
                IsAsyncIterator$1(type) ? CreateType(FromAsyncIterator(moduleProperties, type.items), type) :
                    IsComputed$1(type) ? CreateType(FromComputed(moduleProperties, type.target, type.parameters)) :
                        IsConstructor$1(type) ? CreateType(FromConstructor(moduleProperties, type.parameters, type.returns), type) :
                            IsFunction$1(type) ? CreateType(FromFunction(moduleProperties, type.parameters, type.returns), type) :
                                IsIntersect$1(type) ? CreateType(FromIntersect(moduleProperties, type.allOf), type) :
                                    IsIterator$1(type) ? CreateType(FromIterator(moduleProperties, type.items), type) :
                                        IsObject$1(type) ? CreateType(FromObject(moduleProperties, type.properties), type) :
                                            IsTuple$1(type) ? CreateType(FromTuple(moduleProperties, type.items || []), type) :
                                                IsUnion$1(type) ? CreateType(FromUnion(moduleProperties, type.anyOf), type) :
                                                    type);
}
// prettier-ignore
function ComputeType(moduleProperties, key) {
    return (key in moduleProperties
        ? FromType(moduleProperties, moduleProperties[key])
        : Never());
}
// prettier-ignore
function ComputeModuleProperties(moduleProperties) {
    return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
        return { ...result, [key]: ComputeType(moduleProperties, key) };
    }, {});
}

// ------------------------------------------------------------------
// Module
// ------------------------------------------------------------------
// prettier-ignore
class TModule {
    constructor($defs) {
        const computed = ComputeModuleProperties($defs);
        const identified = this.WithIdentifiers(computed);
        this.$defs = identified;
    }
    /** `[Json]` Imports a Type by Key. */
    Import(key, options) {
        const $defs = { ...this.$defs, [key]: CreateType(this.$defs[key], options) };
        return CreateType({ [Kind]: 'Import', $defs, $ref: key });
    }
    // prettier-ignore
    WithIdentifiers($defs) {
        return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
            return { ...result, [key]: { ...$defs[key], $id: key } };
        }, {});
    }
}
/** `[Json]` Creates a Type Definition Module. */
function Module(properties) {
    return new TModule(properties);
}

/** `[Json]` Creates a Not type */
function Not(type, options) {
    return CreateType({ [Kind]: 'Not', not: type }, options);
}

/** `[JavaScript]` Extracts the Parameters from the given Function type */
function Parameters(schema, options) {
    return Tuple(schema.parameters, options);
}

/** `[Json]` Creates a Readonly and Optional property */
function ReadonlyOptional(schema) {
    return Readonly(Optional(schema));
}

// Auto Tracked For Recursive Types without ID's
let Ordinal = 0;
/** `[Json]` Creates a Recursive type */
function Recursive(callback, options = {}) {
    if (IsUndefined$3(options.$id))
        options.$id = `T${Ordinal++}`;
    const thisType = CloneType(callback({ [Kind]: 'This', $ref: `${options.$id}` }));
    thisType.$id = options.$id;
    // prettier-ignore
    return CreateType({ [Hint]: 'Recursive', ...thisType }, options);
}

/** `[JavaScript]` Creates a RegExp type */
function RegExp$1(unresolved, options) {
    const expr = IsString$2(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
    return CreateType({ [Kind]: 'RegExp', type: 'RegExp', source: expr.source, flags: expr.flags }, options);
}

// ------------------------------------------------------------------
// TypeGuard
// ------------------------------------------------------------------
// prettier-ignore
function RestResolve(T) {
    return (IsIntersect$1(T) ? T.allOf :
        IsUnion$1(T) ? T.anyOf :
            IsTuple$1(T) ? T.items ?? [] :
                []);
}
/** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
function Rest(T) {
    return RestResolve(T);
}

/** `[JavaScript]` Extracts the ReturnType from the given Function type */
function ReturnType(schema, options) {
    return CreateType(schema.returns, options);
}

// ------------------------------------------------------------------
// TransformBuilders
// ------------------------------------------------------------------
class TransformDecodeBuilder {
    constructor(schema) {
        this.schema = schema;
    }
    Decode(decode) {
        return new TransformEncodeBuilder(this.schema, decode);
    }
}
// prettier-ignore
class TransformEncodeBuilder {
    constructor(schema, decode) {
        this.schema = schema;
        this.decode = decode;
    }
    EncodeTransform(encode, schema) {
        const Encode = (value) => schema[TransformKind].Encode(encode(value));
        const Decode = (value) => this.decode(schema[TransformKind].Decode(value));
        const Codec = { Encode: Encode, Decode: Decode };
        return { ...schema, [TransformKind]: Codec };
    }
    EncodeSchema(encode, schema) {
        const Codec = { Decode: this.decode, Encode: encode };
        return { ...schema, [TransformKind]: Codec };
    }
    Encode(encode) {
        return (IsTransform$1(this.schema) ? this.EncodeTransform(encode, this.schema) : this.EncodeSchema(encode, this.schema));
    }
}
/** `[Json]` Creates a Transform type */
function Transform(schema) {
    return new TransformDecodeBuilder(schema);
}

/** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
function Unsafe(options = {}) {
    return CreateType({ [Kind]: options[Kind] ?? 'Unsafe' }, options);
}

/** `[JavaScript]` Creates a Void type */
function Void(options) {
    return CreateType({ [Kind]: 'Void', type: 'void' }, options);
}

// ------------------------------------------------------------------
// Type: Module
// ------------------------------------------------------------------

const TypeBuilder = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Any,
	Array: Array$1,
	AsyncIterator,
	Awaited,
	BigInt: BigInt$1,
	Boolean: Boolean$1,
	Capitalize,
	Composite,
	Const,
	Constructor,
	ConstructorParameters,
	Date: Date$1,
	Enum,
	Exclude,
	Extends,
	Extract,
	Function: Function$1,
	Index,
	InstanceType,
	Integer,
	Intersect,
	Iterator,
	KeyOf,
	Literal,
	Lowercase,
	Mapped,
	Module,
	Never,
	Not,
	Null,
	Number: Number$1,
	Object: Object$1,
	Omit,
	Optional,
	Parameters,
	Partial,
	Pick,
	Promise: Promise$1,
	Readonly,
	ReadonlyOptional,
	Record,
	Recursive,
	Ref,
	RegExp: RegExp$1,
	Required,
	Rest,
	ReturnType,
	String: String$1,
	Symbol: Symbol$1,
	TemplateLiteral,
	Transform,
	Tuple,
	Uint8Array: Uint8Array$1,
	Uncapitalize,
	Undefined,
	Union,
	Unknown,
	Unsafe,
	Uppercase,
	Void
}, Symbol.toStringTag, { value: 'Module' }));

// ------------------------------------------------------------------
// JsonTypeBuilder
// ------------------------------------------------------------------
/** JavaScript Type Builder with Static Resolution for TypeScript */
const Type = TypeBuilder;

const SchemaData$14 = Type.Object({
  message_id: Type.Union([Type.Number(), Type.String()])
});
class GetMsg extends OneBotAction {
  actionName = ActionName.GetMsg;
  payloadSchema = SchemaData$14;
  async _handle(payload, adapter) {
    const network = Object.values(this.obContext.configLoader.configData.network);
    const msgFormat = network.flat().find((e) => e.name === adapter)?.messagePostFormat ?? "array";
    if (!payload.message_id) {
      throw Error("参数message_id不能为空");
    }
    const MsgShortId = MessageUnique.getShortIdByMsgId(payload.message_id.toString());
    const msgIdWithPeer = MessageUnique.getMsgIdAndPeerByShortId(MsgShortId ?? +payload.message_id);
    if (!msgIdWithPeer) {
      throw new Error("消息不存在");
    }
    const peer = { guildId: "", peerUid: msgIdWithPeer?.Peer.peerUid, chatType: msgIdWithPeer.Peer.chatType };
    const orimsg = this.obContext.recallMsgCache.get(msgIdWithPeer.MsgId);
    let msg;
    if (orimsg) {
      msg = orimsg;
    } else {
      msg = (await this.core.apis.MsgApi.getMsgsByMsgId(peer, [msgIdWithPeer?.MsgId || payload.message_id.toString()])).msgList[0];
    }
    const retMsg = await this.obContext.apis.MsgApi.parseMessage(msg, msgFormat);
    if (!retMsg) throw Error("消息为空");
    try {
      retMsg.message_id = MessageUnique.createUniqueMsgId(peer, msg.msgId);
      retMsg.message_seq = retMsg.message_id;
      retMsg.real_id = retMsg.message_id;
    } catch (e) {
    }
    return retMsg;
  }
}

class GetLoginInfo extends OneBotAction {
  actionName = ActionName.GetLoginInfo;
  async _handle(payload) {
    return OB11Construct.selfInfo(this.core.selfInfo);
  }
}

const SchemaData$13 = Type.Object({
  no_cache: Type.Optional(Type.Union([Type.Boolean(), Type.String()]))
});
class GetFriendList extends OneBotAction {
  actionName = ActionName.GetFriendList;
  payloadSchema = SchemaData$13;
  async _handle(payload) {
    return OB11Construct.friends(await this.core.apis.FriendApi.getBuddy(typeof payload.no_cache === "string" ? payload.no_cache === "true" : !!payload.no_cache));
  }
}

const SchemaData$12 = Type.Object({
  no_cache: Type.Optional(Type.Union([Type.Boolean(), Type.String()]))
});
class GetGroupList extends OneBotAction {
  actionName = ActionName.GetGroupList;
  payloadSchema = SchemaData$12;
  async _handle(payload) {
    return OB11Construct.groups(
      await this.core.apis.GroupApi.getGroups(
        typeof payload.no_cache === "string" ? payload.no_cache === "true" : !!payload.no_cache
      )
    );
  }
}

const SchemaData$11 = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()])
});
class GetGroupInfo extends OneBotAction {
  actionName = ActionName.GetGroupInfo;
  payloadSchema = SchemaData$11;
  async _handle(payload) {
    const group = (await this.core.apis.GroupApi.getGroups()).find((e) => e.groupCode == payload.group_id.toString());
    if (!group) {
      const data = await this.core.apis.GroupApi.fetchGroupDetail(payload.group_id.toString());
      return {
        ...data,
        group_id: +payload.group_id,
        group_name: data.groupName,
        member_count: data.memberNum,
        max_member_count: data.maxMemberNum
      };
    }
    return OB11Construct.group(group);
  }
}

const SchemaData$10 = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  user_id: Type.Union([Type.Number(), Type.String()]),
  no_cache: Type.Optional(Type.Union([Type.Boolean(), Type.String()]))
});
class GetGroupMemberInfo extends OneBotAction {
  actionName = ActionName.GetGroupMemberInfo;
  payloadSchema = SchemaData$10;
  parseBoolean(value) {
    return typeof value === "string" ? value === "true" : value;
  }
  async getUid(userId) {
    const uid = await this.core.apis.UserApi.getUidByUinV2(userId.toString());
    if (!uid) throw new Error(`Uin2Uid Error: 用户ID ${userId} 不存在`);
    return uid;
  }
  async _handle(payload) {
    const isNocache = this.parseBoolean(payload.no_cache ?? true);
    const uid = await this.getUid(payload.user_id);
    const [member, info] = await Promise.all([
      this.core.apis.GroupApi.getGroupMemberEx(payload.group_id.toString(), uid, isNocache),
      this.core.apis.UserApi.getUserDetailInfo(uid)
    ]);
    if (!member) throw new Error(`群(${payload.group_id})成员${payload.user_id}不存在`);
    if (info) {
      Object.assign(member, info);
    } else {
      this.core.context.logger.logDebug(`获取群成员详细信息失败, 只能返回基础信息`);
    }
    return OB11Construct.groupMember(payload.group_id.toString(), member);
  }
}

class SendGroupMsg extends SendMsg {
  actionName = ActionName.SendGroupMsg;
  contextMode = ContextMode.Group;
  async check(payload) {
    delete payload.user_id;
    payload.message_type = "group";
    return super.check(payload);
  }
}

class SendPrivateMsg extends SendMsg {
  actionName = ActionName.SendPrivateMsg;
  contextMode = ContextMode.Private;
  async check(payload) {
    payload.message_type = "private";
    return super.check(payload);
  }
}

const SchemaData$$ = Type.Object({
  message_id: Type.Union([Type.Number(), Type.String()])
});
class DeleteMsg extends OneBotAction {
  actionName = ActionName.DeleteMsg;
  payloadSchema = SchemaData$$;
  async _handle(payload) {
    const msg = MessageUnique.getMsgIdAndPeerByShortId(Number(payload.message_id));
    if (msg) {
      await this.core.apis.MsgApi.recallMsg(msg.Peer, msg.MsgId);
    } else {
      throw new Error("Recall failed");
    }
  }
}

class GetVersionInfo extends OneBotAction {
  actionName = ActionName.GetVersionInfo;
  async _handle(payload) {
    return {
      app_name: "NapCat.Onebot",
      protocol_version: "v11",
      app_version: napCatVersion
    };
  }
}

class CanSendRecord extends OneBotAction {
  actionName = ActionName.CanSendRecord;
  async _handle(_payload) {
    return {
      yes: true
    };
  }
}

class CanSendImage extends CanSendRecord {
  actionName = ActionName.CanSendImage;
}

class GetStatus extends OneBotAction {
  actionName = ActionName.GetStatus;
  async _handle(payload) {
    return {
      online: !!this.core.selfInfo.online,
      good: true,
      stat: {}
    };
  }
}

class GoCQHTTPSendForwardMsg extends SendMsg {
  actionName = ActionName.GoCQHTTP_SendForwardMsg;
  async check(payload) {
    if (payload.messages) payload.message = normalize(payload.messages);
    return super.check(payload);
  }
}
class GoCQHTTPSendPrivateForwardMsg extends GoCQHTTPSendForwardMsg {
  actionName = ActionName.GoCQHTTP_SendPrivateForwardMsg;
}
class GoCQHTTPSendGroupForwardMsg extends GoCQHTTPSendForwardMsg {
  actionName = ActionName.GoCQHTTP_SendGroupForwardMsg;
}

Type.Object({
  user_id: Type.Union([Type.Number(), Type.String()])
});
class GoCQHTTPGetStrangerInfo extends OneBotAction {
  actionName = ActionName.GoCQHTTP_GetStrangerInfo;
  async _handle(payload) {
    const user_id = payload.user_id.toString();
    const extendData = await this.core.apis.UserApi.getUserDetailInfoByUin(user_id);
    let uid = await this.core.apis.UserApi.getUidByUinV2(user_id);
    if (!uid) uid = extendData.detail.uid;
    const info = await this.core.apis.UserApi.getUserDetailInfo(uid);
    return {
      ...extendData.detail.simpleInfo.coreInfo,
      ...extendData.detail.commonExt ?? {},
      ...extendData.detail.simpleInfo.baseInfo,
      ...extendData.detail.simpleInfo.relationFlags ?? {},
      ...extendData.detail.simpleInfo.status ?? {},
      user_id: parseInt(extendData.detail.uin) ?? 0,
      uid: info.uid ?? uid,
      nickname: extendData.detail.simpleInfo.coreInfo.nick,
      age: extendData.detail.simpleInfo.baseInfo.age ?? info.age,
      qid: extendData.detail.simpleInfo.baseInfo.qid,
      qqLevel: calcQQLevel(extendData.detail.commonExt?.qqLevel ?? info.qqLevel),
      sex: OB11Construct.sex(extendData.detail.simpleInfo.baseInfo.sex) ?? OB11UserSex.unknown,
      long_nick: extendData.detail.simpleInfo.baseInfo.longNick ?? info.longNick,
      reg_time: extendData.detail.commonExt?.regTime ?? info.regTime,
      is_vip: extendData.detail.simpleInfo.vasInfo?.svipFlag,
      is_years_vip: extendData.detail.simpleInfo.vasInfo?.yearVipFlag,
      vip_level: extendData.detail.simpleInfo.vasInfo?.vipLevel,
      remark: extendData.detail.simpleInfo.coreInfo.remark ?? info.remark,
      status: extendData.detail.simpleInfo.status?.status ?? info.status,
      login_days: 0
      //失效
    };
  }
}

const SchemaData$_ = Type.Object({
  times: Type.Union([Type.Number(), Type.String()], { default: 1 }),
  user_id: Type.Union([Type.Number(), Type.String()])
});
class SendLike extends OneBotAction {
  actionName = ActionName.SendLike;
  payloadSchema = SchemaData$_;
  async _handle(payload) {
    const qq = payload.user_id.toString();
    const uid = await this.core.apis.UserApi.getUidByUinV2(qq) ?? "";
    const result = await this.core.apis.UserApi.like(uid, +payload.times);
    if (result.result !== 0) {
      throw new Error(`点赞失败 ${result.errMsg}`);
    }
    return null;
  }
}

const SchemaData$Z = Type.Object({
  flag: Type.Union([Type.String(), Type.Number()]),
  approve: Type.Optional(Type.Union([Type.Boolean(), Type.String()])),
  reason: Type.Optional(Type.Union([Type.String({ default: " " }), Type.Null()]))
});
class SetGroupAddRequest extends OneBotAction {
  actionName = ActionName.SetGroupAddRequest;
  payloadSchema = SchemaData$Z;
  async _handle(payload) {
    const flag = payload.flag.toString();
    const approve = payload.approve?.toString() !== "false";
    const reason = payload.reason ?? " ";
    const notify = await this.findNotify(flag);
    if (!notify) {
      throw new Error("No such request");
    }
    await this.core.apis.GroupApi.handleGroupRequest(
      notify,
      approve ? NTGroupRequestOperateTypes.KAGREE : NTGroupRequestOperateTypes.KREFUSE,
      reason
    );
    return null;
  }
  async findNotify(flag) {
    let notify = (await this.core.apis.GroupApi.getSingleScreenNotifies(false, 100)).find((e) => e.seq == flag);
    if (!notify) {
      notify = (await this.core.apis.GroupApi.getSingleScreenNotifies(true, 100)).find((e) => e.seq == flag);
    }
    return notify;
  }
}

const SchemaData$Y = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  is_dismiss: Type.Optional(Type.Union([Type.Boolean(), Type.String()]))
});
class SetGroupLeave extends OneBotAction {
  actionName = ActionName.SetGroupLeave;
  payloadSchema = SchemaData$Y;
  async _handle(payload) {
    await this.core.apis.GroupApi.quitGroup(payload.group_id.toString());
  }
}

const SchemaData$X = Type.Object({
  flag: Type.Union([Type.String(), Type.Number()]),
  approve: Type.Optional(Type.Union([Type.String(), Type.Boolean()])),
  remark: Type.Optional(Type.String())
});
class SetFriendAddRequest extends OneBotAction {
  actionName = ActionName.SetFriendAddRequest;
  payloadSchema = SchemaData$X;
  async _handle(payload) {
    const approve = payload.approve?.toString() !== "false";
    const notify = (await this.core.apis.FriendApi.getBuddyReq()).buddyReqs.find((e) => e.reqTime == payload.flag.toString());
    if (!notify) {
      throw new Error("No such request");
    }
    await this.core.apis.FriendApi.handleFriendRequest(notify, approve);
    if (payload.remark) {
      await this.core.apis.FriendApi.setBuddyRemark(notify.friendUid, payload.remark);
    }
    return null;
  }
}

const SchemaData$W = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  enable: Type.Optional(Type.Union([Type.Boolean(), Type.String()]))
});
class SetGroupWholeBan extends OneBotAction {
  actionName = ActionName.SetGroupWholeBan;
  payloadSchema = SchemaData$W;
  async _handle(payload) {
    const enable = payload.enable?.toString() !== "false";
    await this.core.apis.GroupApi.banGroup(payload.group_id.toString(), enable);
    return null;
  }
}

const SchemaData$V = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  group_name: Type.String()
});
class SetGroupName extends OneBotAction {
  actionName = ActionName.SetGroupName;
  payloadSchema = SchemaData$V;
  async _handle(payload) {
    const ret = await this.core.apis.GroupApi.setGroupName(payload.group_id.toString(), payload.group_name);
    if (ret.result !== 0) {
      throw new Error(`设置群名称失败 ErrCode: ${ret.result} ErrMsg: ${ret.errMsg}`);
    }
    return null;
  }
}

const SchemaData$U = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  user_id: Type.Union([Type.Number(), Type.String()]),
  duration: Type.Union([Type.Number(), Type.String()], { default: 0 })
});
class SetGroupBan extends OneBotAction {
  actionName = ActionName.SetGroupBan;
  payloadSchema = SchemaData$U;
  async _handle(payload) {
    const uid = await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
    if (!uid) throw new Error("uid error");
    await this.core.apis.GroupApi.banMember(
      payload.group_id.toString(),
      [{ uid, timeStamp: +payload.duration }]
    );
    return null;
  }
}

const SchemaData$T = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  user_id: Type.Union([Type.Number(), Type.String()]),
  reject_add_request: Type.Optional(Type.Union([Type.Boolean(), Type.String()]))
});
class SetGroupKick extends OneBotAction {
  actionName = ActionName.SetGroupKick;
  payloadSchema = SchemaData$T;
  async _handle(payload) {
    const rejectReq = payload.reject_add_request?.toString() == "true";
    const uid = await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
    if (!uid) throw new Error("get Uid Error");
    await this.core.apis.GroupApi.kickMember(payload.group_id.toString(), [uid], rejectReq);
    return null;
  }
}

const SchemaData$S = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  user_id: Type.Union([Type.Number(), Type.String()]),
  enable: Type.Optional(Type.Union([Type.Boolean(), Type.String()]))
});
class SetGroupAdmin extends OneBotAction {
  actionName = ActionName.SetGroupAdmin;
  payloadSchema = SchemaData$S;
  async _handle(payload) {
    const enable = typeof payload.enable === "string" ? payload.enable === "true" : !!payload.enable;
    const uid = await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
    if (!uid) throw new Error("get Uid Error");
    await this.core.apis.GroupApi.setMemberRole(payload.group_id.toString(), uid, enable ? NTGroupMemberRole.KADMIN : NTGroupMemberRole.KMEMBER);
    return null;
  }
}

const SchemaData$R = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  user_id: Type.Union([Type.Number(), Type.String()]),
  card: Type.Optional(Type.String())
});
class SetGroupCard extends OneBotAction {
  actionName = ActionName.SetGroupCard;
  payloadSchema = SchemaData$R;
  async _handle(payload) {
    const member = await this.core.apis.GroupApi.getGroupMember(payload.group_id.toString(), payload.user_id.toString());
    if (member) await this.core.apis.GroupApi.setMemberCard(payload.group_id.toString(), member.uid, payload.card || "");
    return null;
  }
}

const GetFileBase_PayloadSchema = Type.Object({
  file: Type.Optional(Type.String()),
  file_id: Type.Optional(Type.String())
});
class GetFileBase extends OneBotAction {
  payloadSchema = GetFileBase_PayloadSchema;
  async _handle(payload) {
    payload.file ||= payload.file_id || "";
    const contextMsgFile = FileNapCatOneBotUUID.decode(payload.file);
    if (contextMsgFile) {
      const { peer, msgId, elementId } = contextMsgFile;
      const downloadPath = await this.core.apis.FileApi.downloadMedia(msgId, peer.chatType, peer.peerUid, elementId, "", "");
      const rawMessage = (await this.core.apis.MsgApi.getMsgsByMsgId(peer, [msgId]))?.msgList.find((msg) => msg.msgId === msgId);
      const mixElement = rawMessage?.elements.find((e) => e.elementId === elementId);
      const mixElementInner = mixElement?.videoElement ?? mixElement?.fileElement ?? mixElement?.pttElement ?? mixElement?.picElement;
      if (!mixElementInner) throw new Error("element not found");
      const fileSize = mixElementInner.fileSize?.toString() ?? "";
      const fileName = mixElementInner.fileName ?? "";
      let url = "";
      if (mixElement?.picElement && rawMessage) {
        const tempData = await this.obContext.apis.MsgApi.rawToOb11Converters.picElement?.(mixElement?.picElement, rawMessage, mixElement, { parseMultMsg: false });
        url = tempData?.data.url ?? "";
      }
      if (mixElement?.videoElement && rawMessage) {
        const tempData = await this.obContext.apis.MsgApi.rawToOb11Converters.videoElement?.(mixElement?.videoElement, rawMessage, mixElement, { parseMultMsg: false });
        url = tempData?.data.url ?? "";
      }
      const res = {
        file: downloadPath,
        url: url !== "" ? url : downloadPath,
        file_size: fileSize,
        file_name: fileName
      };
      if (this.obContext.configLoader.configData.enableLocalFile2Url && downloadPath) {
        try {
          res.base64 = await fsPromise.readFile(downloadPath, "base64");
        } catch (e) {
          throw new Error("文件下载失败. " + e);
        }
      }
      return res;
    }
    const contextModelIdFile = FileNapCatOneBotUUID.decodeModelId(payload.file);
    if (contextModelIdFile) {
      const { peer, modelId } = contextModelIdFile;
      const downloadPath = await this.core.apis.FileApi.downloadFileForModelId(peer, modelId, "");
      const res = {
        file: downloadPath,
        url: downloadPath,
        file_size: "",
        file_name: ""
      };
      if (this.obContext.configLoader.configData.enableLocalFile2Url && downloadPath) {
        try {
          res.base64 = await fsPromise.readFile(downloadPath, "base64");
        } catch (e) {
          throw new Error("文件下载失败. " + e);
        }
      }
      return res;
    }
    const searchResult = await this.core.apis.FileApi.searchForFile([payload.file]);
    if (searchResult) {
      const downloadPath = await this.core.apis.FileApi.downloadFileById(searchResult.id, parseInt(searchResult.fileSize));
      const res = {
        file: downloadPath,
        url: downloadPath,
        file_size: searchResult.fileSize.toString(),
        file_name: searchResult.fileName
      };
      if (this.obContext.configLoader.configData.enableLocalFile2Url && downloadPath) {
        try {
          res.base64 = await fsPromise.readFile(downloadPath, "base64");
        } catch (e) {
          throw new Error("文件下载失败. " + e);
        }
      }
      return res;
    }
    throw new Error("file not found");
  }
}
class GetFile extends GetFileBase {
  actionName = ActionName.GetFile;
}

class GetImage extends GetFileBase {
  actionName = ActionName.GetImage;
}

const FFMPEG_PATH = process.env.FFMPEG_PATH || "ffmpeg";
const out_format = ["mp3", "amr", "wma", "m4a", "spx", "ogg", "wav", "flac"];
class GetRecord extends GetFileBase {
  actionName = ActionName.GetRecord;
  async _handle(payload) {
    const res = await super._handle(payload);
    if (payload.out_format && typeof payload.out_format === "string") {
      const inputFile = res.file;
      if (!inputFile) throw new Error("file not found");
      if (!out_format.includes(payload.out_format)) {
        throw new Error("转换失败 out_format 字段可能格式不正确");
      }
      const pcmFile = `${inputFile}.pcm`;
      const outputFile = `${inputFile}.${payload.out_format}`;
      try {
        await promises.access(inputFile);
        try {
          await promises.access(outputFile);
        } catch (error) {
          await this.decodeFile(inputFile, pcmFile);
          await this.convertFile(pcmFile, outputFile, payload.out_format);
        }
        const base64Data = await promises.readFile(outputFile, { encoding: "base64" });
        res.file = outputFile;
        res.url = outputFile;
        res.base64 = base64Data;
      } catch (error) {
        console.error("Error processing file:", error);
        throw error;
      }
    }
    return res;
  }
  async decodeFile(inputFile, outputFile) {
    try {
      const inputData = await promises.readFile(inputFile);
      const decodedData = await decode(inputData, 24e3);
      await promises.writeFile(outputFile, Buffer.from(decodedData.data));
    } catch (error) {
      console.error("Error decoding file:", error);
      throw error;
    }
  }
  convertFile(inputFile, outputFile, format) {
    return new Promise((resolve, reject) => {
      const params = format === "amr" ? ["-f", "s16le", "-ar", "24000", "-ac", "1", "-i", inputFile, "-ar", "8000", "-b:a", "12.2k", outputFile] : ["-f", "s16le", "-ar", "24000", "-ac", "1", "-i", inputFile, outputFile];
      const ffmpeg = spawn(FFMPEG_PATH, params);
      ffmpeg.on("close", (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`ffmpeg process exited with code ${code}`));
        }
      });
      ffmpeg.on("error", (error) => {
        reject(error);
      });
    });
  }
}

const SchemaData$Q = Type.Object({
  user_id: Type.Optional(Type.Union([Type.String(), Type.Number()])),
  group_id: Type.Optional(Type.Union([Type.String(), Type.Number()])),
  message_id: Type.Optional(Type.Union([Type.String(), Type.Number()]))
});
class MarkMsgAsRead extends OneBotAction {
  async getPeer(payload) {
    if (payload.message_id) {
      const s_peer = MessageUnique.getMsgIdAndPeerByShortId(+payload.message_id)?.Peer;
      if (s_peer) {
        return s_peer;
      }
      const l_peer = MessageUnique.getPeerByMsgId(payload.message_id.toString())?.Peer;
      if (l_peer) {
        return l_peer;
      }
    }
    if (payload.user_id) {
      const peerUid = await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
      if (!peerUid) {
        throw new Error(`私聊${payload.user_id}不存在`);
      }
      const isBuddy = await this.core.apis.FriendApi.isBuddy(peerUid);
      return { chatType: isBuddy ? ChatType.KCHATTYPEC2C : ChatType.KCHATTYPETEMPC2CFROMGROUP, peerUid };
    }
    if (!payload.group_id) {
      throw new Error("缺少参数 group_id 或 user_id");
    }
    return { chatType: ChatType.KCHATTYPEGROUP, peerUid: payload.group_id.toString() };
  }
  async _handle(payload) {
    const ret = await this.core.apis.MsgApi.setMsgRead(await this.getPeer(payload));
    if (ret.result != 0) {
      throw new Error("设置已读失败," + ret.errMsg);
    }
    return null;
  }
}
class MarkPrivateMsgAsRead extends MarkMsgAsRead {
  payloadSchema = SchemaData$Q;
  actionName = ActionName.MarkPrivateMsgAsRead;
}
class MarkGroupMsgAsRead extends MarkMsgAsRead {
  payloadSchema = SchemaData$Q;
  actionName = ActionName.MarkGroupMsgAsRead;
}
class GoCQHTTPMarkMsgAsRead extends MarkMsgAsRead {
  actionName = ActionName.GoCQHTTP_MarkMsgAsRead;
}
class MarkAllMsgAsRead extends OneBotAction {
  actionName = ActionName._MarkAllMsgAsRead;
  async _handle() {
    await this.core.apis.MsgApi.markAllMsgAsRead();
    return null;
  }
}

const SchemaData$P = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  file: Type.String(),
  name: Type.String(),
  folder: Type.Optional(Type.String()),
  folder_id: Type.Optional(Type.String())
  //临时扩展
});
class GoCQHTTPUploadGroupFile extends OneBotAction {
  actionName = ActionName.GoCQHTTP_UploadGroupFile;
  payloadSchema = SchemaData$P;
  async _handle(payload) {
    let file = payload.file;
    if (fs__default.existsSync(file)) {
      file = `file://${file}`;
    }
    const downloadResult = await uriToLocalFile(this.core.NapCatTempPath, file);
    const peer = {
      chatType: ChatType.KCHATTYPEGROUP,
      peerUid: payload.group_id.toString()
    };
    if (!downloadResult.success) {
      throw new Error(downloadResult.errMsg);
    }
    const msgContext = {
      peer,
      deleteAfterSentFiles: []
    };
    const sendFileEle = await this.core.apis.FileApi.createValidSendFileElement(msgContext, downloadResult.path, payload.name, payload.folder ?? payload.folder_id);
    await this.obContext.apis.MsgApi.sendMsgWithOb11UniqueId(peer, [sendFileEle], msgContext.deleteAfterSentFiles, true);
    return null;
  }
}

const SchemaData$O = Type.Object({
  file: Type.String()
});
class SetAvatar extends OneBotAction {
  actionName = ActionName.SetQQAvatar;
  payloadSchema = SchemaData$O;
  async _handle(payload) {
    const { path, success } = await uriToLocalFile(this.core.NapCatTempPath, payload.file);
    if (!success) {
      throw new Error(`头像${payload.file}设置失败,file字段可能格式不正确`);
    }
    if (path) {
      await checkFileExist(path, 5e3);
      const ret = await this.core.apis.UserApi.setQQAvatar(path);
      fs$2.unlink(path).catch(() => {
      });
      if (!ret) {
        throw new Error(`头像${payload.file}设置失败,api无返回`);
      }
      if (ret.result == 1004022) {
        throw new Error(`头像${payload.file}设置失败，文件可能不是图片格式`);
      } else if (ret.result != 0) {
        throw new Error(`头像${payload.file}设置失败,未知的错误,${ret.result}:${ret.errMsg}`);
      }
    } else {
      fs$2.unlink(path).catch(() => {
      });
      throw new Error(`头像${payload.file}设置失败,无法获取头像,文件可能不存在`);
    }
    return null;
  }
}

const SchemaData$N = Type.Object({
  url: Type.Optional(Type.String()),
  base64: Type.Optional(Type.String()),
  name: Type.Optional(Type.String()),
  headers: Type.Optional(Type.Union([Type.String(), Type.Array(Type.String())]))
});
class GoCQHTTPDownloadFile extends OneBotAction {
  actionName = ActionName.GoCQHTTP_DownloadFile;
  payloadSchema = SchemaData$N;
  async _handle(payload) {
    const isRandomName = !payload.name;
    const name = payload.name || randomUUID();
    const filePath = join(this.core.NapCatTempPath, name);
    if (payload.base64) {
      fs__default.writeFileSync(filePath, payload.base64, "base64");
    } else if (payload.url) {
      const headers = this.getHeaders(payload.headers);
      const buffer = await httpDownload({ url: payload.url, headers });
      fs__default.writeFileSync(filePath, Buffer.from(buffer), "binary");
    } else {
      throw new Error("不存在任何文件, 无法下载");
    }
    if (fs__default.existsSync(filePath)) {
      if (isRandomName) {
        const md5 = await calculateFileMD5(filePath);
        const newPath = join(this.core.NapCatTempPath, md5);
        fs__default.renameSync(filePath, newPath);
        return { file: newPath };
      }
      return { file: filePath };
    } else {
      throw new Error("文件写入失败, 检查权限");
    }
  }
  getHeaders(headersIn) {
    const headers = {};
    if (typeof headersIn == "string") {
      headersIn = headersIn.split("[\\r\\n]");
    }
    if (Array.isArray(headersIn)) {
      for (const headerItem of headersIn) {
        const spilt = headerItem.indexOf("=");
        if (spilt < 0) {
          headers[headerItem] = "";
        } else {
          const key = headerItem.substring(0, spilt);
          headers[key] = headerItem.substring(spilt + 1);
        }
      }
    }
    if (!headers["Content-Type"]) {
      headers["Content-Type"] = "application/octet-stream";
    }
    return headers;
  }
}

const SchemaData$M = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  message_seq: Type.Optional(Type.Union([Type.Number(), Type.String()])),
  count: Type.Union([Type.Number(), Type.String()], { default: 20 }),
  reverseOrder: Type.Optional(Type.Union([Type.Boolean(), Type.String()]))
});
class GoCQHTTPGetGroupMsgHistory extends OneBotAction {
  actionName = ActionName.GoCQHTTP_GetGroupMsgHistory;
  payloadSchema = SchemaData$M;
  async _handle(payload, adapter) {
    const isReverseOrder = typeof payload.reverseOrder === "string" ? payload.reverseOrder === "true" : !!payload.reverseOrder;
    const peer = { chatType: ChatType.KCHATTYPEGROUP, peerUid: payload.group_id.toString() };
    const hasMessageSeq = !payload.message_seq ? !!payload.message_seq : !(payload.message_seq?.toString() === "" || payload.message_seq?.toString() === "0");
    const startMsgId = hasMessageSeq ? MessageUnique.getMsgIdAndPeerByShortId(+payload.message_seq)?.MsgId ?? payload.message_seq.toString() : "0";
    const msgList = hasMessageSeq ? (await this.core.apis.MsgApi.getMsgHistory(peer, startMsgId, +payload.count)).msgList : (await this.core.apis.MsgApi.getAioFirstViewLatestMsgs(peer, +payload.count)).msgList;
    if (msgList.length === 0) throw new Error(`消息${payload.message_seq}不存在`);
    if (isReverseOrder) msgList.reverse();
    await Promise.all(msgList.map(async (msg) => {
      msg.id = MessageUnique.createUniqueMsgId({ guildId: "", chatType: msg.chatType, peerUid: msg.peerUid }, msg.msgId);
    }));
    const network = Object.values(this.obContext.configLoader.configData.network);
    const msgFormat = network.flat().find((e) => e.name === adapter)?.messagePostFormat ?? "array";
    const ob11MsgList = (await Promise.all(
      msgList.map((msg) => this.obContext.apis.MsgApi.parseMessage(msg, msgFormat))
    )).filter((msg) => msg !== void 0);
    return { "messages": ob11MsgList };
  }
}

const SchemaData$L = Type.Object({
  message_id: Type.Optional(Type.Union([Type.Number(), Type.String()])),
  id: Type.Optional(Type.Union([Type.Number(), Type.String()]))
});
class GoCQHTTPGetForwardMsgAction extends OneBotAction {
  actionName = ActionName.GoCQHTTP_GetForwardMsg;
  payloadSchema = SchemaData$L;
  createTemplateNode(message) {
    return {
      type: OB11MessageDataType.node,
      data: {
        user_id: message.user_id,
        nickname: message.sender.nickname,
        message: [],
        content: []
      }
    };
  }
  async parseForward(messages) {
    const retMsg = [];
    for (const message of messages) {
      const templateNode = this.createTemplateNode(message);
      for (const msgdata of message.message) {
        if (msgdata.type === OB11MessageDataType.forward) {
          const newNode = this.createTemplateNode(message);
          newNode.data.message = await this.parseForward(msgdata.data.content ?? []);
          templateNode.data.message.push(newNode);
        } else {
          templateNode.data.message.push(msgdata);
        }
      }
      retMsg.push(templateNode);
    }
    return retMsg;
  }
  async _handle(payload) {
    const msgId = payload.message_id || payload.id;
    if (!msgId) {
      throw new Error("message_id is required");
    }
    const rootMsgId = MessageUnique.getShortIdByMsgId(msgId.toString());
    const rootMsg = MessageUnique.getMsgIdAndPeerByShortId(rootMsgId ?? +msgId);
    if (!rootMsg) {
      throw new Error("msg not found");
    }
    const data = await this.core.apis.MsgApi.getMsgsByMsgId(rootMsg.Peer, [rootMsg.MsgId]);
    if (!data || data.result !== 0) {
      throw new Error("找不到相关的聊天记录" + data?.errMsg);
    }
    const singleMsg = data.msgList[0];
    const resMsg = (await this.obContext.apis.MsgApi.parseMessageV2(singleMsg))?.arrayMsg;
    if (!resMsg?.message?.[0]?.data?.content) {
      throw new Error("找不到相关的聊天记录");
    }
    return {
      messages: resMsg?.message?.[0]?.data?.content
    };
  }
}

const SchemaData$K = Type.Object({
  user_id: Type.Union([Type.Number(), Type.String()]),
  message_seq: Type.Optional(Type.Union([Type.Number(), Type.String()])),
  count: Type.Union([Type.Number(), Type.String()], { default: 20 }),
  reverseOrder: Type.Optional(Type.Union([Type.Boolean(), Type.String()]))
});
class GetFriendMsgHistory extends OneBotAction {
  actionName = ActionName.GetFriendMsgHistory;
  payloadSchema = SchemaData$K;
  async _handle(payload, adapter) {
    const uid = await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
    const isReverseOrder = typeof payload.reverseOrder === "string" ? payload.reverseOrder === "true" : !!payload.reverseOrder;
    if (!uid) throw new Error(`记录${payload.user_id}不存在`);
    const friend = await this.core.apis.FriendApi.isBuddy(uid);
    const peer = { chatType: friend ? ChatType.KCHATTYPEC2C : ChatType.KCHATTYPETEMPC2CFROMGROUP, peerUid: uid };
    const hasMessageSeq = !payload.message_seq ? !!payload.message_seq : !(payload.message_seq?.toString() === "" || payload.message_seq?.toString() === "0");
    const startMsgId = hasMessageSeq ? MessageUnique.getMsgIdAndPeerByShortId(+payload.message_seq)?.MsgId ?? payload.message_seq.toString() : "0";
    const msgList = hasMessageSeq ? (await this.core.apis.MsgApi.getMsgHistory(peer, startMsgId, +payload.count)).msgList : (await this.core.apis.MsgApi.getAioFirstViewLatestMsgs(peer, +payload.count)).msgList;
    if (msgList.length === 0) throw new Error(`消息${payload.message_seq}不存在`);
    if (isReverseOrder) msgList.reverse();
    await Promise.all(msgList.map(async (msg) => {
      msg.id = MessageUnique.createUniqueMsgId({ guildId: "", chatType: msg.chatType, peerUid: msg.peerUid }, msg.msgId);
    }));
    const network = Object.values(this.obContext.configLoader.configData.network);
    const ob11MsgList = (await Promise.all(
      msgList.map((msg) => this.obContext.apis.MsgApi.parseMessage(msg, network.flat().find((e) => e.name === adapter)?.messagePostFormat ?? "array"))
    )).filter((msg) => msg !== void 0);
    return { "messages": ob11MsgList };
  }
}

const SchemaData$J = Type.Object({
  domain: Type.String()
});
class GetCookies extends OneBotAction {
  actionName = ActionName.GetCookies;
  payloadSchema = SchemaData$J;
  async _handle(payload) {
    const cookiesObject = await this.core.apis.UserApi.getCookies(payload.domain);
    const cookies = Object.entries(cookiesObject).map(([key, value]) => `${key}=${value}`).join("; ");
    const bkn = cookiesObject?.skey ? this.core.apis.WebApi.getBknFromCookie(cookiesObject) : "";
    return { cookies, bkn };
  }
}

const SchemaData$I = Type.Object({
  message_id: Type.Union([Type.Number(), Type.String()]),
  emoji_id: Type.Union([Type.Number(), Type.String()]),
  set: Type.Optional(Type.Union([Type.Boolean(), Type.String()]))
});
class SetMsgEmojiLike extends OneBotAction {
  actionName = ActionName.SetMsgEmojiLike;
  payloadSchema = SchemaData$I;
  async _handle(payload) {
    const msg = MessageUnique.getMsgIdAndPeerByShortId(+payload.message_id);
    if (!msg) {
      throw new Error("msg not found");
    }
    if (!payload.emoji_id) {
      throw new Error("emojiId not found");
    }
    payload.set = payload.set ?? true;
    const msgData = (await this.core.apis.MsgApi.getMsgsByMsgId(msg.Peer, [msg.MsgId])).msgList;
    if (!msgData || msgData.length === 0 || !msgData[0].msgSeq) {
      throw new Error("find msg by msgid error");
    }
    return await this.core.apis.MsgApi.setEmojiLike(
      msg.Peer,
      msgData[0].msgSeq,
      payload.emoji_id.toString(),
      typeof payload.set === "string" ? payload.set === "true" : !!payload.set
    );
  }
}

class GetRobotUinRange extends OneBotAction {
  actionName = ActionName.GetRobotUinRange;
  async _handle() {
    return await this.core.apis.UserApi.getRobotUinRange();
  }
}

const SchemaData$H = Type.Object({
  status: Type.Union([Type.Number(), Type.String()]),
  ext_status: Type.Union([Type.Number(), Type.String()]),
  battery_status: Type.Union([Type.Number(), Type.String()])
});
class SetOnlineStatus extends OneBotAction {
  actionName = ActionName.SetOnlineStatus;
  payloadSchema = SchemaData$H;
  async _handle(payload) {
    const ret = await this.core.apis.UserApi.setSelfOnlineStatus(
      +payload.status,
      +payload.ext_status,
      +payload.battery_status
    );
    if (ret.result !== 0) {
      throw new Error("设置在线状态失败");
    }
    return null;
  }
}

const SchemaData$G = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()])
});
class GetGroupNotice extends OneBotAction {
  actionName = ActionName.GoCQHTTP_GetGroupNotice;
  payloadSchema = SchemaData$G;
  async _handle(payload) {
    const group = payload.group_id.toString();
    const ret = await this.core.apis.WebApi.getGroupNotice(group);
    if (!ret) {
      throw new Error("获取公告失败");
    }
    const retNotices = new Array();
    for (const key in ret.feeds) {
      const retApiNotice = ret.feeds[key];
      const retNotice = {
        notice_id: retApiNotice.fid,
        sender_id: retApiNotice.u,
        publish_time: retApiNotice.pubt,
        message: {
          text: retApiNotice.msg.text,
          image: retApiNotice.msg.pics?.map((pic) => {
            return { id: pic.id, height: pic.h, width: pic.w };
          }) || []
        }
      };
      retNotices.push(retNotice);
    }
    return retNotices;
  }
}

const SchemaData$F = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()])
});
class GetGroupEssence extends OneBotAction {
  actionName = ActionName.GoCQHTTP_GetEssenceMsg;
  payloadSchema = SchemaData$F;
  async msgSeqToMsgId(peer, msgSeq, msgRandom) {
    const replyMsgList = (await this.core.apis.MsgApi.getMsgsBySeqAndCount(peer, msgSeq, 1, true, true)).msgList.find((msg) => msg.msgSeq === msgSeq && msg.msgRandom === msgRandom);
    if (!replyMsgList) {
      return void 0;
    }
    return {
      id: MessageUnique.createUniqueMsgId(peer, replyMsgList.msgId),
      msg: replyMsgList
    };
  }
  async _handle(payload, adapter) {
    const network = Object.values(this.obContext.configLoader.configData.network);
    const msgFormat = network.flat().find((e) => e.name === adapter)?.messagePostFormat ?? "array";
    const msglist = (await this.core.apis.WebApi.getGroupEssenceMsgAll(payload.group_id.toString())).flatMap((e) => e.data.msg_list);
    if (!msglist) {
      throw new Error("获取失败");
    }
    return await Promise.all(msglist.map(async (msg) => {
      const msgOriginData = await this.msgSeqToMsgId({
        chatType: ChatType.KCHATTYPEGROUP,
        peerUid: payload.group_id.toString()
      }, msg.msg_seq.toString(), msg.msg_random.toString());
      if (msgOriginData) {
        const { id: message_id, msg: rawMessage } = msgOriginData;
        return {
          msg_seq: msg.msg_seq,
          msg_random: msg.msg_random,
          sender_id: +msg.sender_uin,
          sender_nick: msg.sender_nick,
          operator_id: +msg.add_digest_uin,
          operator_nick: msg.add_digest_nick,
          message_id,
          operator_time: msg.add_digest_time,
          content: (await this.obContext.apis.MsgApi.parseMessage(rawMessage, msgFormat))?.message
        };
      }
      const msgTempData = JSON.stringify({
        msg_seq: msg.msg_seq.toString(),
        msg_random: msg.msg_random.toString(),
        group_id: payload.group_id.toString()
      });
      const hash = crypto__default.createHash("md5").update(msgTempData).digest();
      hash[0] &= 127;
      const shortId = hash.readInt32BE(0);
      this.core.apis.GroupApi.essenceLRU.set(shortId, msgTempData);
      return {
        msg_seq: msg.msg_seq,
        msg_random: msg.msg_random,
        sender_id: +msg.sender_uin,
        sender_nick: msg.sender_nick,
        operator_id: +msg.add_digest_uin,
        operator_nick: msg.add_digest_nick,
        message_id: shortId,
        operator_time: msg.add_digest_time,
        content: msg.msg_content.map((msg2) => {
          if (msg2.msg_type === 1) {
            return {
              type: "text",
              data: {
                text: msg2?.text
              }
            };
          } else if (msg2.msg_type === 3) {
            return {
              type: "image",
              data: {
                url: msg2?.image_url
              }
            };
          }
          return void 0;
        }).filter((e) => e !== void 0)
      };
    }));
  }
}

const SchemaData$E = Type.Object({
  message_id: Type.Union([Type.Number(), Type.String()]),
  group_id: Type.Optional(Type.Union([Type.Number(), Type.String()])),
  user_id: Type.Optional(Type.Union([Type.Number(), Type.String()]))
});
class ForwardSingleMsg extends OneBotAction {
  async getTargetPeer(payload) {
    if (payload.user_id) {
      const peerUid = await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
      if (!peerUid) {
        throw new Error(`无法找到私聊对象${payload.user_id}`);
      }
      return { chatType: ChatType.KCHATTYPEC2C, peerUid };
    }
    return { chatType: ChatType.KCHATTYPEGROUP, peerUid: payload.group_id.toString() };
  }
  async _handle(payload) {
    const msg = MessageUnique.getMsgIdAndPeerByShortId(+payload.message_id);
    if (!msg) {
      throw new Error(`无法找到消息${payload.message_id}`);
    }
    const peer = await this.getTargetPeer(payload);
    const ret = await this.core.apis.MsgApi.forwardMsg(
      msg.Peer,
      peer,
      [msg.MsgId]
    );
    if (ret.result !== 0) {
      throw new Error(`转发消息失败 ${ret.errMsg}`);
    }
    return null;
  }
}
class ForwardFriendSingleMsg extends ForwardSingleMsg {
  payloadSchema = SchemaData$E;
  actionName = ActionName.ForwardFriendSingleMsg;
}
class ForwardGroupSingleMsg extends ForwardSingleMsg {
  payloadSchema = SchemaData$E;
  actionName = ActionName.ForwardGroupSingleMsg;
}

class GetFriendWithCategory extends OneBotAction {
  actionName = ActionName.GetFriendsWithCategory;
  async _handle(payload) {
    return (await this.core.apis.FriendApi.getBuddyV2ExWithCate()).map((category) => ({
      ...category,
      buddyList: OB11Construct.friends(category.buddyList)
    }));
  }
}

Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  content: Type.String(),
  image: Type.Optional(Type.String()),
  pinned: Type.Union([Type.Number(), Type.String()], { default: 0 }),
  type: Type.Union([Type.Number(), Type.String()], { default: 1 }),
  confirm_required: Type.Union([Type.Number(), Type.String()], { default: 1 }),
  is_show_edit_card: Type.Union([Type.Number(), Type.String()], { default: 0 }),
  tip_window_type: Type.Union([Type.Number(), Type.String()], { default: 0 })
});
class SendGroupNotice extends OneBotAction {
  actionName = ActionName.GoCQHTTP_SendGroupNotice;
  async _handle(payload) {
    let UploadImage = void 0;
    if (payload.image) {
      const {
        path,
        success
      } = await uriToLocalFile(this.core.NapCatTempPath, payload.image);
      if (!success) {
        throw new Error(`群公告${payload.image}设置失败,image字段可能格式不正确`);
      }
      if (!path) {
        throw new Error(`群公告${payload.image}设置失败,获取资源失败`);
      }
      await checkFileExist(path, 5e3);
      const ImageUploadResult = await this.core.apis.GroupApi.uploadGroupBulletinPic(payload.group_id.toString(), path);
      if (ImageUploadResult.errCode != 0) {
        throw new Error(`群公告${payload.image}设置失败,图片上传失败`);
      }
      unlink(path).catch(() => {
      });
      UploadImage = ImageUploadResult.picInfo;
    }
    const publishGroupBulletinResult = await this.core.apis.WebApi.setGroupNotice(
      payload.group_id.toString(),
      payload.content,
      +payload.pinned,
      +payload.type,
      +payload.is_show_edit_card,
      +payload.tip_window_type,
      +payload.confirm_required,
      UploadImage?.id,
      UploadImage?.width,
      UploadImage?.height
    );
    if (!publishGroupBulletinResult || publishGroupBulletinResult.ec != 0) {
      throw new Error(`设置群公告失败,错误信息:${publishGroupBulletinResult?.em}`);
    }
    return null;
  }
}

const SchemaData$D = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  type: Type.Optional(Type.Enum(WebHonorType))
});
class GetGroupHonorInfo extends OneBotAction {
  actionName = ActionName.GetGroupHonorInfo;
  payloadSchema = SchemaData$D;
  async _handle(payload) {
    if (!payload.type) {
      payload.type = WebHonorType.ALL;
    }
    return await this.core.apis.WebApi.getGroupHonorInfo(payload.group_id.toString(), payload.type);
  }
}

class GoCQHTTPHandleQuickAction extends OneBotAction {
  actionName = ActionName.GoCQHTTP_HandleQuickAction;
  async _handle(payload) {
    this.obContext.apis.QuickActionApi.handleQuickOperation(payload.context, payload.operation).catch((e) => this.core.context.logger.logError(e));
    return null;
  }
}

class GetGroupIgnoredNotifies extends OneBotAction {
  actionName = ActionName.GetGroupIgnoredNotifies;
  async _handle() {
    const SingleScreenNotifies = await this.core.apis.GroupApi.getSingleScreenNotifies(false, 50);
    const retData = { InvitedRequest: [], join_requests: [] };
    const notifyPromises = SingleScreenNotifies.map(async (SSNotify) => {
      const invitorUin = SSNotify.user1?.uid ? +await this.core.apis.UserApi.getUinByUidV2(SSNotify.user1.uid) : 0;
      const actorUin = SSNotify.user2?.uid ? +await this.core.apis.UserApi.getUinByUidV2(SSNotify.user2.uid) : 0;
      const commonData = {
        request_id: +SSNotify.seq,
        invitor_uin: invitorUin,
        invitor_nick: SSNotify.user1?.nickName,
        group_id: +SSNotify.group?.groupCode,
        message: SSNotify?.postscript,
        group_name: SSNotify.group?.groupName,
        checked: SSNotify.status !== GroupNotifyMsgStatus.KUNHANDLE,
        actor: actorUin,
        requester_nick: SSNotify.user1?.nickName
      };
      if (SSNotify.type === 1) {
        retData.InvitedRequest.push(commonData);
      } else if (SSNotify.type === 7) {
        retData.join_requests.push(commonData);
      }
    });
    await Promise.all(notifyPromises);
    return retData;
  }
}

class GetOnlineClient extends OneBotAction {
  actionName = ActionName.GetOnlineClient;
  async _handle(payload) {
    this.core.apis.SystemApi.getOnlineDev();
    await sleep(500);
    return [];
  }
}

const SchemaData$C = Type.Object({
  image: Type.String()
});
class OCRImage extends OneBotAction {
  actionName = ActionName.OCRImage;
  payloadSchema = SchemaData$C;
  async _handle(payload) {
    const { path, success } = await uriToLocalFile(this.core.NapCatTempPath, payload.image);
    if (!success) {
      throw new Error(`OCR ${payload.image}失败,image字段可能格式不正确`);
    }
    if (path) {
      await checkFileExist(path, 5e3);
      const ret = await this.core.apis.SystemApi.ocrImage(path);
      fs__default.unlink(path, () => {
      });
      if (!ret) {
        throw new Error(`OCR ${payload.image}失败`);
      }
      return ret.result;
    }
    fs__default.unlink(path, () => {
    });
    throw new Error(`OCR ${payload.image}失败,文件可能不存在`);
  }
}
class IOCRImage extends OCRImage {
  actionName = ActionName.IOCRImage;
}

const SchemaData$B = Type.Object({
  words: Type.Array(Type.String())
});
class TranslateEnWordToZn extends OneBotAction {
  actionName = ActionName.TranslateEnWordToZn;
  payloadSchema = SchemaData$B;
  async _handle(payload) {
    const ret = await this.core.apis.SystemApi.translateEnWordToZn(payload.words);
    if (ret.result !== 0) {
      throw new Error("翻译失败");
    }
    return ret.words;
  }
}

const SchemaData$A = Type.Object({
  nickname: Type.String(),
  personal_note: Type.Optional(Type.String()),
  sex: Type.Optional(Type.Union([Type.Number(), Type.String()]))
  // 传Sex值？建议传0
});
class SetQQProfile extends OneBotAction {
  actionName = ActionName.SetQQProfile;
  payloadSchema = SchemaData$A;
  async _handle(payload) {
    const self = this.core.selfInfo;
    const OldProfile = await this.core.apis.UserApi.getUserDetailInfo(self.uid);
    return await this.core.apis.UserApi.modifySelfProfile({
      nick: payload.nickname,
      longNick: (payload?.personal_note ?? OldProfile?.longNick) || "",
      sex: parseInt(payload?.sex ? payload?.sex.toString() : OldProfile?.sex.toString()),
      birthday: {
        birthday_year: OldProfile?.birthday_year.toString(),
        birthday_month: OldProfile?.birthday_month.toString(),
        birthday_day: OldProfile?.birthday_day.toString()
      },
      location: void 0
    });
  }
}

const SchemaData$z = Type.Object({
  user_id: Type.Optional(Type.Union([Type.Number(), Type.String()])),
  group_id: Type.Optional(Type.Union([Type.Number(), Type.String()])),
  phoneNumber: Type.String({ default: "" })
});
class SharePeer extends OneBotAction {
  actionName = ActionName.SharePeer;
  payloadSchema = SchemaData$z;
  async _handle(payload) {
    if (payload.group_id) {
      return await this.core.apis.GroupApi.getGroupRecommendContactArkJson(payload.group_id.toString());
    } else if (payload.user_id) {
      return await this.core.apis.UserApi.getBuddyRecommendContactArkJson(payload.user_id.toString(), payload.phoneNumber);
    }
  }
}
const SchemaDataGroupEx = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()])
});
class ShareGroupEx extends OneBotAction {
  actionName = ActionName.ShareGroupEx;
  payloadSchema = SchemaDataGroupEx;
  async _handle(payload) {
    return await this.core.apis.GroupApi.getArkJsonGroupShare(payload.group_id.toString());
  }
}

const SchemaData$y = Type.Object({
  rawData: Type.String(),
  brief: Type.String()
});
class CreateCollection extends OneBotAction {
  actionName = ActionName.CreateCollection;
  payloadSchema = SchemaData$y;
  async _handle(payload) {
    return await this.core.apis.CollectionApi.createCollection(
      this.core.selfInfo.uin,
      this.core.selfInfo.uid,
      this.core.selfInfo.nick,
      payload.brief,
      payload.rawData
    );
  }
}

const SchemaData$x = Type.Object({
  longNick: Type.String()
});
class SetLongNick extends OneBotAction {
  actionName = ActionName.SetLongNick;
  payloadSchema = SchemaData$x;
  async _handle(payload) {
    return await this.core.apis.UserApi.setLongNick(payload.longNick);
  }
}

const SchemaData$w = Type.Object({
  message_id: Type.Union([Type.Number(), Type.String()])
});
class DelEssenceMsg extends OneBotAction {
  actionName = ActionName.DelEssenceMsg;
  payloadSchema = SchemaData$w;
  async _handle(payload) {
    const msg = MessageUnique.getMsgIdAndPeerByShortId(+payload.message_id);
    if (!msg) {
      const data = this.core.apis.GroupApi.essenceLRU.getValue(+payload.message_id);
      if (!data) throw new Error("消息不存在");
      const { msg_seq, msg_random, group_id } = JSON.parse(data);
      return await this.core.apis.GroupApi.removeGroupEssenceBySeq(group_id, msg_seq, msg_random);
    }
    return await this.core.apis.GroupApi.removeGroupEssence(
      msg.Peer.peerUid,
      msg.MsgId
    );
  }
}

const SchemaData$v = Type.Object({
  message_id: Type.Union([Type.Number(), Type.String()])
});
class SetEssenceMsg extends OneBotAction {
  actionName = ActionName.SetEssenceMsg;
  payloadSchema = SchemaData$v;
  async _handle(payload) {
    const msg = MessageUnique.getMsgIdAndPeerByShortId(+payload.message_id);
    if (!msg) {
      throw new Error("msg not found");
    }
    return await this.core.apis.GroupApi.addGroupEssence(
      msg.Peer.peerUid,
      msg.MsgId
    );
  }
}

const SchemaData$u = Type.Object({
  count: Type.Union([Type.Number(), Type.String()], { default: 10 })
});
class GetRecentContact extends OneBotAction {
  actionName = ActionName.GetRecentContact;
  payloadSchema = SchemaData$u;
  async _handle(payload, adapter) {
    const ret = await this.core.apis.UserApi.getRecentContactListSnapShot(+payload.count);
    const network = Object.values(this.obContext.configLoader.configData.network);
    const msgFormat = network.flat().find((e) => e.name === adapter)?.messagePostFormat ?? "array";
    return await Promise.all(ret.info.changedList.map(async (t) => {
      const FastMsg = await this.core.apis.MsgApi.getMsgsByMsgId({ chatType: t.chatType, peerUid: t.peerUid }, [t.msgId]);
      if (FastMsg.msgList.length > 0) {
        const lastestMsg = await this.obContext.apis.MsgApi.parseMessage(FastMsg.msgList[0], msgFormat);
        return {
          lastestMsg,
          peerUin: t.peerUin,
          remark: t.remark,
          msgTime: t.msgTime,
          chatType: t.chatType,
          msgId: t.msgId,
          sendNickName: t.sendNickName,
          sendMemberName: t.sendMemberName,
          peerName: t.peerName
        };
      }
      return {
        peerUin: t.peerUin,
        remark: t.remark,
        msgTime: t.msgTime,
        chatType: t.chatType,
        msgId: t.msgId,
        sendNickName: t.sendNickName,
        sendMemberName: t.sendMemberName,
        peerName: t.peerName
      };
    }));
  }
}

const SchemaData$t = Type.Object({
  user_id: Type.Optional(Type.Union([Type.Number(), Type.String()])),
  start: Type.Union([Type.Number(), Type.String()], { default: 0 }),
  count: Type.Union([Type.Number(), Type.String()], { default: 10 }),
  type: Type.Union([Type.Number(), Type.String()], { default: 2 })
});
class GetProfileLike extends OneBotAction {
  actionName = ActionName.GetProfileLike;
  payloadSchema = SchemaData$t;
  async _handle(payload) {
    const user_uid = this.core.selfInfo.uin === payload.user_id || !payload.user_id ? this.core.selfInfo.uid : await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
    const ret = await this.core.apis.UserApi.getProfileLike(user_uid ?? this.core.selfInfo.uid, +payload.start, +payload.count, +payload.type);
    const listdata = ret.info.userLikeInfos[0].voteInfo.userInfos;
    for (const item of listdata) {
      item.uin = +(await this.core.apis.UserApi.getUinByUidV2(item.uid) ?? "");
    }
    return ret.info.userLikeInfos[0].voteInfo;
  }
}

const SchemaData$s = Type.Object({
  file: Type.String(),
  group_id: Type.Union([Type.Number(), Type.String()])
});
class SetGroupPortrait extends OneBotAction {
  actionName = ActionName.SetGroupPortrait;
  payloadSchema = SchemaData$s;
  async _handle(payload) {
    const { path, success } = await uriToLocalFile(this.core.NapCatTempPath, payload.file);
    if (!success) {
      throw new Error(`头像${payload.file}设置失败,file字段可能格式不正确`);
    }
    if (path) {
      await checkFileExistV2(path, 5e3);
      const ret = await this.core.apis.GroupApi.setGroupAvatar(payload.group_id.toString(), path);
      fs$2.unlink(path).catch(() => {
      });
      if (!ret) {
        throw new Error(`头像${payload.file}设置失败,api无返回`);
      }
      if (ret.result == 1004022) {
        throw new Error(`头像${payload.file}设置失败，文件可能不是图片格式或权限不足`);
      } else if (ret.result != 0) {
        throw new Error(`头像${payload.file}设置失败,未知的错误,${ret.result}:${ret.errMsg}`);
      }
      return ret;
    } else {
      fs$2.unlink(path).catch(() => {
      });
      throw new Error(`头像${payload.file}设置失败,无法获取头像,文件可能不存在`);
    }
  }
}

const SchemaData$r = Type.Object({
  count: Type.Union([Type.Number(), Type.String()], { default: 48 })
});
class FetchCustomFace extends OneBotAction {
  actionName = ActionName.FetchCustomFace;
  payloadSchema = SchemaData$r;
  async _handle(payload) {
    const ret = await this.core.apis.MsgApi.fetchFavEmojiList(+payload.count);
    return ret.emojiInfoList.map((e) => e.url);
  }
}

const SchemaData$q = Type.Object({
  user_id: Type.Union([Type.Number(), Type.String()]),
  file: Type.String(),
  name: Type.String()
});
class GoCQHTTPUploadPrivateFile extends OneBotAction {
  actionName = ActionName.GOCQHTTP_UploadPrivateFile;
  payloadSchema = SchemaData$q;
  async getPeer(payload) {
    if (payload.user_id) {
      const peerUid = await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
      if (!peerUid) {
        throw new Error(`私聊${payload.user_id}不存在`);
      }
      const isBuddy = await this.core.apis.FriendApi.isBuddy(peerUid);
      return { chatType: isBuddy ? ChatType.KCHATTYPEC2C : ChatType.KCHATTYPETEMPC2CFROMGROUP, peerUid };
    }
    throw new Error("缺少参数 user_id");
  }
  async _handle(payload) {
    let file = payload.file;
    if (fs__default.existsSync(file)) {
      file = `file://${file}`;
    }
    const downloadResult = await uriToLocalFile(this.core.NapCatTempPath, file);
    if (!downloadResult.success) {
      throw new Error(downloadResult.errMsg);
    }
    const msgContext = {
      peer: await createContext(this.core, {
        user_id: payload.user_id.toString(),
        group_id: void 0
      }, ContextMode.Private),
      deleteAfterSentFiles: []
    };
    const sendFileEle = await this.core.apis.FileApi.createValidSendFileElement(msgContext, downloadResult.path, payload.name);
    await this.obContext.apis.MsgApi.sendMsgWithOb11UniqueId(await this.getPeer(payload), [sendFileEle], msgContext.deleteAfterSentFiles, true);
    return null;
  }
}

const SchemaData$p = Type.Object({
  message_id: Type.Union([Type.Number(), Type.String()]),
  emojiId: Type.Union([Type.Number(), Type.String()]),
  emojiType: Type.Union([Type.Number(), Type.String()]),
  count: Type.Union([Type.Number(), Type.String()], { default: 20 })
});
class FetchEmojiLike extends OneBotAction {
  actionName = ActionName.FetchEmojiLike;
  payloadSchema = SchemaData$p;
  async _handle(payload) {
    const msgIdPeer = MessageUnique.getMsgIdAndPeerByShortId(+payload.message_id);
    if (!msgIdPeer) throw new Error("消息不存在");
    const msg = (await this.core.apis.MsgApi.getMsgsByMsgId(msgIdPeer.Peer, [msgIdPeer.MsgId])).msgList[0];
    return await this.core.apis.MsgApi.getMsgEmojiLikesList(
      msgIdPeer.Peer,
      msg.msgSeq,
      payload.emojiId.toString(),
      payload.emojiType.toString(),
      +payload.count
    );
  }
}

Type.Object({
  user_id: Type.Union([Type.Number(), Type.String()])
});
class FetchUserProfileLike extends OneBotAction {
  actionName = ActionName.FetchUserProfileLike;
  async _handle(payload) {
    return await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
  }
}

Type.Object({
  user_id: Type.Union([Type.Number(), Type.String()]),
  event_type: Type.Number()
});
class SetInputStatus extends OneBotAction {
  actionName = ActionName.SetInputStatus;
  async _handle(payload) {
    const uid = await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
    if (!uid) throw new Error("uid is empty");
    const peer = {
      chatType: ChatType.KCHATTYPEC2C,
      peerUid: uid
    };
    return await this.core.apis.MsgApi.sendShowInputStatusReq(peer, payload.event_type);
  }
}

class GetCSRF extends OneBotAction {
  actionName = ActionName.GetCSRF;
  async _handle(payload) {
    const sKey = await this.core.apis.UserApi.getSKey();
    if (!sKey) {
      throw new Error("SKey is undefined");
    }
    return {
      token: +this.core.apis.WebApi.getBknFromSKey(sKey)
    };
  }
}

const SchemaData$o = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  notice_id: Type.String()
});
class DelGroupNotice extends OneBotAction {
  actionName = ActionName.DelGroupNotice;
  payloadSchema = SchemaData$o;
  async _handle(payload) {
    const group = payload.group_id.toString();
    const noticeId = payload.notice_id;
    return await this.core.apis.GroupApi.deleteGroupBulletin(group, noticeId);
  }
}

const SchemaData$n = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()])
});
class GetGroupInfoEx extends OneBotAction {
  actionName = ActionName.GetGroupInfoEx;
  payloadSchema = SchemaData$n;
  async _handle(payload) {
    return (await this.core.apis.GroupApi.getGroupExtFE0Info([payload.group_id.toString()])).result.groupExtInfos.get(payload.group_id.toString());
  }
}

const SchemaData$m = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  file_id: Type.String()
});
class DeleteGroupFile extends OneBotAction {
  actionName = ActionName.GOCQHTTP_DeleteGroupFile;
  payloadSchema = SchemaData$m;
  async _handle(payload) {
    const data = FileNapCatOneBotUUID.decodeModelId(payload.file_id);
    if (!data) throw new Error("Invalid file_id");
    return await this.core.apis.GroupApi.delGroupFile(payload.group_id.toString(), [data.fileId]);
  }
}

const SchemaData$l = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  folder_name: Type.String()
});
class CreateGroupFileFolder extends OneBotAction {
  actionName = ActionName.GoCQHTTP_CreateGroupFileFolder;
  payloadSchema = SchemaData$l;
  async _handle(payload) {
    return (await this.core.apis.GroupApi.creatGroupFileFolder(payload.group_id.toString(), payload.folder_name)).resultWithGroupItem;
  }
}

const SchemaData$k = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  folder_id: Type.Optional(Type.String()),
  folder: Type.Optional(Type.String())
});
class DeleteGroupFileFolder extends OneBotAction {
  actionName = ActionName.GoCQHTTP_DeleteGroupFileFolder;
  payloadSchema = SchemaData$k;
  async _handle(payload) {
    return (await this.core.apis.GroupApi.delGroupFileFolder(
      payload.group_id.toString(),
      payload.folder ?? payload.folder_id ?? ""
    )).groupFileCommonResult;
  }
}

const SchemaData$j = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()])
});
class GetGroupFileSystemInfo extends OneBotAction {
  actionName = ActionName.GoCQHTTP_GetGroupFileSystemInfo;
  payloadSchema = SchemaData$j;
  async _handle(payload) {
    return {
      file_count: (await this.core.apis.GroupApi.getGroupFileCount([payload.group_id.toString()])).groupFileCounts[0],
      limit_count: 1e4,
      used_space: 0,
      total_space: 10 * 1024 * 1024 * 1024
    };
  }
}

const SchemaData$i = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  file_count: Type.Union([Type.Number(), Type.String()], { default: 50 })
});
class GetGroupRootFiles extends OneBotAction {
  actionName = ActionName.GoCQHTTP_GetGroupRootFiles;
  payloadSchema = SchemaData$i;
  async _handle(payload) {
    const ret = await this.core.apis.MsgApi.getGroupFileList(payload.group_id.toString(), {
      sortType: 1,
      fileCount: +payload.file_count,
      startIndex: 0,
      sortOrder: 2,
      showOnlinedocFolder: 0
    });
    return {
      files: ret.filter((item) => item.fileInfo).map((item) => OB11Construct.file(item.peerId, item.fileInfo)),
      folders: ret.filter((item) => item.folderInfo).map((item) => OB11Construct.folder(item.peerId, item.folderInfo))
    };
  }
}

const SchemaData$h = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  folder_id: Type.Optional(Type.String()),
  folder: Type.Optional(Type.String()),
  file_count: Type.Union([Type.Number(), Type.String()], { default: 50 })
});
class GetGroupFilesByFolder extends OneBotAction {
  actionName = ActionName.GoCQHTTP_GetGroupFilesByFolder;
  payloadSchema = SchemaData$h;
  async _handle(payload) {
    const ret = await this.core.apis.MsgApi.getGroupFileList(payload.group_id.toString(), {
      sortType: 1,
      fileCount: +payload.file_count,
      startIndex: 0,
      sortOrder: 2,
      showOnlinedocFolder: 0,
      folderId: payload.folder ?? payload.folder_id ?? ""
    }).catch(() => []);
    return {
      files: ret.filter((item) => item.fileInfo).map((item) => OB11Construct.file(item.peerId, item.fileInfo)),
      folders: []
    };
  }
}

class GetGroupSystemMsg extends OneBotAction {
  actionName = ActionName.GetGroupSystemMsg;
  async _handle() {
    const SingleScreenNotifies = await this.core.apis.GroupApi.getSingleScreenNotifies(false, 50);
    const retData = { InvitedRequest: [], join_requests: [] };
    const notifyPromises = SingleScreenNotifies.map(async (SSNotify) => {
      const invitorUin = SSNotify.user1?.uid ? +await this.core.apis.UserApi.getUinByUidV2(SSNotify.user1.uid) : 0;
      const actorUin = SSNotify.user2?.uid ? +await this.core.apis.UserApi.getUinByUidV2(SSNotify.user2.uid) : 0;
      const commonData = {
        request_id: +SSNotify.seq,
        invitor_uin: invitorUin,
        invitor_nick: SSNotify.user1?.nickName,
        group_id: +SSNotify.group?.groupCode,
        message: SSNotify?.postscript,
        group_name: SSNotify.group?.groupName,
        checked: SSNotify.status !== GroupNotifyMsgStatus.KUNHANDLE,
        actor: actorUin,
        requester_nick: SSNotify.user1?.nickName
      };
      if (SSNotify.type === 1) {
        retData.InvitedRequest.push(commonData);
      } else if (SSNotify.type === 7) {
        retData.join_requests.push(commonData);
      }
    });
    await Promise.all(notifyPromises);
    return retData;
  }
}

class GetPacketStatusDepends extends OneBotAction {
  actionName = ActionName.GetPacketStatus;
  async check(payload) {
    if (!this.core.apis.PacketApi.available) {
      return {
        valid: false,
        message: "packetBackend不可用，请参照文档 https://napneko.github.io/config/advanced 和启动日志检查packetBackend状态或进行配置！错误堆栈信息：" + this.core.apis.PacketApi.clientLogStack
      };
    }
    return await super.check(payload);
  }
}
class GetPacketStatus extends GetPacketStatusDepends {
  async _handle(payload) {
    return null;
  }
}

const SchemaData$g = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  user_id: Type.Union([Type.Number(), Type.String()])
});
class GroupPoke extends GetPacketStatusDepends {
  actionName = ActionName.GroupPoke;
  payloadSchema = SchemaData$g;
  async _handle(payload) {
    await this.core.apis.PacketApi.pkt.operation.GroupPoke(+payload.user_id, +payload.group_id);
  }
}

const SchemaData$f = Type.Object({
  user_id: Type.Union([Type.Number(), Type.String()])
});
class GetUserStatus extends GetPacketStatusDepends {
  actionName = ActionName.GetUserStatus;
  payloadSchema = SchemaData$f;
  async _handle(payload) {
    return await this.core.apis.PacketApi.pkt.operation.GetStrangerStatus(+payload.user_id);
  }
}

class GetRkey extends GetPacketStatusDepends {
  actionName = ActionName.GetRkey;
  async _handle() {
    return await this.core.apis.PacketApi.pkt.operation.FetchRkey();
  }
}

const SchemaData$e = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  user_id: Type.Union([Type.Number(), Type.String()]),
  special_title: Type.String()
});
class SetSpecialTittle extends GetPacketStatusDepends {
  actionName = ActionName.SetSpecialTittle;
  payloadSchema = SchemaData$e;
  async _handle(payload) {
    const uid = await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
    if (!uid) throw new Error("User not found");
    await this.core.apis.PacketApi.pkt.operation.SetGroupSpecialTitle(+payload.group_id, uid, payload.special_title);
  }
}

const SchemaData$d = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()])
});
class GetGroupShutList extends OneBotAction {
  actionName = ActionName.GetGroupShutList;
  payloadSchema = SchemaData$d;
  async _handle(payload) {
    return await this.core.apis.GroupApi.getGroupShutUpMemberList(payload.group_id.toString());
  }
}

const SchemaData$c = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  no_cache: Type.Optional(Type.Union([Type.Boolean(), Type.String()]))
});
class GetGroupMemberList extends OneBotAction {
  actionName = ActionName.GetGroupMemberList;
  payloadSchema = SchemaData$c;
  async _handle(payload) {
    const groupIdStr = payload.group_id.toString();
    const noCache = payload.no_cache ? this.stringToBoolean(payload.no_cache) : false;
    const memberCache = this.core.apis.GroupApi.groupMemberCache;
    let groupMembers = memberCache.get(groupIdStr);
    if (noCache || !groupMembers) {
      this.core.apis.GroupApi.refreshGroupMemberCache(groupIdStr).then().catch();
      groupMembers = memberCache.get(groupIdStr);
      if (!groupMembers) {
        throw new Error(`Failed to get group member list for group ${groupIdStr}`);
      }
    }
    const memberPromises = Array.from(groupMembers.values()).map(
      (item) => OB11Construct.groupMember(groupIdStr, item)
    );
    const _groupMembers = await Promise.all(memberPromises);
    const MemberMap = new Map(_groupMembers.map((member) => [member.user_id, member]));
    return Array.from(MemberMap.values());
  }
  stringToBoolean(str) {
    return typeof str === "boolean" ? str : str.toLowerCase() === "true";
  }
}

const SchemaData$b = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  file_id: Type.String()
});
class GetGroupFileUrl extends GetPacketStatusDepends {
  actionName = ActionName.GOCQHTTP_GetGroupFileUrl;
  payloadSchema = SchemaData$b;
  async _handle(payload) {
    const contextMsgFile = FileNapCatOneBotUUID.decode(payload.file_id) || FileNapCatOneBotUUID.decodeModelId(payload.file_id);
    if (contextMsgFile?.fileUUID) {
      return {
        url: await this.core.apis.PacketApi.pkt.operation.GetGroupFileUrl(+payload.group_id, contextMsgFile.fileUUID)
      };
    }
    throw new Error("real fileUUID not found!");
  }
}

const SchemaData$a = Type.Object({
  user_id: Type.Union([Type.Number(), Type.String()])
});
class FriendPoke extends GetPacketStatusDepends {
  actionName = ActionName.FriendPoke;
  payloadSchema = SchemaData$a;
  async _handle(payload) {
    await this.core.apis.PacketApi.pkt.operation.FriendPoke(+payload.user_id);
  }
}

const SchemaData$9 = Type.Object({
  domain: Type.String()
});
class GetCredentials extends OneBotAction {
  actionName = ActionName.GetCredentials;
  payloadSchema = SchemaData$9;
  async _handle(payload) {
    const cookiesObject = await this.core.apis.UserApi.getCookies(payload.domain);
    const cookies = Object.entries(cookiesObject).map(([key, value]) => `${key}=${value}`).join("; ");
    const bkn = cookiesObject?.skey ? this.core.apis.WebApi.getBknFromCookie(cookiesObject) : "";
    return { cookies, token: +bkn };
  }
}

const SchemaData$8 = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()])
});
class SetGroupSign extends GetPacketStatusDepends {
  actionName = ActionName.SetGroupSign;
  payloadSchema = SchemaData$8;
  async _handle(payload) {
    return await this.core.apis.PacketApi.pkt.operation.GroupSign(+payload.group_id);
  }
}
class SendGroupSign extends SetGroupSign {
  actionName = ActionName.SendGroupSign;
}

const SchemaData$7 = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()])
});
class GoCQHTTPGetGroupAtAllRemain extends OneBotAction {
  actionName = ActionName.GoCQHTTP_GetGroupAtAllRemain;
  payloadSchema = SchemaData$7;
  async _handle(payload) {
    const ret = await this.core.apis.GroupApi.getGroupRemainAtTimes(payload.group_id.toString());
    const data = {
      can_at_all: ret.atInfo.canAtAll,
      remain_at_all_count_for_group: ret.atInfo.RemainAtAllCountForGroup,
      remain_at_all_count_for_uin: ret.atInfo.RemainAtAllCountForUin
    };
    return data;
  }
}

const SchemaData$6 = Type.Object({
  url: Type.String()
});
class GoCQHTTPCheckUrlSafely extends OneBotAction {
  actionName = ActionName.GoCQHTTP_CheckUrlSafely;
  payloadSchema = SchemaData$6;
  async _handle(payload) {
    return { level: 1 };
  }
}

const SchemaData$5 = Type.Object({
  model: Type.String()
});
class GoCQHTTPGetModelShow extends OneBotAction {
  actionName = ActionName.GoCQHTTP_GetModelShow;
  payloadSchema = SchemaData$5;
  async _handle(payload) {
    if (!payload.model) {
      payload.model = "napcat";
    }
    return [{
      variants: {
        model_show: "napcat",
        need_pay: false
      }
    }];
  }
}

class GoCQHTTPSetModelShow extends OneBotAction {
  actionName = ActionName.GoCQHTTP_SetModelShow;
  async _handle(payload) {
    return null;
  }
}

const SchemaData$4 = Type.Object({
  friend_id: Type.Optional(Type.Union([Type.String(), Type.Number()])),
  user_id: Type.Optional(Type.Union([Type.String(), Type.Number()])),
  temp_block: Type.Optional(Type.Boolean()),
  temp_both_del: Type.Optional(Type.Boolean())
});
class GoCQHTTPDeleteFriend extends OneBotAction {
  actionName = ActionName.GoCQHTTP_DeleteFriend;
  payloadSchema = SchemaData$4;
  async _handle(payload) {
    const uin = payload.friend_id ?? payload.user_id ?? "";
    const uid = await this.core.apis.UserApi.getUidByUinV2(uin.toString());
    if (!uid) {
      return {
        valid: false,
        message: "好友不存在"
      };
    }
    const isBuddy = await this.core.apis.FriendApi.isBuddy(uid);
    if (!isBuddy) {
      return {
        valid: false,
        message: "不是好友"
      };
    }
    return await this.core.apis.FriendApi.delBuudy(uid, payload.temp_block, payload.temp_both_del);
  }
}

class MiniAppInfo {
  static sdkId = "V1_PC_MINISDK_99.99.99_1_APP_A";
  template;
  static appMap = /* @__PURE__ */ new Map();
  constructor(template) {
    this.template = template;
  }
  static get(name) {
    return this.appMap.get(name);
  }
  static Bili = new class extends MiniAppInfo {
    constructor() {
      super({
        sdkId: MiniAppInfo.sdkId,
        appId: "1109937557",
        scene: 1,
        templateType: 1,
        businessType: 0,
        verType: 3,
        shareType: 0,
        versionId: "cfc5f7b05b44b5956502edaecf9d2240",
        withShareTicket: 0,
        iconUrl: "https://miniapp.gtimg.cn/public/appicon/51f90239b78a2e4994c11215f4c4ba15_200.jpg"
      });
      MiniAppInfo.appMap.set("bili", this);
    }
  }();
  static WeiBo = new class extends MiniAppInfo {
    constructor() {
      super({
        sdkId: MiniAppInfo.sdkId,
        appId: "1109224783",
        scene: 1,
        templateType: 1,
        businessType: 0,
        verType: 3,
        shareType: 0,
        versionId: "e482a3cc4e574d9b772e96ba6eec9ba2",
        withShareTicket: 0,
        iconUrl: "https://miniapp.gtimg.cn/public/appicon/35bbb44dc68e65194cfacfb206b8f1f7_200.jpg"
      });
      MiniAppInfo.appMap.set("weibo", this);
    }
  }();
}
class MiniAppInfoHelper {
  static generateReq(custom, template) {
    return {
      ...custom,
      ...template
    };
  }
  static RawToSend(rawData) {
    return {
      ver: rawData.ver,
      prompt: rawData.prompt,
      config: rawData.config,
      app: rawData.appName,
      view: rawData.appView,
      meta: rawData.metaData,
      miniappShareOrigin: 3,
      miniappOpenRefer: "10002"
    };
  }
  static SendToRaw(data) {
    return {
      appName: data.app,
      appView: data.view,
      ver: data.ver,
      desc: data.meta.detail_1.desc,
      prompt: data.prompt,
      metaData: data.meta,
      config: data.config
    };
  }
}

const SchemaData$3 = Type.Union([
  Type.Object({
    type: Type.Union([Type.Literal("bili"), Type.Literal("weibo")]),
    title: Type.String(),
    desc: Type.String(),
    picUrl: Type.String(),
    jumpUrl: Type.String(),
    rawArkData: Type.Optional(Type.Union([Type.Boolean(), Type.String()]))
  }),
  Type.Object({
    title: Type.String(),
    desc: Type.String(),
    picUrl: Type.String(),
    jumpUrl: Type.String(),
    iconUrl: Type.String(),
    appId: Type.String(),
    scene: Type.Union([Type.Number(), Type.String()]),
    templateType: Type.Union([Type.Number(), Type.String()]),
    businessType: Type.Union([Type.Number(), Type.String()]),
    verType: Type.Union([Type.Number(), Type.String()]),
    shareType: Type.Union([Type.Number(), Type.String()]),
    versionId: Type.String(),
    sdkId: Type.String(),
    withShareTicket: Type.Union([Type.Number(), Type.String()]),
    rawArkData: Type.Optional(Type.Union([Type.Boolean(), Type.String()]))
  })
]);
class GetMiniAppArk extends GetPacketStatusDepends {
  actionName = ActionName.GetMiniAppArk;
  payloadSchema = SchemaData$3;
  async _handle(payload) {
    let reqParam;
    const customParams = {
      title: payload.title,
      desc: payload.desc,
      picUrl: payload.picUrl,
      jumpUrl: payload.jumpUrl
    };
    if ("type" in payload) {
      reqParam = MiniAppInfoHelper.generateReq(customParams, MiniAppInfo.get(payload.type).template);
    } else {
      const { appId, scene, iconUrl, templateType, businessType, verType, shareType, versionId, withShareTicket } = payload;
      reqParam = MiniAppInfoHelper.generateReq(
        customParams,
        {
          sdkId: payload.sdkId ?? MiniAppInfo.sdkId,
          appId,
          scene: +scene,
          iconUrl,
          templateType: +templateType,
          businessType: +businessType,
          verType: +verType,
          shareType: +shareType,
          versionId,
          withShareTicket: +withShareTicket
        }
      );
    }
    const arkData = await this.core.apis.PacketApi.pkt.operation.GetMiniAppAdaptShareInfo(reqParam);
    return {
      data: payload.rawArkData ? arkData : MiniAppInfoHelper.RawToSend(arkData)
    };
  }
}

var AIVoiceChatType = /* @__PURE__ */ ((AIVoiceChatType2) => {
  AIVoiceChatType2[AIVoiceChatType2["Unknown"] = 0] = "Unknown";
  AIVoiceChatType2[AIVoiceChatType2["Sound"] = 1] = "Sound";
  AIVoiceChatType2[AIVoiceChatType2["Sing"] = 2] = "Sing";
  return AIVoiceChatType2;
})(AIVoiceChatType || {});

const SchemaData$2 = Type.Object({
  character: Type.String(),
  group_id: Type.Union([Type.Number(), Type.String()]),
  text: Type.String()
});
class GetAiRecord extends GetPacketStatusDepends {
  actionName = ActionName.GetAiRecord;
  payloadSchema = SchemaData$2;
  async _handle(payload) {
    const rawRsp = await this.core.apis.PacketApi.pkt.operation.GetAiVoice(+payload.group_id, payload.character, payload.text, AIVoiceChatType.Sound);
    return await this.core.apis.PacketApi.pkt.operation.GetGroupPttUrl(+payload.group_id, rawRsp.msgInfoBody[0].index);
  }
}

const SchemaData$1 = Type.Object({
  character: Type.String(),
  group_id: Type.Union([Type.Number(), Type.String()]),
  text: Type.String()
});
class SendGroupAiRecord extends GetPacketStatusDepends {
  actionName = ActionName.SendGroupAiRecord;
  payloadSchema = SchemaData$1;
  async _handle(payload) {
    const rawRsp = await this.core.apis.PacketApi.pkt.operation.GetAiVoice(+payload.group_id, payload.character, payload.text, AIVoiceChatType.Sound);
    const url = await this.core.apis.PacketApi.pkt.operation.GetGroupPttUrl(+payload.group_id, rawRsp.msgInfoBody[0].index);
    const { path, errMsg, success } = await uriToLocalFile(this.core.NapCatTempPath, url);
    if (!success) {
      throw new Error(errMsg);
    }
    const peer = { chatType: ChatType.KCHATTYPEGROUP, peerUid: payload.group_id.toString() };
    const element = await this.core.apis.FileApi.createValidSendPttElement(path);
    const sendRes = await this.obContext.apis.MsgApi.sendMsgWithOb11UniqueId(peer, [element], [path]);
    return { message_id: sendRes.id ?? -1 };
  }
}

const SchemaData = Type.Object({
  group_id: Type.Union([Type.Number(), Type.String()]),
  chat_type: Type.Union([Type.Union([Type.Number(), Type.String()])], { default: 1 })
});
class GetAiCharacters extends GetPacketStatusDepends {
  actionName = ActionName.GetAiCharacters;
  payloadSchema = SchemaData;
  async _handle(payload) {
    const rawList = await this.core.apis.PacketApi.pkt.operation.FetchAiVoiceList(+payload.group_id, +payload.chat_type);
    return rawList?.map((item) => ({
      type: item.category,
      characters: item.voices.map((voice) => ({
        character_id: voice.voiceId,
        character_name: voice.voiceDisplayName,
        preview_url: voice.voiceExampleUrl
      }))
    })) ?? [];
  }
}

class GetGuildList extends OneBotAction {
  actionName = ActionName.GetGuildList;
  async _handle(payload) {
    return null;
  }
}

class GetGuildProfile extends OneBotAction {
  actionName = ActionName.GetGuildProfile;
  async _handle(payload) {
    return null;
  }
}

function createActionMap(obContext, core) {
  const actionHandlers = [
    new GetGroupInfoEx(obContext, core),
    new FetchEmojiLike(obContext, core),
    new GetFile(obContext, core),
    new SetQQProfile(obContext, core),
    new ShareGroupEx(obContext, core),
    new SharePeer(obContext, core),
    new CreateCollection(obContext, core),
    new SetLongNick(obContext, core),
    new ForwardFriendSingleMsg(obContext, core),
    new ForwardGroupSingleMsg(obContext, core),
    new MarkGroupMsgAsRead(obContext, core),
    new MarkPrivateMsgAsRead(obContext, core),
    new SetAvatar(obContext, core),
    new TranslateEnWordToZn(obContext, core),
    new GetGroupRootFiles(obContext, core),
    new SetGroupSign(obContext, core),
    new SendGroupSign(obContext, core),
    // onebot11
    new SendLike(obContext, core),
    new GetMsg(obContext, core),
    new GetLoginInfo(obContext, core),
    new GetFriendList(obContext, core),
    new GetGroupList(obContext, core),
    new GetGroupInfo(obContext, core),
    new GetGroupMemberList(obContext, core),
    new GetGroupMemberInfo(obContext, core),
    new SendGroupMsg(obContext, core),
    new SendPrivateMsg(obContext, core),
    new SendMsg(obContext, core),
    new DeleteMsg(obContext, core),
    new SetGroupAddRequest(obContext, core),
    new SetFriendAddRequest(obContext, core),
    new SetGroupLeave(obContext, core),
    new GetVersionInfo(obContext, core),
    new CanSendRecord(obContext, core),
    new CanSendImage(obContext, core),
    new GetStatus(obContext, core),
    new SetGroupWholeBan(obContext, core),
    new SetGroupBan(obContext, core),
    new SetGroupKick(obContext, core),
    new SetGroupAdmin(obContext, core),
    new SetGroupName(obContext, core),
    new SetGroupCard(obContext, core),
    new GetImage(obContext, core),
    new GetRecord(obContext, core),
    new SetMsgEmojiLike(obContext, core),
    new GetCookies(obContext, core),
    new SetOnlineStatus(obContext, core),
    new GetRobotUinRange(obContext, core),
    new GetFriendWithCategory(obContext, core),
    //以下为go-cqhttp api
    new GoCQHTTPDeleteFriend(obContext, core),
    new GoCQHTTPCheckUrlSafely(obContext, core),
    new GetOnlineClient(obContext, core),
    new OCRImage(obContext, core),
    new IOCRImage(obContext, core),
    new GetGroupHonorInfo(obContext, core),
    new SendGroupNotice(obContext, core),
    new GetGroupNotice(obContext, core),
    new GetGroupEssence(obContext, core),
    new GoCQHTTPGetGroupAtAllRemain(obContext, core),
    new GoCQHTTPSendForwardMsg(obContext, core),
    new GoCQHTTPSendGroupForwardMsg(obContext, core),
    new GoCQHTTPSendPrivateForwardMsg(obContext, core),
    new GoCQHTTPGetStrangerInfo(obContext, core),
    new GoCQHTTPDownloadFile(obContext, core),
    new GetGuildList(obContext, core),
    new GoCQHTTPMarkMsgAsRead(obContext, core),
    new GoCQHTTPUploadGroupFile(obContext, core),
    new GoCQHTTPGetGroupMsgHistory(obContext, core),
    new GoCQHTTPGetForwardMsgAction(obContext, core),
    new GetFriendMsgHistory(obContext, core),
    new GoCQHTTPHandleQuickAction(obContext, core),
    new GetGroupIgnoredNotifies(obContext, core),
    new DelEssenceMsg(obContext, core),
    new SetEssenceMsg(obContext, core),
    new GetRecentContact(obContext, core),
    new MarkAllMsgAsRead(obContext, core),
    new GetProfileLike(obContext, core),
    new SetGroupPortrait(obContext, core),
    new FetchCustomFace(obContext, core),
    new GoCQHTTPUploadPrivateFile(obContext, core),
    new GetGuildProfile(obContext, core),
    new GoCQHTTPGetModelShow(obContext, core),
    new GoCQHTTPSetModelShow(obContext, core),
    new GoCQHTTPCheckUrlSafely(obContext, core),
    new SetInputStatus(obContext, core),
    new GetCSRF(obContext, core),
    new GetCredentials(obContext, core),
    new DelGroupNotice(obContext, core),
    new DeleteGroupFile(obContext, core),
    new CreateGroupFileFolder(obContext, core),
    new DeleteGroupFileFolder(obContext, core),
    new GetGroupFileSystemInfo(obContext, core),
    new GetGroupFilesByFolder(obContext, core),
    new GetGroupSystemMsg(obContext, core),
    new FetchUserProfileLike(obContext, core),
    new GetPacketStatus(obContext, core),
    new GroupPoke(obContext, core),
    new FriendPoke(obContext, core),
    new GetUserStatus(obContext, core),
    new GetRkey(obContext, core),
    new SetSpecialTittle(obContext, core),
    // new UploadForwardMsg(obContext, core),
    new GetGroupShutList(obContext, core),
    new GetGroupFileUrl(obContext, core),
    new GetMiniAppArk(obContext, core),
    new GetAiRecord(obContext, core),
    new SendGroupAiRecord(obContext, core),
    new GetAiCharacters(obContext, core)
  ];
  const actionMap = /* @__PURE__ */ new Map();
  for (const action of actionHandlers) {
    actionMap.set(action.actionName, action);
    actionMap.set(action.actionName + "_async", action);
    actionMap.set(action.actionName + "_rate_limited", action);
  }
  return actionMap;
}

const LoginRuntime = {
  LoginCurrentTime: Date.now(),
  LoginCurrentRate: 0,
  QQLoginStatus: false,
  //已实现 但太傻了 得去那边注册个回调刷新
  QQQRCodeURL: "",
  QQLoginUin: "",
  NapCatHelper: {
    onOB11ConfigChanged: async () => {
      return;
    },
    onQuickLoginRequested: async () => {
      return { result: false, message: "" };
    },
    QQLoginList: []
  }
};
const WebUiDataRuntime = {
  checkLoginRate: async function(RateLimit) {
    LoginRuntime.LoginCurrentRate++;
    if (Date.now() - LoginRuntime.LoginCurrentTime > 1e3 * 60) {
      LoginRuntime.LoginCurrentRate = 0;
      LoginRuntime.LoginCurrentTime = Date.now();
      return true;
    }
    return LoginRuntime.LoginCurrentRate <= RateLimit;
  },
  getQQLoginStatus: async function() {
    return LoginRuntime.QQLoginStatus;
  },
  setQQLoginStatus: async function(status) {
    LoginRuntime.QQLoginStatus = status;
  },
  setQQLoginQrcodeURL: async function(url) {
    LoginRuntime.QQQRCodeURL = url;
  },
  getQQLoginQrcodeURL: async function() {
    return LoginRuntime.QQQRCodeURL;
  },
  setQQLoginUin: async function(uin) {
    LoginRuntime.QQLoginUin = uin;
  },
  getQQLoginUin: async function() {
    return LoginRuntime.QQLoginUin;
  },
  getQQQuickLoginList: async function() {
    return LoginRuntime.NapCatHelper.QQLoginList;
  },
  setQQQuickLoginList: async function(list) {
    LoginRuntime.NapCatHelper.QQLoginList = list;
  },
  setQuickLoginCall(func) {
    LoginRuntime.NapCatHelper.onQuickLoginRequested = func;
  },
  requestQuickLogin: async function(uin) {
    return await LoginRuntime.NapCatHelper.onQuickLoginRequested(uin);
  },
  setOnOB11ConfigChanged: async function(func) {
    LoginRuntime.NapCatHelper.onOB11ConfigChanged = func;
  },
  setOB11Config: async function(ob11) {
    await LoginRuntime.NapCatHelper.onOB11ConfigChanged(ob11);
  }
};

class OB11InputStatusEvent extends OB11BaseNoticeEvent {
  notice_type = "notify";
  sub_type = "input_status";
  status_text = "对方正在输入...";
  event_type = 1;
  user_id = 0;
  group_id = 0;
  constructor(core, user_id, eventType, status_text) {
    super(core);
    this.user_id = user_id;
    this.event_type = eventType;
    this.status_text = status_text;
  }
}

class OB11FriendRequestEvent extends OB11BaseNoticeEvent {
  post_type = EventType.REQUEST;
  request_type = "friend";
  user_id;
  comment;
  flag;
  constructor(core, user_id, comment, flag) {
    super(core);
    this.user_id = user_id;
    this.comment = comment;
    this.flag = flag;
  }
}

class OB11GroupRequestEvent extends OB11GroupNoticeEvent {
  post_type = EventType.REQUEST;
  request_type = "group";
  user_id;
  comment;
  flag;
  sub_type;
  constructor(core, groupId, userId, sub_type, comment, flag) {
    super(core, groupId, userId);
    this.user_id = userId;
    this.sub_type = sub_type;
    this.comment = comment;
    this.flag = flag;
  }
}

class OB11FriendRecallNoticeEvent extends OB11BaseNoticeEvent {
  notice_type = "friend_recall";
  user_id;
  message_id;
  constructor(core, userId, messageId) {
    super(core);
    this.user_id = userId;
    this.message_id = messageId;
  }
}

class OB11GroupRecallNoticeEvent extends OB11GroupNoticeEvent {
  notice_type = "group_recall";
  operator_id;
  message_id;
  constructor(core, groupId, userId, operatorId, messageId) {
    super(core, groupId, userId);
    this.group_id = groupId;
    this.user_id = userId;
    this.operator_id = operatorId;
    this.message_id = messageId;
  }
}

class NodeIKernelRecentContactListener {
  onDeletedContactsNotify(...args) {
  }
  onRecentContactNotification(msgList, arg0, arg1) {
  }
  onMsgUnreadCountUpdate(...args) {
  }
  onGuildDisplayRecentContactListChanged(...args) {
  }
  onRecentContactListChanged(...args) {
  }
  onRecentContactListChangedVer2(...args) {
  }
}

class BotOfflineEvent extends OB11BaseNoticeEvent {
  notice_type = "bot_offline";
  user_id;
  tag = "BotOfflineEvent";
  message = "BotOfflineEvent";
  constructor(core, tag, message) {
    super(core);
    this.user_id = +core.selfInfo.uin;
    this.tag = tag;
    this.message = message;
  }
}

const createDefaultAdapterConfig = (config) => config;
const httpServerDefaultConfigs = createDefaultAdapterConfig({
  name: "http-server",
  enable: false,
  port: 3e3,
  host: "0.0.0.0",
  enableCors: true,
  enableWebsocket: true,
  messagePostFormat: "array",
  token: "",
  debug: false
});
const httpClientDefaultConfigs = createDefaultAdapterConfig({
  name: "http-client",
  enable: false,
  url: "http://localhost:8080",
  messagePostFormat: "array",
  reportSelfMessage: false,
  token: "",
  debug: false
});
const websocketServerDefaultConfigs = createDefaultAdapterConfig({
  name: "websocket-server",
  enable: false,
  host: "0.0.0.0",
  port: 3001,
  messagePostFormat: "array",
  reportSelfMessage: false,
  token: "",
  enableForcePushEvent: true,
  debug: false,
  heartInterval: 3e4
});
const websocketClientDefaultConfigs = createDefaultAdapterConfig({
  name: "websocket-client",
  enable: false,
  url: "ws://localhost:8082",
  messagePostFormat: "array",
  reportSelfMessage: false,
  reconnectInterval: 5e3,
  token: "",
  debug: false,
  heartInterval: 3e4
});
function mergeConfigs(defaultConfig, userConfig) {
  return { ...defaultConfig, ...userConfig };
}
const createDefaultConfig = (config) => config;
const defaultOneBotConfigs = createDefaultConfig({
  network: {
    httpServers: [],
    httpClients: [],
    websocketServers: [],
    websocketClients: []
  },
  musicSignUrl: "",
  enableLocalFile2Url: false,
  parseMultMsg: true
});
const mergeNetworkDefaultConfig = {
  httpServers: httpServerDefaultConfigs,
  httpClients: httpClientDefaultConfigs,
  websocketServers: websocketServerDefaultConfigs,
  websocketClients: websocketClientDefaultConfigs
};
function mergeOneBotConfigs(userConfig, defaultConfig = defaultOneBotConfigs) {
  const mergedConfig = { ...defaultConfig };
  if (userConfig.network) {
    mergedConfig.network = { ...defaultConfig.network };
    for (const key in userConfig.network) {
      const userNetworkConfig = userConfig.network[key];
      const defaultNetworkConfig = mergeNetworkDefaultConfig[key];
      if (Array.isArray(userNetworkConfig)) {
        mergedConfig.network[key] = userNetworkConfig.map(
          (e) => mergeConfigs(defaultNetworkConfig, e)
        );
      }
    }
  }
  if (userConfig.musicSignUrl !== void 0) {
    mergedConfig.musicSignUrl = userConfig.musicSignUrl;
  }
  if (userConfig.enableLocalFile2Url !== void 0) {
    mergedConfig.enableLocalFile2Url = userConfig.enableLocalFile2Url;
  }
  if (userConfig.parseMultMsg !== void 0) {
    mergedConfig.parseMultMsg = userConfig.parseMultMsg;
  }
  return mergedConfig;
}
function checkIsOneBotConfigV1(v1Config) {
  return v1Config.http !== void 0 || v1Config.ws !== void 0 || v1Config.reverseWs !== void 0;
}
function migrateOneBotConfigsV1(config) {
  if (!checkIsOneBotConfigV1(config)) {
    return config;
  }
  const mergedConfig = { ...defaultOneBotConfigs };
  if (config.http) {
    mergedConfig.network.httpServers = [
      mergeConfigs(httpServerDefaultConfigs, {
        name: "http-server",
        enable: config.http.enable,
        port: config.http.port,
        host: config.http.host,
        token: config.http.secret,
        debug: config.debug,
        messagePostFormat: config.messagePostFormat
      })
    ];
  }
  if (config.ws) {
    mergedConfig.network.websocketServers = [
      mergeConfigs(websocketServerDefaultConfigs, {
        name: "websocket-server",
        enable: config.ws.enable,
        port: config.ws.port,
        host: config.ws.host,
        token: config.token,
        debug: config.debug,
        messagePostFormat: config.messagePostFormat,
        reportSelfMessage: config.reportSelfMessage
      })
    ];
  }
  if (config.reverseWs) {
    mergedConfig.network.websocketClients = config.reverseWs.urls.map(
      (url) => mergeConfigs(websocketClientDefaultConfigs, {
        name: "websocket-client-" + config.reverseWs?.urls.indexOf(url).toString(),
        enable: config.reverseWs?.enable,
        url,
        token: config.token,
        debug: config.debug,
        messagePostFormat: config.messagePostFormat,
        reportSelfMessage: config.reportSelfMessage
      })
    );
  }
  if (config.heartInterval) {
    mergedConfig.network.websocketServers[0].heartInterval = config.heartInterval;
  }
  if (config.musicSignUrl) {
    mergedConfig.musicSignUrl = config.musicSignUrl;
  }
  if (config.enableLocalFile2Url) {
    mergedConfig.enableLocalFile2Url = config.enableLocalFile2Url;
  }
  return mergedConfig;
}

class NapCatOneBot11Adapter {
  core;
  context;
  configLoader;
  apis;
  networkManager;
  actions;
  bootTime = Date.now() / 1e3;
  recallMsgCache = new LRUCache(100);
  constructor(core, context, pathWrapper) {
    this.core = core;
    this.context = context;
    this.configLoader = new OB11ConfigLoader(core, pathWrapper.configPath);
    this.configLoader.save(migrateOneBotConfigsV1(this.configLoader.configData));
    this.configLoader.save(mergeOneBotConfigs(this.configLoader.configData));
    this.apis = {
      GroupApi: new OneBotGroupApi(this, core),
      UserApi: new OneBotUserApi(this, core),
      FriendApi: new OneBotFriendApi(this, core),
      MsgApi: new OneBotMsgApi(this, core),
      QuickActionApi: new OneBotQuickActionApi(this, core)
    };
    this.actions = createActionMap(this, core);
    this.networkManager = new OB11NetworkManager();
  }
  async creatOneBotLog(ob11Config) {
    let log = `[network] 配置加载
`;
    for (const key of ob11Config.network.httpServers) {
      log += `HTTP服务: ${key.host}:${key.port}, : ${key.enable ? "已启动" : "未启动"}
`;
    }
    for (const key of ob11Config.network.httpClients) {
      log += `HTTP上报服务: ${key.url}, : ${key.enable ? "已启动" : "未启动"}
`;
    }
    for (const key of ob11Config.network.websocketServers) {
      log += `WebSocket服务: ${key.host}:${key.port}, : ${key.enable ? "已启动" : "未启动"}
`;
    }
    for (const key of ob11Config.network.websocketClients) {
      log += `WebSocket反向服务: ${key.url}, : ${key.enable ? "已启动" : "未启动"}
`;
    }
    return log;
  }
  async InitOneBot() {
    const selfInfo = this.core.selfInfo;
    const ob11Config = this.configLoader.configData;
    this.core.apis.UserApi.getUserDetailInfo(selfInfo.uid).then((user) => {
      selfInfo.nick = user.nick;
      this.context.logger.setLogSelfInfo(selfInfo);
    }).catch((e) => this.context.logger.logError(e));
    const serviceInfo = await this.creatOneBotLog(ob11Config);
    this.context.logger.log(`[Notice] [OneBot11] ${serviceInfo}`);
    for (const key of ob11Config.network.httpServers) {
      if (key.enable) {
        this.networkManager.registerAdapter(
          new OB11PassiveHttpAdapter(key.name, key, this.core, this.actions)
        );
      }
    }
    for (const key of ob11Config.network.httpClients) {
      if (key.enable) {
        this.networkManager.registerAdapter(
          new OB11ActiveHttpAdapter(key.name, key, this.core, this, this.actions)
        );
      }
    }
    for (const key of ob11Config.network.websocketServers) {
      if (key.enable) {
        this.networkManager.registerAdapter(
          new OB11PassiveWebSocketAdapter(
            key.name,
            key,
            this.core,
            this.actions
          )
        );
      }
    }
    for (const key of ob11Config.network.websocketClients) {
      if (key.enable) {
        this.networkManager.registerAdapter(
          new OB11ActiveWebSocketAdapter(
            key.name,
            key,
            this.core,
            this.actions
          )
        );
      }
    }
    await this.networkManager.openAllAdapters();
    this.initMsgListener();
    this.initBuddyListener();
    this.initGroupListener();
    await WebUiDataRuntime.setQQLoginUin(selfInfo.uin.toString());
    await WebUiDataRuntime.setQQLoginStatus(true);
    await WebUiDataRuntime.setOnOB11ConfigChanged(async (newConfig) => {
      const prev = this.configLoader.configData;
      this.configLoader.save(newConfig);
      this.context.logger.log(`OneBot11 配置更改：${JSON.stringify(prev)} -> ${JSON.stringify(newConfig)}`);
      await this.reloadNetwork(prev, newConfig);
    });
  }
  initRecentContactListener() {
    const recentContactListener = new NodeIKernelRecentContactListener();
    recentContactListener.onRecentContactNotification = function(msgList) {
      msgList.forEach((msg) => {
        if (msg.chatType == ChatType.KCHATTYPEGROUP) ;
      });
    };
  }
  async reloadNetwork(prev, now) {
    const prevLog = await this.creatOneBotLog(prev);
    const newLog = await this.creatOneBotLog(now);
    this.context.logger.log(`[Notice] [OneBot11] 配置变更前:
${prevLog}`);
    this.context.logger.log(`[Notice] [OneBot11] 配置变更后:
${newLog}`);
    await this.handleConfigChange(prev.network.httpServers, now.network.httpServers, OB11PassiveHttpAdapter);
    await this.handleConfigChange(prev.network.httpClients, now.network.httpClients, OB11ActiveHttpAdapter);
    await this.handleConfigChange(prev.network.websocketServers, now.network.websocketServers, OB11PassiveWebSocketAdapter);
    await this.handleConfigChange(prev.network.websocketClients, now.network.websocketClients, OB11ActiveWebSocketAdapter);
  }
  async handleConfigChange(prevConfig, nowConfig, adapterClass) {
    for (const adapterConfig of prevConfig) {
      const existingAdapter = nowConfig.find((e) => e.name === adapterConfig.name);
      if (!existingAdapter) {
        const existingAdapter2 = this.networkManager.findSomeAdapter(adapterConfig.name);
        if (existingAdapter2) {
          await this.networkManager.closeSomeAdaterWhenOpen([existingAdapter2]);
        }
      }
    }
    for (const adapterConfig of nowConfig) {
      const existingAdapter = this.networkManager.findSomeAdapter(adapterConfig.name);
      if (existingAdapter) {
        const networkChange = await existingAdapter.reload(adapterConfig);
        if (networkChange === OB11NetworkReloadType.NetWorkClose) {
          await this.networkManager.closeSomeAdaterWhenOpen([existingAdapter]);
        }
      } else if (adapterConfig.enable) {
        const newAdapter = new adapterClass(adapterConfig.name, adapterConfig, this.core, this.actions);
        await this.networkManager.registerAdapterAndOpen(newAdapter);
      }
    }
  }
  initMsgListener() {
    const msgListener = new NodeIKernelMsgListener();
    msgListener.onRecvSysMsg = (msg) => {
      this.apis.MsgApi.parseSysMessage(msg).then((event) => {
        if (event) this.networkManager.emitEvent(event);
      }).catch(
        (e) => this.context.logger.logError(
          "constructSysMessage error: ",
          e,
          "\n Parse Hex:",
          Buffer.from(msg).toString("hex")
        )
      );
    };
    msgListener.onInputStatusPush = async (data) => {
      const uin = await this.core.apis.UserApi.getUinByUidV2(data.fromUin);
      this.context.logger.log(`[Notice] [输入状态] ${uin} ${data.statusText}`);
      await this.networkManager.emitEvent(
        new OB11InputStatusEvent(this.core, parseInt(uin), data.eventType, data.statusText)
      );
    };
    msgListener.onRecvMsg = async (msg) => {
      for (const m of msg) {
        if (this.bootTime > parseInt(m.msgTime)) {
          this.context.logger.logDebug(`消息时间${m.msgTime}早于启动时间${this.bootTime}，忽略上报`);
          continue;
        }
        m.id = MessageUnique.createUniqueMsgId(
          {
            chatType: m.chatType,
            peerUid: m.peerUid,
            guildId: ""
          },
          m.msgId
        );
        await this.emitMsg(m).catch(
          (e) => this.context.logger.logError("处理消息失败", e)
        );
      }
    };
    msgListener.onAddSendMsg = async (msg) => {
      try {
        if (msg.sendStatus == SendStatusType.KSEND_STATUS_SENDING) {
          const [updatemsgs] = await this.core.eventWrapper.registerListen("NodeIKernelMsgListener/onMsgInfoListUpdate", (msgList) => {
            const report = msgList.find(
              (e) => e.senderUin == this.core.selfInfo.uin && e.sendStatus !== SendStatusType.KSEND_STATUS_SENDING && e.msgId === msg.msgId
            );
            return !!report;
          }, 1, 10 * 60 * 1e3);
          const updatemsg = updatemsgs.find((e) => e.msgId === msg.msgId);
          if (updatemsg?.sendStatus == SendStatusType.KSEND_STATUS_SUCCESS || updatemsg?.sendStatus == SendStatusType.KSEND_STATUS_SUCCESS_NOSEQ) {
            updatemsg.id = MessageUnique.createUniqueMsgId(
              {
                chatType: updatemsg.chatType,
                peerUid: updatemsg.peerUid,
                guildId: ""
              },
              updatemsg.msgId
            );
            this.emitMsg(updatemsg);
          }
        }
      } catch (error) {
        this.context.logger.logError("处理发送消息失败", error);
      }
    };
    msgListener.onMsgRecall = async (chatType, uid, msgSeq) => {
      const peer = {
        chatType,
        peerUid: uid,
        guildId: ""
      };
      const msg = (await this.core.apis.MsgApi.queryMsgsWithFilterExWithSeq(peer, msgSeq)).msgList.find((e) => e.msgType == NTMsgType.KMSGTYPEGRAYTIPS);
      const element = msg?.elements[0];
      if (msg && element) {
        const recallEvent = await this.emitRecallMsg(msg, element);
        try {
          if (recallEvent) {
            await this.networkManager.emitEvent(recallEvent);
          }
        } catch (e) {
          this.context.logger.logError("处理消息撤回失败", e);
        }
      }
    };
    msgListener.onKickedOffLine = async (kick) => {
      const event = new BotOfflineEvent(this.core, kick.tipsTitle, kick.tipsDesc);
      this.networkManager.emitEvent(event).catch((e) => this.context.logger.logError("处理Bot掉线失败", e));
    };
    this.context.session.getMsgService().addKernelMsgListener(proxiedListenerOf(msgListener, this.context.logger));
  }
  initBuddyListener() {
    const buddyListener = new NodeIKernelBuddyListener();
    buddyListener.onBuddyReqChange = async (reqs) => {
      this.core.apis.FriendApi.clearBuddyReqUnreadCnt();
      for (let i = 0; i < reqs.unreadNums; i++) {
        const req = reqs.buddyReqs[i];
        if (!!req.isInitiator || req.isDecide && req.reqType !== BuddyReqType.KMEINITIATORWAITPEERCONFIRM) {
          continue;
        }
        try {
          const requesterUin = await this.core.apis.UserApi.getUinByUidV2(req.friendUid);
          await this.networkManager.emitEvent(
            new OB11FriendRequestEvent(
              this.core,
              +requesterUin,
              req.extWords,
              req.reqTime
            )
          );
        } catch (e) {
          this.context.logger.logDebug("获取加好友者QQ号失败", e);
        }
      }
    };
    this.context.session.getBuddyService().addKernelBuddyListener(proxiedListenerOf(buddyListener, this.context.logger));
  }
  initGroupListener() {
    const groupListener = new NodeIKernelGroupListener();
    groupListener.onGroupNotifiesUpdated = async (_, notifies) => {
      await this.core.apis.GroupApi.clearGroupNotifiesUnreadCount(false);
      if (![
        GroupNotifyMsgType.SET_ADMIN,
        GroupNotifyMsgType.CANCEL_ADMIN_NOTIFY_CANCELED,
        GroupNotifyMsgType.CANCEL_ADMIN_NOTIFY_ADMIN
      ].includes(notifies[0]?.type)) {
        for (const notify of notifies) {
          const notifyTime = parseInt(notify.seq) / 1e3 / 1e3;
          if (notifyTime < this.bootTime) {
            continue;
          }
          const flag = notify.seq;
          this.context.logger.logDebug("收到群通知", notify);
          if ([GroupNotifyMsgType.REQUEST_JOIN_NEED_ADMINI_STRATOR_PASS].includes(notify.type) && notify.status == GroupNotifyMsgStatus.KUNHANDLE) {
            this.context.logger.logDebug("有加群请求");
            try {
              let requestUin = await this.core.apis.UserApi.getUinByUidV2(notify.user1.uid);
              if (isNaN(parseInt(requestUin))) {
                requestUin = (await this.core.apis.UserApi.getUserDetailInfo(notify.user1.uid)).uin;
              }
              const groupRequestEvent = new OB11GroupRequestEvent(
                this.core,
                parseInt(notify.group.groupCode),
                parseInt(requestUin),
                "add",
                notify.postscript,
                flag
              );
              this.networkManager.emitEvent(groupRequestEvent).catch(
                (e) => this.context.logger.logError("处理加群请求失败", e)
              );
            } catch (e) {
              this.context.logger.logError(
                "获取加群人QQ号失败 Uid:",
                notify.user1.uid,
                e
              );
            }
          } else if (notify.type == GroupNotifyMsgType.INVITED_BY_MEMBER && notify.status == GroupNotifyMsgStatus.KUNHANDLE) {
            this.context.logger.logDebug(`收到邀请我加群通知:${notify}`);
            const groupInviteEvent = new OB11GroupRequestEvent(
              this.core,
              +notify.group.groupCode,
              +await this.core.apis.UserApi.getUinByUidV2(notify.user2.uid),
              "invite",
              notify.postscript,
              flag
            );
            this.networkManager.emitEvent(groupInviteEvent).catch(
              (e) => this.context.logger.logError("处理邀请本人加群失败", e)
            );
          } else if (notify.type == GroupNotifyMsgType.INVITED_NEED_ADMINI_STRATOR_PASS && notify.status == GroupNotifyMsgStatus.KUNHANDLE) {
            this.context.logger.logDebug(`收到群员邀请加群通知:${notify}`);
            const groupInviteEvent = new OB11GroupRequestEvent(
              this.core,
              +notify.group.groupCode,
              +await this.core.apis.UserApi.getUinByUidV2(notify.user1.uid),
              "add",
              notify.postscript,
              flag
            );
            this.networkManager.emitEvent(groupInviteEvent).catch(
              (e) => this.context.logger.logError("处理邀请本人加群失败", e)
            );
          }
        }
      }
    };
    this.context.session.getGroupService().addKernelGroupListener(proxiedListenerOf(groupListener, this.context.logger));
  }
  async emitMsg(message) {
    const network = Object.values(this.configLoader.configData.network).flat();
    this.context.logger.logDebug("收到新消息 RawMessage", message);
    await Promise.allSettled([
      this.handleMsg(message, network),
      message.chatType == ChatType.KCHATTYPEGROUP ? this.handleGroupEvent(message) : this.handlePrivateMsgEvent(message)
    ]);
  }
  async handleMsg(message, network) {
    try {
      const ob11Msg = await this.apis.MsgApi.parseMessageV2(message, this.configLoader.configData.parseMultMsg);
      if (ob11Msg) {
        const isSelfMsg = this.isSelfMessage(ob11Msg);
        this.context.logger.logDebug("转化为 OB11Message", ob11Msg);
        const msgMap = this.createMsgMap(network, ob11Msg, isSelfMsg, message);
        this.handleDebugNetwork(network, msgMap, message);
        this.handleNotReportSelfNetwork(network, msgMap, isSelfMsg);
        this.networkManager.emitEventByNames(msgMap);
      }
    } catch (e) {
      this.context.logger.logError("constructMessage error: ", e);
    }
  }
  isSelfMessage(ob11Msg) {
    return ob11Msg.stringMsg.user_id.toString() == this.core.selfInfo.uin || ob11Msg.arrayMsg.user_id.toString() == this.core.selfInfo.uin;
  }
  createMsgMap(network, ob11Msg, isSelfMsg, message) {
    const msgMap = /* @__PURE__ */ new Map();
    network.filter((e) => e.enable).forEach((e) => {
      if (isSelfMsg || message.chatType !== ChatType.KCHATTYPEGROUP) {
        ob11Msg.stringMsg.target_id = parseInt(message.peerUin);
        ob11Msg.arrayMsg.target_id = parseInt(message.peerUin);
      }
      if (e.messagePostFormat == "string") {
        msgMap.set(e.name, structuredClone(ob11Msg.stringMsg));
      } else {
        msgMap.set(e.name, structuredClone(ob11Msg.arrayMsg));
      }
    });
    return msgMap;
  }
  handleDebugNetwork(network, msgMap, message) {
    const debugNetwork = network.filter((e) => e.enable && e.debug);
    if (debugNetwork.length > 0) {
      debugNetwork.forEach((adapter) => {
        const msg = msgMap.get(adapter.name);
        if (msg) {
          msg.raw = message;
        }
      });
    } else if (msgMap.size === 0) {
      return;
    }
  }
  handleNotReportSelfNetwork(network, msgMap, isSelfMsg) {
    if (isSelfMsg) {
      const notReportSelfNetwork = network.filter((e) => e.enable && ("reportSelfMessage" in e && !e.reportSelfMessage || !("reportSelfMessage" in e)));
      notReportSelfNetwork.forEach((adapter) => {
        msgMap.delete(adapter.name);
      });
    }
  }
  async handleGroupEvent(message) {
    try {
      if (message.senderUin && message.senderUin !== "0") {
        const cardChangedEvent = await this.apis.GroupApi.parseCardChangedEvent(message);
        if (cardChangedEvent) {
          await this.networkManager.emitEvent(cardChangedEvent);
        }
      }
      if (message.msgType === NTMsgType.KMSGTYPEFILE) {
        const elementWrapper = message.elements.find((e) => !!e.fileElement);
        if (elementWrapper?.fileElement) {
          const uploadGroupFileEvent = await this.apis.GroupApi.parseGroupUploadFileEvene(message, elementWrapper.fileElement, elementWrapper);
          if (uploadGroupFileEvent) {
            await this.networkManager.emitEvent(uploadGroupFileEvent);
          }
        }
      } else if (message.msgType === NTMsgType.KMSGTYPEGRAYTIPS) {
        const grayTipElement = message.elements[0].grayTipElement;
        if (grayTipElement) {
          const event = await this.apis.GroupApi.parseGrayTipElement(message, grayTipElement);
          if (event) {
            await this.networkManager.emitEvent(event);
          }
        }
      }
    } catch (e) {
      this.context.logger.logError("constructGroupEvent error: ", e);
    }
  }
  async handlePrivateMsgEvent(message) {
    try {
      if (message.msgType === NTMsgType.KMSGTYPEGRAYTIPS) {
        const grayTipElement = message.elements[0].grayTipElement;
        if (grayTipElement) {
          const event = await this.apis.MsgApi.parsePrivateMsgEvent(message, grayTipElement);
          if (event) {
            await this.networkManager.emitEvent(event);
          }
        }
      }
    } catch (e) {
      this.context.logger.logError("constructPrivateEvent error: ", e);
    }
  }
  async emitRecallMsg(message, element) {
    const peer = { chatType: message.chatType, peerUid: message.peerUid, guildId: "" };
    const oriMessageId = MessageUnique.getShortIdByMsgId(message.msgId) ?? MessageUnique.createUniqueMsgId(peer, message.msgId);
    if (message.chatType == ChatType.KCHATTYPEC2C) {
      return await this.emitFriendRecallMsg(message, oriMessageId, element);
    } else if (message.chatType == ChatType.KCHATTYPEGROUP) {
      return await this.emitGroupRecallMsg(message, oriMessageId, element);
    }
  }
  async emitFriendRecallMsg(message, oriMessageId, element) {
    const operatorUid = element.grayTipElement?.revokeElement.operatorUid;
    if (!operatorUid) return void 0;
    return new OB11FriendRecallNoticeEvent(
      this.core,
      +message.senderUin,
      oriMessageId
    );
  }
  async emitGroupRecallMsg(message, oriMessageId, element) {
    const operatorUid = element.grayTipElement?.revokeElement.operatorUid;
    if (!operatorUid) return void 0;
    const operatorId = await this.core.apis.UserApi.getUinByUidV2(operatorUid);
    return new OB11GroupRecallNoticeEvent(
      this.core,
      +message.peerUin,
      +message.senderUin,
      +operatorId,
      oriMessageId
    );
  }
}

const MAX_PORT_TRY = 100;
async function tryUseHost(host) {
  return new Promise((resolve2, reject) => {
    try {
      const server = net.createServer();
      server.on("listening", () => {
        server.close();
        resolve2(host);
      });
      server.on("error", (err) => {
        if (err.code === "EADDRNOTAVAIL") {
          reject(new Error("主机地址验证失败，可能为非本机地址"));
        } else {
          reject(new Error(`遇到错误: ${err.code}`));
        }
      });
      server.listen(0, host);
    } catch (error) {
      reject(new Error(`服务器启动时发生错误: ${error}`));
    }
  });
}
async function tryUsePort(port, host, tryCount = 0) {
  return new Promise((resolve2, reject) => {
    try {
      const server = net.createServer();
      server.on("listening", () => {
        server.close();
        resolve2(port);
      });
      server.on("error", (err) => {
        if (err.code === "EADDRINUSE") {
          if (tryCount < MAX_PORT_TRY) {
            resolve2(tryUsePort(port + 1, host, tryCount + 1));
          } else {
            reject(new Error(`端口尝试失败，达到最大尝试次数: ${MAX_PORT_TRY}`));
          }
        } else {
          reject(new Error(`遇到错误: ${err.code}`));
        }
      });
      server.listen(port, host);
    } catch (error) {
      reject(new Error(`服务器启动时发生错误: ${error}`));
    }
  });
}
class WebUiConfigWrapper {
  WebUiConfigData = void 0;
  applyDefaults(obj, defaults) {
    return { ...defaults, ...obj };
  }
  async GetWebUIConfig() {
    if (this.WebUiConfigData) {
      return this.WebUiConfigData;
    }
    const defaultconfig = {
      host: "0.0.0.0",
      port: 6099,
      prefix: "",
      token: "",
      // 默认先填空，空密码无法登录
      loginRate: 3
    };
    try {
      defaultconfig.token = Math.random().toString(36).slice(2);
    } catch (e) {
      console.log("随机密码生成失败", e);
    }
    try {
      const configPath = resolve$1(webUiPathWrapper.configPath, "./webui.json");
      if (!await fs$2.access(configPath, constants$1.R_OK | constants$1.W_OK).then(() => true).catch(() => false)) {
        await fs$2.writeFile(configPath, JSON.stringify(defaultconfig, null, 4));
      }
      const fileContent = await fs$2.readFile(configPath, "utf-8");
      const parsedConfig = this.applyDefaults(JSON.parse(fileContent), defaultconfig);
      if (!parsedConfig.prefix.startsWith("/")) parsedConfig.prefix = "/" + parsedConfig.prefix;
      if (parsedConfig.prefix.endsWith("/")) parsedConfig.prefix = parsedConfig.prefix.slice(0, -1);
      await fs$2.writeFile(configPath, JSON.stringify(parsedConfig, null, 4));
      const [host_err, host] = await tryUseHost(parsedConfig.host).then((data) => [null, data]).catch((err) => [err, null]);
      if (host_err) {
        console.log("host不可用", host_err);
        parsedConfig.port = 0;
      } else {
        parsedConfig.host = host;
        const [port_err, port] = await tryUsePort(parsedConfig.port, parsedConfig.host).then((data) => [null, data]).catch((err) => [err, null]);
        if (port_err) {
          console.log("port不可用", port_err);
          parsedConfig.port = 0;
        } else {
          parsedConfig.port = port;
        }
      }
      this.WebUiConfigData = parsedConfig;
      return this.WebUiConfigData;
    } catch (e) {
      console.log("读取配置文件失败", e);
    }
    return defaultconfig;
  }
  // 获取日志文件夹路径
  static async GetLogsPath() {
    return resolve$1(webUiPathWrapper.logsPath);
  }
  // 获取日志列表
  static async GetLogsList() {
    if (await fs$2.access(webUiPathWrapper.logsPath, constants$1.F_OK).then(() => true).catch(() => false)) {
      return (await fs$2.readdir(webUiPathWrapper.logsPath)).filter((file) => file.endsWith(".log")).map((file) => file.replace(".log", ""));
    }
    return [];
  }
  // 获取指定日志文件内容
  static async GetLogContent(filename) {
    const logPath = resolve$1(webUiPathWrapper.logsPath, `${filename}.log`);
    if (await fs$2.access(logPath, constants$1.R_OK).then(() => true).catch(() => false)) {
      return await fs$2.readFile(logPath, "utf-8");
    }
    return "";
  }
}

var HttpStatusCode = /* @__PURE__ */ ((HttpStatusCode2) => {
  HttpStatusCode2[HttpStatusCode2["OK"] = 200] = "OK";
  HttpStatusCode2[HttpStatusCode2["BadRequest"] = 400] = "BadRequest";
  HttpStatusCode2[HttpStatusCode2["Unauthorized"] = 401] = "Unauthorized";
  HttpStatusCode2[HttpStatusCode2["Forbidden"] = 403] = "Forbidden";
  HttpStatusCode2[HttpStatusCode2["NotFound"] = 404] = "NotFound";
  HttpStatusCode2[HttpStatusCode2["InternalServerError"] = 500] = "InternalServerError";
  return HttpStatusCode2;
})(HttpStatusCode || {});
var ResponseCode = /* @__PURE__ */ ((ResponseCode2) => {
  ResponseCode2[ResponseCode2["Success"] = 0] = "Success";
  ResponseCode2[ResponseCode2["Error"] = -1] = "Error";
  return ResponseCode2;
})(ResponseCode || {});

const sendError = (res, message = "error") => {
  res.status(HttpStatusCode.OK).json({
    code: ResponseCode.Error,
    message
  });
};
const sendSuccess = (res, data, message = "success") => {
  res.status(HttpStatusCode.OK).json({
    code: ResponseCode.Success,
    data,
    message
  });
};

const isEmpty = (data) => data === void 0 || data === null || data === "";

const OB11GetConfigHandler = async (_, res) => {
  const isLogin = await WebUiDataRuntime.getQQLoginStatus();
  if (!isLogin) {
    return sendError(res, "Not Login");
  }
  const uin = await WebUiDataRuntime.getQQLoginUin();
  const configFilePath = resolve$1(webUiPathWrapper.configPath, `./onebot11_${uin}.json`);
  try {
    const data = JSON.parse(
      existsSync(configFilePath) ? readFileSync(configFilePath).toString() : readFileSync(resolve$1(webUiPathWrapper.configPath, "./onebot11.json")).toString()
    );
    return sendSuccess(res, data);
  } catch (e) {
    return sendError(res, "Config Get Error");
  }
};
const OB11SetConfigHandler = async (req, res) => {
  const isLogin = await WebUiDataRuntime.getQQLoginStatus();
  if (!isLogin) {
    return sendError(res, "Not Login");
  }
  if (isEmpty(req.body.config)) {
    return sendError(res, "config is empty");
  }
  try {
    await WebUiDataRuntime.setOB11Config(JSON.parse(req.body.config));
    return sendSuccess(res, null);
  } catch (e) {
    return sendError(res, "Config Set Error");
  }
};

const router$4 = Router();
router$4.post("/GetConfig", OB11GetConfigHandler);
router$4.post("/SetConfig", OB11SetConfigHandler);

class AuthHelper {
  static secretKey = Math.random().toString(36).slice(2);
  /**
   * 签名凭证方法。
   * @param token 待签名的凭证字符串。
   * @returns 签名后的凭证对象。
   */
  static async signCredential(token) {
    const innerJson = {
      CreatedTime: Date.now(),
      TokenEncoded: token
    };
    const jsonString = JSON.stringify(innerJson);
    const hmac = crypto__default.createHmac("sha256", AuthHelper.secretKey).update(jsonString, "utf8").digest("hex");
    return { Data: innerJson, Hmac: hmac };
  }
  /**
   * 检查凭证是否被篡改的方法。
   * @param credentialJson 凭证的JSON对象。
   * @returns 布尔值，表示凭证是否有效。
   */
  static async checkCredential(credentialJson) {
    try {
      const jsonString = JSON.stringify(credentialJson.Data);
      const calculatedHmac = crypto__default.createHmac("sha256", AuthHelper.secretKey).update(jsonString, "utf8").digest("hex");
      return calculatedHmac === credentialJson.Hmac;
    } catch (error) {
      return false;
    }
  }
  /**
   * 验证凭证在1小时内有效且token与原始token相同。
   * @param token 待验证的原始token。
   * @param credentialJson 已签名的凭证JSON对象。
   * @returns 布尔值，表示凭证是否有效且token匹配。
   */
  static async validateCredentialWithinOneHour(token, credentialJson) {
    const isValid = await AuthHelper.checkCredential(credentialJson);
    if (!isValid) {
      return false;
    }
    const currentTime = Date.now() / 1e3;
    const createdTime = credentialJson.Data.CreatedTime;
    const timeDifference = currentTime - createdTime;
    return timeDifference <= 3600 && credentialJson.Data.TokenEncoded === token;
  }
}

async function auth(req, res, next) {
  if (req.url == "/auth/login") {
    return next();
  }
  if (req.headers?.authorization) {
    const authorization = req.headers.authorization.split(" ");
    if (authorization.length < 2) {
      return sendError(res, "Unauthorized");
    }
    const token = authorization[1];
    let Credential;
    try {
      Credential = JSON.parse(Buffer.from(token, "base64").toString("utf-8"));
    } catch (e) {
      return sendError(res, "Unauthorized");
    }
    const config = await WebUiConfig.GetWebUIConfig();
    const credentialJson = await AuthHelper.validateCredentialWithinOneHour(config.token, Credential);
    if (credentialJson) {
      return next();
    }
    return sendError(res, "Unauthorized");
  }
  return sendError(res, "Unauthorized");
}

const QQGetQRcodeHandler = async (req, res) => {
  if (await WebUiDataRuntime.getQQLoginStatus()) {
    return sendError(res, "QQ Is Logined");
  }
  const qrcodeUrl = await WebUiDataRuntime.getQQLoginQrcodeURL();
  if (isEmpty(qrcodeUrl)) {
    return sendError(res, "QRCode Get Error");
  }
  const data = {
    qrcode: qrcodeUrl
  };
  return sendSuccess(res, data);
};
const QQCheckLoginStatusHandler = async (req, res) => {
  const data = {
    isLogin: await WebUiDataRuntime.getQQLoginStatus(),
    qrcodeurl: await WebUiDataRuntime.getQQLoginQrcodeURL()
  };
  return sendSuccess(res, data);
};
const QQSetQuickLoginHandler = async (req, res) => {
  const { uin } = req.body;
  const isLogin = await WebUiDataRuntime.getQQLoginStatus();
  if (isLogin) {
    return sendError(res, "QQ Is Logined");
  }
  if (isEmpty(uin)) {
    return sendError(res, "uin is empty");
  }
  const { result, message } = await WebUiDataRuntime.requestQuickLogin(uin);
  if (!result) {
    return sendError(res, message);
  }
  return sendSuccess(res, null);
};
const QQGetQuickLoginListHandler = async (_, res) => {
  const quickLoginList = await WebUiDataRuntime.getQQQuickLoginList();
  return sendSuccess(res, quickLoginList);
};

const router$3 = Router();
router$3.all("/GetQuickLoginList", QQGetQuickLoginListHandler);
router$3.post("/CheckLoginStatus", QQCheckLoginStatusHandler);
router$3.post("/GetQQLoginQrcode", QQGetQRcodeHandler);
router$3.post("/SetQuickLogin", QQSetQuickLoginHandler);

const LoginHandler = async (req, res) => {
  const WebUiConfigData = await WebUiConfig.GetWebUIConfig();
  const { token } = req.body;
  if (isEmpty(token)) {
    return sendError(res, "token is empty");
  }
  if (!await WebUiDataRuntime.checkLoginRate(WebUiConfigData.loginRate)) {
    return sendError(res, "login rate limit");
  }
  if (WebUiConfigData.token !== token) {
    return sendError(res, "token is invalid");
  }
  const signCredential = Buffer.from(JSON.stringify(await AuthHelper.signCredential(WebUiConfigData.token))).toString(
    "base64"
  );
  return sendSuccess(res, {
    Credential: signCredential
  });
};
const LogoutHandler = (_, res) => {
  return sendSuccess(res, null);
};
const checkHandler = async (req, res) => {
  const WebUiConfigData = await WebUiConfig.GetWebUIConfig();
  const authorization = req.headers.authorization;
  try {
    const CredentialBase64 = authorization?.split(" ")[1];
    const Credential = JSON.parse(Buffer.from(CredentialBase64, "base64").toString());
    await AuthHelper.validateCredentialWithinOneHour(WebUiConfigData.token, Credential);
    return sendSuccess(res, null);
  } catch (e) {
    return sendError(res, "Authorization Faild");
  }
};

const router$2 = Router();
router$2.post("/login", LoginHandler);
router$2.post("/check", checkHandler);
router$2.post("/logout", LogoutHandler);

const LogHandler = async (req, res) => {
  const filename = req.query.id;
  if (filename.includes("..")) {
    return sendError(res, "ID不合法");
  }
  const logContent = await WebUiConfigWrapper.GetLogContent(filename);
  return sendSuccess(res, logContent);
};
const LogListHandler = async (_, res) => {
  const logList = await WebUiConfigWrapper.GetLogsList();
  return sendSuccess(res, logList);
};
const LogRealTimeHandler = async (req, res) => {
  res.setHeader("Content-Type", "text/event-stream");
  res.setHeader("Connection", "keep-alive");
  const listener = (log) => {
    try {
      res.write(`data: ${log}

`);
    } catch (error) {
      console.error("向客户端写入日志数据时出错:", error);
    }
  };
  logSubscription.subscribe(listener);
  req.on("close", () => {
    logSubscription.unsubscribe(listener);
  });
};

const router$1 = Router();
router$1.get("/GetLog", LogHandler);
router$1.get("/GetLogList", LogListHandler);
router$1.get("/GetLogRealTime", LogRealTimeHandler);

const router = Router();
router.use(auth);
router.all("/test", (_, res) => {
  return sendSuccess(res);
});
router.use("/auth", router$2);
router.use("/QQLogin", router$3);
router.use("/OB11Config", router$4);
router.use("/Log", router$1);

const cors = (req, res, next) => {
  const origin = req.headers.origin || "*";
  res.header("Access-Control-Allow-Origin", origin);
  res.header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
  res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept, Authorization");
  res.header("Access-Control-Allow-Credentials", "true");
  if (req.method === "OPTIONS") {
    res.sendStatus(204);
    return;
  }
  next();
};

const normalizeHost = (host) => {
  if (host === "0.0.0.0") return "127.0.0.1";
  if (isIP(host) === 6) return `[${host}]`;
  return host;
};
const createUrl = (host, port, path = "/", search, protocol = "http") => {
  const url = new URL(`${protocol}://${normalizeHost(host)}`);
  url.port = port;
  url.pathname = path;
  if (search) {
    for (const key in search) {
      url.searchParams.set(key, search[key]);
    }
  }
  return url.toString();
};

const app = express();
let WebUiConfig;
let webUiPathWrapper;
async function InitWebUi(logger, pathWrapper) {
  webUiPathWrapper = pathWrapper;
  WebUiConfig = new WebUiConfigWrapper();
  const config = await WebUiConfig.GetWebUIConfig();
  if (config.port == 0) {
    logger.log("[NapCat] [WebUi] Current WebUi is not run.");
    return;
  }
  app.use(express.json());
  app.use(cors);
  app.use(config.prefix + "/webui", express.static(pathWrapper.staticPath));
  app.use(config.prefix + "/api", router);
  app.all(config.prefix + "/", (_req, res) => {
    sendSuccess(res, null, "NapCat WebAPI is now running!");
  });
  app.listen(config.port, config.host, async () => {
    const port = config.port.toString(), searchParams = { token: config.token }, path = `${config.prefix}/webui`;
    if (config.host !== "" && config.host !== "0.0.0.0") {
      logger.log(`[NapCat] [WebUi] WebUi User Panel Url: ${createUrl(config.host, port, path, searchParams)}`);
      logger.log(`[NapCat] [WebUi] WebUi User Panel Url: https://napcat.152710.xyz/web_login?back=http://${config.host}:${config.port}${config.prefix}&token=${config.token}`);
    }
    logger.log(`[NapCat] [WebUi] WebUi Local Panel Url: ${createUrl("127.0.0.1", port, path, searchParams)}`);
    logger.log(`[NapCat] [WebUi] WebUi Local Panel Url: https://napcat.152710.xyz/web_login?back=http://127.0.0.1:${config.port}${config.prefix}&token=${config.token}`);
  });
}

class NodeIO3MiscListener {
  getOnAmgomDataPiece(...arg) {
  }
}

async function handleUncaughtExceptions(logger) {
  process.on("uncaughtException", (err) => {
    logger.logError("[NapCat] [Error] Unhandled Exception:", err.message);
  });
  process.on("unhandledRejection", (reason, promise) => {
    logger.logError("[NapCat] [Error] unhandledRejection:", reason);
  });
}
function getDataPaths(wrapper) {
  if (os__default.platform() === "darwin") {
    const userPath = os__default.homedir();
    const appDataPath = path.resolve(userPath, "./Library/Application Support/QQ");
    return [appDataPath, path.join(appDataPath, "global")];
  }
  let dataPath = wrapper.NodeQQNTWrapperUtil.getNTUserDataInfoConfig();
  if (!dataPath) {
    dataPath = path.resolve(os__default.homedir(), "./.config/QQ");
    fs__default.mkdirSync(dataPath, { recursive: true });
  }
  const dataPathGlobal = path.resolve(dataPath, "./nt_qq/global");
  return [dataPath, dataPathGlobal];
}
function getPlatformType() {
  const platformMapping = {
    win32: PlatformType.KWINDOWS,
    darwin: PlatformType.KMAC,
    linux: PlatformType.KLINUX
  };
  return platformMapping[os__default.platform()] ?? PlatformType.KWINDOWS;
}
async function initializeEngine(engine, basicInfoWrapper, dataPathGlobal, systemPlatform, systemVersion2) {
  engine.initWithDeskTopConfig(
    {
      base_path_prefix: "",
      platform_type: systemPlatform,
      app_type: 4,
      app_version: basicInfoWrapper.getFullQQVesion(),
      os_version: systemVersion2,
      use_xlog: false,
      qua: basicInfoWrapper.QQVersionQua,
      global_path_config: {
        desktopGlobalPath: dataPathGlobal
      },
      thumb_config: { maxSide: 324, minSide: 48, longLimit: 6, density: 2 }
    },
    new NodeIGlobalAdapter()
  );
}
async function initializeLoginService(loginService, basicInfoWrapper, dataPathGlobal, systemVersion2, hostname2) {
  loginService.initConfig({
    machineId: "",
    appid: basicInfoWrapper.QQVersionAppid ?? "",
    platVer: systemVersion2,
    commonPath: dataPathGlobal,
    clientVer: basicInfoWrapper.getFullQQVesion(),
    hostName: hostname2
  });
}
async function handleLogin(loginService, logger, pathWrapper, quickLoginUin, historyLoginList) {
  return new Promise((resolve) => {
    const loginListener = new NodeIKernelLoginListener();
    let isLogined = false;
    loginListener.onUserLoggedIn = (userid) => {
      logger.logError(`当前账号(${userid})已登录,无法重复登录`);
    };
    loginListener.onQRCodeLoginSucceed = async (loginResult) => {
      isLogined = true;
      resolve({
        uid: loginResult.uid,
        uin: loginResult.uin,
        nick: "",
        online: true
      });
    };
    loginListener.onQRCodeGetPicture = ({ pngBase64QrcodeData, qrcodeUrl }) => {
      WebUiDataRuntime.setQQLoginQrcodeURL(qrcodeUrl);
      const realBase64 = pngBase64QrcodeData.replace(/^data:image\/\w+;base64,/, "");
      const buffer = Buffer.from(realBase64, "base64");
      logger.logWarn("请扫描下面的二维码，然后在手Q上授权登录：");
      const qrcodePath = path.join(pathWrapper.cachePath, "qrcode.png");
      qrcode.generate(qrcodeUrl, { small: true }, (res) => {
        logger.logWarn([
          "\n",
          res,
          "二维码解码URL: " + qrcodeUrl,
          "如果控制台二维码无法扫码，可以复制解码url到二维码生成网站生成二维码再扫码，也可以打开下方的二维码路径图片进行扫码。"
        ].join("\n"));
        fs__default.writeFile(qrcodePath, buffer, {}, () => {
          logger.logWarn("二维码已保存到", qrcodePath);
        });
      });
    };
    loginListener.onQRCodeSessionFailed = (errType, errCode, errMsg) => {
      if (!isLogined) {
        logger.logError("[Core] [Login] Login Error,ErrCode: ", errCode, " ErrMsg:", errMsg);
        loginService.getQRCodePicture();
      }
    };
    loginListener.onLoginFailed = (args) => {
      logger.logError("[Core] [Login] Login Error , ErrInfo: ", args);
    };
    loginService.addKernelLoginListener(proxiedListenerOf(loginListener, logger));
    const isConnect = loginService.connect();
    if (!isConnect) {
      logger.logError("核心登录服务连接失败!");
      return;
    }
    logger.log("核心登录服务连接成功!");
    loginService.getLoginList().then((res) => {
      WebUiDataRuntime.setQQQuickLoginList(res.LocalLoginInfoList.filter((item) => item.isQuickLogin).map((item) => item.uin.toString()));
    });
    WebUiDataRuntime.setQuickLoginCall(async (uin) => {
      return await new Promise((resolve2) => {
        if (uin) {
          logger.log("正在快速登录 ", uin);
          loginService.quickLoginWithUin(uin).then((res) => {
            if (res.loginErrorInfo.errMsg) {
              resolve2({ result: false, message: res.loginErrorInfo.errMsg });
            }
            resolve2({ result: true, message: "" });
          }).catch((e) => {
            logger.logError(e);
            resolve2({ result: false, message: "快速登录发生错误" });
          });
        } else {
          resolve2({ result: false, message: "快速登录失败" });
        }
      });
    });
    if (quickLoginUin) {
      if (historyLoginList.some((u) => u.uin === quickLoginUin)) {
        logger.log("正在快速登录 ", quickLoginUin);
        setTimeout(() => {
          loginService.quickLoginWithUin(quickLoginUin).then((result) => {
            if (result.loginErrorInfo.errMsg) {
              logger.logError("快速登录错误：", result.loginErrorInfo.errMsg);
              if (!isLogined) loginService.getQRCodePicture();
            }
          }).catch();
        }, 1e3);
      } else {
        logger.logError("快速登录失败，未找到该 QQ 历史登录记录，将使用二维码登录方式");
        if (!isLogined) loginService.getQRCodePicture();
      }
    } else {
      logger.log("没有 -q 指令指定快速登录，将使用二维码登录方式");
      if (historyLoginList.length > 0) {
        logger.log(`可用于快速登录的 QQ：
${historyLoginList.map((u, index) => `${index + 1}. ${u.uin} ${u.nickName}`).join("\n")}`);
      }
      loginService.getQRCodePicture();
    }
  });
}
async function initializeSession(session, sessionConfig, logger) {
  return new Promise((resolve, reject) => {
    const sessionListener = new NodeIKernelSessionListener();
    sessionListener.onSessionInitComplete = (r) => {
      if (r === 0) {
        resolve();
      } else {
        reject(new Error("登录异常" + r?.toString()));
      }
    };
    session.init(
      sessionConfig,
      new NodeIDependsAdapter(),
      new NodeIDispatcherAdapter(),
      sessionListener
    );
    try {
      session.startNT(0);
    } catch (_) {
      try {
        session.startNT();
      } catch (e) {
        reject(new Error("init failed " + e.message));
      }
    }
  });
}
async function NCoreInitShell() {
  console.log("NapCat Shell App Loading...");
  const pathWrapper = new NapCatPathWrapper();
  const logger = new LogWrapper(pathWrapper.logsPath);
  handleUncaughtExceptions(logger);
  const basicInfoWrapper = new QQBasicInfoWrapper({ logger });
  const wrapper = loadQQWrapper(basicInfoWrapper.getFullQQVesion());
  const o3Service = wrapper.NodeIO3MiscService.get();
  o3Service.addO3MiscListener(new NodeIO3MiscListener());
  logger.log(`[NapCat] [Core] NapCat.Core Version: ` + napCatVersion);
  InitWebUi(logger, pathWrapper).then().catch((e) => logger.logError(e));
  const engine = wrapper.NodeIQQNTWrapperEngine.get();
  const loginService = wrapper.NodeIKernelLoginService.get();
  const session = wrapper.NodeIQQNTWrapperSession.create();
  const [dataPath, dataPathGlobal] = getDataPaths(wrapper);
  const systemPlatform = getPlatformType();
  if (!basicInfoWrapper.QQVersionAppid || !basicInfoWrapper.QQVersionQua) throw new Error("QQVersionAppid or QQVersionQua  is not defined");
  await initializeEngine(engine, basicInfoWrapper, dataPathGlobal, systemPlatform, systemVersion);
  await initializeLoginService(loginService, basicInfoWrapper, dataPathGlobal, systemVersion, hostname);
  program.option("-q, --qq [number]", "QQ号").parse(process.argv);
  const cmdOptions = program.opts();
  const quickLoginUin = cmdOptions.qq;
  const historyLoginList = (await loginService.getLoginList()).LocalLoginInfoList;
  const dataTimestape = (/* @__PURE__ */ new Date()).getTime().toString();
  o3Service.reportAmgomWeather("login", "a1", [dataTimestape, "0", "0"]);
  const selfInfo = await handleLogin(loginService, logger, pathWrapper, quickLoginUin, historyLoginList);
  const amgomDataPiece = "eb1fd6ac257461580dc7438eb099f23aae04ca679f4d88f53072dc56e3bb1129";
  o3Service.setAmgomDataPiece(basicInfoWrapper.QQVersionAppid, new Uint8Array(Buffer.from(amgomDataPiece, "hex")));
  let guid = loginService.getMachineGuid();
  guid = guid.slice(0, 8) + "-" + guid.slice(8, 12) + "-" + guid.slice(12, 16) + "-" + guid.slice(16, 20) + "-" + guid.slice(20);
  o3Service.reportAmgomWeather("login", "a6", [dataTimestape, "184", "329"]);
  const sessionConfig = await genSessionConfig(
    guid,
    basicInfoWrapper.QQVersionAppid,
    basicInfoWrapper.getFullQQVesion(),
    selfInfo.uin,
    selfInfo.uid,
    dataPath
  );
  await initializeSession(session, sessionConfig);
  const accountDataPath = path.resolve(dataPath, "./NapCat/data");
  fs__default.mkdirSync(dataPath, { recursive: true });
  logger.logDebug("本账号数据/缓存目录：", accountDataPath);
  await new NapCatShell(
    wrapper,
    session,
    logger,
    loginService,
    selfInfo,
    basicInfoWrapper,
    pathWrapper
  ).InitNapCat();
}
class NapCatShell {
  core;
  context;
  constructor(wrapper, session, logger, loginService, selfInfo, basicInfoWrapper, pathWrapper) {
    this.context = {
      workingEnv: NapCatCoreWorkingEnv.Shell,
      wrapper,
      session,
      logger,
      loginService,
      basicInfoWrapper,
      pathWrapper
    };
    this.core = new NapCatCore(this.context, selfInfo);
  }
  async InitNapCat() {
    await this.core.initCore();
    new NapCatOneBot11Adapter(this.core, this.context, this.context.pathWrapper).InitOneBot().catch((e) => this.context.logger.logError("初始化OneBot失败", e));
  }
}

NCoreInitShell();
